

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Kon4tsu">
  <meta name="keywords" content="">
  
    <meta name="description" content="MYDB1. 项目结构整体架构  Transaction Manager（TM） Data Manager（DM） Version Manager（VM） Index Manager（IM） Table Manager（TBM）  每个模块的职责如下：  TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。 DM 直接管理数据库 DB 文件和日志文件。DM 的主">
<meta property="og:type" content="article">
<meta property="og:title" content="MYDB record">
<meta property="og:url" content="http://example.com/2025/02/21/MYDB-record/index.html">
<meta property="og:site_name" content="Kon4tsu Blog">
<meta property="og:description" content="MYDB1. 项目结构整体架构  Transaction Manager（TM） Data Manager（DM） Version Manager（VM） Index Manager（IM） Table Manager（TBM）  每个模块的职责如下：  TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。 DM 直接管理数据库 DB 文件和日志文件。DM 的主">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502211203817.jpg">
<meta property="og:image" content="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502221957403.jpg">
<meta property="og:image" content="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502221935459.png">
<meta property="article:published_time" content="2025-02-21T02:30:03.000Z">
<meta property="article:modified_time" content="2025-02-22T12:27:24.574Z">
<meta property="article:author" content="Kon4tsu">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502211203817.jpg">
  
  
  
  <title>MYDB record - Kon4tsu Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kon4tsu&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MYDB record"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-21 10:30" pubdate>
          2025年2月21日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          16k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          134 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MYDB record</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="MYDB"><a href="#MYDB" class="headerlink" title="MYDB"></a><strong>MYDB</strong></h1><h1 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502211203817.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol>
<li>Transaction Manager（TM）</li>
<li>Data Manager（DM）</li>
<li>Version Manager（VM）</li>
<li>Index Manager（IM）</li>
<li>Table Manager（TBM）</li>
</ol>
<p>每个模块的职责如下：</p>
<ol>
<li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li>
<li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li>
<li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li>
<li>IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。</li>
<li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li>
</ol>
<h1 id="2-Transaction-Manager"><a href="#2-Transaction-Manager" class="headerlink" title="2. Transaction Manager"></a>2. Transaction Manager</h1><blockquote>
<p>TM模块通过维护一个XID文件来维护事务状态，并提供接口供其他模块来查询某个事务的状态</p>
</blockquote>
<h2 id="XID文件"><a href="#XID文件" class="headerlink" title="XID文件"></a>XID文件</h2><p>在 MYDB 中，每一个事务都有一个 XID，这个 ID 唯一标识了这个事务。事务的 XID 从 1 开始标号，并自增，不可重复。并特殊规定 <strong>XID 0 是一个超级事务（Super Transaction）</strong>。当一些操作想在没有申请事务的情况下进行，那么可以将操作的 XID 设置为 0。XID 为 0 的事务的状态永远是 committed。</p>
<p>TransactionManager 维护了一个 XID 格式的文件，用来记录各个事务的状态。MYDB 中，每个事务都有下面的三种状态：</p>
<ol>
<li><code>active</code>，正在进行，尚未结束</li>
<li><code>committed</code>，已提交</li>
<li><code>aborted</code>，已撤销（回滚）</li>
</ol>
<p>XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，<strong>事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处</strong>，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。（XID文件头8个字节用于记录此XID文件管理的事务数量，后面记录事务的状态）</p>
<h2 id="必要的常量及变量"><a href="#必要的常量及变量" class="headerlink" title="必要的常量及变量"></a>必要的常量及变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XID文件头长度</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LEN_XID_HEADER_LENGTH</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 每个事务的占用长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">XID_FIELD_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 事务的三种状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ACTIVE</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_COMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ABORTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 超级事务，永远为commited状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SUPER_XID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// XID 文件后缀</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">XID_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.xid&quot;</span>;<br><br><span class="hljs-comment">// 用于获取XID文件</span><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-comment">// 文件通道，用于文件的读写</span><br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-comment">// 用于记录XID文件中事务的数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> xidCounter;<br><span class="hljs-keyword">private</span> Lock counterLock;<br></code></pre></td></tr></table></figure>

<h2 id="XID文件校验"><a href="#XID文件校验" class="headerlink" title="XID文件校验"></a>XID文件校验</h2><p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，通过<strong>文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比</strong>。如果不同则认为 XID 文件不合法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">fileLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 记录文件的实际长度</span><br>        fileLen = file.length();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br>  	<span class="hljs-comment">// 文件实际长度比文件头的8字节还小，说明文件不合法</span><br>    <span class="hljs-keyword">if</span>(fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 设置FileChannel的position</span><br>        fc.position(<span class="hljs-number">0</span>);<br>      	<span class="hljs-comment">// 从文件通道读取内容到ByteBuffer中</span><br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.xidCounter = Parser.parseLong(buf.array());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> getXidPosition(<span class="hljs-built_in">this</span>.xidCounter + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(end != fileLen) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 根据事务xid取得其在xid文件中对应的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getXidPosition</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-keyword">return</span> LEN_XID_HEADER_LENGTH + (xid-<span class="hljs-number">1</span>)*XID_FIELD_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="更新事务状态"><a href="#更新事务状态" class="headerlink" title="更新事务状态"></a>更新事务状态</h2><ul>
<li><code>begin()</code>：开启一个事务，首先设置<code>xid = xidCounter+1</code>的事务状态为<code>active</code>，随后<strong>xidCounter自增</strong></li>
<li><code>commit()</code>：提交一个事务，将<code>xid</code>事务的状态设置为<code>committed</code></li>
<li><code>abort()</code>：取消一个事务，将<code>xid</code>事务的状态设置为<code>aborted</code></li>
<li>这三个更新操作都可借助下面的<code>updateXID()</code>方法实现，同时开启事务还需要实现一个xidCounter自增的方法<code>incrXIDCounter()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 更新xid事务的状态为status</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">byte</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE];<br>    tmp[<span class="hljs-number">0</span>] = status;<br>  	<span class="hljs-comment">// tmp数组包装成bytebuffer数组</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(tmp);<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 将ByteBuffer中的内容写入到文件通道中的offset位置，即更改事务状态</span><br>        fc.position(offset);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 所有文件操作，在执行后都需要立刻刷入文件中，防止在崩溃后文件丢失数据，fileChannel 的 force() 方法，强制同步缓存内容到文件中。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。</span><br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将XID加一，并更新XID Header（开启一个新事务时需要此操作）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    xidCounter ++;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(<span class="hljs-number">0</span>);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="检查事务状态"><a href="#检查事务状态" class="headerlink" title="检查事务状态"></a>检查事务状态</h2><p><code>isActive()</code>、<code>isCommitted()</code> 和 <code>isAborted()</code> 都是检查一个 xid 的状态，可以用一个通用的方法解决：（检查时需要排除<code>SUPER_XID</code>的情况，因为该情况一定是<code>committed</code>的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检测XID事务是否处于status状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE]);<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf.array()[<span class="hljs-number">0</span>] == status;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="创建和打开XID文件"><a href="#创建和打开XID文件" class="headerlink" title="创建和打开XID文件"></a>创建和打开XID文件</h2><p>在接口中创建的两个静态方法<code>create()</code>和<code>open()</code></p>
<ul>
<li><code>create()</code>：创建一个XID文件，并创建TM（TM的构造器需要XID文件和FileChannel）</li>
<li><code>open()</code>：从一个已有的XID文件来创建TM</li>
</ul>
<h1 id="3-Data-Manager"><a href="#3-Data-Manager" class="headerlink" title="3. Data Manager"></a>3. Data Manager</h1><blockquote>
<p>DataManager（DM）功能归纳：</p>
<ul>
<li>上层模块和文件系统中的一个抽象层。向上，提供数据包装；向下，直接读写文件。</li>
<li>提供日志功能。</li>
</ul>
</blockquote>
<h2 id="计数缓存框架"><a href="#计数缓存框架" class="headerlink" title="计数缓存框架"></a>计数缓存框架</h2><blockquote>
<p>分页管理和数据项（DataItem）管理涉及缓存，故抽象出一个<strong>通用缓存框架</strong>。</p>
</blockquote>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>**引用计数法（Reference counting）**是一种内存管理技术，它通过计算每个对象被引用的次数来判断是否需要回收该对象。当对象被创建时，引用计数为 1，每当有一个新的引用指向该对象时，计数加 1，当引用失效时，计数减 1。<strong>当计数为 0 时，该对象就可以被回收</strong>。</p>
<p>在 MYDB 的实践中，需要的效果是，只有上层模块<strong>主动释放引用</strong>，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。于是，选择引用计数法。增加了一个方法 <code>release (key)</code>，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p>
<p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）。</p>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>**LRU（least recently used）**是一种缓存淘汰算法。它的特点是根据数据最近被访问的时间来决定哪些数据应该被保留，哪些数据应该被淘汰。当缓存达到一定容量时，会淘汰掉最近最少使用的数据。</p>
<p>如果使用 LRU 缓存，那么只需要设计一个<code>get (key)</code>接口即可，释放缓存可以在缓存满了之后自动完成。</p>
<p>however，当某时刻缓存满了，缓存驱逐一个资源，此时上层模块想将某个资源强制刷回数据源，这个资源恰恰是刚被驱逐的资源。此时的上层模块会发现，资源在缓存中消失了，那么，是否有必要做回源操作？</p>
<ul>
<li><strong>不回源</strong>。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li>
<li><strong>回源</strong>。如果数据项被驱逐时的数据和现在又是相同的，那就是一次<strong>无效回源</strong></li>
<li><strong>放回缓存里，等下次被驱逐时回源</strong>。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致<strong>缓存抖动</strong>问题。</li>
</ul>
<h3 id="必要的变量"><a href="#必要的变量" class="headerlink" title="必要的变量"></a>必要的变量</h3><p><code>AbstractCache&lt;T&gt;</code>是一个抽象类，内部有两个抽象方法，留给实现类去实现具体的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当资源不在缓存时的获取行为（去数据源中获取）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当资源被驱逐时的写回行为</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(T obj)</span>;<br></code></pre></td></tr></table></figure>

<p>由于我们选择使用的是引用计数法实现缓存，因此除了普通的缓存功能，还需要另外<strong>维护一个计数</strong>，用于记录资源被引用的个数。除此以外，为了应对<strong>多线程场景</strong>，还需要记录哪些资源正在从数据源获取中（<strong>从数据源获取资源是一个相对费时的操作</strong>）。于是有下面三个 Map：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="hljs-comment">// 实际缓存的数据</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="hljs-comment">// 资源的引用个数</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="hljs-comment">// 正在被获取的资源</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxResource;                            <span class="hljs-comment">// 缓存的最大缓存资源数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                              <span class="hljs-comment">// 缓存中元素的个数</span><br><span class="hljs-keyword">private</span> Lock lock;<br></code></pre></td></tr></table></figure>

<h3 id="get-方法获取资源"><a href="#get-方法获取资源" class="headerlink" title="get()方法获取资源"></a>get()方法获取资源</h3><ol>
<li>判断请求的资源是否正在被其他线程获取，若是，则过一段时间再来查看</li>
<li>没有其他线程在获取目标资源，到缓存中查看是否有需要的资源，若有，则直接返回</li>
<li>资源不在缓存中，且缓存已满，抛出<code>CacheFullException</code>异常</li>
<li>资源不在缓存中且缓存没满，尝试去数据源获取该资源</li>
<li>在数据源中没找到该资源，抛出异常</li>
<li>在数据源中找到需要的资源，添加到缓存中后返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        lock.lock();<br>        <span class="hljs-comment">// 1.1.首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看</span><br>        <span class="hljs-keyword">if</span>(getting.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 请求的资源正在被其他线程获取</span><br>            lock.unlock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 1.2.如果没有其他线程在获取这个资源，那么就可以尝试从缓存中获取了</span><br>        <span class="hljs-keyword">if</span>(cache.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 资源在缓存中，直接返回</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-comment">// 记得给资源的引用计数加一</span><br>            references.put(key, references.get(key) + <span class="hljs-number">1</span>);<br>            lock.unlock();<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br><br>        <span class="hljs-comment">// 1.3.尝试获取该资源</span><br>        <span class="hljs-comment">// a.判断缓存是否已满，如果已满，就抛出一个异常</span><br>        <span class="hljs-keyword">if</span>(maxResource &gt; <span class="hljs-number">0</span> &amp;&amp; count == maxResource) &#123;<br>            lock.unlock();<br>            <span class="hljs-keyword">throw</span> Error.CacheFullException;<br>        &#125;<br>        <span class="hljs-comment">// b.如果缓存未满，就在 getting 中注册一下，该线程准备从数据源获取资源了</span><br>        count ++;<br>        getting.put(key, <span class="hljs-literal">true</span>);<br>        lock.unlock();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.从数据源获取资源</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用抽象方法从数据源中获取资源</span><br>        obj = getForCache(key);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 如果获取失败，就把 getting 中的注册信息清除掉</span><br>        lock.lock();<br>        count --;<br>        getting.remove(key);<br>        lock.unlock();<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br><br>    lock.lock();<br>    getting.remove(key);       <span class="hljs-comment">// 获取完成要从 getting 中清除注册信息</span><br>    cache.put(key, obj);<br>    references.put(key, <span class="hljs-number">1</span>);<br>    lock.unlock();<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="release-方法释放资源"><a href="#release-方法释放资源" class="headerlink" title="release()方法释放资源"></a>release()方法释放资源</h3><p>当引用计数references减到0后，就可以回源并删除缓存中的相关结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3.释放资源</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 释放一个缓存时，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> references.get(key) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(ref == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-comment">// 调用抽象方法释放缓存</span><br>            releaseForCache(obj);<br>            <span class="hljs-comment">// 删除缓存中所有相关的结构</span><br>            references.remove(key);<br>            cache.remove(key);<br>            count --;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            references.put(key, ref);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="close-方法关闭缓存"><a href="#close-方法关闭缓存" class="headerlink" title="close()方法关闭缓存"></a>close()方法关闭缓存</h3><p>缓存应当还有以一个安全关闭的功能，在关闭时，需要将缓存中所有的资源强行回源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Set&lt;Long&gt; keys = cache.keySet();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> key : keys) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            releaseForCache(obj);<br>            references.remove(key);<br>            cache.remove(key);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，一个简单的缓存框架就实现完了，其他的缓存只需要继承这个类，并实现那两个抽象方法即可。</p>
<h2 id="数据页的缓存与管理"><a href="#数据页的缓存与管理" class="headerlink" title="数据页的缓存与管理"></a>数据页的缓存与管理</h2><h3 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h3><p>参考大部分数据库的设计，将<strong>默认数据页大小定为 8K</strong>。如果想要提升向数据库写入大量数据情况下的性能的话，也可以适当增大这个值。</p>
<p>上一节我们已经实现了一个通用的缓存框架，那么这一节我们需要缓存页面，就可以直接借用那个缓存的框架了。但是首先，需要<strong>定义出页面的结构</strong>。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。定义一个页面如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Page</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pageNumber;		<span class="hljs-comment">// 页号，从1开始</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] data;			<span class="hljs-comment">// 此页面实际包含的字节数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> dirty;		<span class="hljs-comment">// 标识该页面是否是脏页面，在缓存驱逐的时候，脏页面需要被写回磁盘</span><br>    <span class="hljs-keyword">private</span> Lock lock;<br><br>    <span class="hljs-keyword">private</span> PageCache pc;			<span class="hljs-comment">// 这里保存了一个 PageCache（还未定义）的引用，用来方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>页面缓存接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageCache</span> &#123;<br>  <br>  	<span class="hljs-comment">// 页面大小8192</span><br>  	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PAGE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>;<br>  <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span>;<br>    Page <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Page page)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">truncateByBgno</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPgno)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getPageNumber</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">flushPage</span><span class="hljs-params">(Page pg)</span>;<br>  <br>  	<span class="hljs-comment">// 创建一个新的.db文件</span><br>  	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageCacheImpl <span class="hljs-title function_">create</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> memory)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+PageCacheImpl.DB_SUFFIX);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(!f.createNewFile()) &#123;<br>                Panic.panic(Error.FileExistsException);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;<br>            Panic.panic(Error.FileCannotRWException);<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br>            fc = raf.getChannel();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageCacheImpl</span>(raf, fc, (<span class="hljs-type">int</span>)memory/PAGE_SIZE);<br>    &#125;<br><br>  	<span class="hljs-comment">// 打开一个.db文件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageCacheImpl <span class="hljs-title function_">open</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> memory)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+PageCacheImpl.DB_SUFFIX);<br>        <span class="hljs-keyword">if</span>(!f.exists()) &#123;<br>            Panic.panic(Error.FileNotExistsException);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;<br>            Panic.panic(Error.FileCannotRWException);<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br>            fc = raf.getChannel();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageCacheImpl</span>(raf, fc, (<span class="hljs-type">int</span>)memory/PAGE_SIZE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>页面缓存的具体实现类<code>PageCacheImpl</code>，需要继承抽象缓存框架AbstractCache，并且实现<code>getForCache() </code>和 <code>releaseForCache() </code>两个抽象方法。由于数据源就是文件系统（<strong>.db文件</strong>），<code>getForCache() </code>直接从文件中读取，并包裹成 Page 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据pageNumber从数据库文件中读取页数据，并包裹成Page</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Page <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  	<span class="hljs-comment">// 页号</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)key;<br>  	<span class="hljs-comment">// 页号对应的页在文件中的位置</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageCacheImpl.pageOffset(pgno);<br><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(PAGE_SIZE);<br>    fileLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    fileLock.unlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, buf.array(), <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pageOffset</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> &#123;<br>    <span class="hljs-comment">// 页号从 1 开始</span><br>    <span class="hljs-keyword">return</span> (pgno-<span class="hljs-number">1</span>) * PAGE_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而<code> releaseForCache()</code>驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-keyword">if</span>(pg.isDirty()) &#123;<br>        flush(pg);<br>        pg.setDirty(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pg.getPageNumber();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> pageOffset(pgno);<br><br>    fileLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(pg.getData());<br>        fc.position(offset);<br>        fc.write(buf);<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        fileLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pageNumbers.incrementAndGet();<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, initData, <span class="hljs-literal">null</span>);<br>    flush(pg);  <span class="hljs-comment">// 新建的页面需要立刻写回</span><br>    <span class="hljs-keyword">return</span> pgno;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数据页管理"><a href="#数据页管理" class="headerlink" title="数据页管理"></a>数据页管理</h3><h4 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h4><p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是<strong>用来做启动检查</strong>。具体的原理是，在每次数据库<strong>启动</strong>时，会生成一串随机字节，存储在 <strong>100 ~ 107</strong> 字节。在数据库<strong>正常关闭</strong>时，会将这串字节，拷贝到第一页的 1<strong>08 ~ 115</strong> 字节。</p>
<p>这样数据库在每次启动时，就会<strong>检查第一页两处的字节是否相同</strong>，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p>
<p>启动时设置初始字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(Page pg)</span> &#123;<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    setVcOpen(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="hljs-number">0</span>, raw, OF_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关闭时拷贝字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(Page pg)</span> &#123;<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    setVcClose(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>校验字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-keyword">return</span> checkVc(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    <span class="hljs-keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="hljs-number">2</span>*LEN_VC));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="普通页"><a href="#普通页" class="headerlink" title="普通页"></a>普通页</h4><p>一个普通页面以一个 <strong>2 字节无符号数</strong>起始，表示<strong>这一页的空闲位置的偏移</strong>。剩下的部分都是实际存储的数据。对普通页的管理，基本都是围绕着对 <strong>FSO（Free Space Offset）进行的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageX</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">short</span> <span class="hljs-variable">OF_FREE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;		<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">short</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;		<span class="hljs-comment">// 数据起始位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_FREE_SPACE</span> <span class="hljs-operator">=</span> PageCache.PAGE_SIZE - OF_DATA;		<span class="hljs-comment">// 页面最大空闲空间</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] initRaw() &#123;<br>        <span class="hljs-type">byte</span>[] raw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[PageCache.PAGE_SIZE];<br>        setFSO(raw, OF_DATA);<br>        <span class="hljs-keyword">return</span> raw;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> ofData)</span> &#123;<br>        System.arraycopy(Parser.short2Byte(ofData), <span class="hljs-number">0</span>, raw, OF_FREE, OF_DATA);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取pg的FSO</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(Page pg)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFSO(pg.getData());<br>    &#125;<br>		<span class="hljs-comment">// 获取页面数据row的前两个字节（这两个字节标识空闲位置的起始位置）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>        <span class="hljs-keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中，返回插入位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>        setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset + raw.length));<br>        <span class="hljs-keyword">return</span> offset;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取页面的空闲空间大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFreeSpace</span><span class="hljs-params">(Page pg)</span> &#123;<br>        <span class="hljs-keyword">return</span> PageCache.PAGE_SIZE - (<span class="hljs-type">int</span>)getFSO(pg.getData());<br>    &#125;<br><br>  	<span class="hljs-comment">// 下面两个函数在updateLog 和 insertLog 的重做和撤销处理中涉及，用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用</span><br>    <span class="hljs-comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverInsert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br><br>        <span class="hljs-type">short</span> <span class="hljs-variable">rawFSO</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>        <span class="hljs-keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;<br>            setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset+raw.length));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中的offset位置，不更新update</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverUpdate</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="日志文件与恢复策略"><a href="#日志文件与恢复策略" class="headerlink" title="日志文件与恢复策略"></a>日志文件与恢复策略</h2><blockquote>
<p>MYDB 提供了崩溃后的数据恢复功能。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库崩溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 必要的常量及变量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SEED</span> <span class="hljs-operator">=</span> <span class="hljs-number">13331</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;		<span class="hljs-comment">// 单条记录Size的起始位置：0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_CHECKSUM</span> <span class="hljs-operator">=</span> OF_SIZE + <span class="hljs-number">4</span>;	<span class="hljs-comment">// 单条记录CheckSum起始位置：4</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> OF_CHECKSUM + <span class="hljs-number">4</span>;	<span class="hljs-comment">// 单条记录数据起始位置：8</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOG_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.log&quot;</span>;	<span class="hljs-comment">// 日志文件后缀</span><br><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-keyword">private</span> Lock lock;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> position;  <span class="hljs-comment">// 当前日志指针的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> fileSize;  <span class="hljs-comment">// 初始化时记录，log操作不更新</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> xChecksum;  <span class="hljs-comment">// 总校验和</span><br></code></pre></td></tr></table></figure>

<h3 id="日志读写"><a href="#日志读写" class="headerlink" title="日志读写"></a>日志读写</h3><h4 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h4><p>日志的二进制文件，按照如下的格式排布：</p>
<blockquote>
<p>[<code>XCheckSum</code>] [<code>Log1</code>] [<code>Log2</code>] [<code>Log3</code>] … [<code>LogN</code>] [<code>BadTail</code>]</p>
</blockquote>
<p>其中 <code>XChecksum</code> 是一个四字节的整数int，是<strong>对后续所有日志计算的校验和</strong>。<code>Log1</code> ~ <code>LogN</code> 是常规的日志数据，<code>BadTail</code> 是在数据库崩溃时，<strong>没有来得及写完的日志数据</strong>，这个 <code>BadTail</code> 不一定存在。</p>
<p>每条日志的格式如下：</p>
<blockquote>
<p>[<code>Size</code>] [<code>CheckSum</code>] [<code>Data</code>]</p>
</blockquote>
<p>其中，Size 是一个四字节整数int，标识了 <strong>Data 段的字节数</strong>。Checksum 则是<strong>该条日志的校验和int</strong>。单条日志的校验和，其实就是通过一个指定的种子实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calChecksum</span><span class="hljs-params">(<span class="hljs-type">int</span> xCheck, <span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : log) &#123;<br>        xCheck = xCheck * SEED + b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> xCheck;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，对所有日志求出校验和<code>CheckSum</code>，每条校验和再求和（❌）就能得到日志文件的校验和<code>XCheckSum</code>了。</p>
<blockquote>
<p>注意，文件里的<code>XCheckSum</code>和每条日志的<code>CheckSum</code>计算对象是不一样的：</p>
<ul>
<li><code>XCheckSum</code>是用后续所有日志（包括日志里的<code>size</code>、<code>checkSum</code>、<code>data</code>字段）计算得到的<ul>
<li><code>XCheckSum</code>是用来保证文件的完整性的，关心的是整个文件，故可以用一整条日志参与计算</li>
</ul>
</li>
<li>每条日志里的<code>CheckSum</code>只用到日志里的<code>data</code>字段计算得到<ul>
<li>这是因为每条日志里的<code>CheckSum</code>是用来确保当前日志<code>data</code>部分的完整性，故只用<code>data</code>部分计算</li>
<li>此外，每条日志里的<code>CheckSum</code>的计算也无法用到整条日志进行计算，这是因为整条日志里也包含自身，如果用整条日志计算<code>CheckSum</code>会用到<code>CheckSum</code>自身，这是有问题的</li>
</ul>
</li>
<li>因此<code>XCheckSum</code>  !&#x3D; <code>calChecksum( calChecksum( calChecksum(0, data1), data2), ... dataN)</code></li>
</ul>
</blockquote>
<h4 id="遍历日志文件中的每一条日志"><a href="#遍历日志文件中的每一条日志" class="headerlink" title="遍历日志文件中的每一条日志"></a>遍历日志文件中的每一条日志</h4><p>Logger 被实现成迭代器模式，通过 <code>next()</code> 方法，不断地从文件中<strong>读取下一条日志</strong>，并<strong>将其中的 <code>Data</code> 解析出来并返回</strong>，<code>next()</code> 方法的实现主要依靠 <code>internNext()</code>，大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] internNext() &#123;<br>  	<span class="hljs-comment">// 位置超出文件大小</span><br>    <span class="hljs-keyword">if</span>(position + OF_DATA &gt;= fileSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取size，读取后position指针向后移动4位，指向checkSum开头</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    fc.position(position);<br>    fc.read(tmp);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Parser.parseInt(tmp.array());<br>    <span class="hljs-keyword">if</span>(position + size + OF_DATA &gt; fileSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取checksum+data，log中包含size+checkSum+data</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(OF_DATA + size);<br>    fc.position(position);<br>    fc.read(buf);<br>    <span class="hljs-type">byte</span>[] log = buf.array();<br><br>    <span class="hljs-comment">// 校验 checksum，确保本条日志的完整性</span><br>  	<span class="hljs-comment">// checkSum1:手动计算该条日志的校验和，从log的第8位到最后一位读取</span><br>  	<span class="hljs-comment">// checkSum2:从日志数据log中读取该条日志的校验和，从log的4到8位读取</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">checkSum1</span> <span class="hljs-operator">=</span> calChecksum(<span class="hljs-number">0</span>, Arrays.copyOfRange(log, OF_DATA, log.length));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">checkSum2</span> <span class="hljs-operator">=</span> Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));<br>    <span class="hljs-keyword">if</span>(checkSum1 != checkSum2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  	<span class="hljs-comment">// position指针位置指向下一条日志</span><br>    position += log.length;<br>  	<span class="hljs-comment">// 返回这条日志</span><br>    <span class="hljs-keyword">return</span> log;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="校验日志文件"><a href="#校验日志文件" class="headerlink" title="校验日志文件"></a>校验日志文件</h4><p>在<strong>打开一个日志文件</strong>时，需要首先<strong>校验日志文件</strong>的 <code>XChecksum</code>，并移除文件尾部可能存在的 <code>BadTail</code>，由于 <code>BadTail</code> 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 <code>BadTail</code> 即可保证日志文件的一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndRemoveTail</span><span class="hljs-params">()</span> &#123;<br>  	<span class="hljs-comment">// 设置position为4，也就是XCheckSum后面，第一条日志开头的位置</span><br>    rewind();<br><br>  	<span class="hljs-comment">// 对每条日志的!!所有字段!!(区别于一条日志的校验和计算)计算校验和，校验和再求和得到总校验和xCheck</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">xCheck</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">byte</span>[] log = internNext();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        xCheck = calChecksum(xCheck, log);<br>    &#125;<br>  <br>  	<span class="hljs-comment">// xCheckSum是从日志文件开头4个字节获得的</span><br>    <span class="hljs-keyword">if</span>(xCheck != xChecksum) &#123;<br>        Panic.panic(Error.BadLogFileException);<br>    &#125;<br><br>    <span class="hljs-comment">// 截断文件到正常日志的末尾</span><br>    truncate(position);<br>  	<span class="hljs-comment">// position指针回到起点</span><br>    rewind();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rewind</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算总校验和是用不到它，因为它只返回了日志的数据部分</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] next() &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">byte</span>[] log = internNext();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(log, OF_DATA, log.length);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="写入日志"><a href="#写入日志" class="headerlink" title="写入日志"></a>写入日志</h4><p>向日志文件写入日志时，也是首先<strong>将数据包裹成日志格式</strong>，写入文件后，再<strong>更新文件的校验和</strong>，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>  	<span class="hljs-comment">// 将数据包装成日志格式[Size][CheckSum][Data]</span><br>    <span class="hljs-type">byte</span>[] log = wrapLog(data);<br>  	<span class="hljs-comment">// 将包装好的一条日志包装成ByteBuffer格式</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(log);<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 将日志写到文件通道中的末尾</span><br>        fc.position(fc.size());<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>  	<span class="hljs-comment">// 更新总校验和xCheckSum（这里的log是[Size][CheckSum][Data]这样一整条日志的格式）</span><br>    updateXChecksum(log);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXChecksum</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-built_in">this</span>.xChecksum = calChecksum(<span class="hljs-built_in">this</span>.xChecksum, log);<br>  	<span class="hljs-comment">// 将更新后的总校验和xCheckSum写到文件开头4个字节的位置</span><br>    fc.position(<span class="hljs-number">0</span>);<br>    fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));<br>    fc.force(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 在数据前面拼接上Size和CheckSum</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] wrapLog(<span class="hljs-type">byte</span>[] data) &#123;<br>    <span class="hljs-type">byte</span>[] checksum = Parser.int2Byte(calChecksum(<span class="hljs-number">0</span>, data));<br>    <span class="hljs-type">byte</span>[] size = Parser.int2Byte(data.length);<br>    <span class="hljs-keyword">return</span> Bytes.concat(size, checksum, data);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h3><p>DM 为上层模块，提供了两种操作，分别是<strong>插入新数据（I）<strong>和</strong>更新现有数据（U）</strong>。（不包含删除操作）DM 的日志策略很简单，一句话就是：</p>
<blockquote>
<p>在进行 I 和 U 操作之前，<strong>必须先进行对应的日志操作</strong>，在保证日志写入磁盘后，才进行数据操作。</p>
</blockquote>
<p>这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后<strong>没有来得及同步到磁盘</strong>，<strong>数据库就发生了崩溃</strong>，后续也可以<strong>通过磁盘上的日志恢复该数据</strong>。</p>
<p>对于两种数据操作，DM 记录的日志如下：</p>
<ul>
<li>(Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x</li>
<li>(Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx</li>
</ul>
<p>我们首先不考虑并发的情况，那么在某一时刻，只可能有一个事务在操作数据库。日志会看起来像下面那样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(Ti, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Ti, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), (Tj, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Tj, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), (Tk, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Tk, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>)<br></code></pre></td></tr></table></figure>

<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下<strong>利用日志恢复</strong>很简单，假设日志中<strong>最后一个事务是 Ti</strong>：</p>
<ol>
<li>对 <strong>Ti 之前所有的事务</strong>的日志，进行<strong>重做（redo）</strong></li>
<li>接着检查 <strong>Ti 的状态（XID 文件）</strong>，如果 Ti 的状态是<strong>已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo）</strong></li>
</ol>
<p>接着，是如何对事务 T 进行 <strong>redo</strong>：</p>
<ol>
<li><strong>正序扫描</strong>事务 T 的所有日志</li>
<li>如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置</li>
<li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx</li>
</ol>
<p><strong>undo</strong> 也很好理解：</p>
<ol>
<li><strong>倒序扫描</strong>事务 T 的所有日志</li>
<li>如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除</li>
<li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx</li>
</ol>
<p>注意，MYDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>考虑以下两种情况：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 情况1</span><br><br>T1 <span class="hljs-keyword">begin</span><br>T2 <span class="hljs-keyword">begin</span><br>T2 U(<span class="hljs-variable language_">x</span>)<br>T1 R(<span class="hljs-variable language_">x</span>)<br>...<br>T1 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure>

<p>在系统崩溃时，T2 仍然是<strong>活跃</strong>状态（active）。那么当数据库重新启动，执行恢复例程时，会<strong>撤销 T2</strong>，它对数据库的影响会被消除。但是<strong>由于 T1 读取了 T2 更新的值</strong>，既然 T2 被撤销，那么 <strong>T1 也应当被撤销</strong>。这种情况，就是<strong>级联回滚Cascading Rollback</strong>。但是，T1 已经 commit 了，所有 commit 的事务的影响，应当被持久化。这里就造成了矛盾。所以这里需要保证：</p>
<blockquote>
<p>规定1:正在进行的事务，不会读取其他未提交的事务产生的数据（读提交Read Committed）</p>
</blockquote>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 情况2，假设x的初值为0</span><br><br>T1 <span class="hljs-keyword">begin</span><br>T2 <span class="hljs-keyword">begin</span><br>T1 set <span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 产生的日志为(T1, U, A, 0, 1)</span><br>T2 set <span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 产生的日志为(T1, U, A, 1, 2)</span><br>T2 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure>

<p>在系统崩溃时，T1 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，<strong>会对 T1 进行撤销，对 T2 进行重做</strong>，但是，无论撤销和重做的先后顺序如何，x 最后的结果，要么是 0，要么是 2，这都是错误的。</p>
<blockquote>
<p>出现这种问题的原因, 归根结底是因为我们的<strong>日志太过简单</strong>, 仅仅记录了**”前相”和”后相”<strong>. 并单纯的</strong>依靠”前相”undo, 依靠”后相”redo.** 这种简单的日志方式和恢复方式, 并不能涵盖住所有数据库操作形成的语义</p>
</blockquote>
<p>解决方法有两种：</p>
<ol>
<li>增加日志种类</li>
<li>限制数据库操作</li>
</ol>
<p>MYDB 采用的是<strong>限制数据库操作</strong>，需要保证：</p>
<blockquote>
<p>规定2：正在进行的事务，<strong>不会修改其他任何未提交的事务修改或产生的数据</strong>。</p>
</blockquote>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="两种日志的格式"><a href="#两种日志的格式" class="headerlink" title="两种日志的格式"></a><strong>两种日志的格式</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">LOG_TYPE_INSERT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">LOG_TYPE_UPDATE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// updateLog:</span><br><span class="hljs-comment">// [LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><br><span class="hljs-comment">// insertLog:</span><br><span class="hljs-comment">// [LogType] [XID] [Pgno] [Offset] [Raw]</span><br></code></pre></td></tr></table></figure>

<p>和原理中描述的类似，recover 例程主要也是两步：<strong>重做所有已完成事务，撤销所有未完成事务</strong></p>
<h5 id="重做所有已完成事务（committed、aborted）"><a href="#重做所有已完成事务（committed、aborted）" class="headerlink" title="重做所有已完成事务（committed、aborted）"></a><strong>重做所有已完成事务（committed、aborted）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重做所有已完成事务（committed、aborted）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">redoTranscations</span><span class="hljs-params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;<br>  	<span class="hljs-comment">// 从第一个事务开始（重做redo要按顺序重做）</span><br>    lg.rewind();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>      	<span class="hljs-comment">// 一个一个事务遍历</span><br>        <span class="hljs-type">byte</span>[] log = lg.next();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>          	<span class="hljs-comment">// 如果是插入事务</span><br>            <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> li.xid;<br>            <span class="hljs-keyword">if</span>(!tm.isActive(xid)) &#123;<br>              	<span class="hljs-comment">// 事务状态是committed或aborted，重做插入操作</span><br>                doInsertLog(pc, log, REDO);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          	<span class="hljs-comment">// 如果是更新事务</span><br>            <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xi.xid;<br>            <span class="hljs-keyword">if</span>(!tm.isActive(xid)) &#123;<br>              	<span class="hljs-comment">// 事务状态是committed或aborted，重做更新操作</span><br>                doUpdateLog(pc, log, REDO);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="撤销所有未完成事务（active）"><a href="#撤销所有未完成事务（active）" class="headerlink" title="撤销所有未完成事务（active）"></a><strong>撤销所有未完成事务（active）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 撤销所有未完成事务（active）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undoTranscations</span><span class="hljs-params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;<br>  	<span class="hljs-comment">// 用于记录(要撤回事务的xid，事务xid要撤回的操作列表)，一个事务可能要撤回多个操作，所以要用列表记录</span><br>    Map&lt;Long, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt; logCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    lg.rewind();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">byte</span>[] log = lg.next();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>          	<span class="hljs-comment">// 如果是插入事务</span><br>            <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> li.xid;<br>          	<span class="hljs-comment">// 事务状态是active</span><br>            <span class="hljs-keyword">if</span>(tm.isActive(xid)) &#123;<br>              	<span class="hljs-comment">// 把事务xid及其要撤回的操作加入到logCache中</span><br>                <span class="hljs-keyword">if</span>(!logCache.containsKey(xid)) &#123;<br>                    logCache.put(xid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                logCache.get(xid).add(log);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          	<span class="hljs-comment">// 如果是更新事务</span><br>            <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xi.xid;<br>          	<span class="hljs-comment">// 事务状态是active</span><br>            <span class="hljs-keyword">if</span>(tm.isActive(xid)) &#123;<br>              	<span class="hljs-comment">// 把事务xid及其要撤回的操作加入到logCache中</span><br>                <span class="hljs-keyword">if</span>(!logCache.containsKey(xid)) &#123;<br>                    logCache.put(xid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                logCache.get(xid).add(log);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对所有active log进行倒序undo</span><br>    <span class="hljs-keyword">for</span>(Entry&lt;Long, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt; entry : logCache.entrySet()) &#123;<br>        List&lt;<span class="hljs-type">byte</span>[]&gt; logs = entry.getValue();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> logs.size()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-type">byte</span>[] log = logs.get(i);<br>            <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>                doInsertLog(pc, log, UNDO);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                doUpdateLog(pc, log, UNDO);<br>            &#125;<br>        &#125;<br>        tm.abort(entry.getKey());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判读是否是插入事务，否则是更新事务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInsertLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-keyword">return</span> log[<span class="hljs-number">0</span>] == LOG_TYPE_INSERT;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="解析插入事务与更新事务"><a href="#解析插入事务与更新事务" class="headerlink" title="解析插入事务与更新事务"></a><strong>解析插入事务与更新事务</strong></h5><ul>
<li><strong>解析插入事务日志</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解析插入事务日志 [LogType] [XID] [Pgno] [Offset] [Raw]</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;		<span class="hljs-comment">// LogType位置：0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XID</span> <span class="hljs-operator">=</span> OF_TYPE+<span class="hljs-number">1</span>;	<span class="hljs-comment">// XID位置：1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_PGNO</span> <span class="hljs-operator">=</span> OF_XID+<span class="hljs-number">8</span>;	<span class="hljs-comment">// 插入事务发生的页号位置：9</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_OFFSET</span> <span class="hljs-operator">=</span> OF_INSERT_PGNO+<span class="hljs-number">4</span>;	<span class="hljs-comment">// 插入事务发生在页中的位置：13</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_RAW</span> <span class="hljs-operator">=</span> OF_INSERT_OFFSET+<span class="hljs-number">2</span>;	<span class="hljs-comment">// 插入数据位置：15</span><br><br><span class="hljs-comment">// 插入事务日志信息</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertLogInfo</span> &#123;<br>    <span class="hljs-type">long</span> xid;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] raw;<br>&#125;<br><br><span class="hljs-comment">// 解析插入事务日志</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InsertLogInfo <span class="hljs-title function_">parseInsertLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsertLogInfo</span>();<br>    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_INSERT_PGNO));<br>    li.pgno = Parser.parseInt(Arrays.copyOfRange(log, OF_INSERT_PGNO, OF_INSERT_OFFSET));<br>    li.offset = Parser.parseShort(Arrays.copyOfRange(log, OF_INSERT_OFFSET, OF_INSERT_RAW));<br>    li.raw = Arrays.copyOfRange(log, OF_INSERT_RAW, log.length);<br>    <span class="hljs-keyword">return</span> li;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>解析更新事务日志</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解析更新事务日志 [LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_UPDATE_UID</span> <span class="hljs-operator">=</span> OF_XID+<span class="hljs-number">8</span>;	<span class="hljs-comment">// UID位置：9</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_UPDATE_RAW</span> <span class="hljs-operator">=</span> OF_UPDATE_UID+<span class="hljs-number">8</span>;	<span class="hljs-comment">// 更新数据位置：17</span><br><br><span class="hljs-comment">// 更新事务日志信息</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateLogInfo</span> &#123;<br>    <span class="hljs-type">long</span> xid;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] oldRaw;<br>    <span class="hljs-type">byte</span>[] newRaw;<br>&#125;<br><br><span class="hljs-comment">// 解析更新事务日志</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UpdateLogInfo <span class="hljs-title function_">parseUpdateLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateLogInfo</span>();<br>    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_UPDATE_UID));<br>    <span class="hljs-type">long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> Parser.parseLong(Arrays.copyOfRange(log, OF_UPDATE_UID, OF_UPDATE_RAW));<br>    li.offset = (<span class="hljs-type">short</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">16</span>) - <span class="hljs-number">1</span>));<br>    uid &gt;&gt;&gt;= <span class="hljs-number">32</span>;<br>    li.pgno = (<span class="hljs-type">int</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (log.length - OF_UPDATE_RAW) / <span class="hljs-number">2</span>;<br>    li.oldRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW, OF_UPDATE_RAW+length);<br>    li.newRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW+length, OF_UPDATE_RAW+length*<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> li;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="updateLog-和-insertLog-的重做和撤销处理"><a href="#updateLog-和-insertLog-的重做和撤销处理" class="headerlink" title="updateLog 和 insertLog 的重做和撤销处理"></a><strong>updateLog 和 insertLog 的重做和撤销处理</strong></h5><p>updateLog 和 insertLog 的重做和撤销处理，分别合并为一个方法实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// updateLog的重做和撤销处理</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doUpdateLog</span><span class="hljs-params">(PageCache pc, <span class="hljs-type">byte</span>[] log, <span class="hljs-type">int</span> flag)</span> &#123;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] raw;<br>    <span class="hljs-keyword">if</span>(flag == REDO) &#123;<br>      	<span class="hljs-comment">// 重做</span><br>        <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>        pgno = xi.pgno;<br>        offset = xi.offset;<br>        raw = xi.newRaw;	<span class="hljs-comment">// 重做要设置数据到最新</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      	<span class="hljs-comment">// 撤销</span><br>        <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>        pgno = xi.pgno;<br>        offset = xi.offset;<br>        raw = xi.oldRaw;	<span class="hljs-comment">// 撤销要设置数据到久版本</span><br>    &#125;<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(pgno);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 见普通页部分</span><br>        PageX.recoverUpdate(pg, raw, offset);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        pg.release();<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// insertLog的重做和撤销操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInsertLog</span><span class="hljs-params">(PageCache pc, <span class="hljs-type">byte</span>[] log, <span class="hljs-type">int</span> flag)</span> &#123;<br>    <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(li.pgno);<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(flag == UNDO) &#123;<br>          	<span class="hljs-comment">// 撤销插入，逻辑删除，大致的作用，就是将该条 DataItem 的有效位设置为无效，来进行逻辑删除。</span><br>            DataItem.setDataItemRawInvalid(li.raw);<br>        &#125;<br>      	<span class="hljs-comment">// 见普通页部分</span><br>        PageX.recoverInsert(pg, li.raw, li.offset);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        pg.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="页面索引与DM的实现"><a href="#页面索引与DM的实现" class="headerlink" title="页面索引与DM的实现"></a>页面索引与DM的实现</h2><blockquote>
<p>本节将为 DM 层做收尾，介绍一个实现简单的页面索引。并且实现了 DM 层对于上层的抽象：DataItem。</p>
</blockquote>
<h3 id="页面索引"><a href="#页面索引" class="headerlink" title="页面索引"></a>页面索引</h3><p>页面索引，<strong>缓存了每一页的空闲空间</strong>。用于在上层模块进行插入操作时，能够快速找到一个合适空间的页面，而<strong>无需从磁盘或者缓存中检查每一个页面的信息</strong>。</p>
<p>MYDB 用一个比较粗略的算法实现了页面索引，将一页的空间划分成了 <strong>40 个区间</strong>。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这 40 个区间中。insert 在请求一个页时，会首先将所需的空间<strong>向上取整</strong>，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。</p>
<p><code>PageIndex</code> 的实现也很简单，一个 List 类型的数组。</p>
<blockquote>
<p><code>lists</code>的作用是将页面信息根据页面的剩余空间分组存储，<code>THRESHOLD</code> &#x3D; 8192 &#x2F; 40 &#x3D; 204.8，这意味着，页面的剩余空间将被按大约 <strong>204.8 字节</strong>划分成多个区间，每个页面的剩余空间将根据这个阈值来计算自己属于哪个区间，并将自己的页面信息PageInfo放到对应的<code>list</code>下。打个比方：</p>
<ul>
<li>如果页面的<strong>剩余空间是 500 字节</strong>，那么它将**被划分到 500 &#x2F; 204.8 ≈ 2 的区间中（即 lists[2]）。**此时如果有一个数据，大小在 <code>[1 * 204.8, 2 * 204.8] </code>之间，那么他就会先到lists[2]中找到这个页面，并将数据保存在这个页面。</li>
<li>如果剩余空间是 1500 字节，那么它将被划分到 1500 &#x2F; 204.8 ≈ 7 的区间中（即 lists[7]）。</li>
<li>如果有多个页面，它们的<strong>剩余空间都在同一个区间内</strong>，那就会<strong>放在同一个<code>list</code>中</strong>，要取的时候，从列表头取起。</li>
<li>通过这个操作，要保存数据的时候就不用到磁盘中去一个个找哪个页面能够容纳这个数据，直接在<code>PageIndex</code>中就能够知道哪一页是能容纳该数据的。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageIndex</span> &#123;<br>    <span class="hljs-comment">// 将一页划成40个区间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERVALS_NO</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br>  	<span class="hljs-comment">// 一个区间的大小，8192 / 40 = 204.8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> PageCache.PAGE_SIZE / INTERVALS_NO;<br><br>    <span class="hljs-keyword">private</span> Lock lock;<br>  	<span class="hljs-comment">// </span><br>    <span class="hljs-keyword">private</span> List&lt;PageInfo&gt;[] lists;<br>  <br>  	<span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PageIndex</span><span class="hljs-params">()</span> &#123;<br>        lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[INTERVALS_NO+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; INTERVALS_NO+<span class="hljs-number">1</span>; i ++) &#123;<br>            lists[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageInfo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> freeSpace;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PageInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno, <span class="hljs-type">int</span> freeSpace)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pgno = pgno;<br>        <span class="hljs-built_in">this</span>.freeSpace = freeSpace;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当来了一个大小为<code>spaceSize</code>的数据要保存到页面时，使用<code>select()</code>方法，直接算出区间号，直接取即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> PageInfo <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> spaceSize)</span> &#123;<br>  	<span class="hljs-comment">// 计算哪个区间内的页面能容纳该数据（大于number的list中包含能容纳该数据的页面）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> spaceSize / THRESHOLD;<br>    <span class="hljs-keyword">if</span>(number &lt; INTERVALS_NO) number ++;<br>    <span class="hljs-keyword">while</span>(number &lt;= INTERVALS_NO) &#123;<br>      	<span class="hljs-comment">// lists[number]中没有页面，那就往下找</span><br>        <span class="hljs-keyword">if</span>(lists[number].size() == <span class="hljs-number">0</span>) &#123;<br>            number ++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>      	<span class="hljs-comment">// 找到一个符合的页面，返回页面信息PageInfo，并将该页从list中移除</span><br>        <span class="hljs-keyword">return</span> lists[number].remove(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以注意到，被选择的页，会<strong>直接从 <code>PageIndex</code> 中移除</strong>，这意味着，<strong>同一个页面是不允许并发写的</strong>。在上层模块使用完这个页面后，需要将其重新插入 <code>PageIndex</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno, <span class="hljs-type">int</span> freeSpace)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> freeSpace / THRESHOLD;<br>    lists[number].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>(pgno, freeSpace));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 <code>DataManager</code> 被创建时，需要获取所有页面并填充 <code>PageIndex</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化pageIndex</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">fillPageIndex</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageNumber</span> <span class="hljs-operator">=</span> pc.getPageNumber();<br>  	<span class="hljs-comment">// 第一页用于启动检查，页面从1开始，故int i = 2</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= pageNumber; i ++) &#123;<br>        <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          	<span class="hljs-comment">// getPage调用了AbstractCache中get方法，调用这个方法会先到缓存（HashMap cache）中找对应页号i的页面，若没有再到数据源（文件系统）找</span><br>            pg = pc.getPage(i);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>      	<span class="hljs-comment">// 将对应的页面信息添加到PageIndex中</span><br>        pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));<br>      	<span class="hljs-comment">// 注意在使用完 Page 后需要及时 release，否则可能会撑爆缓存</span><br>        pg.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="DataItem"><a href="#DataItem" class="headerlink" title="DataItem"></a>DataItem</h3><p><code>DataItem</code>是 DM 层<strong>向上层提供的数据抽象</strong>。上层模块通过地址，向 DM 请求到对应的 <code>DataItem</code>，再获取到其中的数据。<code>DataItem</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dataItem 结构如下：</span><br><span class="hljs-comment"> * [ValidFlag] [DataSize] [Data]</span><br><span class="hljs-comment"> * ValidFlag 1字节，0为合法，1为非法</span><br><span class="hljs-comment"> * DataSize  2字节，标识Data的长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataItemImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataItem</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_VALID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>		<br>    <span class="hljs-keyword">private</span> SubArray raw;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] oldRaw;<br>    <span class="hljs-keyword">private</span> Lock rLock;<br>    <span class="hljs-keyword">private</span> Lock wLock;<br>    <span class="hljs-keyword">private</span> DataManagerImpl dm;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> uid;<br>    <span class="hljs-keyword">private</span> Page pg;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] raw;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> start;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SubArray</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-built_in">this</span>.raw = raw;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>DataItem</code>中<code>SubArray raw</code>的大概意思：</p>
<ul>
<li>因为数据都是放在页面里的，取数据的时候也是按页为单位取的，故**<code>raw.raw</code>一般表示的是数据所在页那一整页的数据**</li>
<li>所以**<code>raw.start</code>表示的是<code>DataItem</code>所表示的数据在这一页中的起始位置**（偏移<code>offset</code>）</li>
</ul>
</blockquote>
<p>DataItem 中保存的数据，结构如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[ValidFlag]</span> <span class="hljs-selector-attr">[DataSize]</span> <span class="hljs-selector-attr">[Data]</span><br></code></pre></td></tr></table></figure>

<p>其中 <code>ValidFlag</code> 占用 1 字节，<strong>标识了该 <code>DataItem</code> 是否有效</strong>。<strong>删除一个 <code>DataItem</code>，只需要简单地将其有效位设置为 1</strong>。<code>DataSize</code> 占用 2 字节，标识了后面 <code>Data</code> 的长度。</p>
<blockquote>
<p>根据上面<code>DataItem</code>的结构，我们有：</p>
<ul>
<li><code>offset = raw.start</code></li>
<li><code>ValidFlag = raw.raw[offset + OF_VALID]</code></li>
<li><code>DataSize = Parser.parseShort(Arrays.copyOfRange(raw, offset+DataItemImpl.OF_SIZE, offset+DataItemImpl.OF_DATA))</code></li>
</ul>
</blockquote>
<p>上层模块在获取到 <code>DataItem</code> 后，可以通过 <code>data()</code> 方法，该方法返回的数组是数据共享的，而不是拷贝实现的，所以使用了 <code>SubArray</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SubArray <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(raw.raw, raw.start+OF_DATA, raw.end);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上层模块试图对 <code>DataItem</code> 进行修改时，需要遵循一定的流程：在<strong>修改之前</strong>需要调用 <code>before()</code> 方法，想要<strong>撤销修改</strong>时，调用 <code>unBefore()</code> 方法，在<strong>修改完成</strong>后，调用 <code>after()</code> 方法。整个流程，<strong>主要是为了保存前相数据，并及时落日志</strong>。DM 会保证对 <code>DataItem</code> 的修改是原子性的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>    wLock.lock();<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    System.arraycopy(raw.raw, raw.start, oldRaw, <span class="hljs-number">0</span>, oldRaw.length);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unBefore</span><span class="hljs-params">()</span> &#123;<br>    System.arraycopy(oldRaw, <span class="hljs-number">0</span>, raw.raw, raw.start, oldRaw.length);<br>    wLock.unlock();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>  	<span class="hljs-comment">// 调用 dm 中的一个方法，对修改操作落日志</span><br>    dm.logDataItem(xid, <span class="hljs-built_in">this</span>);<br>    wLock.unlock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> raw.raw[raw.start+OF_VALID] == (<span class="hljs-type">byte</span>)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在使用完 <code>DataItem</code> 后，也应当及时调用 <code>release()</code>方法，释放掉 <code>DataItem</code> 的缓存（由 DM 缓存 <code>DataItem</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    dm.releaseDataItem(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="DM的实现"><a href="#DM的实现" class="headerlink" title="DM的实现"></a>DM的实现</h3><h4 id="DM读取、释放数据DataItem"><a href="#DM读取、释放数据DataItem" class="headerlink" title="DM读取、释放数据DataItem"></a>DM读取、释放数据DataItem</h4><p><code>DataManager</code> 是 DM 层直接对外提供方法的类，同时，也实现成 <code>DataItem</code> 对象的<strong>缓存</strong>，继承<code>AbstractCache</code>。<code>DataItem</code> 存储的 <strong>key</strong>，是<strong>由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4 字节</strong>。</p>
<p>DataItem 缓存，<code>getForCache()</code>，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> DataItem <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">16</span>) - <span class="hljs-number">1</span>));<br>    uid &gt;&gt;&gt;= <span class="hljs-number">32</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>));<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> pc.getPage(pgno);<br>    <span class="hljs-keyword">return</span> DataItem.parseDataItem(pg, offset, <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 从页面的offset处解析处DataItem</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataItem <span class="hljs-title function_">parseDataItem</span><span class="hljs-params">(Page pg, <span class="hljs-type">short</span> offset, DataManagerImpl dm)</span> &#123;<br>  	<span class="hljs-comment">// 获取这个页面的所有数据</span><br>    <span class="hljs-type">byte</span>[] raw = pg.getData();<br>  	<span class="hljs-comment">// 获取这个DataItem的Data字段的长度</span><br>    <span class="hljs-type">short</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Parser.parseShort(Arrays.copyOfRange(raw, offset+DataItemImpl.OF_SIZE, offset+DataItemImpl.OF_DATA));<br>  	<span class="hljs-comment">// 获取这个DataItem总长度，则这个DataItem在这个页面中的范围是[offset， offset + length]</span><br>    <span class="hljs-type">short</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(size + DataItemImpl.OF_DATA);<br>  	<span class="hljs-comment">// 获取这个DataItem的uid</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> Types.addressToUid(pg.getPageNumber(), offset);<br>  	<span class="hljs-comment">// 拼装成一个DataItem返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataItemImpl</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(raw, offset, offset+length), <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length], pg, uid, dm);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>DataItem</code> 缓存释放，需要将 <code>DataItem</code> 写回数据源，由于对文件的读写是以页为单位进行的，只需要<strong>将 <code>DataItem</code> 所在的页 release</strong> 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(DataItem di)</span> &#123;<br>    di.page().release();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="DM的创建与打开"><a href="#DM的创建与打开" class="headerlink" title="DM的创建与打开"></a>DM的创建与打开</h4><p>从<strong>已有文件</strong>创建 <code>DataManager</code> 和从<strong>空文件</strong>创建 <code>DataManager</code> 的流程稍有不同，除了 PageCache 和 Logger 的创建方式有所不同以外，从<strong>空文件创建首先需要对第一页进行初始化</strong>，而<strong>从已有文件创建，则是需要对第一页进行校验</strong>，来判断是否需要执行恢复流程。并重新对第一页生成随机字节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataManager <span class="hljs-title function_">create</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem, TransactionManager tm)</span> &#123;<br>    <span class="hljs-type">PageCache</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> PageCache.create(path, mem);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> Logger.create(path);<br>    <span class="hljs-type">DataManagerImpl</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataManagerImpl</span>(pc, lg, tm);<br>    dm.initPageOne();<br>    <span class="hljs-keyword">return</span> dm;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataManager <span class="hljs-title function_">open</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem, TransactionManager tm)</span> &#123;<br>    <span class="hljs-type">PageCache</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> PageCache.open(path, mem);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> Logger.open(path);<br>    <span class="hljs-type">DataManagerImpl</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataManagerImpl</span>(pc, lg, tm);<br>    <span class="hljs-keyword">if</span>(!dm.loadCheckPageOne()) &#123;<br>        Recover.recover(tm, lg, pc);<br>    &#125;<br>    dm.fillPageIndex();<br>    PageOne.setVcOpen(dm.pageOne);<br>    dm.pc.flushPage(dm.pageOne);<br>    <span class="hljs-keyword">return</span> dm;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中，初始化第一页，和校验第一页，基本都是调用 PageOne 类中的方法实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在创建文件时初始化PageOne</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">initPageOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pc.newPage(PageOne.InitRaw());<br>    <span class="hljs-keyword">assert</span> pgno == <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pageOne = pc.getPage(pgno);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    pc.flushPage(pageOne);<br>&#125;<br><br><span class="hljs-comment">// 在打开已有文件时时读入PageOne，并验证正确性</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">loadCheckPageOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pageOne = pc.getPage(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> PageOne.checkVc(pageOne);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="DM读、插入数据"><a href="#DM读、插入数据" class="headerlink" title="DM读、插入数据"></a>DM读、插入数据</h4><p>DM 层提供了三个功能<strong>供上层使用</strong>，分别是读、插入和修改。修改是通过读出的 <code>DataItem</code> 实现的，于是 <code>DataManager</code> 只需要提供 <code>read()</code> 和 <code>insert()</code> 方法。</p>
<ul>
<li><code>read()</code> 根据 UID 从缓存中获取 DataItem，并校验有效位：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> DataItem <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DataItemImpl</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> (DataItemImpl)<span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">if</span>(!di.isValid()) &#123;<br>        di.release();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> di;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>insert()</code> 方法，在 <code>pageIndex</code> 中获取一个<strong>足以存储插入内容的页面的页号</strong>，获取页面后，<strong>首先需要写入插入日志</strong>，接着才可以<strong>通过 pageX 插入数据</strong>，并返回插入位置的偏移。最后需要<strong>将页面信息重新插入 pageIndex</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] wrapDataItemRaw(<span class="hljs-type">byte</span>[] raw) &#123;<br>    <span class="hljs-type">byte</span>[] valid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span>];	<span class="hljs-comment">// 起始默认值为0，表示合法</span><br>    <span class="hljs-type">byte</span>[] size = Parser.short2Byte((<span class="hljs-type">short</span>)raw.length);<br>    <span class="hljs-keyword">return</span> Bytes.concat(valid, size, raw);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  	<span class="hljs-comment">// 包装成DataItem</span><br>    <span class="hljs-type">byte</span>[] raw = DataItem.wrapDataItemRaw(data);<br>    <span class="hljs-keyword">if</span>(raw.length &gt; PageX.MAX_FREE_SPACE) &#123;<br>        <span class="hljs-keyword">throw</span> Error.DataTooLargeException;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试获取可用页</span><br>    <span class="hljs-type">PageInfo</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) &#123;<br>        pi = pIndex.select(raw.length);<br>        <span class="hljs-keyword">if</span> (pi != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newPgno</span> <span class="hljs-operator">=</span> pc.newPage(PageX.initRaw());<br>            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pi == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> Error.DatabaseBusyException;<br>    &#125;<br><br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">freeSpace</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(pi.pgno);<br>        <span class="hljs-comment">// 首先做日志</span><br>        <span class="hljs-type">byte</span>[] log = Recover.insertLog(xid, pg, raw);<br>        logger.log(log);<br>        <span class="hljs-comment">// 再执行插入操作</span><br>        <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageX.insert(pg, raw);<br><br>        pg.release();<br>        <span class="hljs-keyword">return</span> Types.addressToUid(pi.pgno, offset);<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 将取出的pg重新插入pIndex</span><br>        <span class="hljs-keyword">if</span>(pg != <span class="hljs-literal">null</span>) &#123;<br>            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pIndex.add(pi.pgno, freeSpace);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="DM的关闭"><a href="#DM的关闭" class="headerlink" title="DM的关闭"></a>DM的关闭</h4><p><code>DataManager</code> 正常关闭时，需要执行缓存和日志的关闭流程，不要忘了设置<strong>第一页的字节校验</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>  	<span class="hljs-comment">// DataManager缓存关闭</span><br>    <span class="hljs-built_in">super</span>.close();<br>  	<span class="hljs-comment">// 日志关闭</span><br>    logger.close();<br>		<br>  <br>  	<span class="hljs-comment">// 第一页的字节校验</span><br>    PageOne.setVcClose(pageOne);<br>    pageOne.release();<br>  	<span class="hljs-comment">// 页面缓存关闭</span><br>    pc.close();<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="4-Version-Manager"><a href="#4-Version-Manager" class="headerlink" title="4. Version Manager"></a>4. Version Manager</h1><blockquote>
<p>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。类似于 Data Manager 是 MYDB 的数据管理核心，Version Manager 是 MYDB 的<strong>事务和数据版本的管理核心</strong>。</p>
</blockquote>
<h2 id="2PL与MVCC"><a href="#2PL与MVCC" class="headerlink" title="2PL与MVCC"></a>2PL与MVCC</h2><h3 id="冲突与2PL"><a href="#冲突与2PL" class="headerlink" title="冲突与2PL"></a>冲突与2PL</h3><p>首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这<strong>两个操作相互冲突</strong>：</p>
<ol>
<li>这两个操作是由不同的事务执行的</li>
<li>这两个操作操作的是同一个数据项</li>
<li>这两个操作至少有一个是更新操作</li>
</ol>
<p>那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：</p>
<ol>
<li>两个不同事务的 U 操作冲突</li>
<li>两个不同事务的 U、R 操作冲突</li>
</ol>
<p>那么冲突或者不冲突，意义何在？作用在于，<strong>交换两个互不冲突的操作的顺序，不会对最终的结果造成影响</strong>，而交换两个冲突操作的顺序，则是会有影响的。 </p>
<p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。<strong>MYDB 采用两段锁协议（2PL）来实现。<strong>当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作</strong>相互冲突</strong>的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的<strong>读或者写操作都会被阻塞</strong>，T2 必须等待 T1 释放掉对 x 的锁。</p>
<p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了<strong>事务间的相互阻塞</strong>，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</p>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>在介绍 MVCC 之前，首先明确记录和版本的概念。</p>
<p>DM 层向上层提供了数据项（<code>DataItem</code>）的概念，VM 通过管理所有的数据项，向上层提供了记录（<code>Entry</code>）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（<code>Version</code>）。每当上层模块对某个记录进行修改时，VM 就会为这个记录<strong>创建一个新的版本</strong>。</p>
<p>MYDB 通过 MVCC，<strong>降低了事务的阻塞概率</strong>。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是<strong>创建了一个新的 X 的版本，假设为 x3</strong>。假设 T1 <strong>还没有释放</strong> X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会<strong>返回一个较老版本的 X，例如 x2</strong>。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X <strong>没有一个更老的版本</strong>，那<strong>只能等待 T1 释放锁</strong>了。所以只是<strong>降低了概率</strong>。</p>
<h2 id="记录的实现"><a href="#记录的实现" class="headerlink" title="记录的实现"></a>记录的实现</h2><p>对于一条记录来说，MYDB 使用 <code>Entry</code> 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 <code>Update</code> 操作，对于字段的<strong>更新操作由后面的表和字段管理（TBM）实现</strong>。所以在 VM 的实现中，一条记录只有一个版本。</p>
<p>一条记录存储在一条 <code>DataItem</code> 中，所以 <code>Entry</code> 中保存一个 <code>DataItem</code> 的引用即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM向上层抽象出entry</span><br><span class="hljs-comment"> * entry结构：</span><br><span class="hljs-comment"> * [XMIN] [XMAX] [data]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XMIN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;		<span class="hljs-comment">// entry XMIN的起始位置：0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XMAX</span> <span class="hljs-operator">=</span> OF_XMIN+<span class="hljs-number">8</span>;	<span class="hljs-comment">// entry XMAX的起始位置：8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> OF_XMAX+<span class="hljs-number">8</span>;	<span class="hljs-comment">// 注意⚠️，这里的OF_DATA=16要和DataItemImpl中的OF_DATA=3区分开来</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> uid;<br>    <span class="hljs-keyword">private</span> DataItem dataItem;<br>    <span class="hljs-keyword">private</span> VersionManager vm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title function_">loadEntry</span><span class="hljs-params">(VersionManager vm, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DataItem</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);<br>        <span class="hljs-keyword">return</span> newEntry(vm, di, uid);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        dataItem.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们规定，一条 <code>Entry</code> 中存储的数据格式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">// XMIN和XMAX都是一个<span class="hljs-number">8</span>字节的byte<span class="hljs-selector-attr">[]</span><br><span class="hljs-selector-attr">[XMIN]</span> <span class="hljs-selector-attr">[XMAX]</span> <span class="hljs-selector-attr">[DATA]</span><br></code></pre></td></tr></table></figure>

<p><code>XMIN</code> 是<strong>创建该条记录（版本）的事务编号</strong>，而 <code>XMAX</code> 则是<strong>删除该条记录（版本）的事务编号</strong>。它们的作用将在下一节中说明。<code>DATA</code> 就是<strong>这条记录持有的数据</strong>。根据这个结构，在<strong>创建记录</strong>时调用的 <code>wrapEntryRaw()</code> 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] wrapEntryRaw(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data) &#123;<br>    <span class="hljs-type">byte</span>[] xmin = Parser.long2Byte(xid);<br>    <span class="hljs-type">byte</span>[] xmax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">return</span> Bytes.concat(xmin, xmax, data);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同样，如果要<strong>获取记录中持有的数据</strong>，也就需要按照这个结构来解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以拷贝的形式返回内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] data() &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 从DataItem中取出数据部分：也就是除去VaildFlag和DataSize后面的数据部分，也是一个SubArray</span><br>        <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> dataItem.data();<br>      	<span class="hljs-comment">// 取出来的数据sa也被分为[XMIN] [XMAX] [DATA]的结构，这里的OF_DATA=16</span><br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[sa.end - sa.start - OF_DATA];<br>        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="hljs-number">0</span>, data.length);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里以拷贝的形式返回数据，如果需要修改的话，需要对 <code>DataItem</code> 执行 <code>before()</code> 方法，这个在设置 <code>XMAX</code> 的值中体现了（<code>XMAX</code>表示的是）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setXmax</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    dataItem.before();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> dataItem.data();<br>      	<span class="hljs-comment">// 将sa的XMAX部分修改为当前的xid</span><br>        System.arraycopy(Parser.long2Byte(xid), <span class="hljs-number">0</span>, sa.raw, sa.start+OF_XMAX, <span class="hljs-number">8</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.after(xid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="读提交（Read-Committed-RC）"><a href="#读提交（Read-Committed-RC）" class="headerlink" title="读提交（Read Committed, RC）"></a>读提交（Read Committed, RC）</h3><p>上面提到，如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，MYDB 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是<strong>版本可见性</strong>的概念就诞生了。</p>
<p>版本的可见性与事务的隔离度是相关的。MYDB 支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。</p>
<p>MYDB 实现读提交，为每个版本维护了两个变量，就是上面提到的 <code>XMIN</code>和 <code>XMAX</code>：</p>
<ul>
<li><code>XMIN</code>：创建该版本的事务编号</li>
<li><code>XMAX</code>：删除该版本的事务编号</li>
</ul>
<p><strong><code>XMIN</code> 应当在版本创建时填写，而 <code>XMAX</code> 则在版本被删除，或者有新版本出现时填写。</strong></p>
<p><code>XMAX</code> 这个变量，也就解释了为什么 DM 层不提供删除操作，<strong>当想删除一个版本时，只需要设置其 <code>XMAX</code></strong>，这样，<strong>这个版本对每一个 <code>XMAX</code> 之后的事务都是不可见的</strong>，也就等价于删除了。</p>
<p>如此，在读提交下，版本对事务的可见性逻辑如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 对于当前事务Ti，当如下逻辑判断为true时，该版本对当前事务Ti可见</span><br><br>(XMIN == Ti <span class="hljs-keyword">and</span>                             	<span class="hljs-comment">// 由Ti创建且</span><br>    XMAX == NULL                            	<span class="hljs-comment">// 还未被删除</span><br>)<br><span class="hljs-symbol">or</span>                                          	<span class="hljs-comment">// 或</span><br>(XMIN is commited <span class="hljs-keyword">and</span>                       	<span class="hljs-comment">// 由一个已提交的事务创建且</span><br>    (XMAX == NULL or                        	<span class="hljs-comment">// 尚未删除或</span><br>    	(XMAX != Ti <span class="hljs-keyword">and</span> XMAX is not commited)   <span class="hljs-comment">// 由一个未提交的事务删除</span><br>    )<br>)<br></code></pre></td></tr></table></figure>

<p>若条件为 true，则版本对 Ti 可见。那么获取 Ti 适合的版本，只需要<strong>从最新版本开始，依次向前检查可见性</strong>，如果为 true，就可以直接返回。以下方法判断某个记录对事务 t 是否可见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readCommitted</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>  	<span class="hljs-comment">// 当前事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> t.xid;<br>  	<span class="hljs-comment">// 该条记录的XMIN，即创建该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmin</span> <span class="hljs-operator">=</span> e.getXmin();<br>  	<span class="hljs-comment">// 该条记录的XMAX，即删除该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  <br>  	<span class="hljs-comment">// 该记录由当前事务创建，且还未被删除，则对当前事务可见</span><br>    <span class="hljs-keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  	<span class="hljs-comment">// 该记录由一条已提交事务创建</span><br>    <span class="hljs-keyword">if</span>(tm.isCommitted(xmin)) &#123;<br>      	<span class="hljs-comment">// 该记录还未被删除，则对当前事务可见</span><br>        <span class="hljs-keyword">if</span>(xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      	<span class="hljs-comment">// 该记录已被删除，但不是当前事务删除的，且删除这条记录的事务还没提交，则对当前事务可见</span><br>        <span class="hljs-keyword">if</span>(xmax != xid) &#123;<br>            <span class="hljs-keyword">if</span>(!tm.isCommitted(xmax)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>  	<span class="hljs-comment">// 对当前事务不可见</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="可重复读（Repeatable-Read-RR）"><a href="#可重复读（Repeatable-Read-RR）" class="headerlink" title="可重复读（Repeatable Read, RR）"></a>可重复读（Repeatable Read, RR）</h3><p>读提交会导致的问题大家也都很清楚，八股也背了不少。那就是不可重复读和幻读。这里我们来解决<strong>不可重复读</strong>的问题。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">T1 begin<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1 读得 0</span><br>T2 begin<br><span class="hljs-function"><span class="hljs-title">U2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// 将 X 修改为 1</span><br>T2 commit<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1 读的 1</span><br></code></pre></td></tr></table></figure>

<p>T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定：</p>
<blockquote>
<p>事务只能读取<strong>它开始时, 就已经结束的那些事务产生的数据版本</strong></p>
</blockquote>
<p>这条规定，相当于，事务需要<strong>忽略</strong>：</p>
<ol>
<li>在<strong>本事务后开始的事务的数据</strong>;</li>
<li><strong>本事务开始时还是 active 状态的事务的数据</strong></li>
</ol>
<p>对于第一条，只需要<strong>比较事务 ID，即可确定，因为事务ID是自增的</strong>。而对于第二条，则需要在<strong>事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)</strong>，如果记录的某个版本，XMIN 在 SP(Ti) 中，说明<strong>创建这个版本记录的事务，在当前事务开始时处于active状态</strong>，也应当对 Ti 不可见。于是，可重复读的判断逻辑如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 对于当前事务Ti，当如下逻辑判断为true时，该版本对当前事务Ti可见</span><br><br>(XMIN == Ti <span class="hljs-keyword">and</span>                 <span class="hljs-comment">// 由Ti创建且</span><br> (XMAX == NULL)                 <span class="hljs-comment">// 尚未被删除</span><br>)<br><span class="hljs-symbol">or</span>                              <span class="hljs-comment">// 或</span><br>(XMIN is commited <span class="hljs-keyword">and</span>           <span class="hljs-comment">// 由一个已提交的事务创建且</span><br> XMIN &lt; XID <span class="hljs-keyword">and</span>                 <span class="hljs-comment">// 这个事务小于Ti且</span><br> XMIN is not in <span class="hljs-built_in">SP</span>(Ti) <span class="hljs-keyword">and</span>      <span class="hljs-comment">// 这个事务在Ti开始前提交且</span><br> (XMAX == NULL or               <span class="hljs-comment">// 尚未被删除或</span><br>  (XMAX != Ti <span class="hljs-keyword">and</span>               <span class="hljs-comment">// 由其他事务删除但是</span><br>   (XMAX is not commited or     <span class="hljs-comment">// 这个事务尚未提交或</span><br><span class="hljs-symbol">XMAX</span> &gt; Ti or                    <span class="hljs-comment">// 这个事务在Ti开始之后才开始或</span><br><span class="hljs-symbol">XMAX</span> is in <span class="hljs-built_in">SP</span>(Ti)               <span class="hljs-comment">// 这个事务在Ti开始前还未提交</span><br>))))<br></code></pre></td></tr></table></figure>

<p>于是，需要提供一个结构，来抽象一个事务，以保存<strong>快照数据</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> xid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> level;<br>  	<span class="hljs-comment">// snapshot用来保存活跃事务id</span><br>    <span class="hljs-keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;<br>    <span class="hljs-keyword">public</span> Exception err;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> autoAborted;<br><br>  	<span class="hljs-comment">// 构造方法，active保存着当前所有状态为active的事务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Transaction <span class="hljs-title function_">newTransaction</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;<br>        <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transaction</span>();<br>        t.xid = xid;<br>        t.level = level;<br>      	<span class="hljs-comment">// 如果是可重复读隔离级别，会将当前处于active的事务id保存到snapshot中</span><br>        <span class="hljs-keyword">if</span>(level != <span class="hljs-number">0</span>) &#123;<br>            t.snapshot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(Long x : active.keySet()) &#123;<br>                t.snapshot.put(x, <span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInSnapshot</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>        <span class="hljs-keyword">if</span>(xid == TransactionManagerImpl.SUPER_XID) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> snapshot.containsKey(xid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>于是，可重复读的隔离级别下，一个版本是否对事务可见的判断如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatableRead</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>  	<span class="hljs-comment">// 当前事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> t.xid;<br>  	<span class="hljs-comment">// 创建该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmin</span> <span class="hljs-operator">=</span> e.getXmin();<br>  	<span class="hljs-comment">// 删除该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  	<span class="hljs-comment">// 当前事务创建了该记录 且 该记录还没被删除</span><br>    <span class="hljs-keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  	<span class="hljs-comment">// 创建该记录的事务已提交 且 创建该记录的事务比当前事务早 且 当前事务创建时，创建该记录的事务不处于active状态</span><br>    <span class="hljs-keyword">if</span>(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;<br>      	<span class="hljs-comment">// 该记录还未被删除</span><br>        <span class="hljs-keyword">if</span>(xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      	<span class="hljs-comment">// 该记录被删除，但不是当前事务删除的</span><br>        <span class="hljs-keyword">if</span>(xmax != xid) &#123;<br>          	<span class="hljs-comment">// 删除该记录的事务未提交 或 删除该记录的事务比当前事务晚 或 当前事务创建时，删除该记录的事务处于active状态</span><br>            <span class="hljs-keyword">if</span>(!tm.isCommitted(xmax) || xmax &gt; xid || t.isInSnapshot(xmax)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="版本跳跃问题"><a href="#版本跳跃问题" class="headerlink" title="版本跳跃问题"></a>版本跳跃问题</h2><p>版本跳跃问题，考虑如下的情况，假设 X 最初只有 x0 版本，T1 和 T2 都是可重复读的隔离级别：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">T1 begin<br>T2 begin<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1读取x0</span><br><span class="hljs-function"><span class="hljs-title">R2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T2读取x0</span><br><span class="hljs-function"><span class="hljs-title">U1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1将X更新到x1</span><br>T1 commit<br><span class="hljs-function"><span class="hljs-title">U2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T2将X更新到x2</span><br>T2 commit<br></code></pre></td></tr></table></figure>

<p>这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 <strong>T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本</strong>。</p>
<p>**读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。**解决版本跳跃的思路也很简单：<strong>如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚</strong>。</p>
<p>上一节中就总结了，<strong>Ti 不可见的 Tj</strong>，有两种情况：</p>
<ol>
<li>XID(Tj) &gt; XID(Ti)</li>
<li>Tj in SP(Ti)</li>
</ol>
<p>于是版本跳跃的检查也就很简单了，取出要修改的数据 X 的最新提交版本，并<strong>检查该最新版本的创建者对当前事务是否可见</strong>：</p>
<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502221957403.jpg" srcset="/img/loading.gif" lazyload alt="IMG_3883 2" style="zoom:10%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检查版本跳跃 -&gt; 检查当前事务要修改的数据最新版本的创建者是否对当前事务可见</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVersionSkip</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  	<span class="hljs-comment">// level = 0是读提交，可以接受版本跳跃</span><br>    <span class="hljs-keyword">if</span>(t.level == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      	<span class="hljs-comment">// 创建该数据的最新版本的事务已提交 且 （这个事务比当前事务创建晚 或 这个事务在当前事务创建时处于active状态），而我们当前事务想要更改这个数据，就会发生版本跳跃</span><br>        <span class="hljs-keyword">return</span> tm.isCommitted(xmax) &amp;&amp; <br>          (xmax &gt; t.xid || t.isInSnapshot(xmax));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj –&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要<strong>查看这个图中是否有环即可</strong>。</p>
<p>MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="hljs-comment">// 某个XID已经获得的资源的UID列表</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="hljs-comment">// UID被某个XID持有</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="hljs-comment">// 正在等待UID的XID列表</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="hljs-comment">// 正在等待资源的XID的锁</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="hljs-comment">// XID正在等待的UID</span><br>    <span class="hljs-keyword">private</span> Lock lock;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<strong>每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测</strong>。如果<strong>检测到死锁，就撤销这条边，不允许添加，并撤销该事务</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// xid事务想要获得uid资源</span><br><span class="hljs-comment">// 不需要等待则返回null，否则返回锁对象</span><br><span class="hljs-comment">// 会造成死锁则抛出异常</span><br><span class="hljs-keyword">public</span> Lock <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// xid事务已获得uid资源</span><br>        <span class="hljs-keyword">if</span>(isInList(x2u, xid, uid)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      	<span class="hljs-comment">// 没有事务持有uid资源，则xid事务可以获取</span><br>        <span class="hljs-keyword">if</span>(!u2x.containsKey(uid)) &#123;<br>            u2x.put(uid, xid);<br>            putIntoList(x2u, xid, uid);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      	<span class="hljs-comment">// xid事务正在等待uid资源</span><br>        waitU.put(xid, uid);<br>      	<span class="hljs-comment">// 将xid事务加入到等待uid资源的事务列表里</span><br>        putIntoList(wait, xid, uid);<br>      	<span class="hljs-comment">// 发生死锁，抛出异常</span><br>        <span class="hljs-keyword">if</span>(hasDeadLock()) &#123;<br>            waitU.remove(xid);<br>            removeFromList(wait, uid, xid);<br>            <span class="hljs-keyword">throw</span> Error.DeadlockException;<br>        &#125;<br>      	<span class="hljs-comment">// 没发生死锁，则将一个上了锁的Lock对象加入到xid事务的锁map里，返回这个锁</span><br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        l.lock();<br>        waitLock.put(xid, l);<br>        <span class="hljs-keyword">return</span> l;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用 add，如果<strong>需要等待的话，会返回一个上了锁的 Lock 对象</strong>。调用方在<strong>获取到该对象时，需要尝试获取该对象的锁，由此实现阻塞线程的目的</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ⚠️</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> lt.add(xid, uid);<br><span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>    l.lock();   <span class="hljs-comment">// 阻塞在这一步？ l是一个可重入锁，同一个线程再执行加锁不会阻塞吧？</span><br>    l.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>查找<strong>图中是否有环</strong>的算法也非常简单，就是一个深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasDeadLock</span><span class="hljs-params">()</span> &#123;<br>    xidStamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    stamp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> xid : x2u.keySet()) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> xidStamp.get(xid);<br>        <span class="hljs-keyword">if</span>(s != <span class="hljs-literal">null</span> &amp;&amp; s &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        stamp ++;<br>        <span class="hljs-keyword">if</span>(dfs(xid)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">stp</span> <span class="hljs-operator">=</span> xidStamp.get(xid);<br>    <span class="hljs-keyword">if</span>(stp != <span class="hljs-literal">null</span> &amp;&amp; stp == stamp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(stp != <span class="hljs-literal">null</span> &amp;&amp; stp &lt; stamp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    xidStamp.put(xid, stamp);<br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> waitU.get(xid);<br>    <span class="hljs-keyword">if</span>(uid == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> u2x.get(uid);<br>    <span class="hljs-keyword">assert</span> x != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> dfs(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在一个事务 commit 或者 abort 时，就可以释放<strong>所有</strong>它持有的锁，并将自身从等待图中删除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        List&lt;Long&gt; l = x2u.get(xid);<br>        <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>          	<span class="hljs-comment">// 把所有资源都释放</span><br>            <span class="hljs-keyword">while</span>(l.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> l.remove(<span class="hljs-number">0</span>);<br>              	<span class="hljs-comment">// 被释放的资源，从它的等待队列中选一个xid事务来占用该uid资源</span><br>                selectNewXID(uid);<br>            &#125;<br>        &#125;<br>      	<br>      	<span class="hljs-comment">// abort时可能还在等别的资源，abort后就不用等了，故移除waitU中的东西</span><br>        waitU.remove(xid);<br>      	<span class="hljs-comment">// xid事务已释放所有资源，将xid从获得资源map中移除</span><br>        x2u.remove(xid);<br>      	<span class="hljs-comment">// 因为abort时可能还在等资源，故waitLock中还有东西，要移除</span><br>        waitLock.remove(xid);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从等待队列中选择一个xid来占用uid</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectNewXID</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> &#123;<br>  	<span class="hljs-comment">// 当前uid已不被占有</span><br>    u2x.remove(uid);<br>  	<span class="hljs-comment">// 去uid资源的等待列表中找一个xid事务来占用</span><br>    List&lt;Long&gt; l = wait.get(uid);<br>  	<span class="hljs-comment">// 没有xid想要uid</span><br>    <span class="hljs-keyword">if</span>(l == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">assert</span> l.size() &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l.size() &gt; <span class="hljs-number">0</span>) &#123;<br>      	<span class="hljs-comment">// 选取等待列表中最前面的xid，并将其从wait中移除</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> l.remove(<span class="hljs-number">0</span>);<br>      	<span class="hljs-comment">// 若xid没有等待资源锁，说明xid已获得过了资源，跳过这个xid</span><br>      	<span class="hljs-comment">// 至于为什么获得过了还会在wait中，因为在remove那里xid释放所有资源时并没有将wait的(uid, xid)记录删除，故导致wait中xid还在等uid，但是实际上xid已经获取并释放过uid了；但是如下方所示，获取资源后会将xid从waitLock中删除，故用waitLock来判断这个xid是否还需要资源。</span><br>        <span class="hljs-keyword">if</span>(!waitLock.containsKey(xid)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          	<span class="hljs-comment">// xid占有uid</span><br>            u2x.put(uid, xid);<br>          	<span class="hljs-comment">// xid的资源列表要加上uid</span><br>          	<span class="hljs-comment">// putIntoList(x2u, xid, uid);</span><br>          <br>          	<span class="hljs-comment">// xid的等待资源锁要移除</span><br>            <span class="hljs-type">Lock</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> waitLock.remove(xid);<br>          	<span class="hljs-comment">// 将(xid,uid)从waitU中移除</span><br>            waitU.remove(xid);<br>          	<span class="hljs-comment">// xid的等待资源锁解锁，才能进行获得资源后的操作</span><br>            lo.unlock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>  	<span class="hljs-comment">// uid资源分配出去后，发现没有事务在等它了，将它从wait中移除</span><br>    <span class="hljs-keyword">if</span>(l.size() == <span class="hljs-number">0</span>) wait.remove(uid);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="VM的实现"><a href="#VM的实现" class="headerlink" title="VM的实现"></a>VM的实现</h2><p>VM 层通过 <code>VersionManager</code> 接口，向上层提供功能，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VersionManager</span> &#123;<br>    <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>同时，VM 的实现类还**被设计为 <code>Entry</code> 的缓存，需要继承 <code>AbstractCache&lt;Entry&gt;</code>。**需要实现的获取到缓存和从缓存释放的方法很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Entry <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> Entry.loadEntry(<span class="hljs-built_in">this</span>, uid);<br>    <span class="hljs-keyword">if</span>(entry == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> Error.NullEntryException;<br>    &#125;<br>    <span class="hljs-keyword">return</span> entry;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Entry entry)</span> &#123;<br>    entry.remove();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title function_">loadEntry</span><span class="hljs-params">(VersionManager vm, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DataItem</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);<br>    <span class="hljs-keyword">return</span> newEntry(vm, di, uid);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    dataItem.release();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>begin()</code> 开启一个事务，并<strong>初始化事务的结构</strong>，将其<strong>存放在 <code>activeTransaction</code> 中</strong>，用于检查和快照使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 创建一个新事务，事务id自增并返回</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> tm.begin();<br>      	<span class="hljs-comment">// 创建事务时传入activeTransaction是为了创造快照</span><br>        <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Transaction.newTransaction(xid, level, activeTransaction);<br>      	<span class="hljs-comment">// 创建完将这个事务也加入active事务组中</span><br>        activeTransaction.put(xid, t);<br>        <span class="hljs-keyword">return</span> xid;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>commit()</code> 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(NullPointerException n) &#123;<br>        System.out.println(xid);<br>        System.out.println(activeTransaction.keySet());<br>        Panic.panic(n);<br>    &#125;<br>    lock.lock();<br>  	<span class="hljs-comment">// 将xid事务从active事务中中移除</span><br>    activeTransaction.remove(xid);<br>    lock.unlock();<br>  	<span class="hljs-comment">// 释放xid事务所拥有的所有资源</span><br>    lt.remove(xid);<br>  	<span class="hljs-comment">// 提交xid事务</span><br>    tm.commit(xid);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>abort</code> 事务的方法则有两种，<strong>手动和自动</strong>。手动指的是调用 <code>abort()</code> 方法；而<strong>自动</strong>，则是在事务被检测出出现<strong>死锁</strong>时，会自动撤销回滚事务；或者出现<strong>版本跳跃</strong>时，也会自动回滚：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internAbort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">boolean</span> autoAborted)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    <span class="hljs-keyword">if</span>(!autoAborted) &#123;<br>        activeTransaction.remove(xid);<br>    &#125;<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.autoAborted) <span class="hljs-keyword">return</span>;<br>    lt.remove(xid);<br>    tm.abort(xid);<br>&#125;<br><br><span class="hljs-comment">// 手动abort</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    internAbort(xid, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">// 自动abort，t.autoAborted默认值为false</span><br>internAbort(xid, <span class="hljs-literal">true</span>); 然后-&gt; t.autoAborted = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>

<p><code>read()</code> 方法读取一个 <code>entry</code>，注意判断下可见性即可：</p>
<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502221935459.png" srcset="/img/loading.gif" lazyload alt="image-20250222193536630" style="zoom: 33%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid) <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 想要读取的资源是对于当前事务是可见的</span><br>        <span class="hljs-keyword">if</span>(Visibility.isVisible(tm, t, entry)) &#123;<br>            <span class="hljs-keyword">return</span> entry.data();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        entry.release();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVisible</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t.level == <span class="hljs-number">0</span>) &#123;<br>      	<span class="hljs-comment">// 读提交隔离级别下查看是否可见</span><br>        <span class="hljs-keyword">return</span> readCommitted(tm, t, e);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      	<span class="hljs-comment">// 可重复读隔离级别下查看是否可见</span><br>        <span class="hljs-keyword">return</span> repeatableRead(tm, t, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>insert()</code> 则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>  	<span class="hljs-comment">// 将数据包裹成Entry格式：[XMIN] [XMAX] [data]，然后交给DM层</span><br>    <span class="hljs-type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data);<br>  	<span class="hljs-comment">// 插入时DM会再将entry包裹成DataItem格式：[ValidFlag] [DataSize] [Data]</span><br>  	<span class="hljs-comment">// Entry就是这里的Data</span><br>    <span class="hljs-keyword">return</span> dm.insert(xid, raw);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>delete()</code> 方法看起来略为复杂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br><br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 要删除的资源对这个事务不可见，无法删除</span><br>        <span class="hljs-keyword">if</span>(!Visibility.isVisible(tm, t, entry)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          	<span class="hljs-comment">// 可见，就让xid去获取uid</span><br>            l = lt.add(xid, uid);<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            t.err = Error.ConcurrentUpdateException;<br>            internAbort(xid, <span class="hljs-literal">true</span>);<br>            t.autoAborted = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>      	<span class="hljs-comment">// 获取非空，是一把锁</span><br>        <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>          	<span class="hljs-comment">// ⚠️由于l是一把可重入锁，当获取到一把已上锁的锁时，再在这里上锁也能上锁成功，不会发生阻塞。。。</span><br>          	<span class="hljs-comment">// 而我们这段代码的思路就是要让程序阻塞在这里。。。</span><br>            l.lock();<br>            l.unlock();<br>        &#125;<br>      	<span class="hljs-comment">// 本事务已经删除过了（同一个事务，前面删除过了，这次再删当然删不了）</span><br>        <span class="hljs-keyword">if</span>(entry.getXmax() == xid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      	<span class="hljs-comment">// 发生版本跳跃，抛出异常</span><br>        <span class="hljs-keyword">if</span>(Visibility.isVersionSkip(tm, t, entry)) &#123;<br>            t.err = Error.ConcurrentUpdateException;<br>            internAbort(xid, <span class="hljs-literal">true</span>);<br>            t.autoAborted = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>      	<span class="hljs-comment">// 设置XMAX为本事务的xid，表明事务xid已删除这条数据</span><br>        entry.setXmax(xid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        entry.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实际上主要是前置的三件事：<strong>一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置 <code>XMAX</code>。</strong></p>
<h1 id="5-Index-Manager"><a href="#5-Index-Manager" class="headerlink" title="5. Index Manager"></a>5. Index Manager</h1><h2 id="二叉树索引"><a href="#二叉树索引" class="headerlink" title="二叉树索引"></a>二叉树索引</h2>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="category-chain-item">数据库</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/MySQL/" class="category-chain-item">MySQL</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="print-no-link">#数据库</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MYDB record</div>
      <div>http://example.com/2025/02/21/MYDB-record/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Kon4tsu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/17/RPC/" title="RPC">
                        <span class="hidden-mobile">RPC</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
