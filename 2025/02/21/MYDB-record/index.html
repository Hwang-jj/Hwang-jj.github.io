

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Kon4tsu">
  <meta name="keywords" content="">
  
    <meta name="description" content="MYDB1. 项目结构整体架构  Transaction Manager（TM） Data Manager（DM） Version Manager（VM） Index Manager（IM） Table Manager（TBM）  每个模块的职责如下：  TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。 DM 直接管理数据库 DB 文件和日志文件。DM 的主">
<meta property="og:type" content="article">
<meta property="og:title" content="MYDB record">
<meta property="og:url" content="http://example.com/2025/02/21/MYDB-record/index.html">
<meta property="og:site_name" content="Kon4tsu Blog">
<meta property="og:description" content="MYDB1. 项目结构整体架构  Transaction Manager（TM） Data Manager（DM） Version Manager（VM） Index Manager（IM） Table Manager（TBM）  每个模块的职责如下：  TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。 DM 直接管理数据库 DB 文件和日志文件。DM 的主">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502211203817.jpg">
<meta property="article:published_time" content="2025-02-21T02:30:03.000Z">
<meta property="article:modified_time" content="2025-02-21T09:33:44.360Z">
<meta property="article:author" content="Kon4tsu">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502211203817.jpg">
  
  
  
  <title>MYDB record - Kon4tsu Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/macpanel.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":false},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kon4tsu&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MYDB record"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-21 10:30" pubdate>
          2025年2月21日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.4k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          62 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MYDB record</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="MYDB"><a href="#MYDB" class="headerlink" title="MYDB"></a><strong>MYDB</strong></h1><h1 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502211203817.jpg" srcset="/img/loading.gif" lazyload alt="img"></p>
<ol>
<li>Transaction Manager（TM）</li>
<li>Data Manager（DM）</li>
<li>Version Manager（VM）</li>
<li>Index Manager（IM）</li>
<li>Table Manager（TBM）</li>
</ol>
<p>每个模块的职责如下：</p>
<ol>
<li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li>
<li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li>
<li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li>
<li>IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。</li>
<li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li>
</ol>
<h1 id="2-Transaction-Manager"><a href="#2-Transaction-Manager" class="headerlink" title="2. Transaction Manager"></a>2. Transaction Manager</h1><blockquote>
<p>TM模块通过维护一个XID文件来维护事务状态，并提供接口供其他模块来查询某个事务的状态</p>
</blockquote>
<h2 id="XID文件"><a href="#XID文件" class="headerlink" title="XID文件"></a>XID文件</h2><p>在 MYDB 中，每一个事务都有一个 XID，这个 ID 唯一标识了这个事务。事务的 XID 从 1 开始标号，并自增，不可重复。并特殊规定 <strong>XID 0 是一个超级事务（Super Transaction）</strong>。当一些操作想在没有申请事务的情况下进行，那么可以将操作的 XID 设置为 0。XID 为 0 的事务的状态永远是 committed。</p>
<p>TransactionManager 维护了一个 XID 格式的文件，用来记录各个事务的状态。MYDB 中，每个事务都有下面的三种状态：</p>
<ol>
<li><code>active</code>，正在进行，尚未结束</li>
<li><code>committed</code>，已提交</li>
<li><code>aborted</code>，已撤销（回滚）</li>
</ol>
<p>XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，<strong>事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处</strong>，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。（XID文件头8个字节用于记录此XID文件管理的事务数量，后面记录事务的状态）</p>
<h2 id="必要的常量及变量"><a href="#必要的常量及变量" class="headerlink" title="必要的常量及变量"></a>必要的常量及变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XID文件头长度</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LEN_XID_HEADER_LENGTH</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 每个事务的占用长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">XID_FIELD_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 事务的三种状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ACTIVE</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_COMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ABORTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 超级事务，永远为commited状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SUPER_XID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// XID 文件后缀</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">XID_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.xid&quot;</span>;<br><br><span class="hljs-comment">// 用于获取XID文件</span><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-comment">// 文件通道，用于文件的读写</span><br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-comment">// 用于记录XID文件中事务的数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> xidCounter;<br><span class="hljs-keyword">private</span> Lock counterLock;<br></code></pre></td></tr></table></figure>

<h2 id="XID文件校验"><a href="#XID文件校验" class="headerlink" title="XID文件校验"></a>XID文件校验</h2><p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，通过<strong>文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比</strong>。如果不同则认为 XID 文件不合法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">fileLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 记录文件的实际长度</span><br>        fileLen = file.length();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br>  	<span class="hljs-comment">// 文件实际长度比文件头的8字节还小，说明文件不合法</span><br>    <span class="hljs-keyword">if</span>(fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 设置FileChannel的position</span><br>        fc.position(<span class="hljs-number">0</span>);<br>      	<span class="hljs-comment">// 从文件通道读取内容到ByteBuffer中</span><br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.xidCounter = Parser.parseLong(buf.array());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> getXidPosition(<span class="hljs-built_in">this</span>.xidCounter + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(end != fileLen) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 根据事务xid取得其在xid文件中对应的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getXidPosition</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-keyword">return</span> LEN_XID_HEADER_LENGTH + (xid-<span class="hljs-number">1</span>)*XID_FIELD_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="更新事务状态"><a href="#更新事务状态" class="headerlink" title="更新事务状态"></a>更新事务状态</h2><ul>
<li><code>begin()</code>：开启一个事务，首先设置<code>xid = xidCounter+1</code>的事务状态为<code>active</code>，随后<strong>xidCounter自增</strong></li>
<li><code>commit()</code>：提交一个事务，将<code>xid</code>事务的状态设置为<code>committed</code></li>
<li><code>abort()</code>：取消一个事务，将<code>xid</code>事务的状态设置为<code>aborted</code></li>
<li>这三个更新操作都可借助下面的<code>updateXID()</code>方法实现，同时开启事务还需要实现一个xidCounter自增的方法<code>incrXIDCounter()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 更新xid事务的状态为status</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">byte</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE];<br>    tmp[<span class="hljs-number">0</span>] = status;<br>  	<span class="hljs-comment">// tmp数组包装成bytebuffer数组</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(tmp);<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 将ByteBuffer中的内容写入到文件通道中的offset位置，即更改事务状态</span><br>        fc.position(offset);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 所有文件操作，在执行后都需要立刻刷入文件中，防止在崩溃后文件丢失数据，fileChannel 的 force() 方法，强制同步缓存内容到文件中。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。</span><br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将XID加一，并更新XID Header（开启一个新事务时需要此操作）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    xidCounter ++;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(<span class="hljs-number">0</span>);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="检查事务状态"><a href="#检查事务状态" class="headerlink" title="检查事务状态"></a>检查事务状态</h2><p><code>isActive()</code>、<code>isCommitted()</code> 和 <code>isAborted()</code> 都是检查一个 xid 的状态，可以用一个通用的方法解决：（检查时需要排除<code>SUPER_XID</code>的情况，因为该情况一定是<code>committed</code>的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检测XID事务是否处于status状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE]);<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf.array()[<span class="hljs-number">0</span>] == status;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="创建和打开XID文件"><a href="#创建和打开XID文件" class="headerlink" title="创建和打开XID文件"></a>创建和打开XID文件</h2><p>在接口中创建的两个静态方法<code>create()</code>和<code>open()</code></p>
<ul>
<li><code>create()</code>：创建一个XID文件，并创建TM（TM的构造器需要XID文件和FileChannel）</li>
<li><code>open()</code>：从一个已有的XID文件来创建TM</li>
</ul>
<h1 id="3-Data-Manager"><a href="#3-Data-Manager" class="headerlink" title="3. Data Manager"></a>3. Data Manager</h1><blockquote>
<p>DataManager（DM）功能归纳：</p>
<ul>
<li>上层模块和文件系统中的一个抽象层。向上，提供数据包装；向下，直接读写文件。</li>
<li>提供日志功能。</li>
</ul>
</blockquote>
<h2 id="计数缓存框架"><a href="#计数缓存框架" class="headerlink" title="计数缓存框架"></a>计数缓存框架</h2><blockquote>
<p>分页管理和数据项（DataItem）管理涉及缓存，故抽象出一个<strong>通用缓存框架</strong>。</p>
</blockquote>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>**引用计数法（Reference counting）**是一种内存管理技术，它通过计算每个对象被引用的次数来判断是否需要回收该对象。当对象被创建时，引用计数为 1，每当有一个新的引用指向该对象时，计数加 1，当引用失效时，计数减 1。<strong>当计数为 0 时，该对象就可以被回收</strong>。</p>
<p>在 MYDB 的实践中，需要的效果是，只有上层模块<strong>主动释放引用</strong>，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。于是，选择引用计数法。增加了一个方法 <code>release (key)</code>，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p>
<p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）。</p>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>**LRU（least recently used）**是一种缓存淘汰算法。它的特点是根据数据最近被访问的时间来决定哪些数据应该被保留，哪些数据应该被淘汰。当缓存达到一定容量时，会淘汰掉最近最少使用的数据。</p>
<p>如果使用 LRU 缓存，那么只需要设计一个<code>get (key)</code>接口即可，释放缓存可以在缓存满了之后自动完成。</p>
<p>however，当某时刻缓存满了，缓存驱逐一个资源，此时上层模块想将某个资源强制刷回数据源，这个资源恰恰是刚被驱逐的资源。此时的上层模块会发现，资源在缓存中消失了，那么，是否有必要做回源操作？</p>
<ul>
<li><strong>不回源</strong>。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li>
<li><strong>回源</strong>。如果数据项被驱逐时的数据和现在又是相同的，那就是一次<strong>无效回源</strong></li>
<li><strong>放回缓存里，等下次被驱逐时回源</strong>。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致<strong>缓存抖动</strong>问题。</li>
</ul>
<h3 id="必要的变量"><a href="#必要的变量" class="headerlink" title="必要的变量"></a>必要的变量</h3><p><code>AbstractCache&lt;T&gt;</code>是一个抽象类，内部有两个抽象方法，留给实现类去实现具体的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当资源不在缓存时的获取行为（去数据源中获取）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当资源被驱逐时的写回行为</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(T obj)</span>;<br></code></pre></td></tr></table></figure>

<p>由于我们选择使用的是引用计数法实现缓存，因此除了普通的缓存功能，还需要另外<strong>维护一个计数</strong>，用于记录资源被引用的个数。除此以外，为了应对<strong>多线程场景</strong>，还需要记录哪些资源正在从数据源获取中（<strong>从数据源获取资源是一个相对费时的操作</strong>）。于是有下面三个 Map：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="hljs-comment">// 实际缓存的数据</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="hljs-comment">// 资源的引用个数</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="hljs-comment">// 正在被获取的资源</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxResource;                            <span class="hljs-comment">// 缓存的最大缓存资源数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                              <span class="hljs-comment">// 缓存中元素的个数</span><br><span class="hljs-keyword">private</span> Lock lock;<br></code></pre></td></tr></table></figure>

<h3 id="get-方法获取资源"><a href="#get-方法获取资源" class="headerlink" title="get()方法获取资源"></a>get()方法获取资源</h3><ol>
<li>判断请求的资源是否正在被其他线程获取，若是，则过一段时间再来查看</li>
<li>没有其他线程在获取目标资源，到缓存中查看是否有需要的资源，若有，则直接返回</li>
<li>资源不在缓存中，且缓存已满，抛出<code>CacheFullException</code>异常</li>
<li>资源不在缓存中且缓存没满，尝试去数据源获取该资源</li>
<li>在数据源中没找到该资源，抛出异常</li>
<li>在数据源中找到需要的资源，添加到缓存中后返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        lock.lock();<br>        <span class="hljs-comment">// 1.1.首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看</span><br>        <span class="hljs-keyword">if</span>(getting.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 请求的资源正在被其他线程获取</span><br>            lock.unlock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 1.2.如果没有其他线程在获取这个资源，那么就可以尝试从缓存中获取了</span><br>        <span class="hljs-keyword">if</span>(cache.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 资源在缓存中，直接返回</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-comment">// 记得给资源的引用计数加一</span><br>            references.put(key, references.get(key) + <span class="hljs-number">1</span>);<br>            lock.unlock();<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br><br>        <span class="hljs-comment">// 1.3.尝试获取该资源</span><br>        <span class="hljs-comment">// a.判断缓存是否已满，如果已满，就抛出一个异常</span><br>        <span class="hljs-keyword">if</span>(maxResource &gt; <span class="hljs-number">0</span> &amp;&amp; count == maxResource) &#123;<br>            lock.unlock();<br>            <span class="hljs-keyword">throw</span> Error.CacheFullException;<br>        &#125;<br>        <span class="hljs-comment">// b.如果缓存未满，就在 getting 中注册一下，该线程准备从数据源获取资源了</span><br>        count ++;<br>        getting.put(key, <span class="hljs-literal">true</span>);<br>        lock.unlock();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.从数据源获取资源</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用抽象方法从数据源中获取资源</span><br>        obj = getForCache(key);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 如果获取失败，就把 getting 中的注册信息清除掉</span><br>        lock.lock();<br>        count --;<br>        getting.remove(key);<br>        lock.unlock();<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br><br>    lock.lock();<br>    getting.remove(key);       <span class="hljs-comment">// 获取完成要从 getting 中清除注册信息</span><br>    cache.put(key, obj);<br>    references.put(key, <span class="hljs-number">1</span>);<br>    lock.unlock();<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="release-方法释放资源"><a href="#release-方法释放资源" class="headerlink" title="release()方法释放资源"></a>release()方法释放资源</h3><p>当引用计数references减到0后，就可以回源并删除缓存中的相关结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3.释放资源</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 释放一个缓存时，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> references.get(key) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(ref == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-comment">// 调用抽象方法释放缓存</span><br>            releaseForCache(obj);<br>            <span class="hljs-comment">// 删除缓存中所有相关的结构</span><br>            references.remove(key);<br>            cache.remove(key);<br>            count --;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            references.put(key, ref);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="close-方法关闭缓存"><a href="#close-方法关闭缓存" class="headerlink" title="close()方法关闭缓存"></a>close()方法关闭缓存</h3><p>缓存应当还有以一个安全关闭的功能，在关闭时，需要将缓存中所有的资源强行回源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Set&lt;Long&gt; keys = cache.keySet();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> key : keys) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            releaseForCache(obj);<br>            references.remove(key);<br>            cache.remove(key);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，一个简单的缓存框架就实现完了，其他的缓存只需要继承这个类，并实现那两个抽象方法即可。</p>
<h2 id="数据页的缓存与管理"><a href="#数据页的缓存与管理" class="headerlink" title="数据页的缓存与管理"></a>数据页的缓存与管理</h2><h3 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h3><p>参考大部分数据库的设计，将<strong>默认数据页大小定为 8K</strong>。如果想要提升向数据库写入大量数据情况下的性能的话，也可以适当增大这个值。</p>
<p>上一节我们已经实现了一个通用的缓存框架，那么这一节我们需要缓存页面，就可以直接借用那个缓存的框架了。但是首先，需要<strong>定义出页面的结构</strong>。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。定义一个页面如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Page</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pageNumber;		<span class="hljs-comment">// 页号，从1开始</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] data;			<span class="hljs-comment">// 此页面实际包含的字节数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> dirty;		<span class="hljs-comment">// 标识该页面是否是脏页面，在缓存驱逐的时候，脏页面需要被写回磁盘</span><br>    <span class="hljs-keyword">private</span> Lock lock;<br><br>    <span class="hljs-keyword">private</span> PageCache pc;			<span class="hljs-comment">// 这里保存了一个 PageCache（还未定义）的引用，用来方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>页面缓存接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageCache</span> &#123;<br>  <br>  	<span class="hljs-comment">// 页面大小8192</span><br>  	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PAGE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>;<br>  <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span>;<br>    Page <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Page page)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">truncateByBgno</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPgno)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getPageNumber</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">flushPage</span><span class="hljs-params">(Page pg)</span>;<br>  <br>  	<span class="hljs-comment">// 创建一个新的.db文件</span><br>  	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageCacheImpl <span class="hljs-title function_">create</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> memory)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+PageCacheImpl.DB_SUFFIX);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(!f.createNewFile()) &#123;<br>                Panic.panic(Error.FileExistsException);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;<br>            Panic.panic(Error.FileCannotRWException);<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br>            fc = raf.getChannel();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageCacheImpl</span>(raf, fc, (<span class="hljs-type">int</span>)memory/PAGE_SIZE);<br>    &#125;<br><br>  	<span class="hljs-comment">// 打开一个.db文件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageCacheImpl <span class="hljs-title function_">open</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> memory)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+PageCacheImpl.DB_SUFFIX);<br>        <span class="hljs-keyword">if</span>(!f.exists()) &#123;<br>            Panic.panic(Error.FileNotExistsException);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;<br>            Panic.panic(Error.FileCannotRWException);<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br>            fc = raf.getChannel();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageCacheImpl</span>(raf, fc, (<span class="hljs-type">int</span>)memory/PAGE_SIZE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>页面缓存的具体实现类<code>PageCacheImpl</code>，需要继承抽象缓存框架AbstractCache，并且实现<code>getForCache() </code>和 <code>releaseForCache() </code>两个抽象方法。由于数据源就是文件系统（<strong>.db文件</strong>），<code>getForCache() </code>直接从文件中读取，并包裹成 Page 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据pageNumber从数据库文件中读取页数据，并包裹成Page</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Page <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  	<span class="hljs-comment">// 页号</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)key;<br>  	<span class="hljs-comment">// 页号对应的页在文件中的位置</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageCacheImpl.pageOffset(pgno);<br><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(PAGE_SIZE);<br>    fileLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    fileLock.unlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, buf.array(), <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pageOffset</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> &#123;<br>    <span class="hljs-comment">// 页号从 1 开始</span><br>    <span class="hljs-keyword">return</span> (pgno-<span class="hljs-number">1</span>) * PAGE_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>而<code> releaseForCache()</code>驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-keyword">if</span>(pg.isDirty()) &#123;<br>        flush(pg);<br>        pg.setDirty(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pg.getPageNumber();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> pageOffset(pgno);<br><br>    fileLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(pg.getData());<br>        fc.position(offset);<br>        fc.write(buf);<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        fileLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pageNumbers.incrementAndGet();<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, initData, <span class="hljs-literal">null</span>);<br>    flush(pg);  <span class="hljs-comment">// 新建的页面需要立刻写回</span><br>    <span class="hljs-keyword">return</span> pgno;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="数据页管理"><a href="#数据页管理" class="headerlink" title="数据页管理"></a>数据页管理</h3><h4 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h4><p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是<strong>用来做启动检查</strong>。具体的原理是，在每次数据库<strong>启动</strong>时，会生成一串随机字节，存储在 <strong>100 ~ 107</strong> 字节。在数据库<strong>正常关闭</strong>时，会将这串字节，拷贝到第一页的 1<strong>08 ~ 115</strong> 字节。</p>
<p>这样数据库在每次启动时，就会<strong>检查第一页两处的字节是否相同</strong>，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p>
<p>启动时设置初始字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(Page pg)</span> &#123;<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    setVcOpen(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="hljs-number">0</span>, raw, OF_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>关闭时拷贝字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(Page pg)</span> &#123;<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    setVcClose(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>校验字节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-keyword">return</span> checkVc(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    <span class="hljs-keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="hljs-number">2</span>*LEN_VC));<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="普通页"><a href="#普通页" class="headerlink" title="普通页"></a>普通页</h4><p>一个普通页面以一个 <strong>2 字节无符号数</strong>起始，表示<strong>这一页的空闲位置的偏移</strong>。剩下的部分都是实际存储的数据。对普通页的管理，基本都是围绕着对 <strong>FSO（Free Space Offset）进行的</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageX</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">short</span> <span class="hljs-variable">OF_FREE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;		<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">short</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;		<span class="hljs-comment">// 数据起始位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_FREE_SPACE</span> <span class="hljs-operator">=</span> PageCache.PAGE_SIZE - OF_DATA;		<span class="hljs-comment">// 页面最大空闲空间</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] initRaw() &#123;<br>        <span class="hljs-type">byte</span>[] raw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[PageCache.PAGE_SIZE];<br>        setFSO(raw, OF_DATA);<br>        <span class="hljs-keyword">return</span> raw;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> ofData)</span> &#123;<br>        System.arraycopy(Parser.short2Byte(ofData), <span class="hljs-number">0</span>, raw, OF_FREE, OF_DATA);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取pg的FSO</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(Page pg)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFSO(pg.getData());<br>    &#125;<br>		<span class="hljs-comment">// 获取页面数据row的前两个字节（这两个字节标识空闲位置的起始位置）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>        <span class="hljs-keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中，返回插入位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>        setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset + raw.length));<br>        <span class="hljs-keyword">return</span> offset;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取页面的空闲空间大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFreeSpace</span><span class="hljs-params">(Page pg)</span> &#123;<br>        <span class="hljs-keyword">return</span> PageCache.PAGE_SIZE - (<span class="hljs-type">int</span>)getFSO(pg.getData());<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverInsert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br><br>        <span class="hljs-type">short</span> <span class="hljs-variable">rawFSO</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>        <span class="hljs-keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;<br>            setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset+raw.length));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中的offset位置，不更新update</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverUpdate</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="日志文件与恢复策略"><a href="#日志文件与恢复策略" class="headerlink" title="日志文件与恢复策略"></a>日志文件与恢复策略</h2><blockquote>
<p>MYDB 提供了崩溃后的数据恢复功能。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库崩溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 必要的常量及变量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SEED</span> <span class="hljs-operator">=</span> <span class="hljs-number">13331</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;		<span class="hljs-comment">// 单条记录Size的起始位置：0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_CHECKSUM</span> <span class="hljs-operator">=</span> OF_SIZE + <span class="hljs-number">4</span>;	<span class="hljs-comment">// 单条记录CheckSum起始位置：4</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> OF_CHECKSUM + <span class="hljs-number">4</span>;	<span class="hljs-comment">// 单条记录数据起始位置：8</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOG_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.log&quot;</span>;	<span class="hljs-comment">// 日志文件后缀</span><br><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-keyword">private</span> Lock lock;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> position;  <span class="hljs-comment">// 当前日志指针的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> fileSize;  <span class="hljs-comment">// 初始化时记录，log操作不更新</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> xChecksum;  <span class="hljs-comment">// 总校验和</span><br></code></pre></td></tr></table></figure>

<h3 id="日志读写"><a href="#日志读写" class="headerlink" title="日志读写"></a>日志读写</h3><h4 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h4><p>日志的二进制文件，按照如下的格式排布：</p>
<blockquote>
<p>[<code>XCheckSum</code>] [<code>Log1</code>] [<code>Log2</code>] [<code>Log3</code>] … [<code>LogN</code>] [<code>BadTail</code>]</p>
</blockquote>
<p>其中 <code>XChecksum</code> 是一个四字节的整数int，是<strong>对后续所有日志计算的校验和</strong>。<code>Log1</code> ~ <code>LogN</code> 是常规的日志数据，<code>BadTail</code> 是在数据库崩溃时，<strong>没有来得及写完的日志数据</strong>，这个 <code>BadTail</code> 不一定存在。</p>
<p>每条日志的格式如下：</p>
<blockquote>
<p>[<code>Size</code>] [<code>CheckSum</code>] [<code>Data</code>]</p>
</blockquote>
<p>其中，Size 是一个四字节整数int，标识了 <strong>Data 段的字节数</strong>。Checksum 则是<strong>该条日志的校验和int</strong>。单条日志的校验和，其实就是通过一个指定的种子实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calChecksum</span><span class="hljs-params">(<span class="hljs-type">int</span> xCheck, <span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : log) &#123;<br>        xCheck = xCheck * SEED + b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> xCheck;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，对所有日志求出校验和<code>CheckSum</code>，每条校验和再求和（❌）就能得到日志文件的校验和<code>XCheckSum</code>了。</p>
<blockquote>
<p>注意，文件里的<code>XCheckSum</code>和每条日志的<code>CheckSum</code>计算对象是不一样的：</p>
<ul>
<li><code>XCheckSum</code>是用后续所有日志（包括日志里的<code>size</code>、<code>checkSum</code>、<code>data</code>字段）计算得到的<ul>
<li><code>XCheckSum</code>是用来保证文件的完整性的，关心的是整个文件，故可以用一整条日志参与计算</li>
</ul>
</li>
<li>每条日志里的<code>CheckSum</code>只用到日志里的<code>data</code>字段计算得到<ul>
<li>这是因为每条日志里的<code>CheckSum</code>是用来确保当前日志<code>data</code>部分的完整性，故只用<code>data</code>部分计算</li>
<li>此外，每条日志里的<code>CheckSum</code>的计算也无法用到整条日志进行计算，这是因为整条日志里也包含自身，如果用整条日志计算<code>CheckSum</code>会用到<code>CheckSum</code>自身，这是有问题的</li>
</ul>
</li>
<li>因此<code>XCheckSum</code>  !&#x3D; <code>calChecksum( calChecksum( calChecksum(0, data1), data2), ... dataN)</code></li>
</ul>
</blockquote>
<h4 id="遍历日志文件中的每一条日志"><a href="#遍历日志文件中的每一条日志" class="headerlink" title="遍历日志文件中的每一条日志"></a>遍历日志文件中的每一条日志</h4><p>Logger 被实现成迭代器模式，通过 <code>next()</code> 方法，不断地从文件中<strong>读取下一条日志</strong>，并<strong>将其中的 <code>Data</code> 解析出来并返回</strong>，<code>next()</code> 方法的实现主要依靠 <code>internNext()</code>，大致如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] internNext() &#123;<br>  	<span class="hljs-comment">// 位置超出文件大小</span><br>    <span class="hljs-keyword">if</span>(position + OF_DATA &gt;= fileSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取size，读取后position指针向后移动4位，指向checkSum开头</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    fc.position(position);<br>    fc.read(tmp);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Parser.parseInt(tmp.array());<br>    <span class="hljs-keyword">if</span>(position + size + OF_DATA &gt; fileSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取checksum+data，log中包含size+checkSum+data</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(OF_DATA + size);<br>    fc.position(position);<br>    fc.read(buf);<br>    <span class="hljs-type">byte</span>[] log = buf.array();<br><br>    <span class="hljs-comment">// 校验 checksum，确保本条日志的完整性</span><br>  	<span class="hljs-comment">// checkSum1:手动计算该条日志的校验和，从log的第8位到最后一位读取</span><br>  	<span class="hljs-comment">// checkSum2:从日志数据log中读取该条日志的校验和，从log的4到8位读取</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">checkSum1</span> <span class="hljs-operator">=</span> calChecksum(<span class="hljs-number">0</span>, Arrays.copyOfRange(log, OF_DATA, log.length));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">checkSum2</span> <span class="hljs-operator">=</span> Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));<br>    <span class="hljs-keyword">if</span>(checkSum1 != checkSum2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  	<span class="hljs-comment">// position指针位置指向下一条日志</span><br>    position += log.length;<br>  	<span class="hljs-comment">// 返回这条日志</span><br>    <span class="hljs-keyword">return</span> log;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="校验日志文件"><a href="#校验日志文件" class="headerlink" title="校验日志文件"></a>校验日志文件</h4><p>在<strong>打开一个日志文件</strong>时，需要首先<strong>校验日志文件</strong>的 <code>XChecksum</code>，并移除文件尾部可能存在的 <code>BadTail</code>，由于 <code>BadTail</code> 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 <code>BadTail</code> 即可保证日志文件的一致性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndRemoveTail</span><span class="hljs-params">()</span> &#123;<br>  	<span class="hljs-comment">// 设置position为4，也就是XCheckSum后面，第一条日志开头的位置</span><br>    rewind();<br><br>  	<span class="hljs-comment">// 对每条日志的!!所有字段!!(区别于一条日志的校验和计算)计算校验和，校验和再求和得到总校验和xCheck</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">xCheck</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">byte</span>[] log = internNext();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        xCheck = calChecksum(xCheck, log);<br>    &#125;<br>  <br>  	<span class="hljs-comment">// xCheckSum是从日志文件开头4个字节获得的</span><br>    <span class="hljs-keyword">if</span>(xCheck != xChecksum) &#123;<br>        Panic.panic(Error.BadLogFileException);<br>    &#125;<br><br>    <span class="hljs-comment">// 截断文件到正常日志的末尾</span><br>    truncate(position);<br>  	<span class="hljs-comment">// position指针回到起点</span><br>    rewind();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rewind</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算总校验和是用不到它，因为它只返回了日志的数据部分</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] next() &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">byte</span>[] log = internNext();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(log, OF_DATA, log.length);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="写入日志"><a href="#写入日志" class="headerlink" title="写入日志"></a>写入日志</h4><p>向日志文件写入日志时，也是首先<strong>将数据包裹成日志格式</strong>，写入文件后，再<strong>更新文件的校验和</strong>，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>  	<span class="hljs-comment">// 将数据包装成日志格式[Size][CheckSum][Data]</span><br>    <span class="hljs-type">byte</span>[] log = wrapLog(data);<br>  	<span class="hljs-comment">// 将包装好的一条日志包装成ByteBuffer格式</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(log);<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      	<span class="hljs-comment">// 将日志写到文件通道中的末尾</span><br>        fc.position(fc.size());<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>  	<span class="hljs-comment">// 更新总校验和xCheckSum（这里的log是[Size][CheckSum][Data]这样一整条日志的格式）</span><br>    updateXChecksum(log);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXChecksum</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-built_in">this</span>.xChecksum = calChecksum(<span class="hljs-built_in">this</span>.xChecksum, log);<br>  	<span class="hljs-comment">// 将更新后的总校验和xCheckSum写到文件开头4个字节的位置</span><br>    fc.position(<span class="hljs-number">0</span>);<br>    fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));<br>    fc.force(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 在数据前面拼接上Size和CheckSum</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] wrapLog(<span class="hljs-type">byte</span>[] data) &#123;<br>    <span class="hljs-type">byte</span>[] checksum = Parser.int2Byte(calChecksum(<span class="hljs-number">0</span>, data));<br>    <span class="hljs-type">byte</span>[] size = Parser.int2Byte(data.length);<br>    <span class="hljs-keyword">return</span> Bytes.concat(size, checksum, data);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h3><p>DM 为上层模块，提供了两种操作，分别是<strong>插入新数据（I）<strong>和</strong>更新现有数据（U）</strong>。（不包含删除操作）DM 的日志策略很简单，一句话就是：</p>
<blockquote>
<p>在进行 I 和 U 操作之前，<strong>必须先进行对应的日志操作</strong>，在保证日志写入磁盘后，才进行数据操作。</p>
</blockquote>
<p>这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后<strong>没有来得及同步到磁盘</strong>，<strong>数据库就发生了崩溃</strong>，后续也可以<strong>通过磁盘上的日志恢复该数据</strong>。</p>
<p>对于两种数据操作，DM 记录的日志如下：</p>
<ul>
<li>(Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x</li>
<li>(Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx</li>
</ul>
<p>我们首先不考虑并发的情况，那么在某一时刻，只可能有一个事务在操作数据库。日志会看起来像下面那样：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(Ti, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Ti, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), (Tj, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Tj, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), (Tk, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Tk, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>)<br></code></pre></td></tr></table></figure>

<h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下<strong>利用日志恢复</strong>很简单，假设日志中<strong>最后一个事务是 Ti</strong>：</p>
<ol>
<li>对 <strong>Ti 之前所有的事务</strong>的日志，进行<strong>重做（redo）</strong></li>
<li>接着检查 <strong>Ti 的状态（XID 文件）</strong>，如果 Ti 的状态是<strong>已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo）</strong></li>
</ol>
<p>接着，是如何对事务 T 进行 <strong>redo</strong>：</p>
<ol>
<li><strong>正序扫描</strong>事务 T 的所有日志</li>
<li>如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置</li>
<li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx</li>
</ol>
<p><strong>undo</strong> 也很好理解：</p>
<ol>
<li><strong>倒序扫描</strong>事务 T 的所有日志</li>
<li>如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除</li>
<li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx</li>
</ol>
<p>注意，MYDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>考虑以下两种情况：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 情况1</span><br><br>T1 <span class="hljs-keyword">begin</span><br>T2 <span class="hljs-keyword">begin</span><br>T2 U(<span class="hljs-variable language_">x</span>)<br>T1 R(<span class="hljs-variable language_">x</span>)<br>...<br>T1 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure>

<p>在系统崩溃时，T2 仍然是<strong>活跃</strong>状态（active）。那么当数据库重新启动，执行恢复例程时，会<strong>撤销 T2</strong>，它对数据库的影响会被消除。但是<strong>由于 T1 读取了 T2 更新的值</strong>，既然 T2 被撤销，那么 <strong>T1 也应当被撤销</strong>。这种情况，就是<strong>级联回滚Cascading Rollback</strong>。但是，T1 已经 commit 了，所有 commit 的事务的影响，应当被持久化。这里就造成了矛盾。所以这里需要保证：</p>
<blockquote>
<p>规定1:正在进行的事务，不会读取其他未提交的事务产生的数据（读提交Read Committed）</p>
</blockquote>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 情况2，假设x的初值为0</span><br><br>T1 <span class="hljs-keyword">begin</span><br>T2 <span class="hljs-keyword">begin</span><br>T1 set <span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 产生的日志为(T1, U, A, 0, 1)</span><br>T2 set <span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 产生的日志为(T1, U, A, 1, 2)</span><br>T2 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure>

<p>在系统崩溃时，T1 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，<strong>会对 T1 进行撤销，对 T2 进行重做</strong>，但是，无论撤销和重做的先后顺序如何，x 最后的结果，要么是 0，要么是 2，这都是错误的。</p>
<blockquote>
<p>出现这种问题的原因, 归根结底是因为我们的<strong>日志太过简单</strong>, 仅仅记录了**”前相”和”后相”<strong>. 并单纯的</strong>依靠”前相”undo, 依靠”后相”redo.** 这种简单的日志方式和恢复方式, 并不能涵盖住所有数据库操作形成的语义</p>
</blockquote>
<p>解决方法有两种：</p>
<ol>
<li>增加日志种类</li>
<li>限制数据库操作</li>
</ol>
<p>MYDB 采用的是<strong>限制数据库操作</strong>，需要保证：</p>
<blockquote>
<p>规定2：正在进行的事务，<strong>不会修改其他任何未提交的事务修改或产生的数据</strong>。</p>
</blockquote>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="两种日志的格式"><a href="#两种日志的格式" class="headerlink" title="两种日志的格式"></a><strong>两种日志的格式</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">LOG_TYPE_INSERT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">LOG_TYPE_UPDATE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// updateLog:</span><br><span class="hljs-comment">// [LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><br><span class="hljs-comment">// insertLog:</span><br><span class="hljs-comment">// [LogType] [XID] [Pgno] [Offset] [Raw]</span><br></code></pre></td></tr></table></figure>

<p>和原理中描述的类似，recover 例程主要也是两步：<strong>重做所有已完成事务，撤销所有未完成事务</strong></p>
<h5 id="重做所有已完成事务（committed、aborted）"><a href="#重做所有已完成事务（committed、aborted）" class="headerlink" title="重做所有已完成事务（committed、aborted）"></a><strong>重做所有已完成事务（committed、aborted）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重做所有已完成事务（committed、aborted）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">redoTranscations</span><span class="hljs-params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;<br>  	<span class="hljs-comment">// 从第一个事务开始（重做redo要按顺序重做）</span><br>    lg.rewind();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>      	<span class="hljs-comment">// 一个一个事务遍历</span><br>        <span class="hljs-type">byte</span>[] log = lg.next();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>          	<span class="hljs-comment">// 如果是插入事务</span><br>            <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> li.xid;<br>            <span class="hljs-keyword">if</span>(!tm.isActive(xid)) &#123;<br>              	<span class="hljs-comment">// 事务状态是committed或aborted，重做插入操作</span><br>                doInsertLog(pc, log, REDO);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          	<span class="hljs-comment">// 如果是更新事务</span><br>            <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xi.xid;<br>            <span class="hljs-keyword">if</span>(!tm.isActive(xid)) &#123;<br>              	<span class="hljs-comment">// 事务状态是committed或aborted，重做更新操作</span><br>                doUpdateLog(pc, log, REDO);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="撤销所有未完成事务（active）"><a href="#撤销所有未完成事务（active）" class="headerlink" title="撤销所有未完成事务（active）"></a><strong>撤销所有未完成事务（active）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 撤销所有未完成事务（active）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undoTranscations</span><span class="hljs-params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;<br>  	<span class="hljs-comment">// 用于记录(要撤回事务的xid，事务xid要撤回的操作列表)，一个事务可能要撤回多个操作，所以要用列表记录</span><br>    Map&lt;Long, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt; logCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    lg.rewind();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">byte</span>[] log = lg.next();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>          	<span class="hljs-comment">// 如果是插入事务</span><br>            <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> li.xid;<br>          	<span class="hljs-comment">// 事务状态是active</span><br>            <span class="hljs-keyword">if</span>(tm.isActive(xid)) &#123;<br>              	<span class="hljs-comment">// 把事务xid及其要撤回的操作加入到logCache中</span><br>                <span class="hljs-keyword">if</span>(!logCache.containsKey(xid)) &#123;<br>                    logCache.put(xid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                logCache.get(xid).add(log);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          	<span class="hljs-comment">// 如果是更新事务</span><br>            <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xi.xid;<br>          	<span class="hljs-comment">// 事务状态是active</span><br>            <span class="hljs-keyword">if</span>(tm.isActive(xid)) &#123;<br>              	<span class="hljs-comment">// 把事务xid及其要撤回的操作加入到logCache中</span><br>                <span class="hljs-keyword">if</span>(!logCache.containsKey(xid)) &#123;<br>                    logCache.put(xid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                logCache.get(xid).add(log);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对所有active log进行倒序undo</span><br>    <span class="hljs-keyword">for</span>(Entry&lt;Long, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt; entry : logCache.entrySet()) &#123;<br>        List&lt;<span class="hljs-type">byte</span>[]&gt; logs = entry.getValue();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> logs.size()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-type">byte</span>[] log = logs.get(i);<br>            <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>                doInsertLog(pc, log, UNDO);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                doUpdateLog(pc, log, UNDO);<br>            &#125;<br>        &#125;<br>        tm.abort(entry.getKey());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判读是否是插入事务，否则是更新事务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInsertLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-keyword">return</span> log[<span class="hljs-number">0</span>] == LOG_TYPE_INSERT;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="解析插入事务与删除事务"><a href="#解析插入事务与删除事务" class="headerlink" title="解析插入事务与删除事务"></a><strong>解析插入事务与删除事务</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InsertLogInfo <span class="hljs-title function_">parseInsertLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>        <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsertLogInfo</span>();<br>        li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_INSERT_PGNO));<br>        li.pgno = Parser.parseInt(Arrays.copyOfRange(log, OF_INSERT_PGNO, OF_INSERT_OFFSET));<br>        li.offset = Parser.parseShort(Arrays.copyOfRange(log, OF_INSERT_OFFSET, OF_INSERT_RAW));<br>        li.raw = Arrays.copyOfRange(log, OF_INSERT_RAW, log.length);<br>        <span class="hljs-keyword">return</span> li;<br>    &#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>MYDB record</div>
      <div>http://example.com/2025/02/21/MYDB-record/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Kon4tsu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/17/RPC/" title="RPC">
                        <span class="hidden-mobile">RPC</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
