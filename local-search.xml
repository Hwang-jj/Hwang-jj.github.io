<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ThreadLocal原理</title>
    <link href="/2025/05/13/ThreadLocal%E5%8E%9F%E7%90%86/"/>
    <url>/2025/05/13/ThreadLocal%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://luming.blog.csdn.net/article/details/141071290?fromshare=blogdetail&sharetype=blogdetail&sharerId=141071290&sharerefer=PC&sharesource=m0_51140831&sharefrom=from_link">https://luming.blog.csdn.net/article/details/141071290?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=141071290&amp;sharerefer=PC&amp;sharesource=m0_51140831&amp;sharefrom=from_link</a></p></blockquote><h2 id="一、什么是ThreadLocal"><a href="#一、什么是ThreadLocal" class="headerlink" title="一、什么是ThreadLocal"></a>一、什么是ThreadLocal</h2><p>在Java中，ThreadLocal 类提供了一种方式，使得每个线程可以独立地持有自己的变量副本，而不是共享变量。这可以避免线程间的同步问题，因为<strong>每个线程只能访问自己的ThreadLocal变量</strong>。通过ThreadLocal为线程添加的值只能由这个线程访问到，其他的线程无法访问，因此就避免了多线程之间的同步问题</p><p>使用ThreadLocal时，通常需要实现以下步骤：</p><ul><li>初始化：创建ThreadLocal变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;T&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><ul><li>设置值：使用set(T value)方法为当前线程设置值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">threadLocal.set(value);<br></code></pre></td></tr></table></figure><ul><li>获取值：使用get()方法获取当前线程的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> threadLocal.get();<br></code></pre></td></tr></table></figure><ul><li>移除值：使用remove()方法在线程结束时清除ThreadLocal变量，以避免内存泄漏。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">threadLocal.remove();<br></code></pre></td></tr></table></figure><ul><li>示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 设置线程局部变量的值</span><br>        threadLocal.set(<span class="hljs-number">10</span>);<br> <br>        <span class="hljs-comment">// 这个值在其他线程中是取不到获取的</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> threadLocal.get();<span class="hljs-comment">//null</span><br>            System.out.println(<span class="hljs-string">&quot;Thread value: &quot;</span> + value);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131013254.png" alt="img"></p><h2 id="二、ThreadLocal的数据结构"><a href="#二、ThreadLocal的数据结构" class="headerlink" title="二、ThreadLocal的数据结构"></a>二、ThreadLocal的数据结构</h2><p>在JDK8之后每一个线程都会维护一个ThreadLocalMap，这个Map是一个哈希散列结构，如下图所示，每一个元素（Entry）都是一个键值对，key为ThreadLocal，Value为存储的数据，也就是set()方法存储的内容。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131013255.png" alt="img"></p><h2 id="三、ThreadLocal的内存泄露问题"><a href="#三、ThreadLocal的内存泄露问题" class="headerlink" title="三、ThreadLocal的内存泄露问题"></a>三、ThreadLocal的内存泄露问题</h2><p>首先是内存泄漏的概念：</p><ul><li>内存溢出：没有足够的内存供申请者使用</li><li>内存泄漏：程序中已经动态分配的内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至崩溃。此外内存泄漏的堆积最终也会导致内存溢出。</li></ul><p>下图是ThreadLocal相关的内存结构图，在栈区中有threadLocal对象和当前线程对象，分别指向堆区真正存储的类对象，<strong>这俩个指向都是强引用</strong>。在堆区中当前线程肯定是只有自己的Map的信息的，而Map中又存储着一个个的Entry节点；在Entry节点中每一个Key都是ThreadLocal的实例，同时Value又指向了真正的存储的数据位置，以上便是下图的引用关系。<br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131013257.png" alt="img"></p><p>那么所谓的内存泄漏，其实就是指的<strong>Entry这块内存不能正确释放</strong></p><blockquote><p>强弱引用的概念：</p><ul><li>强引用(StrongReference)：就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。</li><li>弱引用(WeakReference)：垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul></blockquote><h3 id="如果Key是强引用"><a href="#如果Key是强引用" class="headerlink" title="如果Key是强引用"></a>如果Key是强引用</h3><p>当我们在业务代码中使用完ThreadLocal，在栈区指向堆区的这个指向关系就会被回收掉了，但是由于Key是强引用指向ThreadLocal，故而堆区中的ThreadLocal无法被回收，此时的Key指向ThreadLocal，另外由于当前线程还没有结束，则下面那条强引用指向关系任然存在。故为下图的关系状态<br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131013258.png" alt="img"></p><p>在这样的情况下，由于栈上的指向已经消失了，我们无法访问到堆上的ThreadLocal，故而无法访问到Entry，但是Entry又有Map指向它，故而无法进行回收。那么此时的Entry即无法访问也无法回收，这就造成了<mark>Entry的内存泄露</mark>。</p><h3 id="如果Key是弱引用"><a href="#如果Key是弱引用" class="headerlink" title="如果Key是弱引用"></a>如果Key是弱引用</h3><p>其次是弱引用的情况，当我们在业务代码中使用完ThreadLocal就通过垃圾回收（GC）进行了回收，那么由于Key是弱引用，Key此时就指向null，但是由于当前线程还没有结束，则下面那条强引用指向关系仍然存在</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131013259.png" alt="img"></p><p>在这样的情况下，Entry由于仍然有Map指向它所以不会被GC回收掉，但是此时的Key又为null，所以我们无法访问到这个Value。这就导致了这个Value我们即不能访问到也不能进行回收，此时就造成了<mark>Value的内存泄漏</mark>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上分析，我们得知了不管Entry中的Key是否为弱引用，都会造成内存泄漏的情况，只不过强引用下是Entry的内存泄漏，弱引用下是Value的内存泄漏。造成这样内存泄漏的情况都有这样的共同特性：</p><ul><li>都没有手动删除Entry</li><li>当前线程都在运行</li></ul><p>也就是说，只要我们在使用完ThreadLocal后，调用其remove()方法删除对应的Entry就可以避免内存泄漏的问题。</p><p>并且由于ThreadLoaclMap是Thread的一个属性，故而它的生命周期和线程一样，那么当线程的生命周期结束，自然也就没有Map指向Entry，这也就在根源上解决了问题。</p><p>综上所述，造成ThreadLocal内存泄漏的根本原因是：<mark>由于ThreadLocalMap的生命周期和Thread一样长，如果没有手动删除对应的Key就会导致内存泄漏</mark>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2025/03/12/RabbitMQ/"/>
    <url>/2025/03/12/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="队列相关消息"><a href="#队列相关消息" class="headerlink" title="队列相关消息"></a>队列相关消息</h2><h3 id="1-Provider"><a href="#1-Provider" class="headerlink" title="1.Provider"></a>1.Provider</h3><p>消息生产者，就是投递消息的程序。</p><h3 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2.Consumer"></a>2.Consumer</h3><p>消息消费者，就是接受消息的程序。</p><h3 id="3-没有使用消息队列时消息传递方式"><a href="#3-没有使用消息队列时消息传递方式" class="headerlink" title="3.没有使用消息队列时消息传递方式"></a>3.没有使用消息队列时消息传递方式</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909948.png"></p><h3 id="4-使用消息队列后消息传递方式"><a href="#4-使用消息队列后消息传递方式" class="headerlink" title="4.使用消息队列后消息传递方式"></a>4.使用消息队列后消息传递方式</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909949.png"></p><h3 id="5-什么是队列？"><a href="#5-什么是队列？" class="headerlink" title="5.什么是队列？"></a>5.什么是队列？</h3><p>队列就像存放了商品的仓库或者商店，是生产商品的工厂和购买商品的用户之间的中转站。</p><h3 id="6-队列里存储了什么？"><a href="#6-队列里存储了什么？" class="headerlink" title="6.队列里存储了什么？"></a>6.队列里存储了什么？</h3><p>在 rabbitMQ 中，信息流从你的应用程序出发，来到 Rabbitmq 的队列，所有信息可以只存储在一个队列中。队列可以存储很多信息，因为它基本上是一个无限制的缓冲区，前提是你的机器有足够的存储空间。</p><h3 id="7-队列和应用程序的关系？"><a href="#7-队列和应用程序的关系？" class="headerlink" title="7.队列和应用程序的关系？"></a>7.队列和应用程序的关系？</h3><p>多个生产者可以将消息发送到同一个队列中，多个消息者也可以只从同一个队列接收数据。</p><h2 id="RabbitMQ相关概念"><a href="#RabbitMQ相关概念" class="headerlink" title="RabbitMQ相关概念"></a>RabbitMQ相关概念</h2><h3 id="1-Message"><a href="#1-Message" class="headerlink" title="1.Message"></a>1.Message</h3><p>消息。消息是不具名的，它由消息头消息体组成。消息体是不透明的，而消息头则由<br>一系列可选属性组成，这些属性包括：routing-key(路由键)、priority(相对于其他消息的优先<br>权)、delivery-mode(指出消息可能持久性存储)等。</p><h3 id="2-Publisher"><a href="#2-Publisher" class="headerlink" title="2.Publisher"></a>2.Publisher</h3><p>消息的生产者。也是一个向交换器发布消息的客户端应用程序。</p><h3 id="3-Consumer"><a href="#3-Consumer" class="headerlink" title="3.Consumer"></a>3.Consumer</h3><p>消息的消费者。表示一个从消息队列中取得消息的客户端应用程序。</p><h3 id="4-Exchange"><a href="#4-Exchange" class="headerlink" title="4.Exchange"></a>4.Exchange</h3><p>交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。<br>三种常用的交换器类型</p><ol><li>direct(发布与订阅 完全匹配)</li><li>fanout(广播)</li><li>topic(主题，规则匹配)</li></ol><h3 id="5-Binding"><a href="#5-Binding" class="headerlink" title="5.Binding"></a>5.Binding</h3><p>绑定。用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息<br>队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p><h3 id="6-Queue"><a href="#6-Queue" class="headerlink" title="6.Queue"></a>6.Queue</h3><p>消息队列。用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一<br>个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取<br>走。</p><h3 id="7-Routing-key"><a href="#7-Routing-key" class="headerlink" title="7.Routing-key"></a>7.Routing-key</h3><p>路由键。RabbitMQ 决定消息该投递到哪个队列的规则。<br>队列通过路由键绑定到交换器。<br>消息发送到 MQ 服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ 也会将其<br>和绑定使用的路由键进行匹配。<br>如果相匹配，消息将会投递到该队列。<br>如果不匹配，消息将会进入黑洞。</p><h3 id="8-Connection"><a href="#8-Connection" class="headerlink" title="8.Connection"></a>8.Connection</h3><p>链接。指 rabbit 服务器和服务建立的 TCP 链接。</p><h3 id="9-Channel"><a href="#9-Channel" class="headerlink" title="9.Channel"></a>9.Channel</h3><p>信道。<br>1，Channel 中文叫做信道，是 TCP 里面的虚拟链接。例如：电缆相当于 TCP，信道是<br>一个独立光纤束，一条 TCP 连接上创建多条信道是没有问题的。<br>2，TCP 一旦打开，就会创建 AMQP 信道。<br>3，无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。</p><h3 id="10-Virtual-Host"><a href="#10-Virtual-Host" class="headerlink" title="10.Virtual Host"></a>10.Virtual Host</h3><p>虚拟主机。表示一批交换器，消息队列和相关对象。虚拟主机是共享相同的身份认证<br>和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有<br>自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在链接时指定，<br>RabbitMQ 默认的 vhost 是&#x2F;</p><h3 id="11-Borker"><a href="#11-Borker" class="headerlink" title="11.Borker"></a>11.Borker</h3><p>表示消息队列服务器实体。</p><h3 id="12-交换器和队列的关系"><a href="#12-交换器和队列的关系" class="headerlink" title="12.交换器和队列的关系"></a>12.交换器和队列的关系</h3><p>交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的<br>路由键匹配，那么消息就会被路由到该绑定的队列中。<br>也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由<br>键匹配分发消息到具体的队列中。<br>路由键可以理解为匹配的规则。</p><h3 id="13-RabbitMQ-为什么需要信道？为什么不是-TCP-直接通信？"><a href="#13-RabbitMQ-为什么需要信道？为什么不是-TCP-直接通信？" class="headerlink" title="13.RabbitMQ 为什么需要信道？为什么不是 TCP 直接通信？"></a>13.RabbitMQ 为什么需要信道？为什么不是 TCP 直接通信？</h3><ol><li>TCP 的创建和销毁开销特别大。创建需要 3 次握手，销毁需要 4 次分手。</li><li>如果不用信道，那应用程序就会以 TCP 链接 Rabbit，高峰时每秒成千上万条链接<br>会造成资源巨大的浪费，而且操作系统每秒处理 TCP 链接数也是有限制的，必定造成性能<br>瓶颈。</li><li>信道的原理是一条线程一条通道，多条线程多条通道同用一条 TCP 链接。一条 TCP<br>链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。</li></ol><h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li>安装Erlang：<a href="http://erlang.org/download/otp_win64_21.3.exe">http://erlang.org/download/otp_win64_21.3.exe</a></li><li>下载rabbitmq：<a href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe">https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe</a></li><li>按照提示进行安装，安装完成后进入rabbitmq的安装目录:D:\RabbitMQ Server\rabbitmq_server-3.7.14\sbin</li><li>在地址栏输入cmd并回车启动命令行输入以下命令：rabbitmq-plugins enable rabbitmq_management</li><li>访问地址查看是否安装成功：<a href="http://127.0.0.1:15672/">http://127.0.0.1:15672/</a></li><li>输入账号密码登录：guest guest</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><p>安装erlang：<code>yum install erlang</code>，如报错No package erlang available，需要安装EPEL库。</p></li><li><p>安装wget：<code>yum -y install wget</code></p></li><li><p>安装EPEL库：</p><ul><li><pre><code class="language-shell">wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpmrpm -ivh epel-release-6-8.noarch.rpm<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><br>- 安装RabbitMQ rpm包：<br><br>  - ```shell<br>    wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.5.0/rabbitmq-server<span class="hljs-string">-3</span>.5.0<span class="hljs-string">-1</span>.noarch.rpm<br>    <br>    rpm -ivh rabbitmq-server<span class="hljs-string">-3</span>.5.0<span class="hljs-string">-1</span>.noarch.rpm<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>启动RabbitMQ，并验证启动情况：<code>rabbitmq-server --detached &amp;ps aux |grep rabbitmq</code></p></li><li><p>以服务的方式启动：<code>service rabbitmq-server start</code></p></li><li><p>检查5672端口是否打开：</p><ul><li><pre><code class="language-shell">/sbin/iptables -I INPUT -p tcp --dport 5672 -j ACCEPT/etc/rc.d/init.d/iptables save/etc/init.d/iptables restart/etc/init.d/iptables status<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">- 启用维护插件（web管理界面）:</span><br><br>  - ```shell<br>    rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>重启RabbitMQ：</p><ul><li><pre><code class="language-shell">service rabbitmq-server restart<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><br><span class="hljs-bullet">-</span> <span class="hljs-string">访问UI界面：http://ip/15672。账号密码：guest</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">无法登陆解决：</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">```shell</span><br>    vim /etc/rabbitmq/rabbitmq.config<br>    <span class="hljs-comment">#写入以下信息，并保存</span><br>    [&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p><strong>使用docker镜像中国下载Rabbitmq镜像，选择带有management的，因为这个是有WEB界面：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用docker镜像中国下载Rabbitmq镜像，选择带有management的，因为这个是有WEB界面。</span><br>[root@docker ~]# docker pull registry.docker-cn.com/library/rabbitmq:3.7-management<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909950.png"></p><p><strong>选择官方的：</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909951.png"></p><p><strong>我选择的是这个3.7版本：</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909952.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看镜像</span><br>[root@docker ~]# docker images<br>REPOSITORY                                TAG                 IMAGE ID            CREATED             SIZE<br>registry.docker-cn.com/library/rabbitmq   3.7-management      24cb552c7c00        12 days ago         212 MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">运行容器</span><br>[root@docker ~]# docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq 24cb552c7c00<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看进程</span><br>[root@docker ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                                        NAMES<br>73943a64f336        24cb552c7c00        &quot;docker-entrypoint...&quot;   7 minutes ago       Up 7 minutes        4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp   rabbitmq<br>[root@docker ~]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">关闭防火墙设置开机不启动</span><br>[root@docker ~]# systemctl stop firewalld<br>[root@docker ~]# systemctl disable firewalld<br></code></pre></td></tr></table></figure><p><strong>此时就可以登录Rabbitmq的WEB界面了，访问地址是[ip:15672]默认用户名和密码都是guest。</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909953.png"></p><h2 id="RabbitMQ交换器"><a href="#RabbitMQ交换器" class="headerlink" title="RabbitMQ交换器"></a>RabbitMQ交换器</h2><h3 id="Direct交换器"><a href="#Direct交换器" class="headerlink" title="Direct交换器"></a>Direct交换器</h3><blockquote><p>  发布与订阅，完全匹配。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909954.png"></p><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;project xmlns=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>         xsi:schemaLocation=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;<br>    &lt;modelVersion&gt;<span class="hljs-number">4.0</span>.<span class="hljs-number">0</span>&lt;/modelVersion&gt;<br>    &lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring<span class="hljs-literal">-boot-starter-parent</span>&lt;/artifactId&gt;<br>        &lt;version&gt;<span class="hljs-number">2.1</span>.<span class="hljs-number">4</span>.RELEASE&lt;/version&gt;<br>        &lt;relativePath/&gt; &lt;!<span class="hljs-literal">--</span> lookup parent from repository <span class="hljs-literal">--</span>&gt;<br>    &lt;/parent&gt;<br>    &lt;groupId&gt;com.lzhpo.rabbitmq&lt;/groupId&gt;<br>    &lt;artifactId&gt;rabbitmq<span class="hljs-literal">-direct-provider</span>&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span><span class="hljs-literal">-SNAPSHOT</span>&lt;/version&gt;<br>    &lt;name&gt;rabbitmq<span class="hljs-literal">-direct-provider</span>&lt;/name&gt;<br>    &lt;description&gt;Demo project <span class="hljs-keyword">for</span> Spring Boot&lt;/description&gt;<br><br>    &lt;properties&gt;<br>        &lt;java.version&gt;<span class="hljs-number">1.8</span>&lt;/java.version&gt;<br>    &lt;/properties&gt;<br><br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring<span class="hljs-literal">-boot-starter-amqp</span>&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring<span class="hljs-literal">-boot-starter-web</span>&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring<span class="hljs-literal">-boot-starter-test</span>&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br><br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>                &lt;artifactId&gt;spring<span class="hljs-literal">-boot-maven-plugin</span>&lt;/artifactId&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br><br>&lt;/project&gt;<br></code></pre></td></tr></table></figure><h5 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.direct</span><br><span class="hljs-comment">#info 路由键</span><br><span class="hljs-attr">mq.config.queue.info.routing.key</span>=<span class="hljs-string">log.info.routing.key</span><br><span class="hljs-comment">#error 路由键</span><br><span class="hljs-attr">mq.config.queue.error.routing.key</span>=<span class="hljs-string">log.error.routing.key</span><br><span class="hljs-comment">#error 队列名称</span><br><span class="hljs-attr">mq.config.queue.error</span>=<span class="hljs-string">log.error</span><br></code></pre></td></tr></table></figure><h5 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a>Sender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdirectprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sender</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><br><span class="hljs-comment">//routingkey 路由键</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.queue.error.routing.key&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String routingkey;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange, <span class="hljs-built_in">this</span>.routingkey, msg);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="RabbitmqDirectProviderApplicationTests测试类"><a href="#RabbitmqDirectProviderApplicationTests测试类" class="headerlink" title="RabbitmqDirectProviderApplicationTests测试类"></a>RabbitmqDirectProviderApplicationTests测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdirectprovider;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqDirectProviderApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Sender sender;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试消息队列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-built_in">this</span>.sender.send(<span class="hljs-string">&quot;Hello RabbitMQ&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><h5 id="pom-xml和生产者的一样。"><a href="#pom-xml和生产者的一样。" class="headerlink" title="pom.xml和生产者的一样。"></a>pom.xml和生产者的一样。</h5><h5 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.direct</span><br><span class="hljs-comment">#info 队列名称</span><br><span class="hljs-attr">mq.config.queue.info</span>=<span class="hljs-string">log.info</span><br><span class="hljs-comment">#info 路由键</span><br><span class="hljs-attr">mq.config.queue.info.routing.key</span>=<span class="hljs-string">log.info.routing.key</span><br><span class="hljs-comment">#error 队列名称</span><br><span class="hljs-attr">mq.config.queue.error</span>=<span class="hljs-string">log.error</span><br><span class="hljs-comment">#error 路由键</span><br><span class="hljs-attr">mq.config.queue.error.routing.key</span>=<span class="hljs-string">log.error.routing.key</span><br></code></pre></td></tr></table></figure><h5 id="ErrorReceiver"><a href="#ErrorReceiver" class="headerlink" title="ErrorReceiver"></a>ErrorReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.error&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">key=&quot;$&#123;mq.config.queue.error.routing.key&#125;&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Error..........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="InfoReceiver"><a href="#InfoReceiver" class="headerlink" title="InfoReceiver"></a>InfoReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.info&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">key=&quot;$&#123;mq.config.queue.info.routing.key&#125;&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Info........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqDirectConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitmqDirectConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>先启动消费者，再运行生产者的测试类<code>RabbitmqDirectProviderApplicationTests</code>测试类。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909955.png"></p><h3 id="Topic交换器"><a href="#Topic交换器" class="headerlink" title="Topic交换器"></a>Topic交换器</h3><blockquote><p>  主题，规则匹配。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909956.png"></p><h4 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h4><h5 id="application-properties-2"><a href="#application-properties-2" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.topic</span><br></code></pre></td></tr></table></figure><h5 id="OrderSender"><a href="#OrderSender" class="headerlink" title="OrderSender"></a>OrderSender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderSender</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;order.log.debug&quot;</span>, <span class="hljs-string">&quot;order.log.debug.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;order.log.info&quot;</span>, <span class="hljs-string">&quot;order.log.info.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;order.log.warn&quot;</span>,<span class="hljs-string">&quot;order.log.warn.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;order.log.error&quot;</span>, <span class="hljs-string">&quot;order.log.error.....&quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ProductSender"><a href="#ProductSender" class="headerlink" title="ProductSender"></a>ProductSender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductSender</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;product.log.debug&quot;</span>, <span class="hljs-string">&quot;product.log.debug.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;product.log.info&quot;</span>, <span class="hljs-string">&quot;product.log.info.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;product.log.warn&quot;</span>,<span class="hljs-string">&quot;product.log.warn.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;product.log.error&quot;</span>, <span class="hljs-string">&quot;product.log.error.....&quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="UserSender"><a href="#UserSender" class="headerlink" title="UserSender"></a>UserSender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserSender</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;user.log.debug&quot;</span>, <span class="hljs-string">&quot;user.log.debug.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;user.log.info&quot;</span>, <span class="hljs-string">&quot;user.log.info.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;user.log.warn&quot;</span>,<span class="hljs-string">&quot;user.log.warn.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;user.log.error&quot;</span>, <span class="hljs-string">&quot;user.log.error.....&quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RabbitmqTopicProviderApplicationTests测试类"><a href="#RabbitmqTopicProviderApplicationTests测试类" class="headerlink" title="RabbitmqTopicProviderApplicationTests测试类"></a>RabbitmqTopicProviderApplicationTests测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicprovider;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqTopicProviderApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserSender usersender;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductSender productsender;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderSender ordersender;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试消息队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.usersender.send(<span class="hljs-string">&quot;UserSender.....&quot;</span>);<br>        <span class="hljs-built_in">this</span>.productsender.send(<span class="hljs-string">&quot;ProductSender....&quot;</span>);<br>        <span class="hljs-built_in">this</span>.ordersender.send(<span class="hljs-string">&quot;OrderSender......&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h4><h5 id="application-properties-3"><a href="#application-properties-3" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.topic</span><br><span class="hljs-comment">#info 队列名称</span><br><span class="hljs-attr">mq.config.queue.info</span>=<span class="hljs-string">log.info</span><br><span class="hljs-comment">#error 队列名称</span><br><span class="hljs-attr">mq.config.queue.error</span>=<span class="hljs-string">log.error</span><br><span class="hljs-comment">#log 队列名称</span><br><span class="hljs-attr">mq.config.queue.logs</span>=<span class="hljs-string">log.all</span><br></code></pre></td></tr></table></figure><h5 id="ErrorReceiver-1"><a href="#ErrorReceiver-1" class="headerlink" title="ErrorReceiver"></a>ErrorReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.error&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">key=&quot;*.log.error&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;......Error........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="InfoReceiver-1"><a href="#InfoReceiver-1" class="headerlink" title="InfoReceiver"></a>InfoReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.info&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">key=&quot;*.log.info&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;......Info........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="LogsReceiver"><a href="#LogsReceiver" class="headerlink" title="LogsReceiver"></a>LogsReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.logs&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">key=&quot;*.log.*&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogsReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;......All........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Main-1"><a href="#Main-1" class="headerlink" title="Main"></a>Main</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqTopicConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitmqTopicConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><p>先启动消费者，然后再运行<code>RabbitmqTopicProviderApplicationTests</code>测试类。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909957.png"></p><h3 id="Fanout交换器"><a href="#Fanout交换器" class="headerlink" title="Fanout交换器"></a>Fanout交换器</h3><blockquote><p>  广播。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909958.png"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909959.png"></p><h4 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h4><h5 id="application-properties-4"><a href="#application-properties-4" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">order.fanout</span><br></code></pre></td></tr></table></figure><h5 id="Sender-1"><a href="#Sender-1" class="headerlink" title="Sender"></a>Sender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sender</span> &#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;&quot;</span>,<br>msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RabbitmqFanoutProviderApplicationTests测试类"><a href="#RabbitmqFanoutProviderApplicationTests测试类" class="headerlink" title="RabbitmqFanoutProviderApplicationTests测试类"></a>RabbitmqFanoutProviderApplicationTests测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutprovider;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqFanoutProviderApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Sender sender;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试消息队列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-built_in">this</span>.sender.send(<span class="hljs-string">&quot;Hello RabbitMQ&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h4><h5 id="application-properties-5"><a href="#application-properties-5" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">order.fanout</span><br><span class="hljs-comment">#短信服务队列名称</span><br><span class="hljs-attr">mq.config.queue.sms</span>=<span class="hljs-string">order.sms</span><br><span class="hljs-comment">#push 服务队列名称</span><br><span class="hljs-attr">mq.config.queue.push</span>=<span class="hljs-string">order.push</span><br></code></pre></td></tr></table></figure><h5 id="SmsReceiver"><a href="#SmsReceiver" class="headerlink" title="SmsReceiver"></a>SmsReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> *                key:路由键</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.sms&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.FANOUT)</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Sms........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="PushReceiver"><a href="#PushReceiver" class="headerlink" title="PushReceiver"></a>PushReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.push&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.FANOUT)</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Error..........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Main-2"><a href="#Main-2" class="headerlink" title="Main"></a>Main</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqFanoutConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitmqFanoutConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h4><p>先启动消费者，然后再启动生产者<code>RabbitmqFanoutProviderApplicationTests</code>测试类。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909960.png"></p><h2 id="使用-RabbitMQ-实现松耦合设计"><a href="#使用-RabbitMQ-实现松耦合设计" class="headerlink" title="使用 RabbitMQ 实现松耦合设计"></a>使用 RabbitMQ 实现松耦合设计</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909961.png"></p><h3 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h3><h5 id="application-properties-6"><a href="#application-properties-6" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">order.fanout</span><br></code></pre></td></tr></table></figure><h5 id="Sender-2"><a href="#Sender-2" class="headerlink" title="Sender"></a>Sender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sender</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br>    <span class="hljs-comment">//exchange 交换器名称</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String exchange;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 发送消息的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-comment">//向消息队列发送消息</span><br>        <span class="hljs-comment">//参数一：交换器名称。</span><br>        <span class="hljs-comment">//参数二：路由键</span><br>        <span class="hljs-comment">//参数三：消息</span><br>        <span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;&quot;</span>, msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RabbitmqFanoutOuheProviderApplicationTests测试类"><a href="#RabbitmqFanoutOuheProviderApplicationTests测试类" class="headerlink" title="RabbitmqFanoutOuheProviderApplicationTests测试类"></a>RabbitmqFanoutOuheProviderApplicationTests测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheprovider;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqFanoutOuheProviderApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Sender sender;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试消息队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.sender.send(<span class="hljs-string">&quot;Hello RabbitMQ&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h3><h5 id="application-properties-7"><a href="#application-properties-7" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">order.fanout</span><br><br><span class="hljs-attr">mq.config.queue.sms</span>=<span class="hljs-string">order.sms</span><br><br><span class="hljs-attr">mq.config.queue.push</span>=<span class="hljs-string">order.push</span><br><br><span class="hljs-attr">mq.config.queue.red</span>=<span class="hljs-string">red</span><br></code></pre></td></tr></table></figure><h5 id="PushReceiver-1"><a href="#PushReceiver-1" class="headerlink" title="PushReceiver"></a>PushReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.push&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.FANOUT)</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Push..........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RedReceiver"><a href="#RedReceiver" class="headerlink" title="RedReceiver"></a>RedReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> *                key:路由键</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.red&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.FANOUT)</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;给用户发送10元红包........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="SmsReceiver-1"><a href="#SmsReceiver-1" class="headerlink" title="SmsReceiver"></a>SmsReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> *                key:路由键</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.sms&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.FANOUT)</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Sms........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Main-3"><a href="#Main-3" class="headerlink" title="Main"></a>Main</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqFanoutOuheConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitmqFanoutOuheConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试结果-3"><a href="#测试结果-3" class="headerlink" title="测试结果"></a>测试结果</h4><p>先运行消费者，然后再运行生产者的<code>RabbitmqFanoutOuheProviderApplicationTests</code>测试类。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909962.png"></p><h2 id="RabbitMQ消息处理"><a href="#RabbitMQ消息处理" class="headerlink" title="RabbitMQ消息处理"></a>RabbitMQ消息处理</h2><blockquote><p>  消息的可靠性是 RabbitMQ 的一大特色，那么 RabbitMQ 是如何保证消息可靠性的呢——消息持久化。</p></blockquote><h3 id="RabbitMQ的消息持久化处理"><a href="#RabbitMQ的消息持久化处理" class="headerlink" title="RabbitMQ的消息持久化处理"></a>RabbitMQ的消息持久化处理</h3><h4 id="生产者-4"><a href="#生产者-4" class="headerlink" title="生产者"></a>生产者</h4><h6 id="application-properties-8"><a href="#application-properties-8" class="headerlink" title="application.properties"></a>application.properties</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.direct</span><br><br><span class="hljs-attr">mq.config.queue.info.routing.key</span>=<span class="hljs-string">log.info.routing.key</span><br><br><span class="hljs-attr">mq.config.queue.error.routing.key</span>=<span class="hljs-string">log.error.routing.key</span><br><br><span class="hljs-attr">mq.config.queue.error</span>=<span class="hljs-string">log.error</span><br></code></pre></td></tr></table></figure><h6 id="Sender-3"><a href="#Sender-3" class="headerlink" title="Sender"></a>Sender</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdurabledirectprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sender</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><br><span class="hljs-comment">//routingkey 路由键</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.queue.error.routing.key&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String routingkey;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange, <span class="hljs-built_in">this</span>.routingkey, msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="RabbitmqDurableDirectProviderApplicationTests测试类"><a href="#RabbitmqDurableDirectProviderApplicationTests测试类" class="headerlink" title="RabbitmqDurableDirectProviderApplicationTests测试类"></a>RabbitmqDurableDirectProviderApplicationTests测试类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdurabledirectprovider;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqDurableDirectProviderApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Sender sender;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试消息队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            flag++;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-built_in">this</span>.sender.send(<span class="hljs-string">&quot;Hello RabbitMQ &quot;</span>+flag);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-4"><a href="#消费者-4" class="headerlink" title="消费者"></a>消费者</h4><h6 id="application-properties-9"><a href="#application-properties-9" class="headerlink" title="application.properties"></a>application.properties</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.direct</span><br><br><span class="hljs-attr">mq.config.queue.info</span>=<span class="hljs-string">log.info</span><br><br><span class="hljs-attr">mq.config.queue.info.routing.key</span>=<span class="hljs-string">log.info.routing.key</span><br><br><span class="hljs-attr">mq.config.queue.error</span>=<span class="hljs-string">log.error</span><br><br><span class="hljs-attr">mq.config.queue.error.routing.key</span>=<span class="hljs-string">log.error.routing.key</span><br><br></code></pre></td></tr></table></figure><h6 id="ErrorReceiver-2"><a href="#ErrorReceiver-2" class="headerlink" title="ErrorReceiver"></a>ErrorReceiver</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdurabledirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.error&#125;&quot;,autoDelete=&quot;false&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">key=&quot;$&#123;mq.config.queue.error.routing.key&#125;&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Error..........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="InfoReceiver-2"><a href="#InfoReceiver-2" class="headerlink" title="InfoReceiver"></a>InfoReceiver</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdurabledirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.info&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">key=&quot;$&#123;mq.config.queue.info.routing.key&#125;&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Info........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Main-4"><a href="#Main-4" class="headerlink" title="Main"></a>Main</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdurabledirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqDurableDirectConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitmqDurableDirectConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="测试结果-4"><a href="#测试结果-4" class="headerlink" title="测试结果"></a>测试结果</h5><p>先启动消费者，再运行<code>RabbitmqDurableDirectProviderApplicationTests</code>测试类。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909963.png"></p><h3 id="RabbitMQ中的消息确认ACK机制"><a href="#RabbitMQ中的消息确认ACK机制" class="headerlink" title="RabbitMQ中的消息确认ACK机制"></a>RabbitMQ中的消息确认ACK机制</h3><blockquote><p>  什么是消息确认ACK？</p></blockquote><p>如果在处理消息的过程中，消费者的服务器在处理消息时出现异常，那可能这条正常在处理的消息就没有完成消息消费，数据就会丢失。为了确保数据不会丢失，RabbitMQ支持消息确认ACK。</p><blockquote><p>  ACK的消息确认机制？</p></blockquote><p>ACK机制是消费者从RabbitMQ手到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除。</p><ol><li>如果一个消费者在处理消息出现了网络不稳定、服务器异常等现象，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将消息重新放入队列中。</li><li>如果在集群的环境下：RabbitMQ会立即将这个消息推送给这个在线的其它消费者。这种机制保证了再消费者服务端故障的时候，不会丢失任何消息和任务。</li><li>消息永远不会从RabbitMQ中删除：只有当消费者正确发送ACK反馈，RabbitMQ确认收到后，消息才会从RabbitMQ服务器的数据中删除。</li><li>消息的ACK确认机制默认是打开的。</li></ol><blockquote><p>  ACK机制的开发注意事项？</p></blockquote><p>如果忘记了ACK，那么后果很严重。当Consumer退出时，Message会一直重新分发。然后RabbitMQ会占用越来越多的内存，由于RabbitMQ会长时间运行，因此这个“内存泄漏”是致命的。</p><blockquote><p>  修改 Consusmer 配置文件解决 ACK 反馈问题。</p></blockquote><p>在<code>application.properties</code>配置文件中添加以下</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">############Rabbitmq的消息确认ACK机制############</span><br><span class="hljs-comment">#开启重试</span><br><span class="hljs-attr">spring.rabbitmq.listener.retry.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#重试次数，默认为 3 次</span><br><span class="hljs-attr">spring.rabbitmq.listener.retry.max-attempts</span>=<span class="hljs-string">5</span><br></code></pre></td></tr></table></figure><h2 id="RabbitMQ六种消息模式"><a href="#RabbitMQ六种消息模式" class="headerlink" title="RabbitMQ六种消息模式"></a>RabbitMQ六种消息模式</h2><p>pom依赖:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&lt;dependency&gt;<br>    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;<br>    &lt;artifactId&gt;amqp<span class="hljs-literal">-client</span>&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">4.0</span>.<span class="hljs-number">2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>    &lt;artifactId&gt;slf4j<span class="hljs-literal">-api</span>&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">1.7</span>.<span class="hljs-number">10</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>    &lt;artifactId&gt;slf4j<span class="hljs-literal">-log4j12</span>&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">1.7</span>.<span class="hljs-number">5</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;log4j&lt;/groupId&gt;<br>    &lt;artifactId&gt;log4j&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">1.2</span>.<span class="hljs-number">17</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;junit&lt;/groupId&gt;<br>    &lt;artifactId&gt;junit&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">4.11</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>RabbitMQ的连接工具（我单独写出来了一个工具类，方便使用）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：获取Rabbitmq的连接工具&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionUtils</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取Rabbitmq的连接</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> TimeoutException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//定义一个连接工厂</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br><br>        <span class="hljs-comment">//设置服务地址</span><br>        factory.setHost(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br><br>        <span class="hljs-comment">//AMQP 5672</span><br>        factory.setPort(<span class="hljs-number">5672</span>);<br><br>        <span class="hljs-comment">//vhost</span><br>        factory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br><br>        <span class="hljs-comment">//用户名</span><br>        factory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-comment">//密码</span><br>        factory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> factory.newConnection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h3><blockquote><p>  简单队列：一个生产者P发送消息到队列Q,一个消费者C接收。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909964.png"></p><h4 id="生产者-Send"><a href="#生产者-Send" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.simplequeues;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：生产者生产消息&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_simple_queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//获取一个连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br><br>        <span class="hljs-comment">//从连接中获取一个通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//创建队列声明</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">//需要发送的消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello simple!&quot;</span>;<br><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes());<br><br>        System.out.println(<span class="hljs-string">&quot;---send msg：&quot;</span> +msg);<br><br>        <span class="hljs-comment">//关闭</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-Recv"><a href="#消费者-Recv" class="headerlink" title="消费者(Recv)"></a>消费者(Recv)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.simplequeues;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：消费者获取消息&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_simple_queue&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * main()入口</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//oldApi();//老版本api</span><br>        newApi();<span class="hljs-comment">//新版本api</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新版本api</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newApi</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//获取一个连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br><br>        <span class="hljs-comment">//从连接中获取一个通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//创建队列声明</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">//定义消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;new api recv：&quot;</span> + msg);<br>            &#125;<br>        &#125;;<br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, consumer);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 老版本api</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oldApi</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//获取一个连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br><br>        <span class="hljs-comment">//从连接中获取一个通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//创建队列声明</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">//定义队列的消费者</span><br>        <span class="hljs-type">QueueingConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueingConsumer</span>(channel);<br><br>        <span class="hljs-comment">//监听队列</span><br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, consumer);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            QueueingConsumer.<span class="hljs-type">Delivery</span> <span class="hljs-variable">delivery</span> <span class="hljs-operator">=</span> consumer.nextDelivery();<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">msgString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;[recv] msg: &quot;</span> +msgString);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><h4 id="轮询分发"><a href="#轮询分发" class="headerlink" title="轮询分发"></a>轮询分发</h4><blockquote><p>  【轮询分发】：结果就是不管谁忙或清闲，都不会给谁多一个任务或少一个任务，任务总是你一个我一个的分。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909965.png"></p><h5 id="生产者-Send-1"><a href="#生产者-Send-1" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.lunxun;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：【轮询分发】&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * 备注:消费者 1 我们处理时间是 1s ;而消费者 2 中处理时间是 2s;</span><br><span class="hljs-comment"> * 但是我们看到的现象并不是 1 处理的多 消费者 2 处理的少。</span><br><span class="hljs-comment"> * -----------------------------------</span><br><span class="hljs-comment"> * 消费者1【Recv1】：</span><br><span class="hljs-comment"> *  [1] Received &#x27;.0&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  [1] Received &#x27;.2&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  ......</span><br><span class="hljs-comment"> *  [1] Received &#x27;.46&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  [1] Received &#x27;.48&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  消费者 1 将偶数部分处理掉了</span><br><span class="hljs-comment"> * -----------------------------------</span><br><span class="hljs-comment"> * 消费者2【Recv2】：</span><br><span class="hljs-comment"> *  [2] Received &#x27;.1&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  [2] Received &#x27;.3&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  ......</span><br><span class="hljs-comment"> *  [2] Received &#x27;.47&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  [2] Received &#x27;.49&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> * 消费者 2 中将奇数部分处理掉了。</span><br><span class="hljs-comment"> * -----------------------------------</span><br><span class="hljs-comment"> * 我想要的是 1 处理的多,而 2 处理的少</span><br><span class="hljs-comment"> * 测试结果:</span><br><span class="hljs-comment"> * 1.消费者 1 和消费者 2 获取到的消息内容是不同的,同一个消息只能被一个消费者获取</span><br><span class="hljs-comment"> * 2.消费者 1 和消费者 2 货到的消息数量是一样的 一个奇数一个偶数</span><br><span class="hljs-comment"> * 按道理消费者 1 获取的比消费者 2 要多</span><br><span class="hljs-comment"> * -----------------------------------</span><br><span class="hljs-comment"> * 这种方式叫做【轮询分发】：结果就是不管谁忙或清闲，都不会给谁多一个任务或少一个任务，任务总是你一个我一个的分。</span><br><span class="hljs-comment"> * -----------------------------------</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-comment">//消息内容</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.&quot;</span> +i;<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot; [x] Sent &#x27;&quot;</span> +message +<span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            Thread.sleep(i*<span class="hljs-number">10</span>);<br>        &#125;<br><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="消费者1-Recv1"><a href="#消费者1-Recv1" class="headerlink" title="消费者1(Recv1)"></a>消费者1(Recv1)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.lunxun;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列，主要为了防止消息接收者先运行此程序，队列还不存在时创建队列。</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//定义一个消息的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot; [1] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    doWork(message);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot; [x] Done&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//消息的确认模式自动应答</span><br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(String task)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unused&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oldAPi</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 定义队列的消费者</span><br>        <span class="hljs-type">QueueingConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueingConsumer</span>(channel);<br>        <span class="hljs-comment">// 监听队列，手动返回完成状态false 自动true 自动应答 不需要手动确认</span><br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, consumer);<br>        <span class="hljs-comment">// 获取消息</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            QueueingConsumer.<span class="hljs-type">Delivery</span> <span class="hljs-variable">delivery</span> <span class="hljs-operator">=</span> consumer.nextDelivery();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="消费者2-Recv2"><a href="#消费者2-Recv2" class="headerlink" title="消费者2(Recv2)"></a>消费者2(Recv2)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.lunxun;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//定义一个消息的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot; [2] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot; [x] Done&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//</span><br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平分发"><a href="#公平分发" class="headerlink" title="公平分发"></a>公平分发</h4><blockquote><p>  使用公平分发，必须关闭自动应答，改为手动应答。</p></blockquote><h5 id="生产者-Send-2"><a href="#生产者-Send-2" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.gongping;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：【公平分发】&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * 虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有 2 个消费者，所有的偶数的消息都是繁忙的，而</span><br><span class="hljs-comment"> * 奇数则是轻松的。按照轮询的方式，偶数的任务交给了第一个消费者，所以一直在忙个不停。奇数的任务交给另一</span><br><span class="hljs-comment"> * 个消费者，则立即完成任务，然后闲得不行。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 而 RabbitMQ 则是不了解这些的。他是不知道你消费者的消费能力的,这是因为当消息进入队列，RabbitMQ 就会分派</span><br><span class="hljs-comment"> * 消息。而 rabbitmq 只是盲目的将消息轮询的发给消费者。你一个我一个的这样发送.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 为了解决这个问题，我们使用 basicQos( prefetchCount = 1)方法，来限制 RabbitMQ 只发不超过 1 条的消息给同</span><br><span class="hljs-comment"> * 一个消费者。当消息处理完毕后，有了反馈 ack，才会进行第二次发送。(也就是说需要手动反馈给 Rabbitmq )</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 还有一点需要注意，使用【公平分发】，必须关闭自动应答，改为手动应答。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 这时候现象就是消费者 1 速度大于消费者 2</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-comment">// 创建一个频道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 指定一个队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prefetchCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//每个消费者发送确认信号之前，消息队列不发送下一个消息过来，一次只处理一个消息</span><br>        <span class="hljs-comment">//限制发给同一个消费者不得超过1条消息</span><br>        channel.basicQos(prefetchCount);<br>        <span class="hljs-comment">// 发送的消息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.&quot;</span> + i;<br>            <span class="hljs-comment">// 往队列中发出一条消息</span><br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            Thread.sleep(i * <span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-comment">// 关闭频道和连接</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="消费者1-Recv1-1"><a href="#消费者1-Recv1-1" class="headerlink" title="消费者1(Recv1)"></a>消费者1(Recv1)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.gongping;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列，主要为了防止消息接收者先运行此程序，队列还不存在时创建队列。</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.basicQos(<span class="hljs-number">1</span>);<span class="hljs-comment">//保证一次只分发一个</span><br>        <span class="hljs-comment">//定义一个消息的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot; [1] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    doWork(message);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot; [x] Done&quot;</span>);<br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">/**手动应答**/</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//手动确认消息</span><br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(String task)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="消费者2-Recv2-1"><a href="#消费者2-Recv2-1" class="headerlink" title="消费者2(Recv2)"></a>消费者2(Recv2)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.gongping;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * Message acknowledgment（消息应答）：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * boolean autoAck = false;</span><br><span class="hljs-comment"> * channel.basicConsume(QUEUE_NAME, autoAck, consumer);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * boolean autoAck = true;(自动确认模式)一旦 RabbitMQ 将消息分发给了消费者，就会从内存中删除。</span><br><span class="hljs-comment"> * 在这种情况下，如果杀死正在执行任务的消费者，会丢失正在处理的消息，也会丢失已经分发给这个消</span><br><span class="hljs-comment"> * 费者但尚未处理的消息。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * boolean autoAck = false; (手动确认模式) 我们不想丢失任何任务，如果有一个消费者挂掉了，那么</span><br><span class="hljs-comment"> * 我们应该将分发给它的任务交付给另一个消费者去处理。 为了确保消息不会丢失，RabbitMQ 支持消</span><br><span class="hljs-comment"> * 息应答。消费者发送一个消息应答，告诉 RabbitMQ 这个消息已经接收并且处理完毕了。RabbitMQ 可</span><br><span class="hljs-comment"> * 以删除它了。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 消息应答是默认打开的。也就是 boolean autoAck =false;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.basicQos(<span class="hljs-number">1</span>);<span class="hljs-comment">//保证一次只分发一个</span><br>        <span class="hljs-comment">//定义一个消息的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot; [2] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    doWork(message);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot; [x] Done&quot;</span>);<br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<span class="hljs-comment">/**关闭自动确认应答，手动应答**/</span><br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">/**关闭自动应答**/</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//关闭自动确认</span><br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(String task)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oldAPi</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 定义队列的消费者</span><br>        <span class="hljs-type">QueueingConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueingConsumer</span>(channel);<br>        <span class="hljs-comment">// 监听队列，手动返回完成状态</span><br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">false</span>, consumer);<br>        <span class="hljs-comment">// 获取消息</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            QueueingConsumer.<span class="hljs-type">Delivery</span> <span class="hljs-variable">delivery</span> <span class="hljs-operator">=</span> consumer.nextDelivery();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            <span class="hljs-comment">// 休眠1秒</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<span class="hljs-comment">/**关闭自动确认应答，手动应答**/</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="消息订阅模式"><a href="#消息订阅模式" class="headerlink" title="消息订阅模式"></a>消息订阅模式</h3><blockquote><p>  【订阅模式】：一个消息被多个消费者消费。</p><ol><li>一个生产者，多个消费者。</li><li>每一个消费者都有自己的队列。</li><li>生产者没有直接把消息发送到队列，而是发送到了交换机、转发器exchange。</li><li>每个队列都要绑定到交换机上。</li><li>生产者发送的消息经过交换机到达队列，就能实现一个消息被多个消费者消费。</li></ol></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909966.png"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909966.png"></p><h4 id="生产者-Send-3"><a href="#生产者-Send-3" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.subscribeModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * 先运行Send创建交换器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 但是这个发送的消息到哪了呢? 消息丢失了!!!因为交换机没有存储消息的能力,在 rabbitmq 中只有队列存储消息的</span><br><span class="hljs-comment"> * 能力.因为这时还没有队列,所以就会丢失;</span><br><span class="hljs-comment"> * 小结:消息发送到了一个没有绑定队列的交换机时,消息就会丢失!</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 【订阅模式】：一个消息被多个消费者消费。</span><br><span class="hljs-comment"> * 1.一个生产者，多个消费者。</span><br><span class="hljs-comment"> * 2.每一个消费者都有自己的队列。</span><br><span class="hljs-comment"> * 3.生产者没有直接把消息发送到队列，而是发送到了交换机、转发器exchange</span><br><span class="hljs-comment"> * 4.每个队列都要绑定到交换机上</span><br><span class="hljs-comment"> * 5.生产者发送的消息经过交换机到达队列，就能实现一个消息被多个消费者消费。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 邮件-&gt;注册-&gt;短信</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_fanout&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>        <span class="hljs-comment">// 声明exchange 交换机 转发器</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>); <span class="hljs-comment">//订阅模式</span><br><br>        <span class="hljs-comment">// 消息内容</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello PB&quot;</span>;<br>        channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>, msg.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;Send: &quot;</span> +msg);<br><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者1-Recv1-2"><a href="#消费者1-Recv1-2" class="headerlink" title="消费者1(Recv1)"></a>消费者1(Recv1)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.subscribeModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_fanout_email&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_fanout&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">/** 绑定队列到交换机 **/</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//------------下面逻辑和work模式一样-----</span><br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 定义一个消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[1] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[1] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者2-Recv2-2"><a href="#消费者2-Recv2-2" class="headerlink" title="消费者2(Recv2)"></a>消费者2(Recv2)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.subscribeModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_fanout_sms&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_fanout&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">/** 绑定队列到交换机 **/</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        <span class="hljs-comment">// 定义一个消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[2] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[2] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><blockquote><ol><li>发送消息到交换机并且要指定路由key 。</li><li>消费者将队列绑定到交换机时需要指定路由key。</li></ol></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909967.png"></p><h4 id="生产者-Send-4"><a href="#生产者-Send-4" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.routingModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * 先运行Send创建交换器</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_direct&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明exchange</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">// 消息内容</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello direct!&quot;</span>;<br>        <span class="hljs-comment">//routingKey</span><br>        <span class="hljs-comment">//String routingKey = &quot;error&quot;;//error两个都可以收到</span><br>        <span class="hljs-comment">//String routingKey = &quot;info&quot;;//info只有Recv2能收到</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">routingKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;warning&quot;</span>;<span class="hljs-comment">//warning只有Recv2能收到</span><br>        channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="hljs-literal">null</span>, msg.getBytes());<br><br>        System.out.println(<span class="hljs-string">&quot;-------------send: &quot;</span> +msg);<br><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者1-Recv1-3"><a href="#消费者1-Recv1-3" class="headerlink" title="消费者1(Recv1)"></a>消费者1(Recv1)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.routingModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_direct_1&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_direct&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">/** 绑定队列到交换机 **/</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;error&quot;</span>);<br><br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//定义消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[1] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[1] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者2-Recv2-3"><a href="#消费者2-Recv2-3" class="headerlink" title="消费者2(Recv2)"></a>消费者2(Recv2)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.routingModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_direct_2&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_direct&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">/** 绑定队列到交换机 **/</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;error&quot;</span>);<br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;info&quot;</span>);<br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;warning&quot;</span>);<br><br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//定义消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[2] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[2] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h3><blockquote><p>  Topic主题模式：将路由键和某模式进行匹配，此时队列需要绑定在一个模式上，“#”匹配一个词或多个词，“*”只匹配一个词。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909968.png"></p><h4 id="生产者-Send-5"><a href="#生产者-Send-5" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.topicModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * Topic主题模式：将路由键和某种模式匹配。</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_topic&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明exchange</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;topic&quot;</span>);<br>        <span class="hljs-comment">// 消息内容</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;id=1001&quot;</span>;<br>        channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;item.delete&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者1-Recv1-4"><a href="#消费者1-Recv1-4" class="headerlink" title="消费者1(Recv1)"></a>消费者1(Recv1)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.topicModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_topic_1&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_topic&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 绑定队列到交换机</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;item.update&quot;</span>);<br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;item.delete&quot;</span>);<br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 定义队列的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[2] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[2] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者2-Recv2-4"><a href="#消费者2-Recv2-4" class="headerlink" title="消费者2(Recv2)"></a>消费者2(Recv2)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.topicModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_topic_2&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_topic&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">/** 绑定队列到交换机 **/</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;item.#&quot;</span>);<span class="hljs-comment">//全匹配：item.#</span><br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 定义队列的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[2] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[2] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="RPC远程调用模式"><a href="#RPC远程调用模式" class="headerlink" title="RPC远程调用模式"></a>RPC远程调用模式</h3><blockquote><p>  前面学习了如何使用work队列在多个worker之间分配任务，但是如果需要在远程机器上运行个函数并等待结果，就需要使用RPC（远程过程调用）模式来实现。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909969.png"></p><p>参考官网教程【模拟RPC服务来返回斐波那契数列】：<a href="https://www.rabbitmq.com/tutorials/tutorial-six-java.html">https://www.rabbitmq.com/tutorials/tutorial-six-java.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>MessageQueue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM下05-分析GC日志</title>
    <link href="/2025/02/27/JVM%E4%B8%8B05-%E5%88%86%E6%9E%90GC%E6%97%A5%E5%BF%97/"/>
    <url>/2025/02/27/JVM%E4%B8%8B05-%E5%88%86%E6%9E%90GC%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="5-分析-GC-日志"><a href="#5-分析-GC-日志" class="headerlink" title="5. 分析 GC 日志"></a>5. 分析 GC 日志</h1><h2 id="5-1-GC-分类"><a href="#5-1-GC-分类" class="headerlink" title="5.1. GC 分类"></a>5.1. GC 分类</h2><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li><p>部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（Minor GC &#x2F; Young GC）：只是新生代（Eden &#x2F; S0, S1）的垃圾收集</li><li>老年代收集（Major GC &#x2F; Old GC）：只是老年代的垃圾收集。目前，只有 CMS GC 会有单独收集老年代的行为。<mark>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</mark></li></ul></li><li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有 G1 GC 会有这种行为</p></li><li><p>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</p></li></ul><h2 id="5-2-GC-日志分类"><a href="#5-2-GC-日志分类" class="headerlink" title="5.2. GC 日志分类"></a>5.2. GC 日志分类</h2><p><strong>MinorGC</strong></p><p>MinorGC（或 young GC 或 YGC）日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), <span class="hljs-number">0.0139308</span> secs] [Times: user=<span class="hljs-number">0.05</span> sys=<span class="hljs-number">0.01</span>, real=<span class="hljs-number">0.01</span> secs]<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271121044.png" alt="image-20210506202126562"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271121045.png" alt="image-20210506202156090"></p><p><strong>FullGC</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(Metadata GC Threshold)</span> [PSYoungGen: 5104K-&gt;0K (132096K) ] [Par01dGen: 416K-&gt;5453K (50176K) ]5520K-&gt;5453K (182272K), [Metaspace: 20637K-&gt;20637K (1067008K) ], <span class="hljs-number">0.0245883</span> secs] [Times: user=<span class="hljs-number">0.06</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.02</span> secs]<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271121046.png" alt="image-20210506202330868"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271121047.png" alt="image-20210506202349072"></p><h2 id="5-3-GC-日志结构剖析"><a href="#5-3-GC-日志结构剖析" class="headerlink" title="5.3. GC 日志结构剖析"></a>5.3. GC 日志结构剖析</h2><p><strong>透过日志看垃圾收集器</strong></p><ul><li><p>Serial 收集器：新生代显示 “[DefNew”，即 Default New Generation</p></li><li><p>ParNew 收集器：新生代显示 “[ParNew”，即 Parallel New Generation</p></li><li><p>Parallel Scavenge 收集器：新生代显示”[PSYoungGen”，JDK1.7 使用的即 PSYoungGen</p></li><li><p>Parallel Old 收集器：老年代显示”[ParoldGen”</p></li><li><p>G1 收集器：显示”garbage-first heap“</p></li></ul><p><strong>透过日志看 GC 原因</strong></p><ul><li>Allocation Failure：表明本次引起 GC 的原因是因为新生代中没有足够的区域存放需要分配的数据</li><li>Metadata GCThreshold：Metaspace 区不够用了</li><li>FErgonomics：JVM 自适应调整导致的 GC</li><li>System：调用了 System.gc()方法</li></ul><p><strong>透过日志看 GC 前后情况</strong></p><p>通过图示，我们可以发现 GC 日志格式的规律一般都是：GC 前内存占用-＞ GC 后内存占用（该区域内存总大小）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[PSYoungGen: 5986K-&gt;696K (8704K) ] 5986K-&gt;704K (9216K)<br></code></pre></td></tr></table></figure><ul><li><p>中括号内：GC 回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</p></li><li><p>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p></li></ul><p><mark>注意</mark>：Minor GC 堆内存总容量 &#x3D; 9&#x2F;10 年轻代 + 老年代。原因是 Survivor 区只计算 from 部分，而 JVM 默认年轻代中 Eden 区和 Survivor 区的比例关系，Eden:S0:S1&#x3D;8:1:1。</p><p><strong>透过日志看 GC 时间</strong></p><p>GC 日志中有三个时间：user，sys 和 real</p><ul><li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际 CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间。</li><li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的 CPU 时间</li><li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I&#x2F;O 完成）。对于并行 gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核的原因，一般的 GC 事件中，real time 是小于 sys time ＋ user time 的，因为一般是多个线程并发的去做 GC，所以 real time 是要小于 sys ＋ user time 的。如果 real ＞ sys ＋ user 的话，则你的应用可能存在下列问题：IO 负载非常重或 CPU 不够用。</p><h2 id="5-4-GC-日志分析工具"><a href="#5-4-GC-日志分析工具" class="headerlink" title="5.4. GC 日志分析工具"></a>5.4. GC 日志分析工具</h2><p><strong>GCEasy</strong></p><p>GCEasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄露检测、GC 暂停原因分析、JVM 配置建议优化等功能，大多数功能是免费的。</p><p>官网地址：<a href="https://gceasy.io/">https://gceasy.io/</a></p><p><strong>GCViewer</strong></p><p>GCViewer 是一款离线的 GC 日志分析器，用于可视化 Java VM 选项 -verbose:gc 和 .NET 生成的数据 -Xloggc:&lt;file&gt;。还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p><p>源码下载：<a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></p><p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p><p><strong>GChisto</strong></p><ul><li>官网上没有下载的地方，需要自己从 SVN 上拉下来编译</li><li>不过这个工具似乎没怎么维护了，存在不少 bug</li></ul><p><strong>HPjmeter</strong></p><ul><li>工具很强大，但是只能打开由以下参数生成的 GC log，-verbose:gc -Xloggc:gc.log。添加其他参数生成的 gc.log 无法打开</li><li>HPjmeter 集成了以前的 HPjtune 功能，可以分析在 HP 机器上产生的垃圾回收日志文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM下04-JVM运行时参数</title>
    <link href="/2025/02/27/JVM%E4%B8%8B04-JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0/"/>
    <url>/2025/02/27/JVM%E4%B8%8B04-JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="4-JVM-运行时参数"><a href="#4-JVM-运行时参数" class="headerlink" title="4. JVM 运行时参数"></a>4. JVM 运行时参数</h1><h2 id="4-1-JVM-参数选项"><a href="#4-1-JVM-参数选项" class="headerlink" title="4.1. JVM 参数选项"></a>4.1. JVM 参数选项</h2><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p><h3 id="4-1-1-类型一：标准参数选项"><a href="#4-1-1-类型一：标准参数选项" class="headerlink" title="4.1.1. 类型一：标准参数选项"></a>4.1.1. 类型一：标准参数选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">java -<span class="hljs-built_in">help</span></span><br>用法: java [-options] class [args...]<br>           (执行类)<br>   或  java [-options] -jar jarfile [args...]<br>           (执行 jar 文件)<br>其中选项包括:<br>    -d32          使用 32 位数据模型 (如果可用)<br>    -d64          使用 64 位数据模型 (如果可用)<br>    -server       选择 &quot;server&quot; VM<br>                  默认 VM 是 server.<br><br>    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;<br>    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;<br>                  用 ; 分隔的目录, JAR 档案<br>                  和 ZIP 档案列表, 用于搜索类文件。<br>    -D&lt;名称&gt;=&lt;值&gt;<br>                  设置系统属性<br>    -verbose:[class|gc|jni]<br>                  启用详细输出<br>    -version      输出产品版本并退出<br>    -version:&lt;值&gt;<br>                  警告: 此功能已过时, 将在<br>                  未来发行版中删除。<br>                  需要指定的版本才能运行<br>    -showversion  输出产品版本并继续<br>    -jre-restrict-search | -no-jre-restrict-search<br>                  警告: 此功能已过时, 将在<br>                  未来发行版中删除。<br>                  在版本搜索中包括/排除用户专用 JRE<br>    -? -help      输出此帮助消息<br>    -X            输出非标准选项的帮助<br>    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]<br>    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]<br>                  按指定的粒度启用断言<br>    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]<br>    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]<br>                  禁用具有指定粒度的断言<br>    -esa | -enablesystemassertions<br>                  启用系统断言<br>    -dsa | -disablesystemassertions<br>                  禁用系统断言<br>    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]<br>                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof<br>                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help<br>    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]<br>                  按完整路径名加载本机代理库<br>    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]<br>                  加载 Java 编程语言代理, 请参阅 java.lang.instrument<br>    -splash:&lt;imagepath&gt;<br>                  使用指定的图像显示启动屏幕<br>有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。<br></code></pre></td></tr></table></figure><p><strong>Server 模式和 Client 模式</strong></p><p>Hotspot JVM 有两种模式，分别是 server 和 client，分别通过-server 和-client 模式设置</p><ul><li>32 位系统上，默认使用 Client 类型的 JVM。要想使用 Server 模式，机器配置至少有 2 个以上的 CPU 和 2G 以上的物理内存。client 模式适用于对内存要求较小的桌面应用程序，默认使用 Serial 串行垃圾收集器</li><li>64 位系统上，只支持 server 模式的 JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</li></ul><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html</a></p><p>如何知道系统默认使用的是那种模式呢？</p><p>通过 java -version 命令：可以看到 Server VM 字样，代表当前系统使用是 Server 模式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">java -version</span><br>java version &quot;1.8.0_201&quot;<br>Java(TM) SE Runtime Environment (build 1.8.0_201-b09)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)<br></code></pre></td></tr></table></figure><h3 id="4-1-2-类型二：-X-参数选项"><a href="#4-1-2-类型二：-X-参数选项" class="headerlink" title="4.1.2. 类型二：-X 参数选项"></a>4.1.2. 类型二：-X 参数选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">java -X</span><br>    -Xmixed           混合模式执行 (默认)<br>    -Xint             仅解释模式执行<br>    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;<br>                      设置搜索路径以引导类和资源<br>    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;<br>                      附加在引导类路径末尾<br>    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;<br>                      置于引导类路径之前<br>    -Xdiag            显示附加诊断消息<br>    -Xnoclassgc       禁用类垃圾收集<br>    -Xincgc           启用增量垃圾收集<br>    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)<br>    -Xbatch           禁用后台编译<br>    -Xms&lt;size&gt;        设置初始 Java 堆大小<br>    -Xmx&lt;size&gt;        设置最大 Java 堆大小<br>    -Xss&lt;size&gt;        设置 Java 线程堆栈大小<br>    -Xprof            输出 cpu 配置文件数据<br>    -Xfuture          启用最严格的检查, 预期将来的默认值<br>    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)<br>    -Xcheck:jni       对 JNI 函数执行其他检查<br>    -Xshare:off       不尝试使用共享类数据<br>    -Xshare:auto      在可能的情况下使用共享类数据 (默认)<br>    -Xshare:on        要求使用共享类数据, 否则将失败。<br>    -XshowSettings    显示所有设置并继续<br>    -XshowSettings:all<br>                      显示所有设置并继续<br>    -XshowSettings:vm 显示所有与 vm 相关的设置并继续<br>    -XshowSettings:properties<br>                      显示所有属性设置并继续<br>    -XshowSettings:locale<br>                      显示所有与区域设置相关的设置并继续<br><br>-X 选项是非标准选项, 如有更改, 恕不另行通知。<br></code></pre></td></tr></table></figure><p>如何知道 JVM 默认使用的是混合模式呢？</p><p>同样地，通过 java -version 命令：可以看到 mixed mode 字样，代表当前系统使用的是混合模式</p><h3 id="4-1-3-类型三：-XX-参数选项"><a href="#4-1-3-类型三：-XX-参数选项" class="headerlink" title="4.1.3. 类型三：-XX 参数选项"></a>4.1.3. 类型三：-XX 参数选项</h3><p><strong>Boolean 类型格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+&lt;option&gt;  启用option属性<br>-XX:-&lt;option&gt;  禁用option属性<br></code></pre></td></tr></table></figure><p><strong>非 Boolean 类型格式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G<br>-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值<br></code></pre></td></tr></table></figure><h2 id="4-2-添加-JVM-参数选项"><a href="#4-2-添加-JVM-参数选项" class="headerlink" title="4.2. 添加 JVM 参数选项"></a>4.2. 添加 JVM 参数选项</h2><p>eclipse 和 idea 中配置不必多说，在 Run Configurations 中 VM Options 中配置即可，大同小异</p><p><strong>运行 jar 包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -Xms100m -Xmx100m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -jar demo.jar<br></code></pre></td></tr></table></figure><p><strong>Tomcat 运行 war 包</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">linux下catalina.sh添加</span><br>JAVA_OPTS=&quot;-Xms512M -Xmx1024M&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">windows下catalina.bat添加</span><br>set &quot;JAVA_OPTS=-Xms512M -Xmx1024M&quot;<br></code></pre></td></tr></table></figure><p><strong>程序运行中</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">设置Boolean类型参数</span><br>jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置非Boolean类型参数</span><br>jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;<br></code></pre></td></tr></table></figure><h2 id="4-3-常用的-JVM-参数选项"><a href="#4-3-常用的-JVM-参数选项" class="headerlink" title="4.3. 常用的 JVM 参数选项"></a>4.3. 常用的 JVM 参数选项</h2><h3 id="4-3-1-打印设置的-XX-选项及值"><a href="#4-3-1-打印设置的-XX-选项及值" class="headerlink" title="4.3.1. 打印设置的 XX 选项及值"></a>4.3.1. 打印设置的 XX 选项及值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项<br>-XX:+PrintFlagsInitial 打印所有XX选项的默认值<br>-XX:+PrintFlagsFinal 打印所有XX选项的实际值<br>-XX:+PrintVMOptions 打印JVM的参数<br></code></pre></td></tr></table></figure><h3 id="4-3-2-堆、栈、方法区等内存大小设置"><a href="#4-3-2-堆、栈、方法区等内存大小设置" class="headerlink" title="4.3.2. 堆、栈、方法区等内存大小设置"></a>4.3.2. 堆、栈、方法区等内存大小设置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">栈</span><br>-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">堆</span><br>-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M<br>-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M<br>-Xmn2g &lt;==&gt; -XX:NewSize=2g -XX:MaxNewSize=2g 设置年轻代大小为2G<br>-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8<br>-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2<br>-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启<br>-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效<br>-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15<br>-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">方法区</span><br>-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M<br>-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M<br>-XX:+UseCompressedOops 使用压缩对象<br>-XX:+UseCompressedClassPointers 使用压缩类指针<br>-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接内存</span><br>-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值<br></code></pre></td></tr></table></figure><h3 id="4-3-3-OutOfMemory-相关的选项"><a href="#4-3-3-OutOfMemory-相关的选项" class="headerlink" title="4.3.3. OutOfMemory 相关的选项"></a>4.3.3. OutOfMemory 相关的选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥<br>-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥<br>-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录<br>-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本<br></code></pre></td></tr></table></figure><h3 id="4-3-4-垃圾收集器相关选项"><a href="#4-3-4-垃圾收集器相关选项" class="headerlink" title="4.3.4. 垃圾收集器相关选项"></a>4.3.4. 垃圾收集器相关选项</h3><p>首先需了解垃圾收集器之间的搭配使用关系</p><ul><li>红色虚线表示在 jdk8 时被 Deprecate，jdk9 时被删除</li><li>绿色虚线表示在 jdk14 时被 Deprecate</li><li>绿色虚框表示在 jdk9 时被 Deprecate，jdk14 时被删除</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120897.png" alt="image-20210506182458663"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Serial回收器</span><br>-XX:+UseSerialGC  年轻代使用Serial GC， 老年代使用Serial Old GC<br><span class="hljs-meta prompt_"># </span><span class="language-bash">ParNew回收器</span><br>-XX:+UseParNewGC  年轻代使用ParNew GC<br>-XX:ParallelGCThreads  设置年轻代并行收集器的线程数。<br>一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。<br></code></pre></td></tr></table></figure><p>$$<br>ParallelGCThreads &#x3D;<br>\begin{cases}<br>CPU_Count &amp; \text (CPU_Count &lt;&#x3D; 8) \<br>3 + (5 * CPU＿Count &#x2F; 8) &amp; \text (CPU_Count &gt; 8)<br>\end{cases}<br>$$</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Parallel回收器</span><br>-XX:+UseParallelGC  年轻代使用 Parallel Scavenge GC，互相激活<br>-XX:+UseParallelOldGC  老年代使用 Parallel Old GC，互相激活<br>-XX:ParallelGCThreads<br>-XX:MaxGCPauseMillis  设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。<br>为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。<br>对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量。<br>所以服务器端适合Parallel，进行控制。该参数使用需谨慎。<br>-XX:GCTimeRatio  垃圾收集时间占总时间的比例（1 / (N＋1)），用于衡量吞吐量的大小<br>取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。<br>与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。<br>-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略。<br>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。<br>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">CMS回收器</span><br>-XX:+UseConcMarkSweepGC  年轻代使用CMS GC。<br>开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合<br>-XX:CMSInitiatingOccupanyFraction  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。<br>如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。<br>反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。<br>因此通过该选项便可以有效降低Fu1l GC的执行次数。<br>-XX:+UseCMSInitiatingOccupancyOnly  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动<br>-XX:+UseCMSCompactAtFullCollection  用于指定在执行完Full GC后对内存空间进行压缩整理<br>以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。<br>-XX:CMSFullGCsBeforeCompaction  设置在执行多少次Full GC后对内存空间进行压缩整理。<br>-XX:ParallelCMSThreads  设置CMS的线程数量。<br>CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。<br>当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。<br>-XX:ConcGCThreads  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的<br>-XX:+CMSScavengeBeforeRemark  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度<br>-XX:+CMSClassUnloadingEnable  如果有的话，启用回收Perm 区（JDK8之前）<br>-XX:+CMSParallelInitialEnabled  用于开启CMS initial-mark阶段采用多线程的方式进行标记<br>用于提高标记速度，在Java8开始已经默认开启<br>-XX:+CMSParallelRemarkEnabled  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启<br>-XX:+ExplicitGCInvokesConcurrent<br>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses<br>这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期<br>-XX:+CMSPrecleaningEnabled  指定CMS是否需要进行Pre cleaning阶段<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">G1回收器</span><br>-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。<br>-XX:G1HeapRegionSize 设置每个Region的大小。<br>值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。<br>-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms<br>-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8<br>-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。<br>-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。<br>-XX:G1NewSizePercent  新生代占用整个堆内存的最小百分比（默认5％）<br>-XX:G1MaxNewSizePercent  新生代占用整个堆内存的最大百分比（默认60％）<br>-XX:G1ReservePercent=10  保留内存区域，防止 to space（Survivor中的to区）溢出<br></code></pre></td></tr></table></figure><p>怎么选择垃圾回收器？</p><ul><li>优先让 JVM 自适应，调整堆的大小</li><li>串行收集器：内存小于 100M；单核、单机程序，并且没有停顿时间的要求</li><li>并行收集器：多 CPU、高吞吐量、允许停顿时间超过 1 秒</li><li>并发收集器：多 CPU、追求低停顿时间、快速响应（比如延迟不能超过 1 秒，如互联网应用）</li><li>官方推荐 G1，性能高。现在互联网的项目，基本都是使用 G1</li></ul><p>特别说明：</p><ul><li>没有最好的收集器，更没有万能的收集器</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ul><h3 id="4-3-5-GC-日志相关选项"><a href="#4-3-5-GC-日志相关选项" class="headerlink" title="4.3.5. GC 日志相关选项"></a>4.3.5. GC 日志相关选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息<br>-XX:+PrintGCDetails            打印详细日志信息<br>-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用<br>-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用<br>-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图<br>-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120898.png" alt="image-20210506195156935"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+TraceClassLoading  监控类的加载<br>-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间<br>-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间<br>-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用<br>-XX:+PrintTenuringDistribution  打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布<br>-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储<br>-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目<br>-XX:GCLogFileSize=1M  设置GC日志文件的大小<br></code></pre></td></tr></table></figure><h3 id="4-3-6-其他参数"><a href="#4-3-6-其他参数" class="headerlink" title="4.3.6. 其他参数"></a>4.3.6. 其他参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用<br>-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]  指定代码缓存的大小<br>-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况<br>-XX:+DoEscapeAnalysis  开启逃逸分析<br>-XX:+UseBiasedLocking  开启偏向锁<br>-XX:+UseLargePages  开启使用大页面<br>-XX:+PrintTLAB  打印TLAB的使用情况<br>-XX:TLABSize  设置TLAB大小<br></code></pre></td></tr></table></figure><h2 id="4-4-通过-Java-代码获取-JVM-参数"><a href="#4-4-通过-Java-代码获取-JVM-参数" class="headerlink" title="4.4. 通过 Java 代码获取 JVM 参数"></a>4.4. 通过 Java 代码获取 JVM 参数</h2><p>Java 提供了 java.lang.management 包用于监视和管理 Java 虚拟机和 Java 运行时中的其他组件，它允许本地或远程监控和管理运行的 Java 虚拟机。其中 ManagementFactory 类较为常用，另外 Runtime 类可获取内存、CPU 核数等相关的数据。通过使用这些 api，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MemoryMonitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MemoryMXBean</span> <span class="hljs-variable">memorymbean</span> <span class="hljs-operator">=</span> ManagementFactory.getMemoryMXBean();<br>        <span class="hljs-type">MemoryUsage</span> <span class="hljs-variable">usage</span> <span class="hljs-operator">=</span> memorymbean.getHeapMemoryUsage();<br>        System.out.println(<span class="hljs-string">&quot;INIT HEAP: &quot;</span> + usage.getInit() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;MAX HEAP: &quot;</span> + usage.getMax() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;USE HEAP: &quot;</span> + usage.getUsed() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;\nFull Information:&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Heap Memory Usage: &quot;</span> + memorymbean.getHeapMemoryUsage());<br>        System.out.println(<span class="hljs-string">&quot;Non-Heap Memory Usage: &quot;</span> + memorymbean.getNonHeapMemoryUsage());<br><br>        System.out.println(<span class="hljs-string">&quot;=======================通过java来获取相关系统状态============================ &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;当前堆内存大小totalMemory &quot;</span> + (<span class="hljs-type">int</span>) Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 当前堆内存大小</span><br>        System.out.println(<span class="hljs-string">&quot;空闲堆内存大小freeMemory &quot;</span> + (<span class="hljs-type">int</span>) Runtime.getRuntime().freeMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 空闲堆内存大小</span><br>        System.out.println(<span class="hljs-string">&quot;最大可用总堆内存maxMemory &quot;</span> + Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;m&quot;</span>);<span class="hljs-comment">// 最大可用总堆内存大小</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM下03-JVM监控及诊断工具（GUI篇）</title>
    <link href="/2025/02/27/JVM%E4%B8%8B03-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88GUI%E7%AF%87%EF%BC%89/"/>
    <url>/2025/02/27/JVM%E4%B8%8B03-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88GUI%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="3-JVM-监控及诊断工具-GUI-篇"><a href="#3-JVM-监控及诊断工具-GUI-篇" class="headerlink" title="3. JVM 监控及诊断工具-GUI 篇"></a>3. JVM 监控及诊断工具-GUI 篇</h1><h2 id="3-1-工具概述"><a href="#3-1-工具概述" class="headerlink" title="3.1. 工具概述"></a>3.1. 工具概述</h2><p>使用上一章命令行工具或组合能帮您获取目标 Java 应用性能相关的基础信息，但它们存在下列局限：</p><ul><li>1．无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</li><li>2．要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</li><li>3．分析数据通过终端输出，结果展示不够直观。</li></ul><p>为此，JDK 提供了一些内存泄漏的分析工具，如 jconsole，jvisualvm 等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p><p><strong>JDK 自带的工具</strong></p><ul><li><p>jconsole：JDK 自带的可视化监控工具。查看 Java 应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等</p></li><li><p>Visual VM：Visual VM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机上运行的基于 Java 技术的应用程序的详细信息。</p></li><li><p>JMC：Java Mission Control，内置 Java Flight Recorder。能够以极低的性能开销收集 Java 虚拟机的性能数据。</p></li></ul><p><strong>第三方工具</strong></p><ul><li><p>MAT：MAT（Memory Analyzer Tool）是基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</p></li><li><p>JProfiler：商业软件，需要付费。功能强大。</p></li></ul><h2 id="3-2-JConsole"><a href="#3-2-JConsole" class="headerlink" title="3.2. JConsole"></a>3.2. JConsole</h2><p>jconsole：从 Java5 开始，在 JDK 中自带的 java 监控和管理控制台。用于对 JVM 中内存、线程和类等的监控，是一个基于 JMX（java management extensions）的 GUI 性能监控工具。</p><p>官方地址：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html</a></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120760.png" alt="image-20210505141631635"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120761.png" alt="image-20210505141726143"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120762.png" alt="image-20210505141924211"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120763.png" alt="image-20210505141950000"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120764.png" alt="image-20210505142050157"></p><h2 id="3-3-Visual-VM"><a href="#3-3-Visual-VM" class="headerlink" title="3.3. Visual VM"></a>3.3. Visual VM</h2><p>Visual VM 是一个功能强大的多合一故障诊断和性能监控的可视化工具。它集成了多个 JDK 命令行工具，使用 Visual VM 可用于显示虚拟机进程及进程的配置和环境信息（jps，jinfo），监视应用程序的 CPU、GC、堆、方法区及线程的信息（jstat、jstack）等，甚至代替 JConsole。在 JDK 6 Update 7 以后，Visual VM 便作为 JDK 的一部分发布（VisualVM 在 JDK／bin 目录下）即：它完全免费。</p><p><strong>主要功能：</strong></p><ul><li>1.生成&#x2F;读取堆内存&#x2F;线程快照</li><li>2.查看 JVM 参数和系统属性</li><li>3.查看运行中的虚拟机进程</li><li>4.程序资源的实时监控</li><li>5.JMX 代理连接、远程环境监控、CPU 分析和内存分析</li></ul><p>官方地址：<a href="https://visualvm.github.io/index.html">https://visualvm.github.io/index.html</a></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120765.png" alt="image-20210505143844282"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120766.png" alt="image-20210505144716064"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120767.png" alt="image-20210505144805307"></p><h2 id="3-4-Eclipse-MAT"><a href="#3-4-Eclipse-MAT" class="headerlink" title="3.4. Eclipse MAT"></a>3.4. Eclipse MAT</h2><p>MAT（Memory Analyzer Tool）工具是一款功能强大的 Java 堆内存分析器。可以用于查找内存泄漏以及查看内存消耗情况。MAT 是基于 Eclipse 开发的，不仅可以单独使用，还可以作为插件的形式嵌入在 Eclipse 中使用。是一款免费的性能分析工具，使用起来非常方便。</p><p>MAT 可以分析 heap dump 文件。在进行内存分析时，只要获得了反映当前设备内存映像的 hprof 文件，通过 MAT 打开就可以直观地看到当前的内存信息。一般说来，这些内存信息包含：</p><ul><li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li><li>所有的类信息，包括 classloader、类名称、父类、静态变量等</li><li>GCRoot 到所有的这些对象的引用路径</li><li>线程信息，包括线程的调用栈及此线程的线程局部变量（TLS）</li></ul><p>MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如 Sun，HP，SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM 的 PHD 堆存储文件等都能被很好的解析。</p><p>最吸引人的还是能够快速为开发人员生成内存泄漏报表，方便定位问题和分析问题。虽然 MAT 有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从 MAT 展现给我们的信息当中通过经验和直觉来判断才能发现。</p><p>官方地址： <a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120768.png" alt="image-20210505145708567"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120769.png" alt="image-20210505145826442"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120770.png" alt="image-20210505145945951"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120771.png" alt="image-20210505150039376"></p><h2 id="3-5-JProfiler"><a href="#3-5-JProfiler" class="headerlink" title="3.5. JProfiler"></a>3.5. JProfiler</h2><p>在运行 Java 的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在 eclipse 里面有 Eclipse Memory Analyzer tool（MAT）插件可以测试，而在 IDEA 中也有这么一个插件，就是 JProfiler。JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p><p><strong>特点：</strong></p><ul><li>使用方便、界面操作友好（简单且强大）</li><li>对被分析的应用影响小（提供模板）</li><li>CPU，Thread，Memory 分析功能尤其强大</li><li>支持对 jdbc，noSql，jsp，servlet，socket 等进行分析</li><li>支持多种模式（离线，在线）的分析</li><li>支持监控本地、远程的 JVM</li><li>跨平台，拥有多种操作系统的安装版本</li></ul><p><strong>主要功能：</strong></p><ul><li>1-方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li><li>2-内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li><li>3-线程和锁：JProfiler 提供多种针对线程和锁的分析视图助您发现多线程问题</li><li>4-高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于 JDBC 调用，您可能希望找出执行最慢的 SQL 语句。JProfiler 支持对这些子系统进行集成分析</li></ul><p>官网地址：<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p><p><strong>数据采集方式：</strong></p><p>JProfier 数据采集方式分为两种：Sampling（样本采集）和 Instrumentation（重构模式）</p><p><strong>Instrumentation</strong>：这是 JProfiler 全功能模式。在 class 加载之前，JProfier 把相关功能代码写入到需要分析的 class 的 bytecode 中，对正在运行的 jvm 有一定影响。</p><ul><li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li><li>缺点：若要分析的 class 较多，则对应用的性能影响较大，CPU 开销可能很高（取决于 Filter 的控制）。因此使用此模式一般配合 Filter 使用，只对特定的类或包进行分析</li></ul><p><strong>Sampling</strong>：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。</p><ul><li>优点：对 CPU 的开销非常低，对应用影响小（即使你不配置任何 Filter）</li><li>缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）</li></ul><p>注：JProfiler 本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为 JProfiler 的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是 JProfiler 的数据采集类型。</p><p><strong>遥感监测 Telemetries</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120772.png" alt="image-20210505164521410"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120773.png" alt="image-20210505164907312"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120774.png" alt="image-20210505164815324"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120775.png" alt="image-20210505164945192"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120776.png" alt="image-20210505165010529"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120777.png" alt="image-20210505165128212"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120778.png" alt="image-20210505165249919"></p><p><strong>内存视图 Live Memory</strong></p><p>Live memory 内存剖析：class／class instance 的相关信息。例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点。</p><ul><li><strong>所有对象 All Objects</strong>：显示所有加载的类的列表和在堆上分配的实例数。只有 Java 1.5（JVMTI）才会显示此视图。</li><li><strong>记录对象 Record Objects</strong>：查看特定时间段对象的分配，并记录分配的调用堆栈。</li><li><strong>分配访问树 Allocation Call Tree</strong>：显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的 J2EE 组件。</li><li><strong>分配热点 Allocation Hot Spots</strong>：显示一个列表，包括方法、类、包或分配已选类的 J2EE 组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。</li><li><strong>类追踪器 Class Tracker</strong>：类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120779.png" alt="image-20210505164554298"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120780.png" alt="image-20210505165519790"></p><p><strong>堆遍历 heap walker</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120781.png" alt="image-20210505165710620"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120782.png" alt="image-20210505165823201"></p><p><strong>cpu 视图 cpu views</strong></p><p>JProfiler 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或 J2EE 组件等不同层上。</p><ul><li><strong>访问树 Call Tree</strong>：显示一个积累的自顶向下的树，树中包含所有在 JVM 中已记录的访问队列。JDBC，JMS 和 JNDI 服务请求都被注释在请求树中。请求树可以根据 Servlet 和 JSP 对 URL 的不同需要进行拆分。</li><li><strong>热点 Hot Spots</strong>：显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC，JMS 和 JNDI 服务请求以及按照 URL 请求来进行计算。</li><li><strong>访问图 Call Graph</strong>：显示一个从已选方法、类、包或 J2EE 组件开始的访问队列的图。</li><li><strong>方法统计 Method Statistis</strong>：显示一段时间内记录的方法的调用时间细节。</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120783.png" alt="image-20210505170055722"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120784.png" alt="image-20210505170141278"></p><p><strong>线程视图 threads</strong></p><p>JProfiler 通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p><ul><li><strong>线程历史 Thread History</strong>：显示一个与线程活动和线程状态在一起的活动时间表。</li><li><strong>线程监控 Thread Monitor</strong>：显示一个列表，包括所有的活动线程以及它们目前的活动状况。</li><li><strong>线程转储 Thread Dumps</strong>：显示所有线程的堆栈跟踪。</li></ul><p>线程分析主要关心三个方面：</p><ul><li>1．web 容器的线程最大数。比如：Tomcat 的线程容量应该略大于最大并发数。</li><li>2．线程阻塞</li><li>3．线程死锁</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120785.png" alt="image-20210505170739972"></p><p><strong>监控和锁 Monitors ＆Locks</strong></p><p>所有线程持有锁的情况以及锁的信息。观察 JVM 的内部线程并查看状态：</p><ul><li><strong>死锁探测图表 Current Locking Graph</strong>：显示 JVM 中的当前死锁图表。</li><li><strong>目前使用的监测器 Current Monitors</strong>：显示目前使用的监测器并且包括它们的关联线程。</li><li><strong>锁定历史图表 Locking History Graph</strong>：显示记录在 JVM 中的锁定历史。</li><li><strong>历史检测记录 Monitor History</strong>：显示重大的等待事件和阻塞事件的历史记录。</li><li><strong>监控器使用统计 Monitor Usage Statistics</strong>：显示分组监测，线程和监测类的统计监测数据</li></ul><h2 id="3-6-Arthas"><a href="#3-6-Arthas" class="headerlink" title="3.6. Arthas"></a>3.6. Arthas</h2><p>上述工具都必须在服务端项目进程中配置相关的监控参数，然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境。并且类似于 Jprofiler 这样的商业工具，是需要付费的。</p><p>那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控数据呢？</p><p>阿里巴巴开源的性能分析神器 Arthas 应运而生。</p><p>Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪 Java 代码；实时监控 JVM 状态。Arthas 支持 JDK 6 ＋，支持 Linux／Mac／Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到 JVM 的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>官方地址：<a href="https://arthas.aliyun.com/doc/quick-start.html">https://arthas.aliyun.com/doc/quick-start.html</a></p><p>安装方式：如果速度较慢，可以尝试国内的码云 Gitee 下载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://io/arthas/arthas-boot.jar<br>wget https://arthas/gitee/io/arthas-boot.jar<br></code></pre></td></tr></table></figure><p>Arthas 只是一个 java 程序，所以可以直接用 java -jar 运行。</p><p>除了在命令行查看外，Arthas 目前还支持 Web Console。在成功启动连接进程之后就已经自动启动,可以直接访问 <a href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p><p><strong>基础指令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">quit/exit 退出当前 Arthas客户端，其他 Arthas喜户端不受影响<br>stop/shutdown 关闭 Arthas服务端，所有 Arthas客户端全部退出<br>help 查看命令帮助信息<br>cat 打印文件内容，和linux里的cat命令类似<br>echo 打印参数，和linux里的echo命令类似<br>grep 匹配查找，和linux里的gep命令类似<br>tee 复制标隹输入到标准输出和指定的文件，和linux里的tee命令类似<br>pwd 返回当前的工作目录，和linux命令类似<br>cls 清空当前屏幕区域<br>session 查看当前会话的信息<br>reset 重置增强类，将被 Arthas增强过的类全部还原, Arthas服务端关闭时会重置所有增强过的类<br>version 输出当前目标Java进程所加载的 Arthas版本号<br>history 打印命令历史<br>keymap Arthas快捷键列表及自定义快捷键<br></code></pre></td></tr></table></figure><p><strong>jvm 相关</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">dashboard 当前系统的实时数据面板<br>thread 查看当前JVM的线程堆栈信息<br>jvm 查看当前JVM的信息<br>sysprop 查看和修改JVM的系统属性<br>sysem 查看JVM的环境变量<br>vmoption 查看和修改JVM里诊断相关的option<br>perfcounter 查看当前JVM的 Perf Counter信息<br>logger 查看和修改logger<br>getstatic 查看类的静态属性<br>ognl 执行ognl表达式<br>mbean 查看 Mbean的信息<br>heapdump dump java heap，类似jmap命令的 heap dump功能<br></code></pre></td></tr></table></figure><p><strong>class&#x2F;classloader 相关</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">sc 查看JVM已加载的类信息<br>-d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的Classloader等详细信息。如果一个类被多个Classloader所加载，则会出现多次<br>-E 开启正则表达式匹配，默认为通配符匹配<br>-f 输出当前类的成员变量信息（需要配合参数-d一起使用）<br>-X 指定输出静态变量时属性的遍历深度，默认为0，即直接使用toString输出<br>sm 查看已加载类的方法信息<br>-d 展示每个方法的详细信息<br>-E 开启正则表达式匹配,默认为通配符匹配<br>jad 反编译指定已加载类的源码<br>mc 内存编译器，内存编译.java文件为.class文件<br>retransform 加载外部的.class文件, retransform到JVM里<br>redefine 加载外部的.class文件，redefine到JVM里<br>dump dump已加载类的byte code到特定目录<br>classloader 查看classloader的继承树，urts，类加载信息，使用classloader去getResource<br>-t 查看classloader的继承树<br>-l 按类加载实例查看统计信息<br>-c 用classloader对应的hashcode来查看对应的 Jar urls<br></code></pre></td></tr></table></figure><p><strong>monitor&#x2F;watch&#x2F;trace 相关</strong></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">monitor 方法执行监控，调用次数、执行时间、失败率<br>-c 统计周期，默认值为<span class="hljs-number">120</span>秒<br>watch 方法执行观测，能观察到的范围为：返回值、抛出异常、入参，通过编写groovy表达式进行对应变量的查看<br>-<span class="hljs-selector-tag">b</span> 在方法调用之前观察(默认关闭)<br>-e 在方法异常之后观察(默认关闭)<br>-s 在方法返回之后观察(默认关闭)<br>-f 在方法结束之后(正常返回和异常返回)观察(默认开启)<br>-<span class="hljs-attribute">x</span> 指定输岀结果的属性遍历深度,默认为<span class="hljs-number">0</span><br>trace 方法内部调用路径,并输出方法路径上的每个节点上耗时<br>-n 执行次数限制<br>stack 输出当前方法被调用的调用路径<br>tt 方法执行数据的时空隧道,记录下指定方法每次调用的入参和返回信息,并能对这些不同的时间下调用进行观测<br></code></pre></td></tr></table></figure><p><strong>其他</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">jobs 列出所有job<br>kill 强制终止任务<br>fg 将暂停的任务拉到前台执行<br>bg 将暂停的任务放到后台执行<br>grep 搜索满足条件的结果<br>plaintext 将命令的结果去除ANSI颜色<br>wc 按行统计输出结果<br>options 查看或设置Arthas全局开关<br>profiler 使用async-profiler对应用采样，生成火焰图<br></code></pre></td></tr></table></figure><h2 id="3-7-Java-Misssion-Control"><a href="#3-7-Java-Misssion-Control" class="headerlink" title="3.7. Java Misssion Control"></a>3.7. Java Misssion Control</h2><p>在 Oracle 收购 Sun 之前，Oracle 的 JRockit 虚拟机提供了一款叫做 JRockit Mission Control 的虚拟机诊断工具。</p><p>在 Oracle 收购 sun 之后，Oracle 公司同时拥有了 Hotspot 和 JRockit 两款虚拟机。根据 Oracle 对于 Java 的战略，在今后的发展中，会将 JRokit 的优秀特性移植到 Hotspot 上。其中一个重要的改进就是在 Sun 的 JDK 中加入了 JRockit 的支持。</p><p>在 Oracle JDK 7u40 之后，Mission Control 这款工具己经绑定在 Oracle JDK 中发布。</p><p>自 Java11 开始，本节介绍的 JFR 己经开源。但在之前的 Java 版本，JFR 属于 Commercial Feature 通过 Java 虚拟机参数-XX:+UnlockCommercialFeatures 开启。</p><p>Java Mission Control（简称 JMC) ， Java 官方提供的性能强劲的工具，是一个用于对 Java 应用程序进行管理、监视、概要分析和故障排除的工具套件。它包含一个 GUI 客户端以及众多用来收集 Java 虚拟机性能数据的插件如 JMX Console（能够访问用来存放虚拟机齐个于系统运行数据的 MXBeans）以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p><p>JMC 的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小，完全可以开着 JMC 来做压测（唯一影响可能是 full gc 多了）。</p><p>官方地址：<a href="https://github.com/JDKMissionControl/jmc">https://github.com/JDKMissionControl/jmc</a></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120786.png" alt="image-20210505184358041"></p><p><strong>Java Flight Recorder</strong></p><p>Java Flight Recorder 是 JMC 的其中一个组件，能够以极低的性能开销收集 Java 虚拟机的性能数据。与其他工具相比，JFR 的性能开销很小，在默认配置下平均低于 1%。JFR 能够直接访问虚拟机内的敌据并且不会影响虚拟机的优化。因此它非常适用于生产环境下满负荷运行的 Java 程序。</p><p>Java Flight Recorder 和 JDK Mission Control 共同创建了一个完整的工具链。JDK Mission Control 可对 Java Flight Recorder 连续收集低水平和详细的运行时信息进行高效、详细的分析。</p><p>当启用时 JFR 将记录运行过程中发生的一系列事件。其中包括 Java 层面的事件如线程事件、锁事件，以及 Java 虚拟机内部的事件，如新建对象，垃圾回收和即时编译事件。按照发生时机以及持续时间来划分，JFR 的事件共有四种类型，它们分别为以下四种：</p><ul><li><p>瞬时事件（Instant Event) ，用户关心的是它们发生与否，例如异常、线程启动事件。</p></li><li><p>持续事件(Duration Event) ，用户关心的是它们的持续时间，例如垃圾回收事件。</p></li><li><p>计时事件(Timed Event) ，是时长超出指定阈值的持续事件。</p></li><li><p>取样事件（Sample Event)，是周期性取样的事件。</p></li></ul><p>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时问统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120787.png" alt="image-20210505185941373"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120788.png" alt="image-20210505185954567"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120789.png" alt="image-20210505190009274"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120790.png" alt="image-20210505190023099"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120791.png" alt="image-20210505190037354"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120792.png" alt="image-20210505190052561"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120793.png" alt="image-20210505190106004"></p><h2 id="3-8-其他工具"><a href="#3-8-其他工具" class="headerlink" title="3.8. 其他工具"></a>3.8. 其他工具</h2><p><strong>Flame Graphs（火焰图）</strong></p><p>在追求极致性能的场景下，了解你的程序运行过程中 cpu 在干什么很重要，火焰图就是一种非常直观的展示 CPU 在程序整个生命周期过程中时间分配的工具。火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用找中的 CPU 消耗瓶颈。</p><p>网上的关于 Java 火焰图的讲解大部分来自于 Brenden Gregg 的博客 <a href="http://new.brendangregg.com/flamegraphs.html">http://new.brendangregg.com/flamegraphs.html </a></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120794.png" alt="image-20210505190823214"></p><p>火焰图，简单通过 x 轴横条宽度来度量时间指标，y 轴代表线程栈的层次。</p><p><strong>Tprofiler</strong></p><p>案例： 使用 JDK 自身提供的工具进行 JVM 调优可以将下 TPS 由 2.5 提升到 20（提升了 7 倍），并准确 定位系统瓶颈。</p><p>系统瓶颈有：应用里释态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。</p><p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 Tprofiler 来定位 这些性能代码，成功解决掉了 GC 过于频繁的性能瓶预，并最终在上次优化的基础上将 TPS 再提升了 4 倍，即提升到 100。</p><ul><li>Tprofiler 配置部署、远程操作、 日志阅谈都不太复杂，操作还是很简单的。但是其却是能够 起到一针见血、立竿见影的效果，帮我们解决了 GC 过于频繁的性能瓶预。</li><li>Tprofiler 最重要的特性就是能够统汁出你指定时间段内 JVM 的 top method 这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRokit 首席开发者 Marcus Hirt 在其私人博客《 Lom Overhead Method Profiling cith Java Mission Control》下的评论中曾明确指出 JRMC 井不支持 TOP 方法的统计。</li></ul><p>官方地址：<a href="http://github.com/alibaba/Tprofiler">http://github.com/alibaba/Tprofiler</a></p><p><strong>Btrace</strong></p><p>常见的动态追踪工具有 BTrace、HouseHD（该项目己经停止开发）、Greys-Anatomy（国人开发 个人开发者）、Byteman（JBoss 出品），注意 Java 运行时追踪工具井不限干这几种，但是这几个是相对比较常用的。</p><p>BTrace 是 SUN Kenai 云计算开发平台下的一个开源项目，旨在为 java 提供安全可靠的动态跟踪分析工具。先看一卜日 Trace 的官方定义：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271120795.png" alt="image-20210505192042974"></p><p>大概意思是一个 Java 平台的安全的动态追踪工具，可以用来动态地追踪一个运行的 Java 程序。BTrace 动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪“）。</p><p><strong>YourKit</strong></p><p><strong>JProbe</strong></p><p><strong>Spring Insight</strong></p><hr/>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM下02-JVM监控及诊断工具（命令行篇）</title>
    <link href="/2025/02/27/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/"/>
    <url>/2025/02/27/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="2-JVM-监控及诊断工具-命令行篇"><a href="#2-JVM-监控及诊断工具-命令行篇" class="headerlink" title="2. JVM 监控及诊断工具-命令行篇"></a>2. JVM 监控及诊断工具-命令行篇</h1><h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1. 概述"></a>2.1. 概述</h2><p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p><p>Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络 I&#x2F;O、垃圾收集等。想要定位这些问题，一款优秀的性能诊断工具必不可少。</p><p>体会 1：使用数据说明问题，使用知识分析问题，使用工具处理问题。</p><p>体会 2：无监控、不调优！</p><p><strong>简单命令行工具</strong></p><p>在我们刚接触 java 学习的时候，大家肯定最先了解的两个命令就是 javac，java，那么除此之外，还有没有其他的命令可以供我们使用呢？</p><p>我们进入到安装 jdk 的 bin 目录，发现还有一系列辅助工具。这些辅助工具用来获取目标 JVM 不同方面、不同层次的信息，帮助开发人员很好地解决 Java 应用程序的一些疑难杂症。</p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/5b7c5d239e4da192ba65edb0800055c5.png" alt="image-20210504195803526"></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/fa3c5e41cbf999d261bcf32851731565.png" alt="image-20210504195836342"></p><p>官方源码地址：<a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools">http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools</a></p><h2 id="2-2-jps：查看正在运行的-Java-进程"><a href="#2-2-jps：查看正在运行的-Java-进程" class="headerlink" title="2.2. jps：查看正在运行的 Java 进程"></a>2.2. jps：查看正在运行的 Java 进程</h2><p>jps(Java Process Status)：显示指定系统内所有的 HotSpot 虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p><p>说明：对于本地虚拟机进程来说，进程的本地虚拟机 ID 与操作系统的进程 ID 是一致的，是唯一的。</p><p>基本使用语法为：jps [options] [hostid]</p><p>我们还可以通过追加参数，来打印额外的信息。</p><p><strong>options 参数</strong></p><ul><li>-q：仅仅显示 LVMID（local virtual machine id），即本地虚拟机唯一 id。不显示主类的名称等</li><li>-l：输出应用程序主类的全类名 或 如果进程执行的是 jar 包，则输出 jar 完整路径</li><li>-m：输出虚拟机进程启动时传递给主类 main()的参数</li><li>-v：列出虚拟机进程启动时的 JVM 参数。比如：-Xms20m -Xmx50m 是启动程序指定的 jvm 参数。</li></ul><p>说明：以上参数可以综合使用。</p><p>补充：如果某 Java 进程关闭了默认开启的 UsePerfData 参数（即使用参数-XX：-UsePerfData），那么 jps 命令（以及下面介绍的 jstat）将无法探知该 Java 进程。</p><p><strong>hostid 参数</strong></p><p>RMI 注册表中注册的主机名。如果想要远程监控主机上的 java 程序，需要安装 jstatd。</p><p>对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到 IP 地址欺诈攻击。</p><p>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行 jstatd 服务器，而是在本地使用 jstat 和 jps 工具。</p><h2 id="2-3-jstat：查看-JVM-统计信息"><a href="#2-3-jstat：查看-JVM-统计信息" class="headerlink" title="2.3. jstat：查看 JVM 统计信息"></a>2.3. jstat：查看 JVM 统计信息</h2><p>jstat（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。在没有 GUI 图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p><p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a></p><p>基本使用语法为：jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</p><p>查看命令相关参数：jstat-h 或 jstat-help</p><p>其中 vmid 是进程 id 号，也就是 jps 之后看到的前面的号码，如下：</p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/83dddc874824b88d7fd03dab2b3889f1.png" alt="image-20210504201703222"></p><p><strong>option 参数</strong></p><p>选项 option 可以由以下值构成。</p><p><mark>类装载相关的：</mark></p><ul><li>-class：显示 ClassLoader 的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</li></ul><p><mark>垃圾回收相关的：</mark></p><ul><li>-gc：显示与 GC 相关的堆信息。包括 Eden 区、两个 Survivor 区、老年代、永久代等的容量、已用空间、GC 时间合计等信息。</li><li>-gccapacity：显示内容与-gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间。</li><li>-gcutil：显示内容与-gc 基本相同，但输出主要关注已使用空间占总空间的百分比。</li><li>-gccause：与-gcutil 功能一样，但是会额外输出导致最后一次或当前正在发生的 GC 产生的原因。</li><li>-gcnew：显示新生代 GC 状况</li><li>-gcnewcapacity：显示内容与-gcnew 基本相同，输出主要关注使用到的最大、最小空间</li><li>-geold：显示老年代 GC 状况</li><li>-gcoldcapacity：显示内容与-gcold 基本相同，输出主要关注使用到的最大、最小空间</li><li>-gcpermcapacity：显示永久代使用到的最大、最小空间。</li></ul><p><mark>JIT 相关的：</mark></p><ul><li><p>-compiler：显示 JIT 编译器编译过的方法、耗时等信息</p></li><li><p>-printcompilation：输出已经被 JIT 编译的方法</p></li></ul><p><strong>jstat -class</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/9f2cea8b0a9b1bc47c10281b5c140cc4.png" alt="img"></p><p><strong>jstat -compiler</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/4e11a07ce9b8ff2f73ba5585e11e1da3.png" alt="img"></p><p><strong>jstat -printcompilation</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/2a2553eef35293d28ef095feee3bb3b7.png" alt="img"></p><p><strong>jstat -gc</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/6ea2aa6665c49b4bd35d46152dd2f1aa.png" alt="img"></p><p><strong>jstat -gccapacity</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/be1dbc9fb1100c4ab76fdf802171c000.png" alt="img"></p><p><strong>jstat -gcutil</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/527f347102e0f48036f4e643103a735f.png" alt="img"></p><p><strong>jstat -gccause</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/2e5d220a3ceb094b3d6aee8b46867942.png" alt="img"></p><p><strong>jstat -gcnew</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/766a9d8c98c1add9ff60f001fcbe552b.png" alt="img"></p><p><strong>jstat -gcnewcapacity</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/d26356900de541c149df9c00852245a1.png" alt="img"></p><p><strong>jstat -gcold</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/64f18adec84996fec58edf7052440610.png" alt="img"></p><p><strong>jstat -gcoldcapacity</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/52bf3b50ba4a48247742caa0aa30be7e.png" alt="img"></p><p><strong>jstat -t</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/61a5c6b9c421ba9ec38db1f132ef4161.png" alt="img"></p><p><strong>jstat -t -h</strong></p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/73a294c043f770940daa6a501c1e8d2c.png" alt="img"></p><table><thead><tr><th align="left">表头</th><th align="left">含义（字节）</th></tr></thead><tbody><tr><td align="left">EC</td><td align="left">Eden 区的大小</td></tr><tr><td align="left">EU</td><td align="left">Eden 区已使用的大小</td></tr><tr><td align="left">S0C</td><td align="left">幸存者 0 区的大小</td></tr><tr><td align="left">S1C</td><td align="left">幸存者 1 区的大小</td></tr><tr><td align="left">S0U</td><td align="left">幸存者 0 区已使用的大小</td></tr><tr><td align="left">S1U</td><td align="left">幸存者 1 区已使用的大小</td></tr><tr><td align="left">MC</td><td align="left">元空间的大小</td></tr><tr><td align="left">MU</td><td align="left">元空间已使用的大小</td></tr><tr><td align="left">OC</td><td align="left">老年代的大小</td></tr><tr><td align="left">OU</td><td align="left">老年代已使用的大小</td></tr><tr><td align="left">CCSC</td><td align="left">压缩类空间的大小</td></tr><tr><td align="left">CCSU</td><td align="left">压缩类空间已使用的大小</td></tr><tr><td align="left">YGC</td><td align="left">从应用程序启动到采样时 young gc 的次数</td></tr><tr><td align="left">YGCT</td><td align="left">从应用程序启动到采样时 young gc 消耗时间（秒）</td></tr><tr><td align="left">FGC</td><td align="left">从应用程序启动到采样时 full gc 的次数</td></tr><tr><td align="left">FGCT</td><td align="left">从应用程序启动到采样时的 full gc 的消耗时间（秒）</td></tr><tr><td align="left">GCT</td><td align="left">从应用程序启动到采样时 gc 的总时间</td></tr></tbody></table><p><strong>interval 参数：</strong> 用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p><p><strong>count 参数：</strong> 用于指定查询的总次数</p><p><strong>-t 参数：</strong> 可以在输出信息前加上一个 Timestamp 列，显示程序的运行时间。单位：秒</p><p><strong>-h 参数：</strong> 可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p><p><strong>补充：</strong> jstat 还可以用来判断是否出现内存泄漏。</p><p>第 1 步：在长时间运行的 Java 程序中，我们可以运行 jstat 命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。</p><p>第 2 步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p><h2 id="2-4-jinfo：实时查看和修改-JVM-配置参数"><a href="#2-4-jinfo：实时查看和修改-JVM-配置参数" class="headerlink" title="2.4. jinfo：实时查看和修改 JVM 配置参数"></a>2.4. jinfo：实时查看和修改 JVM 配置参数</h2><p>jinfo(Configuration Info for Java)：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数。在很多情况卡，Java 应用程序不会指定所有的 Java 虚拟机参数。而此时，开发人员可能不知道某一个具体的 Java 虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了 jinfo 工具，开发人员可以很方便地找到 Java 虚拟机参数的当前值。</p><p>基本使用语法为：jinfo [options] pid</p><p>说明：java 进程 ID 必须要加上</p><table><thead><tr><th>选项</th><th>选项说明</th></tr></thead><tbody><tr><td>no option</td><td>输出全部的参数和系统属性</td></tr><tr><td>-flag name</td><td>输出对应名称的参数</td></tr><tr><td>-flag [+-]name</td><td>开启或者关闭对应名称的参数 只有被标记为 manageable 的参数才可以被动态修改</td></tr><tr><td>-flag name&#x3D;value</td><td>设定对应名称的参数</td></tr><tr><td>-flags</td><td>输出全部的参数</td></tr><tr><td>-sysprops</td><td>输出系统属性</td></tr></tbody></table><p><strong>jinfo -sysprops</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">&gt;</span> <span class="hljs-string">jinfo -sysprops</span><br><span class="hljs-attr">jboss.modules.system.pkgs</span> = <span class="hljs-string">com.intellij.rt</span><br><span class="hljs-attr">java.vendor</span> = <span class="hljs-string">Oracle Corporation</span><br><span class="hljs-attr">sun.java.launcher</span> = <span class="hljs-string">SUN_STANDARD</span><br><span class="hljs-attr">sun.management.compiler</span> = <span class="hljs-string">HotSpot 64-Bit Tiered Compilers</span><br><span class="hljs-attr">catalina.useNaming</span> = <span class="hljs-string">true</span><br><span class="hljs-attr">os.name</span> = <span class="hljs-string">Windows 10</span><br><span class="hljs-attr">...</span><br></code></pre></td></tr></table></figure><p><strong>jinfo -flags</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">jinfo -flags 25592</span><br>Non-default VM flags: -XX:CICompilerCount=4 -XX:InitialHeapSize=333447168 -XX:MaxHeapSize=5324668928 -XX:MaxNewSize=1774714880 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=111149056 -XX:OldSize=222298112 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC<br>Command line:  -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:8040,suspend=y,server=n -Drebel.base=C:\Users\Vector\.jrebel -Drebel.env.ide.plugin.version=2021.1.2 -Drebel.env.ide.version=2020.3.3 -Drebel.env.ide.product=IU -Drebel.env.ide=intellij -Drebel.notification.url=http://localhost:7976 -agentpath:C:\Users\Vector\AppData\Roaming\JetBrains\IntelliJIdea2020.3\plugins\jr-ide-idea\lib\jrebel6\lib\jrebel64.dll -Dmaven.home=D:\eclipse\env\maven -Didea.modules.paths.file=C:\Users\Vector\AppData\Local\JetBrains\IntelliJIdea2020.3\Maven\idea-projects-state-596682c7.properties -Dclassworlds.conf=C:\Users\Vector\AppData\Local\Temp\idea-6755-mvn.conf -Dmaven.ext.class.path=D:\IDEA\plugins\maven\lib\maven-event-listener.jar -javaagent:D:\IDEA\plugins\java\lib\rt\debugger-agent.jar -Dfile.encoding=UTF-8<br></code></pre></td></tr></table></figure><p><strong>jinfo -flag</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">jinfo -flag UseParallelGC 25592</span><br>-XX:+UseParallelGC<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">jinfo -flag UseG1GC 25592</span><br>-XX:-UseG1GC<br></code></pre></td></tr></table></figure><p><strong>jinfo -flag name</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">jinfo -flag UseParallelGC 25592</span><br>-XX:+UseParallelGC<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">jinfo -flag UseG1GC 25592</span><br>-XX:-UseG1GC<br></code></pre></td></tr></table></figure><p><strong>jinfo -flag [+-]name</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">jinfo -flag +PrintGCDetails 25592</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">jinfo -flag PrintGCDetails 25592</span><br>-XX:+PrintGCDetails<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">jinfo -flag -PrintGCDetails 25592</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">jinfo -flag PrintGCDetails 25592</span><br>-XX:-PrintGCDetails<br></code></pre></td></tr></table></figure><p>拓展：</p><ul><li><p>java -XX:+PrintFlagsInitial 查看所有 JVM 参数启动的初始值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Global flags]<br>     intx ActiveProcessorCount                      = -1                                  &#123;product&#125;<br>    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   &#123;product&#125;<br>    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  &#123;product&#125;<br>    uintx AdaptiveSizePausePolicy                   = 0                                   &#123;product&#125;<br>...<br></code></pre></td></tr></table></figure></li><li><p>java -XX:+PrintFlagsFinal 查看所有 JVM 参数的最终值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Global flags]<br>     intx ActiveProcessorCount                      = -1                                  &#123;product&#125;<br>...<br>     intx CICompilerCount                          := 4                                   &#123;product&#125;<br>    uintx InitialHeapSize                          := 333447168                           &#123;product&#125;<br>    uintx MaxHeapSize                              := 1029701632                          &#123;product&#125;<br>    uintx MaxNewSize                               := 1774714880                          &#123;product&#125;<br></code></pre></td></tr></table></figure></li><li><p>java -XX:+PrintCommandLineFlags 查看哪些已经被用户或者 JVM 设置过的详细的 XX 参数的名称和值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-XX:InitialHeapSize=332790016 -XX:MaxHeapSize=5324640256 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-5-jmap：导出内存映像文件-内存使用情况"><a href="#2-5-jmap：导出内存映像文件-内存使用情况" class="headerlink" title="2.5. jmap：导出内存映像文件&amp;内存使用情况"></a>2.5. jmap：导出内存映像文件&amp;内存使用情况</h2><p>jmap（JVM Memory Map）：作用一方面是获取 dump 文件（堆转储快照文件，二进制文件），它还可以获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等。开发人员可以在控制台中输入命令“jmap -help”查阅 jmap 工具的具体使用方式和一些标准选项配置。</p><p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">https://docs.oracle.com/en/java/javase/11/tools/jmap.html</a></p><p>基本使用语法为：</p><ul><li>jmap [option] &lt;pid&gt;</li><li>jmap [option] &lt;executable &lt;core&gt;</li><li>jmap [option] [server_id@] &lt;remote server IP or hostname&gt;</li></ul><table><thead><tr><th align="left">选项</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-dump</td><td align="left">生成 dump 文件（Java 堆转储快照），-dump:live 只保存堆中的存活对象</td></tr><tr><td align="left">-heap</td><td align="left">输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息，以及内存的使用信息等</td></tr><tr><td align="left">-histo</td><td align="left">输出堆空间中对象的统计信息，包括类、实例数量和合计容量，-histo:live 只统计堆中的存活对象</td></tr><tr><td align="left">-J &lt;flag&gt;</td><td align="left">传递参数给 jmap 启动的 jvm</td></tr><tr><td align="left">-finalizerinfo</td><td align="left">显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象，仅 linux&#x2F;solaris 平台有效</td></tr><tr><td align="left">-permstat</td><td align="left">以 ClassLoader 为统计口径输出永久代的内存状态信息，仅 linux&#x2F;solaris 平台有效</td></tr><tr><td align="left">-F</td><td align="left">当虚拟机进程对-dump 选项没有任何响应时，强制执行生成 dump 文件，仅 linux&#x2F;solaris 平台有效</td></tr></tbody></table><p>说明：这些参数和 linux 下输入显示的命令多少会有不同，包括也受 jdk 版本的影响。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;&gt; jmap -dump:live,format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span><br></code></pre></td></tr></table></figure><p>由于 jmap 将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap 需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由 jmap 导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</p><p>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live 选项将无法探知到这些对象。</p><p>另外，如果某个线程长时间无法跑到安全点，jmap 将一直等下去。与前面讲的 jstat 则不同，垃圾回收器会主动将 jstat 所需要的摘要数据保存至固定位置之中，而 jstat 只需直接读取即可。</p><h2 id="2-6-jhat：JDK-自带堆分析工具"><a href="#2-6-jhat：JDK-自带堆分析工具" class="headerlink" title="2.6. jhat：JDK 自带堆分析工具"></a>2.6. jhat：JDK 自带堆分析工具</h2><p>jhat(JVM Heap Analysis Tool)：Sun JDK 提供的 jhat 命令与 jmap 命令搭配使用，用于分析 jmap 生成的 heap dump 文件（堆转储快照）。jhat 内置了一个微型的 HTTP&#x2F;HTML 服务器，生成 dump 文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）。</p><p>使用了 jhat 命令，就启动了一个 http 服务，端口是 7000，即 <a href="http://localhost:7000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E5%88%86%E6%9E%90%E3%80%82">http://localhost:7000/，就可以在浏览器里分析。</a></p><p>说明：jhat 命令在 JDK9、JDK10 中已经被删除，官方建议用 VisualVM 代替。</p><p>基本适用语法：jhat &lt;option&gt; &lt;dumpfile&gt;</p><table><thead><tr><th align="left">option 参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-stack false ｜ true</td><td align="left">关闭｜打开对象分配调用栈跟踪</td></tr><tr><td align="left">-refs false ｜ true</td><td align="left">关闭｜打开对象引用跟踪</td></tr><tr><td align="left">-port port-number</td><td align="left">设置 jhat HTTP Server 的端口号，默认 7000</td></tr><tr><td align="left">-exclude exclude-file</td><td align="left">执行对象查询时需要排除的数据成员</td></tr><tr><td align="left">-baseline exclude-file</td><td align="left">指定一个基准堆转储</td></tr><tr><td align="left">-debug int</td><td align="left">设置 debug 级别</td></tr><tr><td align="left">-version</td><td align="left">启动后显示版本信息就退出</td></tr><tr><td align="left">-J &lt;flag&gt;</td><td align="left">传入启动参数，比如-J-Xmx512m</td></tr></tbody></table><h2 id="2-7-jstack：打印-JVM-中线程快照"><a href="#2-7-jstack：打印-JVM-中线程快照" class="headerlink" title="2.7. jstack：打印 JVM 中线程快照"></a>2.7. jstack：打印 JVM 中线程快照</h2><p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p><p>生成线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用 jstack 显示各个线程调用的堆栈情况。</p><p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html">https://docs.oracle.com/en/java/javase/11/tools/jstack.html</a></p><p>在 thread dump 中，要留意下面几种状态</p><ul><li><mark>死锁，Deadlock（重点关注）</mark></li><li><mark>等待资源，Waiting on condition（重点关注）</mark></li><li><mark>等待获取监视器，Waiting on monitor entry（重点关注）</mark></li><li><mark>阻塞，Blocked（重点关注）</mark></li><li>执行中，Runnable</li><li>暂停，Suspended</li><li>对象等待中，Object.wait() 或 TIMED＿WAITING</li><li>停止，Parked</li></ul><table><thead><tr><th align="left">option 参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-F</td><td align="left">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td align="left">-l</td><td align="left">除堆栈外，显示关于锁的附加信息</td></tr><tr><td align="left">-m</td><td align="left">如果调用本地方法的话，可以显示 C&#x2F;C++的堆栈</td></tr></tbody></table><h2 id="2-8-jcmd：多功能命令行"><a href="#2-8-jcmd：多功能命令行" class="headerlink" title="2.8. jcmd：多功能命令行"></a>2.8. jcmd：多功能命令行</h2><p>在 JDK 1.7 以后，新增了一个命令行工具 jcmd。它是一个多功能的工具，可以用来实现前面除了 jstat 之外所有命令的功能。比如：用它来导出堆、内存使用、查看 Java 进程、导出线程信息、执行 GC、JVM 运行时间等。</p><p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">https://docs.oracle.com/en/java/javase/11/tools/jcmd.html</a></p><p>jcmd 拥有 jmap 的大部分功能，并且在 Oracle 的官方网站上也推荐使用 jcmd 命令代 jmap 命令</p><p>**jcmd -l：**列出所有的 JVM 进程</p><p>**jcmd 进程号 help：**针对指定的进程，列出支持的所有具体命令</p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/f3507ac3e24d40625f6c3d54c25c743b.png" alt="image-20210504213044819"></p><p>**jcmd 进程号 具体命令：**显示指定进程的指令命令的数据</p><ul><li>Thread.print 可以替换 jstack 指令</li><li>GC.class_histogram 可以替换 jmap 中的-histo 操作</li><li>GC.heap_dump 可以替换 jmap 中的-dump 操作</li><li>GC.run 可以查看 GC 的执行情况</li><li>VM.uptime 可以查看程序的总执行时间，可以替换 jstat 指令中的-t 操作</li><li>VM.system_properties 可以替换 jinfo -sysprops 进程 id</li><li>VM.flags 可以获取 JVM 的配置参数信息</li></ul><h2 id="2-9-jstatd：远程主机信息收集"><a href="#2-9-jstatd：远程主机信息收集" class="headerlink" title="2.9. jstatd：远程主机信息收集"></a>2.9. jstatd：远程主机信息收集</h2><p>之前的指令只涉及到监控本机的 Java 应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如 jps、jstat）。为了启用远程监控，则需要配合使用 jstatd 工具。命令 jstatd 是一个 RMI 服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd 服务器将本机的 Java 应用程序信息传递到远程计算机。</p><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/JVM%E4%B8%8B02-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87%EF%BC%89/2225de448c4af005aa0f72e84bba5e57.png" alt="image-20210504213301077"></p><hr/>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM下01-概述篇</title>
    <link href="/2025/02/27/JVM%E4%B8%8B01-%E6%A6%82%E8%BF%B0%E7%AF%87/"/>
    <url>/2025/02/27/JVM%E4%B8%8B01-%E6%A6%82%E8%BF%B0%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-概述篇"><a href="#1-概述篇" class="headerlink" title="1. 概述篇"></a>1. 概述篇</h1><h2 id="1-1-大厂面试题"><a href="#1-1-大厂面试题" class="headerlink" title="1.1. 大厂面试题"></a>1.1. 大厂面试题</h2><blockquote><p><mark>支付宝：</mark></p><p>支付宝三面：JVM 性能调优都做了什么？</p><p><mark>小米：</mark></p><p>有做过 JVM 内存优化吗？</p><p>从 SQL、JVM、架构、数据库四个方面讲讲优化思路</p><p><mark>蚂蚁金服：</mark></p><p>JVM 的编译优化</p><p>jvm 性能调优都做了什么</p><p>JVM 诊断调优工具用过哪些？</p><p>二面：jvm 怎样调优，堆内存、栈空间设置多少合适</p><p>三面：JVM 相关的分析工具使用过的有哪些？具体的性能调优步骤如何</p><p><mark>阿里：</mark></p><p>如何进行 JVM 调优？有哪些方法？</p><p>如何理解内存泄漏问题？有哪些情况会导致内存泄漏？如何解决？</p><p><mark>字节跳动：</mark></p><p>三面：JVM 如何调优、参数怎么调？</p><p><mark>拼多多：</mark></p><p>从 SQL、JVM、架构、数据库四个方面讲讲优化思路</p><p><mark>京东：</mark></p><p>JVM 诊断调优工具用过哪些？</p><p>每秒几十万并发的秒杀系统为什么会频繁发生 GC？</p><p>日均百万级交易系统如何优化 JVM？</p><p>线上生产系统 OOM 如何监控及定位与解决？</p><p>高并发系统如何基于 G1 垃圾回收器优化性能？</p></blockquote><h2 id="1-2-背景说明"><a href="#1-2-背景说明" class="headerlink" title="1.2. 背景说明"></a>1.2. 背景说明</h2><p><strong>生产环境中的问题</strong></p><ul><li>生产环境发生了内存溢出该如何处理？</li><li>生产环境应该给服务器分配多少内存合适？</li><li>如何对垃圾回收器的性能进行调优？</li><li>生产环境 CPU 负载飙高该如何处理？</li><li>生产环境应该给应用分配多少线程合适？</li><li>不加 log，如何确定请求是否执行了某一行代码？</li><li>不加 log，如何实时查看某个方法的入参与返回值？</li></ul><p><strong>为什么要调优</strong></p><ul><li>防止出现 OOM</li><li>解决 OOM</li><li>减少 Full GC 出现的频率</li></ul><p><strong>不同阶段的考虑</strong></p><ul><li>上线前</li><li>项目运行阶段</li><li>线上出现 OOM</li></ul><h2 id="1-3-调优概述"><a href="#1-3-调优概述" class="headerlink" title="1.3. 调优概述"></a>1.3. 调优概述</h2><p><strong>监控的依据</strong></p><ul><li>运行日志</li><li>异常堆栈</li><li>GC 日志</li><li>线程快照</li><li>堆转储快照</li></ul><p><strong>调优的大方向</strong></p><ul><li>合理地编写代码</li><li>充分并合理的使用硬件资源</li><li>合理地进行 JVM 调优</li></ul><h2 id="1-4-性能优化的步骤"><a href="#1-4-性能优化的步骤" class="headerlink" title="1.4. 性能优化的步骤"></a>1.4. 性能优化的步骤</h2><p><strong>第 1 步：性能监控</strong></p><ul><li>GC 频繁</li><li>cpu load 过高</li><li>OOM</li><li>内存泄露</li><li>死锁</li><li>程序响应时间较长</li></ul><p><strong>第 2 步：性能分析</strong></p><ul><li>打印 GC 日志，通过 GCviewer 或者 <a href="http://gceasy.io/">http://gceasy.io</a> 来分析异常信息</li><li>灵活运用命令行工具、jstack、jmap、jinfo 等</li><li>dump 出堆文件，使用内存分析工具分析文件</li><li>使用阿里 Arthas、jconsole、JVisualVM 来实时查看 JVM 状态</li><li>jstack 查看堆栈信息</li></ul><p><strong>第 3 步：性能调优</strong></p><ul><li>适当增加内存，根据业务背景选择垃圾回收器</li><li>优化代码，控制内存使用</li><li>增加机器，分散节点压力</li><li>合理设置线程池线程数量</li><li>使用中间件提高程序效率，比如缓存、消息队列等</li><li>其他……</li></ul><h2 id="1-5-性能评价-测试指标"><a href="#1-5-性能评价-测试指标" class="headerlink" title="1.5. 性能评价&#x2F;测试指标"></a>1.5. 性能评价&#x2F;测试指标</h2><p><strong>停顿时间（或响应时间）</strong></p><p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。常用操作的响应时间列表：</p><table><thead><tr><th align="left">操作</th><th align="left">响应时间</th></tr></thead><tbody><tr><td align="left">打开一个站点</td><td align="left">几秒</td></tr><tr><td align="left">数据库查询一条记录（有索引）</td><td align="left">十几毫秒</td></tr><tr><td align="left">机械磁盘一次寻址定位</td><td align="left">4 毫秒</td></tr><tr><td align="left">从机械磁盘顺序读取 1M 数据</td><td align="left">2 毫秒</td></tr><tr><td align="left">从 SSD 磁盘顺序读取 1M 数据</td><td align="left">0.3 毫秒</td></tr><tr><td align="left">从远程分布式换成 Redis 读取一个数据</td><td align="left">0.5 毫秒</td></tr><tr><td align="left">从内存读取 1M 数据</td><td align="left">十几微妙</td></tr><tr><td align="left">Java 程序本地方法调用</td><td align="left">几微妙</td></tr><tr><td align="left">网络传输 2Kb 数据</td><td align="left">1 微妙</td></tr></tbody></table><p>在垃圾回收环节中：</p><ul><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li>-XX:MaxGCPauseMillis</li></ul><p><strong>吞吐量</strong></p><ul><li>对单位时间内完成的工作量（请求）的量度</li><li>在 GC 中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</li><li>吞吐量为 1-1&#x2F;(1+n)，其中-XX::GCTimeRatio&#x3D;n</li></ul><p><strong>并发数</strong></p><ul><li>同一时刻，对服务器有实际交互的请求数</li></ul><p><strong>内存占用</strong></p><ul><li>Java 堆区所占的内存大小</li></ul><p><strong>相互间的关系</strong></p><p>以高速公路通行状况为例</p><ul><li>吞吐量：每天通过高速公路收费站的车辆的数据</li><li>并发数：高速公路上正在行驶的车辆的数目</li><li>响应时间：车速</li></ul><hr/>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM中04-再谈类的加载器</title>
    <link href="/2025/02/27/JVM%E4%B8%AD04-%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <url>/2025/02/27/JVM%E4%B8%AD04-%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>类加载器是JVM执行类加载机制的前提。</p><p><strong>ClassLoader的作用：</strong></p><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116724.png" alt="image-20210501102535142"></p><h2 id="1-1-大厂面试题"><a href="#1-1-大厂面试题" class="headerlink" title="1.1. 大厂面试题"></a>1.1. 大厂面试题</h2><blockquote><p><mark>蚂蚁金服：</mark></p><p>深入分析ClassLoader，双亲委派机制</p><p>类加载器的双亲委派模型是什么？一面：双亲委派机制及使用原因</p><p><mark>百度：</mark></p><p>都有哪些类加载器，这些类加载器都加载哪些文件？</p><p>手写一个类加载器Demo</p><p>Class的forName（“java.lang.String”）和Class的getClassLoader（）的Loadclass（“java.lang.String”）有什么区别？</p><p><mark>腾讯：</mark></p><p>什么是双亲委派模型？</p><p>类加载器有哪些？</p><p><mark>小米：</mark></p><p>双亲委派模型介绍一下</p><p><mark>滴滴：</mark></p><p>简单说说你了解的类加载器一面：讲一下双亲委派模型，以及其优点</p><p><mark>字节跳动：</mark></p><p>什么是类加载器，类加载器有哪些？</p><p><mark>京东：</mark></p><p>类加载器的双亲委派模型是什么？</p><p>双亲委派机制可以打破吗？为什么</p></blockquote><h2 id="1-2-类加载器的分类"><a href="#1-2-类加载器的分类" class="headerlink" title="1.2. 类加载器的分类"></a>1.2. 类加载器的分类</h2><p>类的加载分类：显式加载 vs 隐式加载</p><p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p><ul><li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。</li><li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li></ul><p>在日常开发以上两种方式一般会混合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//隐式加载</span><br>User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br><span class="hljs-comment">//显式加载，并初始化</span><br>Class clazz=Class.forName(<span class="hljs-string">&quot;com.test.java.User&quot;</span>);<br><span class="hljs-comment">//显式加载，但不初始化</span><br>ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.test.java.Parent&quot;</span>); <br></code></pre></td></tr></table></figure><h2 id="1-3-类加载器的必要性"><a href="#1-3-类加载器的必要性" class="headerlink" title="1.3. 类加载器的必要性"></a>1.3. 类加载器的必要性</h2><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p><ul><li>避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的 加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li><li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li><li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li></ul><h2 id="1-4-命名空间"><a href="#1-4-命名空间" class="headerlink" title="1.4. 命名空间"></a>1.4. 命名空间</h2><p><strong>何为类的唯一性？</strong></p><p>$\color{red}{对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。}$每一个类加载器，都拥有一个独立的类名称空间：$\color{red}{比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。}$否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p><strong>命名空间</strong></p><ul><li><p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</p></li><li><p>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</p></li><li><p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</p></li></ul><p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p><h2 id="1-5-类加载机制的基本特征"><a href="#1-5-类加载机制的基本特征" class="headerlink" title="1.5. 类加载机制的基本特征"></a>1.5. 类加载机制的基本特征</h2><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider&#x2F;ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</p><p><mark>可见性</mark>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</p><p><mark>单一性</mark>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</p><h2 id="1-6-类加载器之间的关系"><a href="#1-6-类加载器之间的关系" class="headerlink" title="1.6. 类加载器之间的关系"></a>1.6. 类加载器之间的关系</h2><p>Launcher类核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Launcher.ExtClassLoader var1;<br><span class="hljs-keyword">try</span> &#123;<br>    var1 = Launcher.ExtClassLoader.getExtClassLoader();<br>&#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(<span class="hljs-string">&quot;Could not create extension class loader&quot;</span>, var10);<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);<br>&#125; <span class="hljs-keyword">catch</span> (IOException var9) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InternalError</span>(<span class="hljs-string">&quot;Could not create application class loader&quot;</span>, var9);<br>&#125;<br><br>Thread.currentThread().setContextClassLoader(<span class="hljs-built_in">this</span>.loader);<br></code></pre></td></tr></table></figure><ul><li><p><strong>ExtClassLoader的Parent类是null</strong></p></li><li><p><strong>AppClassLoader的Parent类是ExtClassLoader</strong></p></li><li><p><strong>当前线程的ClassLoader是AppClassLoader</strong></p></li></ul><p>$\color{red}{注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系}$</p><hr/><h1 id="2-类的加载器分类"><a href="#2-类的加载器分类" class="headerlink" title="2. 类的加载器分类"></a>2. 类的加载器分类</h1><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116725.png" alt="image-20210501164413665"></p><ul><li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加戟器。</li><li>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</li></ul><p>父类加载器和子类加载器的关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    ClassLoader parent;<span class="hljs-comment">//父类加载器</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassLoader</span><span class="hljs-params">(ClassLoader parent)</span>&#123;<br>        <span class="hljs-built_in">this</span>.parent = parent;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParentClassLoader</span><span class="hljs-params">(ClassLoader parent)</span>&#123;<br>        <span class="hljs-built_in">super</span>(parent);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChildClassLoader</span><span class="hljs-params">(ClassLoader parent)</span>&#123; <span class="hljs-comment">//parent = new ParentClassLoader();</span><br>        <span class="hljs-built_in">super</span>(parent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器</p><p><strong>注意：</strong></p><p>启动类加载器通过C&#x2F;C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p><h2 id="2-1-引导类加载器"><a href="#2-1-引导类加载器" class="headerlink" title="2.1. 引导类加载器"></a>2.1. 引导类加载器</h2><p><mark>启动类加载器（引导类加载器，Bootstrap ClassLoader）</mark></p><ul><li><p>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部。</p></li><li><p>它用来加载Java的核心库（JAVAHOME&#x2F;jre&#x2F;lib&#x2F;rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</p></li><li><p>并不继承自java.lang.ClassLoader，没有父加载器。</p></li><li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p></li><li><p>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116726.png" alt="image-20210501170011811"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116727.png" alt="image-20210501170038212"><br>使用-XX:+TraceClassLoading参数得到。</p></li></ul><p>启动类加载器使用C++编写的？Yes！</p><ul><li>C&#x2F;C++：指针函数&amp;函数指针、C++支持多继承、更加高效</li><li>Java：由C++演变而来，（C++）–版，单继承</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;＊＊＊＊＊＊＊＊＊＊启动类加载器＊＊＊＊＊＊＊＊＊＊&quot;</span>);<br><span class="hljs-comment">// 获取BootstrapclassLoader能够加载的api的路径</span><br>URL[] urLs = sun.misc.Launcher.getBootstrapcLassPath().getURLs();<br><span class="hljs-keyword">for</span> (URL element : urLs) &#123;<br>    System.out.println(element.toExternalForm());<br>&#125;<br><span class="hljs-comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：引导类加载器</span><br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> java.security.Provider.class.getClassLoader();<br>System.out.println(classLoader);<br></code></pre></td></tr></table></figure><p><strong>执行结果：</strong><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116728.png" alt="image-20210501170425889"></p><h2 id="2-2-扩展类加载器"><a href="#2-2-扩展类加载器" class="headerlink" title="2.2. 扩展类加载器"></a>2.2. 扩展类加载器</h2><p><mark>扩展类加载器（Extension ClassLoader）</mark></p><ul><li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p></li><li><p>继承于ClassLoader类</p></li><li><p>父类加载器为启动类加载器</p></li><li><p>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116729.png" alt="在这里插入图片描述"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;＊＊＊＊＊＊＊＊＊＊＊扩展类加载器＊＊＊＊＊＊＊＊＊＊＊&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">extDirs</span> <span class="hljs-operator">=</span>System.getProperty(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>);<br><span class="hljs-keyword">for</span> (String path :extDirs.split( regex:<span class="hljs-string">&quot;;&quot;</span>))&#123;<br>    System.out.println(path);<br>&#125;<br><br><span class="hljs-comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：扩展类加载器</span><br><span class="hljs-type">lassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> sun.security.ec.CurveDB.class.getClassLoader();<br>System.out.print1n(classLoader1); <span class="hljs-comment">//sun.misc. Launcher$ExtCLassLoader@1540e19d</span><br></code></pre></td></tr></table></figure><p><strong>执行结果：</strong></p><p>  <img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116730.png" alt="img"></p><h2 id="2-3-系统类加载器"><a href="#2-3-系统类加载器" class="headerlink" title="2.3. 系统类加载器"></a>2.3. 系统类加载器</h2><p><mark>应用程序类加载器（系统类加载器，AppClassLoader）</mark></p><ul><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>继承于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li><li>$\color{red}{应用程序中的类加载器默认是系统类加载器。}$</li><li>它是用户自定义类加载器的默认父加载器</li><li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116731.png" alt="image-20210501171206453"></p><h2 id="2-4-用户自定义类加载器"><a href="#2-4-用户自定义类加载器" class="headerlink" title="2.4. 用户自定义类加载器"></a>2.4. 用户自定义类加载器</h2><p><mark>用户自定义类加载器</mark></p><ul><li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li><li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，Java开发者可以自定义类加载器来实现类库的动态加载，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li><li>$\color{red}{通过类加载器可以实现非常绝妙的插件机制}$，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li><li>同时，$\color{red}{自定义加载器能够实现应用隔离}$，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C&#x2F;C++程序要好太多，想不修改C&#x2F;C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li><li>自定义类加载器通常需要继承于ClassLoader。</li></ul><hr/><h1 id="3-测试不同的类的加载器"><a href="#3-测试不同的类的加载器" class="headerlink" title="3. 测试不同的类的加载器"></a>3. 测试不同的类的加载器</h1><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用。<br><strong>获取ClassLoader的途径</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得当前类的ClassLoader</span><br>clazz.getClassLoader()<br><span class="hljs-comment">// 获得当前线程上下文的ClassLoader</span><br>Thread.currentThread().getContextClassLoader()<br><span class="hljs-comment">// 获得系统的ClassLoader</span><br>ClassLoader.getSystemClassLoader()<br></code></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加<br>载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载<br>器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</li><li>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器<br>来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型<br>是基本数据类型，数组类是没有类加载器的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 运行结果：null</span><br>String[] strArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">6</span>];<br>System.out.println(strArr.getClass().getClassLoader());<br><br><span class="hljs-comment">// 运行结果：sun．misc．Launcher＄AppCLassLoader＠18b4aac2</span><br>ClassLoaderTest[] test=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoaderTest</span>[<span class="hljs-number">1</span>];<br>System.out.println(test.getClass().getClassLoader());<br><br><span class="hljs-comment">// 运行结果：null</span><br><span class="hljs-type">int</span>[]ints =<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>System.out.println(ints.getClass().getClassLoader());<br></code></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//获取系统该类加载器</span><br>        ClassLoader systemClassLoader=ClassLoader.getSystemCLassLoader();<br>        System.out.print1n(systemClassLoader);<span class="hljs-comment">//sun.misc.Launcher$AppCLassLoader@18b4aac2</span><br>        <span class="hljs-comment">//获取扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">extClassLoader</span> <span class="hljs-operator">=</span>systemClassLoader.getParent();<br>        System.out.println(extClassLoader);<span class="hljs-comment">//sun.misc. Launcher$ExtCLassLoader@1540e19d</span><br>        <span class="hljs-comment">//试图获取引导类加载器：失败</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bootstrapClassLoader</span> <span class="hljs-operator">=</span>extClassLoader.getParent();<br>        System.out.print1n(bootstrapClassLoader);<span class="hljs-comment">//null</span><br><br>        <span class="hljs-comment">//##################################</span><br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span>Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>).getClassLoader();<br>            System.out.println(classLoader);<br>            <span class="hljs-comment">//自定义的类默认使用系统类加载器</span><br>            ClassLoader classLoader1=Class.forName(<span class="hljs-string">&quot;com.atguigu.java.ClassLoaderTest1&quot;</span>).getClassLoader();<br>            System.out.println(classLoader1);<br>            <br>            <span class="hljs-comment">//关于数组类型的加载：使用的类的加载器与数组元素的类的加载器相同</span><br>            String[] arrstr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];<br>            System.out.println(arrstr.getClass().getClassLoader());<span class="hljs-comment">//null：表示使用的是引导类加载器</span><br>                <br>            ClassLoaderTest1[] arr1 =<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassLoaderTest1</span>[<span class="hljs-number">10</span>];<br>            System.out.println(arr1.getClass().getClassLoader());<span class="hljs-comment">//sun.misc. Launcher$AppcLassLoader@18b4aac2</span><br>            <br>            <span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br>            System.out.println(arr2.getClass().getClassLoader());<span class="hljs-comment">//null:</span><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr/><h1 id="4-ClassLoader源码解析"><a href="#4-ClassLoader源码解析" class="headerlink" title="4. ClassLoader源码解析"></a>4. ClassLoader源码解析</h1><p><strong>ClassLoader与现有类的关系：</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116732.png" alt="image-20210501173110637"></p><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p><h2 id="4-1-ClassLoader的主要方法"><a href="#4-1-ClassLoader的主要方法" class="headerlink" title="4.1. ClassLoader的主要方法"></a>4.1. ClassLoader的主要方法</h2><p>抽象类ClassLoader的主要方法：（内部没有抽象方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ClassLoader <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><p>返回该类加载器的超类加载器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException<br></code></pre></td></tr></table></figure><p>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 ClassNotFoundException异常。该方法中的逻辑就是双亲委派模式的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException<br></code></pre></td></tr></table></figure><p>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p><ul><li><p>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</p></li><li><p>需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。$\color{red}{一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。}$</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="hljs-type">byte</span>[] b,<span class="hljs-type">int</span> off,<span class="hljs-type">int</span> len)<br></code></pre></td></tr></table></figure><p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p><ul><li><p>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</p></li><li><p>$\color{red}{defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象}$</p></li></ul><p><strong>简单举例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>    <span class="hljs-comment">// 获取类的字节数组</span><br>    <span class="hljs-type">byte</span>[] classData =getClassData(name);<br>    <span class="hljs-keyword">if</span> (classData == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>();<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//使用defineClass生成class对象</span><br>        <span class="hljs-keyword">return</span> defineClass(name,classData,θ,classData.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolveClass</span><span class="hljs-params">(Class&lt;?&gt; c)</span><br></code></pre></td></tr></table></figure><p>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)<br></code></pre></td></tr></table></figure><p>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br></code></pre></td></tr></table></figure><p>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p><h2 id="4-2-SecureClassLoader与URLClassLoader"><a href="#4-2-SecureClassLoader与URLClassLoader" class="headerlink" title="4.2. SecureClassLoader与URLClassLoader"></a>4.2. SecureClassLoader与URLClassLoader</h2><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</p><p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。$\color{red}{在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类}$，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116733.png" alt="image-20210501174730756"></p><h2 id="4-3-ExtClassLoader与AppClassLoader"><a href="#4-3-ExtClassLoader与AppClassLoader" class="headerlink" title="4.3. ExtClassLoader与AppClassLoader"></a>4.3. ExtClassLoader与AppClassLoader</h2><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。</p><p>sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116734.png" alt="img"></p><p>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</p><h2 id="4-4-Class-forName-与ClassLoader-loadClass"><a href="#4-4-Class-forName-与ClassLoader-loadClass" class="headerlink" title="4.4. Class.forName()与ClassLoader.loadClass()"></a>4.4. Class.forName()与ClassLoader.loadClass()</h2><p><strong>Class.forName()</strong></p><ul><li><p>Class.forName()：是一个静态方法，最常用的是Class.forName(String className);</p></li><li><p>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，会执行类的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName(<span class="hljs-string">&quot;com.atguigu.java.Helloworld&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul><p><strong>ClassLoader.loadClass()</strong></p><ul><li><p>ClassLoader.loadClass()：这是一个实例方法，需要一个ClassLoader对象来调用该方法。</p></li><li><p>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Classloader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> ......; cl.loadClass(<span class="hljs-string">&quot;com.atguigu.java.Helloworld&quot;</span>);<br></code></pre></td></tr></table></figure><hr/></li></ul><h1 id="5-双亲委派模型"><a href="#5-双亲委派模型" class="headerlink" title="5. 双亲委派模型"></a>5. 双亲委派模型</h1><h2 id="5-1-定义与本质"><a href="#5-1-定义与本质" class="headerlink" title="5.1. 定义与本质"></a>5.1. 定义与本质</h2><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p><p><strong>定义</strong></p><p>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</p><p><strong>本质</strong></p><p>规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116736.png" alt="image-20210501175529542"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116737.png" alt="img"></p><h2 id="5-2-优势与劣势"><a href="#5-2-优势与劣势" class="headerlink" title="5.2. 优势与劣势"></a>5.2. 优势与劣势</h2><p><strong>双亲委派机制优势</strong></p><ul><li><p>避免类的重复加载，确保一个类的全局唯一性</p><p>$\color{red}{Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。}$</p></li><li><p>保护程序安全，防止核心API被随意篡改</p></li></ul><p><strong>代码支持</strong></p><p>双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下：</p><p>（1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p><p>（2）判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</p><p>（3）反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。</p><p>（4）如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</p><p>双亲委派的模型就隐藏在这第2和第3步中。</p><p><strong>举例</strong></p><p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p><p><strong>思考</strong></p><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadclass(String，boolean)方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p><p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)方法，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</p><p><strong>弊端</strong></p><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><p><strong>结论</strong></p><p>$\color{red}{由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。}$比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Serylet规范推荐的一种做法。</p><h2 id="5-3-破坏双亲委派机制"><a href="#5-3-破坏双亲委派机制" class="headerlink" title="5.3. 破坏双亲委派机制"></a>5.3. 破坏双亲委派机制</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p><p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p><p><strong>第一次破坏双亲委派机制</strong></p><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一—即JDK1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，$\color{red}{为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性}$，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><p><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（$\color{red}{越基础的类由越上层的加载器进行加载}$），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有$\color{red}{基础类型又要调用回用户的代码，那该怎么办呢？}$</p><p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，$\color{red}{启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？}$<u>（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</u></p><p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：$\color{red}{线程上下文类加载器（Thread Context ClassLoader）}$。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，$\color{red}{这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则}$，但也是无可奈何的事情。 ，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF&#x2F;services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116738.png" alt="img"></p><p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><p><strong>第三次破坏双亲委派机制</strong></p><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p><p>IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</p><p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p><p>1）$\color{red}{将以java.*开头的类，委派给父类加载器加载。}$</p><p>2）$\color{red}{否则，将委派列表名单内的类，委派给父类加载器加载。}$</p><p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p><p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p><p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p><p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</p><p>7）否则，类查找失败。</p><p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p>小结：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</p><p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p><h2 id="5-4-热替换的实现"><a href="#5-4-热替换的实现" class="headerlink" title="5.4. 热替换的实现"></a>5.4. 热替换的实现</h2><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。$\color{red}{热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。}$基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p><p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p><p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</p><p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116739.png" alt="image-20210501182003439"></p><hr/><h1 id="6-沙箱安全机制"><a href="#6-沙箱安全机制" class="headerlink" title="6. 沙箱安全机制"></a>6. 沙箱安全机制</h1><p>沙箱安全机制</p><ul><li>保证程序安全</li><li>保护Java原生的JDK代码</li></ul><p>$\color{red}{Java安全模型的核心就是Java沙箱（sandbox）}$。什么是沙箱？沙箱是一个限制程序运行的环境。</p><p>沙箱机制就是将Java代码$\color{red}{限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问}$。通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。</p><p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p><h2 id="6-1-JDK1-0时期"><a href="#6-1-JDK1-0时期" class="headerlink" title="6.1. JDK1.0时期"></a>6.1. JDK1.0时期</h2><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于<strong>沙箱（Sandbox）机制</strong>。如下图所示JDK1.0安全模型</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116740.png" alt="image-20210501182608205"></p><h2 id="6-2-JDK1-1时期"><a href="#6-2-JDK1-1时期" class="headerlink" title="6.2. JDK1.1时期"></a>6.2. JDK1.1时期</h2><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p><p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p><p>如下图所示JDK1.1安全模型</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116741.png" alt="image-20210501182626963"></p><h2 id="6-3-JDK1-2时期"><a href="#6-3-JDK1-2时期" class="headerlink" title="6.3. JDK1.2时期"></a>6.3. JDK1.2时期</h2><p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116742.png" alt="image-20210501182652378"></p><h2 id="6-4-JDK1-6时期"><a href="#6-4-JDK1-6时期" class="headerlink" title="6.4. JDK1.6时期"></a>6.4. JDK1.6时期</h2><p>当前最新的安全机制实现，则引入了**域（Domain）**的概念。</p><p>虚拟机会把所有代码加载到不同的系统域和应用域。$\color{red}{系统域部分专门负责与关键资源进行交互}$，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116743.png" alt="image-20210501182740197"></p><hr/><h1 id="7-自定义类的加载器"><a href="#7-自定义类的加载器" class="headerlink" title="7. 自定义类的加载器"></a>7. 自定义类的加载器</h1><h2 id="7-1-为什么要自定义类加载器？"><a href="#7-1-为什么要自定义类加载器？" class="headerlink" title="7.1. 为什么要自定义类加载器？"></a>7.1. 为什么要自定义类加载器？</h2><ul><li><p>$\color{red}{隔离加载类}$</p><p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。</p></li><li><p>$\color{red}{修改类加载的方式}$</p><p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p></li><li><p>$\color{red}{扩展加载源}$</p><p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p></li><li><p>$\color{red}{防止源码泄漏}$</p><p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p></li></ul><p><strong>常见的场景</strong></p><ul><li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</li><li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li></ul><p><strong>注意</strong></p><p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</p><h2 id="7-2-实现方式"><a href="#7-2-实现方式" class="headerlink" title="7.2. 实现方式"></a>7.2. 实现方式</h2><p>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p><p>在自定义ClassLoader的子类时候，我们常见的会有两种做法:</p><ul><li>方式一:重写loadClass()方法</li><li>方式二:重写findclass()方法</li></ul><p><strong>对比</strong></p><ul><li>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</li><li>loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。$\color{red}{因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构}$。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li><li>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</li></ul><p><strong>说明</strong></p><ul><li>其父类加载器是系统类加载器</li><li>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li></ul><hr/><h1 id="8-Java9新特性"><a href="#8-Java9新特性" class="headerlink" title="8. Java9新特性"></a>8. Java9新特性</h1><p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p><ol><li><p>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。</p><p>JDK9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<JAVA_HOME>\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</p></li><li><p>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。</p><p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</p></li></ol><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116744.png" alt="img"></p><p>​如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p><ol start="3"><li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li><li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li><li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li></ol><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116745.png" alt="img"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116746.png" alt="img"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116747.png" alt="img"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116748.png" alt="img"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ClassLoaderTest.class.getClassLoader());<br>        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());<br>        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());<br><br>        <span class="hljs-comment">//获取系统类加载器</span><br>        System.out.println(ClassLoader.getSystemClassLoader());<br>        <span class="hljs-comment">//获取平台类加载器</span><br>        System.out.println(ClassLoader.getPlatformClassLoader());<br>        <span class="hljs-comment">//获取类的加载器的名称</span><br>        System.out.println(ClassLoaderTest.class.getClassLoader().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM中03-类的加载过程</title>
    <link href="/2025/02/27/JVM%E4%B8%AD03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/02/27/JVM%E4%B8%AD03-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 Java 中数据类型分为基本数据类型和引用数据类型。<mark>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</mark></p><p>按照 Java 虚拟机规范，从 class 文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下 7 个阶段：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116436.png" alt="image-20210430215050746"></p><p>其中，验证、准备、解析 3 个部分统称为链接（Linking）</p><p>从程序中类的使用过程看</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116437.png" alt="image-20210430215236716"></p><h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><blockquote><p><mark>蚂蚁金服：</mark></p><p>描述一下 JVM 加载 Class 文件的原理机制？</p><p>一面：类加载过程</p><p><mark>百度：</mark></p><p>类加载的时机</p><p>java 类加载过程？</p><p>简述 java 类加载机制？</p><p><mark>腾讯：</mark></p><p>JVM 中类加载机制，类加载过程？</p><p><mark>滴滴：</mark></p><p>JVM 类加载机制</p><p><mark>美团：</mark></p><p>Java 类加载过程</p><p>描述一下 jvm 加载 class 文件的原理机制</p><p><mark>京东：</mark></p><p>什么是类的加载？</p><p>哪些情况会触发类的加载？</p><p>讲一下 JVM 加载一个类的过程 JVM 的类加载机制是什么？</p></blockquote><hr/><h1 id="2-过程一：Loading（加载）阶段"><a href="#2-过程一：Loading（加载）阶段" class="headerlink" title="2. 过程一：Loading（加载）阶段"></a>2. 过程一：Loading（加载）阶段</h1><h2 id="2-1-加载完成的操作"><a href="#2-1-加载完成的操作" class="headerlink" title="2.1. 加载完成的操作"></a>2.1. 加载完成的操作</h2><p><strong>加载的理解</strong></p><p>$\color{red}{所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象。}$所谓类模板对象，其实就是 Java 类在]VM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样]VM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。</p><p>反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p><p><strong>加载完成的操作</strong></p><p>$\color{red}{加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。}$</p><p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p><ul><li><p>通过类的全名，获取类的二进制数据流。</p></li><li><p>解析类的二进制数据流为方法区内的数据结构（Java 类模型）</p></li><li><p>创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p></li></ul><h2 id="2-2-二进制流的获取方式"><a href="#2-2-二进制流的获取方式" class="headerlink" title="2.2. 二进制流的获取方式"></a>2.2. 二进制流的获取方式</h2><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。<mark>（只要所读取的字节码符合 JVM 规范即可）</mark></p><ul><li>虚拟机可能通过文件系统读入一个 class 后缀的文件$\color{red}{（最常见）}$</li><li>读入 jar、zip 等归档数据包，提取类文件。</li><li>事先存放在数据库中的类的二进制数据</li><li>使用类似于 HTTP 之类的协议通过网络进行加载</li><li>在运行时生成一段 class 的二进制信息等</li><li>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。</li></ul><p>如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><h2 id="2-3-类模型与-Class-实例的位置"><a href="#2-3-类模型与-Class-实例的位置" class="headerlink" title="2.3. 类模型与 Class 实例的位置"></a>2.3. 类模型与 Class 实例的位置</h2><p><strong>类模型的位置</strong></p><p>加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区（JDKl.8 之前：永久代；J0Kl.8 及之后：元空间）。</p><p><strong>Class 实例的位置</strong></p><p>类将.class 文件加载至元空间后，会在堆中创建一个 Java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116438.png" alt="image-20210430221037898"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br><span class="hljs-comment">//获取当前运行时类声明的所有方法</span><br>Method[] ms = clazz.getDecla#FF0000Methods();<br><span class="hljs-keyword">for</span> (Method m : ms) &#123;<br>    <span class="hljs-comment">//获取方法的修饰符</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">mod</span> <span class="hljs-operator">=</span> Modifier.toString(m.getModifiers());<br>    System.out.print(mod + <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">//获取方法的返回值类型</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">returnType</span> <span class="hljs-operator">=</span> (m.getReturnType()).getSimpleName();<br>    System.out.print(returnType + <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">//获取方法名</span><br>    System.out.print(m.getName() + <span class="hljs-string">&quot;(&quot;</span>);<br>    <span class="hljs-comment">//获取方法的参数列表</span><br>    Class&lt;?&gt;[] ps = m.getParameterTypes();<br>    <span class="hljs-keyword">if</span> (ps.length == <span class="hljs-number">0</span>) &#123;<br>        System.out.print(<span class="hljs-string">&#x27;)&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; ps.length; i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> (i == ps.length - <span class="hljs-number">1</span>) ? <span class="hljs-string">&#x27;)&#x27;</span> : <span class="hljs-string">&#x27;,&#x27;</span>;<br>        <span class="hljs-comment">//获取参教的类型</span><br>        System.out.print(ps[i].getSimpleName() + end);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4-数组类的加载"><a href="#2-4-数组类的加载" class="headerlink" title="2.4. 数组类的加载"></a>2.4. 数组类的加载</h2><p>创建数组类的情况稍微有些特殊，因为<mark>数组类本身并不是由类加载器负责创建</mark>，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p><ul><li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型；</li><li>JVM 使用指定的元素类型和数组维度来创建新的数组类。</li></ul><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 public。</p><hr/><h1 id="3-过程二：Linking（链接）阶段"><a href="#3-过程二：Linking（链接）阶段" class="headerlink" title="3. 过程二：Linking（链接）阶段"></a>3. 过程二：Linking（链接）阶段</h1><h2 id="3-1-环节-1：链接阶段之-Verification（验证）"><a href="#3-1-环节-1：链接阶段之-Verification（验证）" class="headerlink" title="3.1. 环节 1：链接阶段之 Verification（验证）"></a>3.1. 环节 1：链接阶段之 Verification（验证）</h2><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p><p>$\color{red}{它的目的是保证加载的字节码是合法、合理并符合规范的。}$</p><p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116439.png" alt="image-20210430221736546"></p><p><strong>整体说明：</strong></p><p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p><ul><li>$\color{red}{其中格式验证会和加载阶段一起执行}$。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li><li>$\color{red}{格式验证之外的验证操作将会在方法区中进行}$。</li></ul><p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p><p><strong>具体说明：</strong></p><ol><li><p><mark>格式验证</mark>：是否以魔数 0XCAFEBABE 开头，主版本和副版本号是否在当前 Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</p></li><li><p><mark>语义检查</mark>：Java 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p><ul><li>是否所有的类都有父类的存在（在 Java 里，除了 object 外，其他类都应该有父类）</li><li>是否一些被定义为 final 的方法或者类被重写或继承了</li><li>非抽象类是否实现了所有抽象方法或者接口方法</li></ul></li><li><p><mark>字节码验证</mark>：Java 虚拟机还会进行字节码验证，$\color{red}{字节码验证也是验证过程中最为复杂的一个过程}$。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</p><ul><li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li><li>函数的调用是否传递了正确类型的参数</li><li>变量的赋值是不是给了正确的数据类型等</li></ul><p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p><p>$\color{red}{在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。}$</p></li><li><p><mark>符号引用的验证</mark>：校验器还将进符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，$\color{red}{虚拟机就会检查这些类或者方法确实是存在的}$，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethodError。此阶段在解析环节才会执行。</p></li></ol><h2 id="3-2-环节-2：链接阶段之-Preparation（准备）"><a href="#3-2-环节-2：链接阶段之-Preparation（准备）" class="headerlink" title="3.2. 环节 2：链接阶段之 Preparation（准备）"></a>3.2. 环节 2：链接阶段之 Preparation（准备）</h2><p>$\color{red}{准备阶段（Preparation），简言之，为类的静态变分配内存，并将其初始化为默认值。}$</p><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java 虚拟机为各类型变量默认的初始值如表所示。</p><table><thead><tr><th align="left">类型</th><th align="left">默认初始值</th></tr></thead><tbody><tr><td align="left">byte</td><td align="left">(byte)0</td></tr><tr><td align="left">short</td><td align="left">(short)0</td></tr><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">long</td><td align="left">0L</td></tr><tr><td align="left">float</td><td align="left">0.0f</td></tr><tr><td align="left">double</td><td align="left">0.0</td></tr><tr><td align="left">char</td><td align="left">\u0000</td></tr><tr><td align="left">boolean</td><td align="left">false</td></tr><tr><td align="left">reference</td><td align="left">null</td></tr></tbody></table><p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故对应的，boolean 的默认值就是 false。</p><p><strong>注意</strong></p><ul><li><p>$\color{red}{这里不包含基本数据类型的字段用static final修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。}$</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello world&quot;</span>;<br><span class="hljs-comment">// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;Hello world&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</p></li><li><p>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</p></li></ul><h2 id="3-3-环节-3：链接阶段之-Resolution（解析）"><a href="#3-3-环节-3：链接阶段之-Resolution（解析）" class="headerlink" title="3.3. 环节 3：链接阶段之 Resolution（解析）"></a>3.3. 环节 3：链接阶段之 Resolution（解析）</h2><p>在准备阶段完成后，就进入了解析阶段。解析阶段（Resolution），简言之，将类、接口、字段和方法的符号引用转为直接引用。</p><p><strong>具体描述</strong>：</p><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在 Class 类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下 println()方法被调用时，系统需要明确知道该方法的位置。</p><p><strong>举例</strong>：</p><p>输出操作 System.out.println()对应的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">invokevirtual #<span class="hljs-number">24</span> &lt;java/io/PrintStream.println&gt;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116440.png" alt="image-20210430225015932"></p><p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。$\color{red}{通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。}$</p><hr/><h1 id="4-过程三：Initialization（初始化）阶段"><a href="#4-过程三：Initialization（初始化）阶段" class="headerlink" title="4. 过程三：Initialization（初始化）阶段"></a>4. 过程三：Initialization（初始化）阶段</h1><h2 id="4-1-static-与-final-的搭配问题"><a href="#4-1-static-与-final-的搭配问题" class="headerlink" title="4.1. static 与 final 的搭配问题"></a>4.1. static 与 final 的搭配问题</h2><p><strong>说明</strong>：使用 static+ final 修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p><ul><li><p>情况 1：在链接阶段的准备环节赋值</p></li><li><p>情况 2：在初始化阶段&lt;clinit&gt;()中赋值</p></li></ul><p><strong>结论</strong>： 在链接阶段的准备环节赋值的情况：</p><ul><li><p>对于基本数据类型的字段来说，如果使用 static final 修饰，则显式赋值(直接赋值常量，而非调用方法通常是在链接阶段的准备环节进行</p></li><li><p>对于 String 来说，如果使用字面量的方式赋值，使用 static final 修饰的话，则显式赋值通常是在链接阶段的准备环节进行</p></li><li><p>在初始化阶段&lt;clinit&gt;()中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</p></li></ul><p><strong>最终结论</strong>：使用 static+final 修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类到或 String 类型的显式财值，是在链接阶段的准备环节进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INT_CONSTANT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;                                <span class="hljs-comment">// 在链接阶段的准备环节赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUM1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>);                  <span class="hljs-comment">// 在初始化阶段clinit&gt;()中赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;                                                  <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">INTEGER_CONSTANT1</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);     <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">INTEGER_CONSTANT2</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">100</span>);           <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中概值</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s0</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;helloworld0&quot;</span>;                            <span class="hljs-comment">// 在链接阶段的准备环节赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;helloworld1&quot;</span>);                <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hellowrold2&quot;</span>;                                  <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span><br></code></pre></td></tr></table></figure><h2 id="4-2-的线程安全性"><a href="#4-2-的线程安全性" class="headerlink" title="4.2. &lt;clinit&gt;()的线程安全性"></a>4.2. &lt;clinit&gt;()的线程安全性</h2><p>对于&lt;clinit&gt;()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p><p>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。</p><p>正是因为$\color{red}{函数<clinit>()带锁线程安全的}$，因此，如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p><p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行&lt;clinit&gt;()方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p><h2 id="4-3-类的初始化情况：主动使用-vs-被动使用"><a href="#4-3-类的初始化情况：主动使用-vs-被动使用" class="headerlink" title="4.3. 类的初始化情况：主动使用 vs 被动使用"></a>4.3. 类的初始化情况：主动使用 vs 被动使用</h2><p>Java 程序对类的使用分为两种：主动使用和被动使用。</p><p><strong>主动使用</strong></p><p>Class 只有在必须要首次使用的时候才会被装载，Java 虚拟机不会无条件地装载 Class 类型。Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p><ol><li><p><mark>实例化</mark>：当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 反序列化</span><br><span class="hljs-comment"> */</span><br>Class Order <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Order类的初始化&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 序列化</span><br>        oos = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;order.dat&quot;</span>));<br>        oos.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>());<br>        <span class="hljs-comment">// 反序列化</span><br>        ois = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;order.dat&quot;</span>));<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> ois.readObject();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (ClassNotFoundException e)&#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (oos != <span class="hljs-literal">null</span>) &#123;<br>                oos.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ois != <span class="hljs-literal">null</span>) &#123;<br>                ois.close();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><mark>静态方法</mark>：当调用类的静态方法时，即当使用了字节码 invokestatic 指令。</p></li><li><p><mark>静态字段</mark>：当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量、赋值变量操作）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActiveUse</span> &#123;<br><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(User.num);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;User类的初始化&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><mark>反射</mark>：当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”)</p></li><li><p><mark>继承</mark>：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p><blockquote><p>当 Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li><li>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</li></ul></blockquote></li><li><p><mark>default 方法</mark>：如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Compare</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;Compare接口的初始化&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><mark>main 方法</mark>：当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。</p><blockquote><p>VM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p></blockquote></li><li><p><mark>MethodHandle<mark>：当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析 REF getStatic、REF_putStatic、REF invokeStatic 方法句柄对应的类）</p></li></ol><p><strong>被动使用</strong></p><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。$\color{red}{被动使用不会引起类的初始化。}$</p><p>也就是说：$\color{red}{并不是在代码中出现的类，就一定会被加载或者初始化。}$如果不符合主动使用的条件，类就不会初始化。</p><ol><li><p><mark>静态字段</mark>：当通过子类引用父类的静态变量，不会导致子类初始化，只有真正声明这个字段的类才会被初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassiveUse</span> &#123;<br> <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Child.num);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child类的初始化&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Parent类的初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><mark>数组定义</mark>：通过数组定义类引用，不会触发此类的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Parent[] parents= <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>[<span class="hljs-number">10</span>];<br>System.out.println(parents.getClass());<br><span class="hljs-comment">// new的话才会初始化</span><br>parents[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Parent</span>();<br></code></pre></td></tr></table></figure></li><li><p><mark>引用常量</mark>：引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassiveUse</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(Serival.num);<br>        <span class="hljs-comment">// 但引用其他类的话还是会初始化</span><br>        System.out.println(Serival.num2);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Serival</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;Serival初始化&quot;</span>);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><mark>loadClass 方法</mark>：调用 ClassLoader 类的 loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clazz</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="hljs-string">&quot;com.test.java.Person&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><p><strong>扩展</strong></p><blockquote><p>-XX:+TraceClassLoading：追踪打印类的加载信息</p></blockquote><hr/><h1 id="5-过程四：类的-Using（使用）"><a href="#5-过程四：类的-Using（使用）" class="headerlink" title="5. 过程四：类的 Using（使用）"></a>5. 过程四：类的 Using（使用）</h1><p>任何一个类型在使用之前都必须经历过完整的加载、链接和初始化 3 个类加载步骤。一旦一个类型成功经历过这 3 个步骤之后，便“厉事俱备只欠东风”，就等着开发者使用了。</p><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用 new 关键字为其创建对象实例。</p><hr/><h1 id="6-过程五：类的-Unloading（卸载）"><a href="#6-过程五：类的-Unloading（卸载）" class="headerlink" title="6. 过程五：类的 Unloading（卸载）"></a>6. 过程五：类的 Unloading（卸载）</h1><h2 id="6-1-类、类的加载器、类的实例之间的引用关系"><a href="#6-1-类、类的加载器、类的实例之间的引用关系" class="headerlink" title="6.1. 类、类的加载器、类的实例之间的引用关系"></a>6.1. 类、类的加载器、类的实例之间的引用关系</h2><p>在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器，调用 Class 对象的 getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为双向关联关系。</p><p>一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 getClass()方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 java 类都有一个静态属性 class，它引用代表这个类的 Class 对象。</p><h2 id="6-2-类的生命周期"><a href="#6-2-类的生命周期" class="headerlink" title="6.2.类的生命周期"></a>6.2.类的生命周期</h2><p>当 Sample 类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，即不可触及时，Class 对象就会结束生命周期，Sample 类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期。</p><p>$\color{red}{一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。}$</p><h2 id="6-3-具体例子"><a href="#6-3-具体例子" class="headerlink" title="6.3. 具体例子"></a>6.3. 具体例子</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271116441.png" alt="image-20210430235455086"></p><p>loader1 变量和 obj 变量间接应用代表 Sample 类的 Class 对象，而 objClass 变量则直接引用它。</p><p>如果程序运行过程中，将上图左侧三个引用变量都置为 null，此时 Sample 对象结束生命周期，MyClassLoader 对象结束生命周期，代表 Sample 类的 Class 对象也结束生命周期，Sample 类在方法区内的二进制数据被卸载。</p><p>当再次有需要时，会检查 Sample 类的 Class 对象是否存在，如果存在会直接使用，不再重新加载；如果不存在 Sample 类会被重新加载，在 Java 虚拟机的堆区会生成一个新的代表 Sample 类的 Class 实例（可以通过哈希码查看是否是同一个实例）</p><h2 id="6-4-类的卸载"><a href="#6-4-类的卸载" class="headerlink" title="6.4. 类的卸载"></a>6.4. 类的卸载</h2><p>（1）启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm 和 jls 规范）</p><p>（2）被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小。</p><p>（3）被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</p><p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p><h2 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h2><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li>$\color{blue}{该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。}$</li><li>$\color{blue}{加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。}$</li><li>$\color{blue}{该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。}$</li></ul><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p><hr/>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM中02-字节码指令集</title>
    <link href="/2025/02/27/JVM%E4%B8%AD02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    <url>/2025/02/27/JVM%E4%B8%AD02-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115617.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115618.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115619.png" alt="img"></p><h1 id="2-加载与存储指令"><a href="#2-加载与存储指令" class="headerlink" title="2. 加载与存储指令"></a>2. 加载与存储指令</h1><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115620.png" alt="0ca8044c-f78d-4787-aeac-c986a35f9cdf"><br><img src="https://gitee.com/vectorx/ImageCloud/raw/master/img/20210424190846.png" alt="16e3afaf-b7d8-4a23-8897-9fe02586aafd"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115621.png" alt="08e01fd0-a33e-47e4-8fd2-34c2935db71d"></p><hr/><h2 id="2-1-局部变量压栈指令"><a href="#2-1-局部变量压栈指令" class="headerlink" title="2.1. 局部变量压栈指令"></a>2.1. 局部变量压栈指令</h2><blockquote><p>iload 从局部变量中装载int类型值</p><p>lload 从局部变量中装载long类型值</p><p>fload 从局部变量中装载float类型值</p><p>dload 从局部变量中装载double类型值</p><p>aload 从局部变量中装载引用类型值（refernce）</p><p>iload_0 从局部变量0中装载int类型值</p><p>iload_1 从局部变量1中装载int类型值</p><p>iload_2 从局部变量2中装载int类型值</p><p>iload_3 从局部变量3中装载int类型值</p><p>lload_0 从局部变量0中装载long类型值</p><p>lload_1 从局部变量1中装载long类型值</p><p>lload_2 从局部变量2中装载long类型值</p><p>lload_3 从局部变量3中装载long类型值</p><p>fload_0 从局部变量0中装载float类型值</p><p>fload_1 从局部变量1中装载float类型值</p><p>fload_2 从局部变量2中装载float类型值</p><p>fload_3 从局部变量3中装载float类型值</p><p>dload_0 从局部变量0中装载double类型值</p><p>dload_1 从局部变量1中装载double类型值</p><p>dload_2 从局部变量2中装载double类型值</p><p>dload_3 从局部变量3中装载double类型值</p><p>aload_0 从局部变量0中装载引用类型值</p><p>aload_1 从局部变量1中装载引用类型值</p><p>aload_2 从局部变量2中装载引用类型值</p><p>aload_3 从局部变量3中装载引用类型值</p><p>iaload 从数组中装载int类型值</p><p>laload 从数组中装载long类型值</p><p>faload 从数组中装载float类型值</p><p>daload 从数组中装载double类型值</p><p>aaload 从数组中装载引用类型值</p><p>baload 从数组中装载byte类型或boolean类型值</p><p>caload 从数组中装载char类型值</p><p>saload 从数组中装载short类型值</p></blockquote><h2 id="局部变量压栈常用指令集"><a href="#局部变量压栈常用指令集" class="headerlink" title="局部变量压栈常用指令集"></a>局部变量压栈常用指令集</h2><table><thead><tr><th>xload_n</th><th>xload_0</th><th>xload_1</th><th>xload_2</th><th>xload_3</th></tr></thead><tbody><tr><td><b>iload_n</b></td><td>iload_0</td><td>iload_1</td><td>iload_2</td><td>iload_3</td></tr><tr><td><b>lload_n</b></td><td>lload_0</td><td>lload_1</td><td>lload_2</td><td>lload_3</td></tr><tr><td><b>fload_n</b></td><td>fload_0</td><td>fload_1</td><td>fload_2</td><td>fload_3</td></tr><tr><td><b>dload_n</b></td><td>dload_0</td><td>dload_1</td><td>dload_2</td><td>dload_3</td></tr><tr><td><b>aload_n</b></td><td>aload_0</td><td>aload_1</td><td>aload_2</td><td>aload_3</td></tr></tbody></table><h2 id="局部变量压栈指令剖析"><a href="#局部变量压栈指令剖析" class="headerlink" title="局部变量压栈指令剖析"></a>局部变量压栈指令剖析</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115622.png" alt="1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">(<span class="hljs-type">int</span> num, Object obj, <span class="hljs-type">long</span> count, <span class="hljs-type">boolean</span> flag, <span class="hljs-type">short</span>[] arr)</span> &#123;<br>System.out.println(num);<br>    System.out.println(obj);<br>    System.out.println(count);<br>    System.out.println(flag);<br>    System.out.println(arr);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115623.png" alt="3"></p><hr/><h2 id="2-2-常量入栈指令"><a href="#2-2-常量入栈指令" class="headerlink" title="2.2. 常量入栈指令"></a>2.2. 常量入栈指令</h2><blockquote><p>aconst_null 将null对象引用压入栈</p><p>iconst_m1 将int类型常量-1压入栈</p><p>iconst_0 将int类型常量0压入栈</p><p>iconst_1 将int类型常量1压入栈</p><p>iconst_2 将int类型常量2压入栈</p><p>iconst_3 将int类型常量3压入栈</p><p>iconst_4 将int类型常量4压入栈</p><p>iconst_5 将int类型常量5压入栈</p><p>lconst_0 将long类型常量0压入栈</p><p>lconst_1 将long类型常量1压入栈</p><p>fconst_0 将float类型常量0压入栈</p><p>fconst_1 将float类型常量1压入栈</p><p>dconst_0 将double类型常量0压入栈</p><p>dconst_1 将double类型常量1压入栈</p><p>bipush 将一个8位带符号整数压入栈</p><p>sipush 将16位带符号整数压入栈</p><p>ldc 把常量池中的项压入栈</p><p>ldc_w 把常量池中的项压入栈（使用宽索引）</p><p>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</p></blockquote><h2 id="常量入栈常用指令集"><a href="#常量入栈常用指令集" class="headerlink" title="常量入栈常用指令集"></a>常量入栈常用指令集</h2><table><thead><tr><th align="center">xconst_n</th><th>范围</th><th>xconst_null</th><th align="center">xconst_m1</th><th align="center">xconst_0</th><th align="center">xconst_1</th><th align="center">xconst_2</th><th align="center">xconst_3</th><th align="center">xconst_4</th><th align="center">xconst_5</th></tr></thead><tbody><tr><td align="center"><strong>iconst_n</strong></td><td>[-1, 5]</td><td></td><td align="center">iconst_m1</td><td align="center">iconst_0</td><td align="center">iconst_1</td><td align="center">iconst_2</td><td align="center">iconst_3</td><td align="center">iconst_4</td><td align="center">iconst_5</td></tr><tr><td align="center"><strong>lconst_n</strong></td><td>0, 1</td><td></td><td align="center"></td><td align="center">lconst_0</td><td align="center">lconst_1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>fconst_n</strong></td><td>0, 1, 2</td><td></td><td align="center"></td><td align="center">fconst_0</td><td align="center">fconst_1</td><td align="center">fconst_2</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>dconst_n</strong></td><td>0, 1</td><td></td><td align="center"></td><td align="center">dconst_0</td><td align="center">dconst_1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>aconst_n</strong></td><td>null, String literal, Class literal</td><td>aconst_null</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>bipush</strong></td><td>一个字节，2^8^，[-2^7^, 2^7^ - 1]，即[-128, 127]</td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>sipush</strong></td><td>两个字节，2^16^，[-2^15^, 2^15^ - 1]，即[-32768, 32767]</td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>ldc</strong></td><td>四个字节，2^32^，[-2^31^, 2^31^ - 1]</td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>ldc_w</strong></td><td>宽索引</td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>ldc2_w</strong></td><td>宽索引，long或double</td><td></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="常量入栈指令剖析"><a href="#常量入栈指令剖析" class="headerlink" title="常量入栈指令剖析"></a>常量入栈指令剖析</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115624.png" alt="437a717e-98e2-4847-b52e-e6632d0745a4"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115625.png" alt="ffd7246e-2e46-41e0-9fd6-1e65ace5dbd1"></p><table>    <tbody>          <tr>            <th>类型</th>             <th>常数指令</th>             <th>范围</th>        </tr>       <tr>            <td rowspan="4">int(boolean,byte,char,short)</td>            <td>iconst</td>            <td>[-1, 5]</td>       </tr>       <tr>            <td>bipush</td>            <td>[-128, 127]</td>       </tr>       <tr>            <td>sipush</td>            <td>[-32768, 32767]</td>       </tr>        <tr>            <td>ldc</td>            <td>any int value</td>       </tr>       <tr>            <td rowspan="2">long</td>            <td>lconst</td>            <td>0, 1</td>       </tr>       <tr>            <td>ldc</td>            <td>any long value</td>       </tr>       <tr>            <td rowspan="2">float</td>            <td>fconst</td>            <td>0, 1, 2</td>       </tr>       <tr>            <td>ldc</td>            <td>any float value</td>       </tr>       <tr>            <td rowspan="2">double</td>            <td>dconst</td>            <td>0, 1</td>       </tr>       <tr>            <td>ldc</td>            <td>any double value</td>       </tr>        <tr>            <td rowspan="2">reference</td>            <td>aconst</td>            <td>null</td>       </tr>       <tr>            <td>ldc</td>            <td>String literal, Class literal</td>       </tr>   <tbody> </table><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115626.png" alt="566b9397-5afe-4a3f-9e17-9ebf504dfc80"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115627.png" alt="b59702d2-4c93-44df-87f1-01a5dfe53b61"></p><hr/><h2 id="2-3-出栈装入局部变量表指令"><a href="#2-3-出栈装入局部变量表指令" class="headerlink" title="2.3. 出栈装入局部变量表指令"></a>2.3. 出栈装入局部变量表指令</h2><blockquote><p>istore 将int类型值存入局部变量</p><p>lstore 将long类型值存入局部变量</p><p>fstore 将float类型值存入局部变量</p><p>dstore 将double类型值存入局部变量</p><p>astore 将将引用类型或returnAddress类型值存入局部变量</p><p>istore_0 将int类型值存入局部变量0</p><p>istore_1 将int类型值存入局部变量1</p><p>istore_2 将int类型值存入局部变量2</p><p>istore_3 将int类型值存入局部变量3</p><p>lstore_0 将long类型值存入局部变量0</p><p>lstore_1 将long类型值存入局部变量1</p><p>lstore_2 将long类型值存入局部变量2</p><p>lstore_3 将long类型值存入局部变量3</p><p>fstore_0 将float类型值存入局部变量0</p><p>fstore_1 将float类型值存入局部变量1</p><p>fstore_2 将float类型值存入局部变量2</p><p>fstore_3 将float类型值存入局部变量3</p><p>dstore_0 将double类型值存入局部变量0</p><p>dstore_1 将double类型值存入局部变量1</p><p>dstore_2 将double类型值存入局部变量2</p><p>dstore_3 将double类型值存入局部变量3</p><p>astore_0 将引用类型或returnAddress类型值存入局部变量0</p><p>astore_1 将引用类型或returnAddress类型值存入局部变量1</p><p>astore_2 将引用类型或returnAddress类型值存入局部变量2</p><p>astore_3 将引用类型或returnAddress类型值存入局部变量3</p><p>iastore 将int类型值存入数组中</p><p>lastore 将long类型值存入数组中</p><p>fastore 将float类型值存入数组中</p><p>dastore 将double类型值存入数组中</p><p>aastore 将引用类型值存入数组中</p><p>bastore 将byte类型或者boolean类型值存入数组中</p><p>castore 将char类型值存入数组中</p><p>sastore 将short类型值存入数组中</p><p>wide指令</p><p>wide 使用附加字节扩展局部变量索引</p></blockquote><h2 id="出栈装入局部变量表常用指令集"><a href="#出栈装入局部变量表常用指令集" class="headerlink" title="出栈装入局部变量表常用指令集"></a>出栈装入局部变量表常用指令集</h2><table><thead><tr><th align="center">xstore_n</th><th align="center">xstore_0</th><th align="center">xstore_1</th><th align="center">xstore_2</th><th align="center">xstore_3</th></tr></thead><tbody><tr><td align="center"><strong>istore_n</strong></td><td align="center">istore_0</td><td align="center">istore_1</td><td align="center">istore_2</td><td align="center">istore_3</td></tr><tr><td align="center"><strong>lstore_n</strong></td><td align="center">lstore_0</td><td align="center">lstore_1</td><td align="center">lstore_2</td><td align="center">lstore_3</td></tr><tr><td align="center"><strong>fstore_n</strong></td><td align="center">fstore_0</td><td align="center">fstore_1</td><td align="center">fstore_2</td><td align="center">fstore_3</td></tr><tr><td align="center"><strong>dstore_n</strong></td><td align="center">dstore_0</td><td align="center">dstore_1</td><td align="center">dstore_2</td><td align="center">dstore_3</td></tr><tr><td align="center"><strong>astore_n</strong></td><td align="center">astore_0</td><td align="center">astore_1</td><td align="center">astore_2</td><td align="center">astore_3</td></tr></tbody></table><h2 id="出栈装入局部变量表指令剖析"><a href="#出栈装入局部变量表指令剖析" class="headerlink" title="出栈装入局部变量表指令剖析"></a>出栈装入局部变量表指令剖析</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115628.png" alt="1"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115629.png" alt="2"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115630.png" alt="3"></p><hr/><h1 id="3-算术指令"><a href="#3-算术指令" class="headerlink" title="3. 算术指令"></a>3. 算术指令</h1><blockquote><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>iadd 执行int类型的加法</p><p>ladd 执行long类型的加法</p><p>isub 执行int类型的减法</p><p>lsub 执行long类型的减法</p><p>imul 执行int类型的乘法</p><p>lmul 执行long类型的乘法</p><p>idiv 执行int类型的除法</p><p>ldiv 执行long类型的除法</p><p>irem 计算int类型除法的余数</p><p>lrem 计算long类型除法的余数</p><p>ineg 对一个int类型值进行取反操作</p><p>lneg 对一个long类型值进行取反操作</p><p>iinc 把一个常量值加到一个int类型的局部变量上</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>ishl 执行int类型的向左移位操作</p><p>lshl 执行long类型的向左移位操作</p><p>ishr 执行int类型的向右移位操作</p><p>lshr 执行long类型的向右移位操作</p><p>iushr 执行int类型的向右逻辑移位操作</p><p>lushr 执行long类型的向右逻辑移位操作</p><h3 id="按位布尔运算"><a href="#按位布尔运算" class="headerlink" title="按位布尔运算"></a>按位布尔运算</h3><p>iand 对int类型值进行“逻辑与”操作</p><p>land 对long类型值进行“逻辑与”操作</p><p>ior 对int类型值进行“逻辑或”操作</p><p>lor 对long类型值进行“逻辑或”操作</p><p>ixor 对int类型值进行“逻辑异或”操作</p><p>lxor 对long类型值进行“逻辑异或”操作</p><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>fadd 执行float类型的加法</p><p>dadd 执行double类型的加法</p><p>fsub 执行float类型的减法</p><p>dsub 执行double类型的减法</p><p>fmul 执行float类型的乘法</p><p>dmul 执行double类型的乘法</p><p>fdiv 执行float类型的除法</p><p>ddiv 执行double类型的除法</p><p>frem 计算float类型除法的余数</p><p>drem 计算double类型除法的余数</p><p>fneg 将一个float类型的数值取反</p><p>dneg 将一个double类型的数值取反</p></blockquote><h2 id="算术指令集"><a href="#算术指令集" class="headerlink" title="算术指令集"></a>算术指令集</h2><table>    <tbody>          <tr>            <th colspan="2">算数指令</th>             <th>int(boolean,byte,char,short)</th>             <th>long</th>            <th>float</th>       <th>double</th>        </tr>       <tr>            <td colspan="2">加法指令</td>            <td>iadd</td>            <td>ladd</td>            <td>fadd</td>            <td>dadd</td>       </tr>       <tr>            <td colspan="2">减法指令</td>            <td>isub</td>            <td>lsub</td>            <td>fsub</td>            <td>dsub</td>       </tr>        <tr>            <td colspan="2">乘法指令</td>            <td>imul</td>            <td>lmul</td>            <td>fmul</td>            <td>dmul</td>       </tr>        <tr>            <td colspan="2">除法指令</td>            <td>idiv</td>            <td>ldiv</td>            <td>fdiv</td>            <td>ddiv</td>       </tr>       <tr>            <td colspan="2">求余指令</td>            <td>irem</td>            <td>lrem</td>            <td>frem</td>            <td>drem</td>       </tr>       <tr>            <td colspan="2">取反指令</td>            <td>ineg</td>            <td>lneg</td>            <td>fneg</td>            <td>dneg</td>       </tr>       <tr>            <td colspan="2">自增指令</td>            <td>iinc</td>            <td></td>            <td></td>            <td></td>       </tr>       <tr>            <td rowspan="4">位运算指令</td>            <td>按位或指令</td>            <td>ior</td>            <td>lor</td>            <td></td>            <td></td>       </tr>        <tr>            <td>按位或指令</td>            <td>ior</td>            <td>lor</td>            <td></td>            <td></td>       </tr>        <tr>            <td>按位与指令</td>            <td>iand</td>            <td>land</td>            <td></td>            <td></td>       </tr>       <tr>            <td>按位异或指令</td>            <td>ixor</td>            <td>lxor</td>            <td></td>            <td></td>       </tr>        <tr>            <td colspan="2">比较指令</td>            <td></td>            <td>lcmp</td>            <td>fcmpg / fcmpl</td>            <td>dcmpg / dcmpl</td>       </tr>    <tbody> </table><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115631.png"></p><blockquote><p>注意：NaN(Not a Number)表示不是一个数字</p></blockquote><h2 id="算术指令举例"><a href="#算术指令举例" class="headerlink" title="算术指令举例"></a>算术指令举例</h2><h3 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bar</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br><span class="hljs-keyword">return</span> ((i + <span class="hljs-number">1</span>) - <span class="hljs-number">2</span>) * <span class="hljs-number">3</span> / <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115632.png" alt="a54c2ac8-dd36-49f4-a49d-9afd725e8365"></p><h3 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">byte</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115633.png" alt="image-20210424210710750"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115634.png" alt="2"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115635.png" alt="3"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115636.gif" alt="img"></p><h3 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x / y;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>System.out.println(a + b);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115637.png" alt="c43c0407-020f-4ec4-bd27-e4c109640b39"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115638.png" alt="04282df1-4e52-4c3d-a47b-84023159b624"></p><hr/><h1 id="4-类型转换指令"><a href="#4-类型转换指令" class="headerlink" title="4. 类型转换指令"></a>4. 类型转换指令</h1><blockquote><h2 id="宽化类型转换"><a href="#宽化类型转换" class="headerlink" title="宽化类型转换"></a>宽化类型转换</h2><p>i2l 把int类型的数据转化为long类型</p><p>i2f 把int类型的数据转化为float类型</p><p>i2d 把int类型的数据转化为double类型</p><p>l2f 把long类型的数据转化为float类型</p><p>l2d 把long类型的数据转化为double类型</p><p>f2d 把float类型的数据转化为double类型</p><h2 id="窄化类型转换"><a href="#窄化类型转换" class="headerlink" title="窄化类型转换"></a>窄化类型转换</h2><p>i2b 把int类型的数据转化为byte类型</p><p>i2c 把int类型的数据转化为char类型</p><p>i2s 把int类型的数据转化为short类型</p><p>l2i 把long类型的数据转化为int类型</p><p>f2i 把float类型的数据转化为int类型</p><p>f2l 把float类型的数据转化为long类型</p><p>d2i 把double类型的数据转化为int类型</p><p>d2l 把double类型的数据转化为long类型</p><p>d2f 把double类型的数据转化为float类型</p></blockquote><table><thead><tr><th align="center"></th><th align="center"><strong>byte</strong></th><th align="center"><strong>char</strong></th><th align="center"><strong>short</strong></th><th align="center"><strong>int</strong></th><th align="center"><strong>long</strong></th><th align="center"><strong>float</strong></th><th align="center"><strong>double</strong></th></tr></thead><tbody><tr><td align="center"><strong>int</strong></td><td align="center">i2b</td><td align="center">i2c</td><td align="center">i2s</td><td align="center">○</td><td align="center">i2l</td><td align="center">i2f</td><td align="center">i2d</td></tr><tr><td align="center"><strong>long</strong></td><td align="center">l2i i2b</td><td align="center">l2i i2c</td><td align="center">l2i i2s</td><td align="center">l2i</td><td align="center">○</td><td align="center">l2f</td><td align="center">l2d</td></tr><tr><td align="center"><strong>float</strong></td><td align="center">f2i i2b</td><td align="center">f2i i2c</td><td align="center">f2i i2s</td><td align="center">f2i</td><td align="center">f2l</td><td align="center">○</td><td align="center">f2d</td></tr><tr><td align="center"><strong>double</strong></td><td align="center">d2i i2b</td><td align="center">d2i i2c</td><td align="center">d2i i2s</td><td align="center">d2i</td><td align="center">d2l</td><td align="center">d2f</td><td align="center">○</td></tr></tbody></table><p>类型转换指令可以将两种不同的数值类型进行相互转换。这些转换操作一般用于实现用户代码中的显式类型转換操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p><h2 id="4-1-宽化类型转换剖析"><a href="#4-1-宽化类型转换剖析" class="headerlink" title="4.1. 宽化类型转换剖析"></a>4.1. 宽化类型转换剖析</h2><blockquote><p>宽化类型转换( Widening Numeric Conversions)</p><ol><li>转换规则</li></ol><p>Java虚拟机直接支持以下数值的宽化类型转换（ widening numeric conversion,小范围类型向大范围类型的安全转换）。也就是说，并不需要指令执行，包括</p><blockquote><p>从int类型到long、float或者 double类型。对应的指令为：i21、i2f、i2d</p><p>从long类型到float、 double类型。对应的指令为：i2f、i2d</p><p>从float类型到double类型。对应的指令为：f2d</p></blockquote><p>简化为：int–&gt;long–&gt;float-&gt; double</p><ol start="2"><li>精度损失问题</li></ol><blockquote><p>2.1. 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long,或者从int转换到double,都不会丢失任何信息，转换前后的值是精确相等的。</p><p>2.2. 从int、long类型数值转换到float,或者long类型数值转换到double时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近含入模式所得到的正确整数值。</p></blockquote><p>尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致Java虚拟机抛出运行时异常</p><ol start="3"><li>补充说明</li></ol><p>从byte、char和 short类型到int类型的宽化类型转换实际上是不存在的。对于byte类型转为int,拟机并没有做实质性的转化处理，只是简单地通过操作数栈交換了两个数据。而将byte转为long时，使用的是i2l,可以看到在内部，byte在这里已经等同于int类型处理，类似的还有 short类型，这种处理方式有两个特点：</p><p>一方面可以减少实际的数据类型，如果为 short和byte都准备一套指令，那么指令的数量就会大増，而虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short和byte当做int处理也在情理之中。</p><p>另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者 short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p></blockquote><h2 id="4-2-窄化类型转换剖析"><a href="#4-2-窄化类型转换剖析" class="headerlink" title="4.2. 窄化类型转换剖析"></a>4.2. 窄化类型转换剖析</h2><blockquote><p>窄化类型转换( Narrowing Numeric Conversion)</p><ol><li>转换规则</li></ol><p>Java虚拟机也直接支持以下窄化类型转换：</p><blockquote><p>从主int类型至byte、 short或者char类型。对应的指令有：i2b、i2c、i2s</p><p>从long类型到int类型。对应的指令有：l2i</p><p>从float类型到int或者long类型。对应的指令有：f2i、f2l</p><p>从double类型到int、long或者float类型。对应的指令有：d2i、d2l、d2f</p></blockquote><ol start="2"><li>精度损失问题</li></ol><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p><ol start="3"><li>补充说明</li></ol><blockquote><p>3.1. 当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则：</p><blockquote><p>如果浮点值是NaN,那转换结果就是int或long类型的0.</p><p>如果浮点值不是无穷大的话，浮点值使用IEEE754的向零含入模式取整，获得整数值Vv如果v在目标类型T(int或long)的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数</p></blockquote><p>3.2. 当将一个double类型窄化转换为float类型时，将遵循以下转换规则</p><blockquote><p>通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断</p><p>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零</p><p>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大。</p><p>对于double类型的NaN值将按规定转換为float类型的NaN值。</p></blockquote></blockquote></blockquote><hr/><h1 id="5-对象的创建与访问指令"><a href="#5-对象的创建与访问指令" class="headerlink" title="5. 对象的创建与访问指令"></a>5. 对象的创建与访问指令</h1><blockquote><h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><p>new 创建一个新对象</p><p>getfield 从对象中获取字段</p><p>putfield 设置对象中字段的值</p><p>getstatic 从类中获取静态字段</p><p>putstatic 设置类中静态字段的值</p><p>checkcast 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。如果不是便抛出异常</p><p>instanceof 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 &#x2F; 接口的实例。是则压入 1，否则压入 0</p><h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><p>newarray 分配数据成员类型为基本上数据类型的新数组</p><p>anewarray 分配数据成员类型为引用类型的新数组</p><p>arraylength 获取数组长度</p><p>multianewarray 分配新的多维数组</p></blockquote><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p><h2 id="5-1-创建指令"><a href="#5-1-创建指令" class="headerlink" title="5.1. 创建指令"></a>5.1. 创建指令</h2><table><thead><tr><th align="left">创建指令</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">new</td><td align="left">创建类实例</td></tr><tr><td align="left">newarray</td><td align="left">创建基本类型数组</td></tr><tr><td align="left">anewarray</td><td align="left">创建引用类型数组</td></tr><tr><td align="left">multilanewarra</td><td align="left">创建多维数组</td></tr></tbody></table><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115639.png" alt="img"></p><h2 id="5-2-字段访问指令"><a href="#5-2-字段访问指令" class="headerlink" title="5.2. 字段访问指令"></a>5.2. 字段访问指令</h2><table><thead><tr><th align="left">字段访问指令</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">getstatic、putstatic</td><td align="left">访问类字段（static字段，或者称为类变量）的指令</td></tr><tr><td align="left">getfield、 putfield</td><td align="left">访问类实例字段（非static字段，或者称为实例变量）的指令</td></tr></tbody></table><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115640.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115641.png" alt="img"></p><h2 id="5-3-数组操作指令"><a href="#5-3-数组操作指令" class="headerlink" title="5.3. 数组操作指令"></a>5.3. 数组操作指令</h2><table><thead><tr><th>数组指令</th><th>byte(boolean)</th><th>char</th><th>short</th><th>long</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td><strong>xaload</strong></td><td>baload</td><td>caload</td><td>saload</td><td>iaload</td><td>laload</td><td>faload</td><td>daload</td><td>aaload</td></tr><tr><td><strong>xastore</strong></td><td>bastore</td><td>castore</td><td>sastore</td><td>iastore</td><td>lastore</td><td>fastore</td><td>dastore</td><td>aastore</td></tr></tbody></table><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115642.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115643.png" alt="img"></p><h2 id="5-4-类型检查指令"><a href="#5-4-类型检查指令" class="headerlink" title="5.4. 类型检查指令"></a>5.4. 类型检查指令</h2><table><thead><tr><th>类型检查指令</th><th>含义</th></tr></thead><tbody><tr><td>instanceof</td><td>检查类型强制转换是否可以进行</td></tr><tr><td>checkcast</td><td>判断给定对象是否是某一个类的实例</td></tr></tbody></table><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115644.png" alt="img"></p><hr/><h1 id="6-方法调用与返回指令"><a href="#6-方法调用与返回指令" class="headerlink" title="6. 方法调用与返回指令"></a>6. 方法调用与返回指令</h1><blockquote><h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><p>invokcvirtual 运行时按照对象的类来调用实例方法</p><p>invokespecial 根据编译时类型来调用实例方法</p><p>invokestatic 调用类（静态）方法</p><p>invokcinterface 调用接口方法</p><h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><p>ireturn 从方法中返回int类型的数据</p><p>lreturn 从方法中返回long类型的数据</p><p>freturn 从方法中返回float类型的数据</p><p>dreturn 从方法中返回double类型的数据</p><p>areturn 从方法中返回引用类型的数据</p><p>return 从方法中返回，返回值为void</p></blockquote><h2 id="6-1-方法调用指令"><a href="#6-1-方法调用指令" class="headerlink" title="6.1. 方法调用指令"></a>6.1. 方法调用指令</h2><table><thead><tr><th>方法调用指令</th><th>含义</th></tr></thead><tbody><tr><td>invokevirtual</td><td>调用对象的实例方法</td></tr><tr><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>invokespecial</td><td>调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法</td></tr><tr><td>invokestatic</td><td>调用命名类中的类方法（static方法）</td></tr><tr><td>invokedynamic</td><td>调用动态绑定的方法</td></tr></tbody></table><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115645.png" alt="img"></p><h2 id="6-2-方法返回指令"><a href="#6-2-方法返回指令" class="headerlink" title="6.2. 方法返回指令"></a>6.2. 方法返回指令</h2><table><thead><tr><th>方法返回指令</th><th>void</th><th>int</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td><strong>xreturn</strong></td><td>return</td><td>ireturn</td><td>lreturn</td><td>freutrn</td><td>dreturn</td><td>areturn</td></tr></tbody></table><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115646.png" alt="image-20210425222017858"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115647.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">methodReturn</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>    <br>    <span class="hljs-keyword">return</span> (i + j) / k;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115648.png" alt="image-20210425222245665"></p><hr/><h1 id="7-操作数栈管理指令"><a href="#7-操作数栈管理指令" class="headerlink" title="7. 操作数栈管理指令"></a>7. 操作数栈管理指令</h1><blockquote><h2 id="通用-无类型）栈操作"><a href="#通用-无类型）栈操作" class="headerlink" title="通用(无类型）栈操作"></a>通用(无类型）栈操作</h2><p>nop 不做任何操作</p><p>pop 弹出栈顶端一个字长的内容</p><p>pop2 弹出栈顶端两个字长的内容</p><p>dup 复制栈顶部一个字长内容</p><p>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈</p><p>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p><p>dup2 复制栈顶部两个字长内容</p><p>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p><p>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈</p><p>swap 交换栈顶部两个字长内容</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115649.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115650.png" alt="img"></p><hr/><h1 id="8-控制转移指令"><a href="#8-控制转移指令" class="headerlink" title="8. 控制转移指令"></a>8. 控制转移指令</h1><blockquote><h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><p>lcmp 比较long类型值</p><p>fcmpl 比较float类型值（当遇到NaN时，返回-1）</p><p>fcmpg 比较float类型值（当遇到NaN时，返回1）</p><p>dcmpl 比较double类型值（当遇到NaN时，返回-1）</p><p>dcmpg 比较double类型值（当遇到NaN时，返回1）</p><h2 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h2><p>ifeq 如果等于0，则跳转</p><p>ifne 如果不等于0，则跳转</p><p>iflt 如果小于0，则跳转</p><p>ifge 如果大于等于0，则跳转</p><p>ifgt 如果大于0，则跳转</p><p>ifle 如果小于等于0，则跳转</p><h2 id="比较条件分支指令"><a href="#比较条件分支指令" class="headerlink" title="比较条件分支指令"></a>比较条件分支指令</h2><p>if_icmpeq 如果两个int值相等，则跳转</p><p>if_icmpne 如果两个int类型值不相等，则跳转</p><p>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转</p><p>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转</p><p>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转</p><p>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转</p><p>ifnull 如果等于null，则跳转</p><p>ifnonnull 如果不等于null，则跳转</p><p>if_acmpeq 如果两个对象引用相等，则跳转</p><p>if_acmpne 如果两个对象引用不相等，则跳转</p><h2 id="多条件分支跳转指令"><a href="#多条件分支跳转指令" class="headerlink" title="多条件分支跳转指令"></a>多条件分支跳转指令</h2><p>tableswitch 通过索引访问跳转表，并跳转</p><p>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p><h2 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h2><p>goto 无条件跳转</p><p>goto_w 无条件跳转（宽索引）</p></blockquote><h2 id="8-1-比较指令"><a href="#8-1-比较指令" class="headerlink" title="8.1. 比较指令"></a>8.1. 比较指令</h2><blockquote><p>比较指令的作用是比较占栈顶两个元素的大小，并将比较结果入栽。</p><p>比较指令有： dcmpg,dcmpl、 fcmpg、fcmpl、lcmp</p><p>与前面讲解的指令类似，首字符d表示double类型，f表示float,l表示long.</p><p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p><p>指令dcmpl和 dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述。</p><p>举例</p><p>指令 fcmp和fcmpl都从中弹出两个操作数，并将它们做比较，设栈顶的元素为v2,顶顺位第2位的元素为v1,若v1&#x3D;v2,则压入0:若v1&gt;v2则压入1:若v1&lt;v2则压入-1.</p><p>两个指令的不同之处在于，如果遇到NaN值， fcmpg会压入1,而fcmpl会压入-1</p></blockquote><h2 id="8-2-条件跳转指令"><a href="#8-2-条件跳转指令" class="headerlink" title="8.2. 条件跳转指令"></a>8.2. 条件跳转指令</h2><table><thead><tr><th>&lt;</th><th>&lt;&#x3D;</th><th>&#x3D;&#x3D;</th><th>!&#x3D;</th><th>&gt;&#x3D;</th><th>&gt;</th><th>null</th><th>not null</th></tr></thead><tbody><tr><td>iflt</td><td>ifle</td><td>ifeq</td><td>ifng</td><td>ifge</td><td>ifgt</td><td>ifnull</td><td>ifnonnull</td></tr></tbody></table><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115651.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115652.png" alt="img"></p><h2 id="8-3-比较条件跳转指令"><a href="#8-3-比较条件跳转指令" class="headerlink" title="8.3. 比较条件跳转指令"></a>8.3. 比较条件跳转指令</h2><table><thead><tr><th>&lt;</th><th>&lt;&#x3D;</th><th>&#x3D;&#x3D;</th><th>!&#x3D;</th><th>&gt;&#x3D;</th><th>&gt;</th></tr></thead><tbody><tr><td>if_icmplt</td><td>if_icmple</td><td>if_icmpeq、if_acmpeq</td><td>if_icmpne、if_acmpne</td><td>if_icmpge</td><td>if_icmpgt</td></tr></tbody></table><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115653.png" alt="img"></p><h2 id="8-4-多条件分支跳转"><a href="#8-4-多条件分支跳转" class="headerlink" title="8.4. 多条件分支跳转"></a>8.4. 多条件分支跳转</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115654.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115655.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115656.png" alt="img"></p><h2 id="8-5-无条件跳转"><a href="#8-5-无条件跳转" class="headerlink" title="8.5. 无条件跳转"></a>8.5. 无条件跳转</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115657.png" alt="img"></p><hr/><h1 id="9-异常处理指令"><a href="#9-异常处理指令" class="headerlink" title="9. 异常处理指令"></a>9. 异常处理指令</h1><blockquote><h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><p>athrow 抛出异常或错误。将栈顶异常抛出</p><p>jsr 跳转到子例程</p><p>jsr_w 跳转到子例程（宽索引）</p><p>rct 从子例程返回</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115658.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115659.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115660.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115661.png" alt="img"></p><hr/><h1 id="10-同步控制指令"><a href="#10-同步控制指令" class="headerlink" title="10. 同步控制指令"></a>10. 同步控制指令</h1><blockquote><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>montiorenter 进入并获取对象监视器。即：为栈顶对象加锁</p><p>monitorexit 释放并退出对象监视器。即：为栈顶对象解锁</p></blockquote><p>Java虚拟机支持两种同步结构：方法级的同步和方法内部一段指令序列的同步，这两种同步都是使用monitor来支持的</p><h2 id="10-1-方法级的同步"><a href="#10-1-方法级的同步" class="headerlink" title="10.1. 方法级的同步"></a>10.1. 方法级的同步</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115662.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>i++;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115663.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115664.png" alt="img"></p><h2 id="10-2-方法内指令指令序列的同步"><a href="#10-2-方法内指令指令序列的同步" class="headerlink" title="10.2. 方法内指令指令序列的同步"></a>10.2. 方法内指令指令序列的同步</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115665.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115666.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115667.png" alt="img"><br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271115668.png" alt="img"></p><hr/>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM中01-class文件结构</title>
    <link href="/2025/02/27/JVM%E4%B8%AD01-class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2025/02/27/JVM%E4%B8%AD01-class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-Class-文件结构"><a href="#1-Class-文件结构" class="headerlink" title="1. Class 文件结构"></a>1. Class 文件结构</h1><h2 id="1-1-Class-字节码文件结构"><a href="#1-1-Class-字节码文件结构" class="headerlink" title="1.1. Class 字节码文件结构"></a>1.1. Class 字节码文件结构</h2><table>    <tbody>          <tr>            <th></th>             <th>类型</th>             <th>名称</th>             <th>说明</th>             <th>长度</th>             <th>数量</th>        </tr>       <tr>            <td>魔数</td>            <td>u4</td>            <td>magic</td>            <td>魔数,识别Class文件格式</td>            <td>4个字节</td>                 <td>1</td>       </tr>       <tr>            <td rowspan="2">版本号</td>            <td>u2</td>            <td>minor_version</td>            <td>副版本号(小版本)</td>            <td>2个字节</td>                 <td>1</td>       </tr>       <tr>            <td>u2</td>            <td>major_version</td>            <td>主版本号(大版本)</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td rowspan="2">常量池集合</td>            <td>u2</td>            <td>constant_pool_count</td>            <td>常量池计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>cp_info</td>            <td>constant_pool</td>            <td>常量池表</td>            <td>n个字节</td>                 <td>constant_pool_count - 1</td>        </tr>        <tr>            <td>访问标识</td>            <td>u2</td>            <td>access_flags</td>            <td>访问标识</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td rowspan="4">索引集合</td>            <td>u2</td>            <td>this_class</td>            <td>类索引</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>u2</td>            <td>super_class</td>            <td>父类索引</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>u2</td>            <td>interfaces_count</td>            <td>接口计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>u2</td>            <td>interfaces</td>            <td>接口索引集合</td>            <td>2个字节</td>                 <td>interfaces_count</td>        </tr>            <tr>            <td rowspan="2">字段表集合</td>            <td>u2</td>            <td>fields_count</td>            <td>字段计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>field_info</td>            <td>fields</td>            <td>字段表</td>            <td>n个字节</td>                 <td>fields_count</td>        </tr>        <tr>            <td rowspan="2">方法表集合</td>            <td>u2</td>            <td>methods_count</td>            <td>方法计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>method_info</td>            <td>methods</td>            <td>方法表</td>            <td>n个字节</td>                 <td>methods_count</td>        </tr>        <tr>            <td rowspan="2">属性表集合</td>            <td>u2</td>            <td>attributes_count</td>            <td>属性计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>attribute_info</td>            <td>attributes</td>            <td>属性表</td>            <td>n个字节</td>                 <td>attributes_count</td>        </tr>   <tbody> </table><h2 id="1-2-Class-文件数据类型"><a href="#1-2-Class-文件数据类型" class="headerlink" title="1.2. Class 文件数据类型"></a>1.2. Class 文件数据类型</h2><table><thead><tr><th align="left">数据类型</th><th align="left">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">无符号数</td><td align="left">无符号数可以用来描述数字、索引引用、数量值或按照 utf-8 编码构成的字符串值。</td><td align="left">其中无符号数属于基本的数据类型。 以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节</td></tr><tr><td align="left">表</td><td align="left">表是由多个无符号数或其他表构成的复合数据结构。</td><td align="left">所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td></tr></tbody></table><h2 id="1-3-魔数"><a href="#1-3-魔数" class="headerlink" title="1.3. 魔数"></a>1.3. 魔数</h2><p><strong>Magic Number（魔数）</strong></p><ul><li>每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number）</li><li>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：魔数是 Class 文件的标识符。</li><li>魔数值固定为 0xCAFEBABE。不会改变。</li><li>如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Error: A JNI error has occurred, please check your installation and <span class="hljs-keyword">try</span> again<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ClassFormatError: Incompatible magic value <span class="hljs-number">1885430635</span> in <span class="hljs-keyword">class</span> <span class="hljs-title class_">file</span> StringTest<br></code></pre></td></tr></table></figure><ul><li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li></ul><h2 id="1-4-文件版本号"><a href="#1-4-文件版本号" class="headerlink" title="1.4. 文件版本号"></a>1.4. 文件版本号</h2><p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是 4 个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 minor_version，而第 7 个和第 8 个字节就是编译的主版本号 major_version。</p><p>它们共同构成了 class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。</p><p>版本号和 Java 编译器的对应关系如下表：</p><h3 id="1-4-1-Class-文件版本号对应关系"><a href="#1-4-1-Class-文件版本号对应关系" class="headerlink" title="1.4.1. Class 文件版本号对应关系"></a>1.4.1. Class 文件版本号对应关系</h3><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><p>Java 的版本号是从 45 开始的，JDK1.1 之后的每个 JDK 大版本发布主版本号向上加 1。</p><p><mark>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的。目前，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行由高版本编译器生成的 Class 文件。否则 JVM 会抛出 java.lang.UnsupportedClassVersionError 异常。（向下兼容）</mark></p><p>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的 JDK 版本和生产环境中的 JDK 版本是否一致。</p><ul><li>虚拟机 JDK 版本为 1.k（k&gt;&#x3D;2）时，对应的 class 文件格式版本号的范围为 45.0 - 44+k.0（含两端）。</li></ul><h2 id="1-5-常量池集合"><a href="#1-5-常量池集合" class="headerlink" title="1.5. 常量池集合"></a>1.5. 常量池集合</h2><p>常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。</p><p>随着 Java 虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个 Class 文件的基石。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271114571.png" alt="image-20210508233536076"></p><p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count）。与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的。</p><table><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">数量</th></tr></thead><tbody><tr><td align="left">u2（无符号数）</td><td align="left">constant_pool_count</td><td align="left">1</td></tr><tr><td align="left">cp_info（表）</td><td align="left">constant_pool</td><td align="left">constant_pool_count - 1</td></tr></tbody></table><p>由上表可见，Class 文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p><ul><li><mark>常量池表项</mark>中，用于存放编译时期生成的各种<mark>字面量</mark>和<mark>符号引用</mark>，这部分内容将在类加载后进入方法区的<mark>运行时常量池</mark>中存放</li></ul><h3 id="1-5-1-常量池计数器"><a href="#1-5-1-常量池计数器" class="headerlink" title="1.5.1. 常量池计数器"></a>1.5.1. 常量池计数器</h3><p><strong>constant_pool_count（常量池计数器）</strong></p><ul><li>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</li><li>常量池容量计数值（u2 类型）：<mark>从 1 开始</mark>，表示常量池中有多少项常量。即 constant_pool_count&#x3D;1 表示常量池中有 0 个常量项。</li><li>Demo 的值为：</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271114572.png" alt="image-20210508234020104"></p><p>其值为 0x0016，掐指一算，也就是 22。需要注意的是，这实际上只有 21 项常量。索引为范围是 1-21。为什么呢？</p><p>通常我们写代码时都是从 0 开始的，但是这里的常量池却是从 1 开始，因为它把第 0 项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值 0 来表示。</p><h3 id="1-5-2-常量池表"><a href="#1-5-2-常量池表" class="headerlink" title="1.5.2. 常量池表"></a>1.5.2. 常量池表</h3><p>constant_pool 是一种表结构，以 1 ~ constant_pool_count - 1 为索引。表明了后面有多少个常量项。</p><p>常量池主要存放两大类常量：<mark>字面量（Literal）</mark>和<mark>符号引用（Symbolic References）</mark></p><p>它包含了 class 文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第 1 个字节作为类型标记，用于确定该项的格式，这个字节称为 tag byte（标记字节、标签字节）。</p><table><thead><tr><th align="left">类型</th><th align="left">标志(或标识)</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">CONSTANT_Utf8_info</td><td align="left">1</td><td align="left">UTF-8 编码的字符串</td></tr><tr><td align="left">CONSTANT_Integer_info</td><td align="left">3</td><td align="left">整型字面量</td></tr><tr><td align="left">CONSTANT_Float_info</td><td align="left">4</td><td align="left">浮点型字面量</td></tr><tr><td align="left">CONSTANT_Long_info</td><td align="left">5</td><td align="left">长整型字面量</td></tr><tr><td align="left">CONSTANT_Double_info</td><td align="left">6</td><td align="left">双精度浮点型字面量</td></tr><tr><td align="left">CONSTANT_Class_info</td><td align="left">7</td><td align="left">类或接口的符号引用</td></tr><tr><td align="left">CONSTANT_String_info</td><td align="left">8</td><td align="left">字符串类型字面量</td></tr><tr><td align="left">CONSTANT_Fieldref_info</td><td align="left">9</td><td align="left">字段的符号引用</td></tr><tr><td align="left">CONSTANT_Methodref_info</td><td align="left">10</td><td align="left">类中方法的符号引用</td></tr><tr><td align="left">CONSTANT_InterfaceMethodref_info</td><td align="left">11</td><td align="left">接口中方法的符号引用</td></tr><tr><td align="left">CONSTANT_NameAndType_info</td><td align="left">12</td><td align="left">字段或方法的符号引用</td></tr><tr><td align="left">CONSTANT_MethodHandle_info</td><td align="left">15</td><td align="left">表示方法句柄</td></tr><tr><td align="left">CONSTANT_MethodType_info</td><td align="left">16</td><td align="left">标志方法类型</td></tr><tr><td align="left">CONSTANT_InvokeDynamic_info</td><td align="left">18</td><td align="left">表示一个动态方法调用点</td></tr></tbody></table><h4 id="Ⅰ-字面量和符号引用"><a href="#Ⅰ-字面量和符号引用" class="headerlink" title="Ⅰ. 字面量和符号引用"></a>Ⅰ. 字面量和符号引用</h4><p>在对这些常量解读前，我们需要搞清楚几个概念。</p><p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。如下表：</p><table><thead><tr><th align="left">常量</th><th align="left">具体的常量</th></tr></thead><tbody><tr><td align="left">字面量</td><td align="left">文本字符串</td></tr><tr><td align="left"></td><td align="left">声明为 final 的常量值</td></tr><tr><td align="left">符号引用</td><td align="left">类和接口的全限定名</td></tr><tr><td align="left"></td><td align="left">字段的名称和描述符</td></tr><tr><td align="left"></td><td align="left">方法的名称和描述符</td></tr></tbody></table><p><strong>全限定名</strong></p><p>com&#x2F;atguigu&#x2F;test&#x2F;Demo 这个就是类的全限定名，仅仅是把包名的“.“替换成”&#x2F;”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。</p><p><strong>简单名称</strong></p><p>简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的 add()方法和 num 字段的简单名称分别是 add 和 num。</p><p><strong>描述符</strong></p><p><mark>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</mark>。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示，详见下表：</p><table><thead><tr><th align="left">标志符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">B</td><td align="left">基本数据类型 byte</td></tr><tr><td align="left">C</td><td align="left">基本数据类型 char</td></tr><tr><td align="left">D</td><td align="left">基本数据类型 double</td></tr><tr><td align="left">F</td><td align="left">基本数据类型 float</td></tr><tr><td align="left">I</td><td align="left">基本数据类型 int</td></tr><tr><td align="left">J</td><td align="left">基本数据类型 long</td></tr><tr><td align="left">S</td><td align="left">基本数据类型 short</td></tr><tr><td align="left">Z</td><td align="left">基本数据类型 boolean</td></tr><tr><td align="left">V</td><td align="left">代表 void 类型</td></tr><tr><td align="left">L</td><td align="left">对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td align="left">[</td><td align="left">数组类型，代表一维数组。比如：&#96;double[] is [D</td></tr></tbody></table><p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法 java.lang.String tostring()的描述符为()Ljava&#x2F;lang&#x2F;String; ，方法 int abc(int[]x, int y)的描述符为([II)I。</p><p><strong>补充说明：</strong></p><p>虚拟机在加载 Class 文件时才会进行动态链接，也就是说，Class 文件中不会保存各个方法和字段的最终内存布局信息。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。<mark>当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中</mark>。</p><p>这里说明下符号引用和直接引用的区别与关联：</p><ul><li>符号引用：符号引用以<mark>一组符号</mark>来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<mark>符号引用与虚拟机实现的内存布局无关</mark>，引用的目标并不一定已经加载到了内存中。</li><li>直接引用：直接引用可以是直接<mark>指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄</mark>。<mark>直接引用是与虚拟机实现的内存布局相关的</mark>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li></ul><h4 id="Ⅱ-常量类型和结构"><a href="#Ⅱ-常量类型和结构" class="headerlink" title="Ⅱ. 常量类型和结构"></a>Ⅱ. 常量类型和结构</h4><p>常量池中每一项常量都是一个表，J0K1.7 之后共有 14 种不同的表结构数据。如下表格所示：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271114573.png" alt="image-20210509001319088"></p><p>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容（主要是字面量、符号引用）的。比如:<br>CONSTANT_Integer_info 是用来描述常量池中字面量信息的，而且只是整型字面量信息。</p><p>标志为 15、16、18 的常量项类型是用来支持动态语言调用的（jdk1.7 时才加入的）。</p><p><strong>细节说明:</strong></p><ul><li>CONSTANT_Class_info 结构用于表示类或接口</li><li>CONSTAT_Fieldref_info、CONSTAHT_Methodref_infoF 和 lCONSTANIT_InterfaceMethodref_info 结构表示字段、方汇和按口小法</li><li>CONSTANT_String_info 结构用于表示示 String 类型的常量对象</li><li>CONSTANT_Integer_info 和 CONSTANT_Float_info 表示 4 字节（int 和 float）的数值常量</li><li>CONSTANT_Long_info 和 CONSTAT_Double_info 结构表示 8 字作（long 和 double）的数值常量<ul><li>在 class 文件的常最池表中，所行的 a 字节常借均占两个表成员（项）的空问。如果一个 CONSTAHT_Long_info 和 CNSTAHT_Double_info 结构在常量池中的索引位 n，则常量池中一个可用的索引位 n+2，此时常量池长中索引为 n+1 的项仍然有效但必须视为不可用的。</li></ul></li><li>CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的 3 个结构不同，CONSTANT_NameAndType_info 结构没有指明该字段或方法所属的类或接口。</li><li>CONSTANT_Utf8_info 用于表示字符常量的值</li><li>CONSTANT_MethodHandle_info 结构用于表示方法句柄</li><li>CONSTANT_MethodType_info 结构表示方法类型</li><li>CONSTANT_InvokeDynamic_info 结构表示 invokedynamic 指令所用到的引导方法(bootstrap method)、引导方法所用到的动态调用名称(dynamic invocation name)、参数和返回类型，并可以给引导方法传入一系列称为静态参数（static argument）的常量。</li></ul><p><strong>解析方法：</strong></p><ul><li>一个字节一个字节的解析</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271114574.png" alt="image-20210509002525647"></p><ul><li>使用 javap 命令解析：javap-verbose Demo.class 或 jclasslib 工具会更方便。</li></ul><p><strong>总结 1：</strong></p><ul><li>这 14 种表（或者常量项结构）的共同点是：表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li><li>在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li><li>这 14 种常量项结构还有一个特点是，其中 13 个常量项占用的字节固定，只有 CONSTANT_Utf8_info 占用字节不固定，其大小由 length 决定。为什么呢？<mark>因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定</mark>，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过 utf-8 编码，就可以知道其长度。</li></ul><p><strong>总结 2：</strong></p><ul><li>常量池：可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一。</li><li>常量池中为什么要包含这些内容？Java 代码在进行 Javac 编译的时候，并不像 C 和 C++那样有“连接”这一步骤，而是在虚拟机加载 C1ass 文件的时候进行动态链接。也就是说，<mark>在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用</mark>。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解</li></ul><h2 id="1-6-访问标志"><a href="#1-6-访问标志" class="headerlink" title="1.6. 访问标志"></a>1.6. 访问标志</h2><p><strong>访问标识（access_flag、访问标志、访问标记）</strong></p><p>在常量池后，紧跟着访问标记。该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示：</p><table><thead><tr><th align="left">标志名称</th><th>标志值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">ACC_PUBLIC</td><td>0x0001</td><td align="left">标志为 public 类型</td></tr><tr><td align="left">ACC_FINAL</td><td>0x0010</td><td align="left">标志被声明为 final，只有类可以设置</td></tr><tr><td align="left">ACC_SUPER</td><td>0x0020</td><td align="left">标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td align="left">ACC_INTERFACE</td><td>0x0200</td><td align="left">标志这是一个接口</td></tr><tr><td align="left">ACC_ABSTRACT</td><td>0x0400</td><td align="left">是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td align="left">ACC_SYNTHETIC</td><td>0x1000</td><td align="left">标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td align="left">ACC_ANNOTATION</td><td>0x2000</td><td align="left">标志这是一个注解</td></tr><tr><td align="left">ACC_ENUM</td><td>0x4000</td><td align="left">标志这是一个枚举</td></tr></tbody></table><p>类的访问权限通常为 ACC_开头的常量。</p><p>每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的。比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL。</p><p>使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。</p><p><strong>补充说明：</strong></p><ol><li><p>带有 ACC_INTERFACE 标志的 class 文件表示的是接口而不是类，反之则表示的是类而不是接口。</p><ul><li>如果一个 class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志。</li><li>如果没有设置 ACC_INTERFACE 标志，那么这个 class 文件可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不得同时设置。</li></ul></li><li><p>ACC_SUPER 标志用于确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义。<mark>针对 Java 虚拟机指令集的编译器都应当设置这个标志</mark>。对于 Java SE 8 及后续版本来说，无论 class 文件中这个标志的实际值是什么，也不管 class 文件的版本号是多少，Java 虚拟机都认为每个 class 文件均设置了 ACC_SUPER 标志。</p><ul><li>ACC_SUPER 标志是为了向后兼容由旧 Java 编译器所编译的代码而设计的。目前的 ACC_SUPER 标志在由 JDK1.0.2 之前的编译器所生成的 access_flags 中是没有确定含义的，如果设置了该标志，那么 0racle 的 Java 虚拟机实现会将其忽略。</li></ul></li><li><p>ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</p></li><li><p>注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_INTERFACE 标志。</p></li><li><p>ACC_ENUM 标志表明该类或其父类为枚举类型。</p></li></ol><h2 id="1-7-类索引、父类索引、接口索引"><a href="#1-7-类索引、父类索引、接口索引" class="headerlink" title="1.7. 类索引、父类索引、接口索引"></a>1.7. 类索引、父类索引、接口索引</h2><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p><table><thead><tr><th>长度</th><th align="left">含义</th></tr></thead><tbody><tr><td>u2</td><td align="left">this_class</td></tr><tr><td>u2</td><td align="left">super_class</td></tr><tr><td>u2</td><td align="left">interfaces_count</td></tr><tr><td>u2</td><td align="left">interfaces[interfaces_count]</td></tr></tbody></table><p>这三项数据来确定这个类的继承关系：</p><ul><li>类索引用于确定这个类的全限定名</li><li>父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.1ang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 e。</li><li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</li></ul><h3 id="1-7-1-this-class（类索引）"><a href="#1-7-1-this-class（类索引）" class="headerlink" title="1.7.1. this_class（类索引）"></a>1.7.1. this_class（类索引）</h3><p>2 字节无符号整数，指向常量池的索引。它提供了类的全限定名，如 com&#x2F;atguigu&#x2F;java1&#x2F;Demo。this_class 的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为 CONSTANT_Class_info 类型结构体，该结构体表示这个 class 文件所定义的类或接口。</p><h3 id="1-7-2-super-class（父类索引）"><a href="#1-7-2-super-class（父类索引）" class="headerlink" title="1.7.2. super_class（父类索引）"></a>1.7.2. super_class（父类索引）</h3><p>2 字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是 java&#x2F;lang&#x2F;object 类。同时，由于 Java 不支持多继承，所以其父类只有一个。</p><p>super_class 指向的父类不能是 final。</p><h3 id="1-7-3-interfaces"><a href="#1-7-3-interfaces" class="headerlink" title="1.7.3. interfaces"></a>1.7.3. interfaces</h3><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口</p><p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的 CONSTANT_Class（当然这里就必须是接口，而不是类）。</p><h4 id="Ⅰ-interfaces-count（接口计数器）"><a href="#Ⅰ-interfaces-count（接口计数器）" class="headerlink" title="Ⅰ. interfaces_count（接口计数器）"></a>Ⅰ. interfaces_count（接口计数器）</h4><p>interfaces_count 项的值表示当前类或接口的直接超接口数量。</p><h4 id="Ⅱ-interfaces-（接口索引集合）"><a href="#Ⅱ-interfaces-（接口索引集合）" class="headerlink" title="Ⅱ. interfaces[]（接口索引集合）"></a>Ⅱ. interfaces[]（接口索引集合）</h4><p>interfaces[]中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。每个成员 interfaces[i]必须为 CONSTANT_Class_info 结构，其中 0 &lt;&#x3D; i &lt; interfaces_count。在 interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即 interfaces[0]对应的是源代码中最左边的接口。</p><h2 id="1-8-字段表集合"><a href="#1-8-字段表集合" class="headerlink" title="1.8. 字段表集合"></a>1.8. 字段表集合</h2><p><strong>fields</strong></p><p>用于描述接口或类中声明的变量。字段（field）包括<mark>类级变量以及实例级变量</mark>，但是不包括方法内部、代码块内部声明的局部变量。</p><p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p><p>它指向常量池索引集合，它描述了每个字段的完整信息。比如<mark>字段的标识符、访问修饰符（public、private 或 protected）、是类变量还是实例变量（static 修饰符）、是否是常量（final 修饰符）</mark>等。</p><p><strong>注意事项：</strong></p><ul><li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li><li>在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</li></ul><h3 id="1-8-1-字段计数器"><a href="#1-8-1-字段计数器" class="headerlink" title="1.8.1. 字段计数器"></a>1.8.1. 字段计数器</h3><p><strong>fields_count（字段计数器）</strong></p><p>fields_count 的值表示当前 class 文件 fields 表的成员个数。使用两个字节来表示。</p><p>fields 表中每个成员都是一个 field_info 结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p><table><thead><tr><th align="left">标志名称</th><th align="left">标志值</th><th align="left">含义</th><th align="left">数量</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">access_flags</td><td align="left">访问标志</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">name_index</td><td align="left">字段名索引</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">descriptor_index</td><td align="left">描述符索引</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">attributes_count</td><td align="left">属性计数器</td><td align="left">1</td></tr><tr><td align="left">attribute_info</td><td align="left">attributes</td><td align="left">属性集合</td><td align="left">attributes_count</td></tr></tbody></table><h3 id="1-8-2-字段表"><a href="#1-8-2-字段表" class="headerlink" title="1.8.2. 字段表"></a>1.8.2. 字段表</h3><h4 id="Ⅰ-字段表访问标识"><a href="#Ⅰ-字段表访问标识" class="headerlink" title="Ⅰ. 字段表访问标识"></a>Ⅰ. 字段表访问标识</h4><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static 修饰符、final 修饰符、volatile 修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p><table><thead><tr><th align="left">标志名称</th><th align="left">标志值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">ACC_PUBLIC</td><td align="left">0x0001</td><td align="left">字段是否为 public</td></tr><tr><td align="left">ACC_PRIVATE</td><td align="left">0x0002</td><td align="left">字段是否为 private</td></tr><tr><td align="left">ACC_PROTECTED</td><td align="left">0x0004</td><td align="left">字段是否为 protected</td></tr><tr><td align="left">ACC_STATIC</td><td align="left">0x0008</td><td align="left">字段是否为 static</td></tr><tr><td align="left">ACC_FINAL</td><td align="left">0x0010</td><td align="left">字段是否为 final</td></tr><tr><td align="left">ACC_VOLATILE</td><td align="left">0x0040</td><td align="left">字段是否为 volatile</td></tr><tr><td align="left">ACC_TRANSTENT</td><td align="left">0x0080</td><td align="left">字段是否为 transient</td></tr><tr><td align="left">ACC_SYNCHETIC</td><td align="left">0x1000</td><td align="left">字段是否为由编译器自动产生</td></tr><tr><td align="left">ACC_ENUM</td><td align="left">0x4000</td><td align="left">字段是否为 enum</td></tr></tbody></table><h4 id="Ⅱ-描述符索引"><a href="#Ⅱ-描述符索引" class="headerlink" title="Ⅱ. 描述符索引"></a>Ⅱ. 描述符索引</h4><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte，char，double，float，int，long，short，boolean）及代表无返回值的 void 类型都用一个大写字符来表示，而对象则用字符 L 加对象的全限定名来表示，如下所示：</p><table><thead><tr><th align="left">标志符</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">B</td><td align="left">基本数据类型 byte</td></tr><tr><td align="left">C</td><td align="left">基本数据类型 char</td></tr><tr><td align="left">D</td><td align="left">基本数据类型 double</td></tr><tr><td align="left">F</td><td align="left">基本数据类型 float</td></tr><tr><td align="left">I</td><td align="left">基本数据类型 int</td></tr><tr><td align="left">J</td><td align="left">基本数据类型 long</td></tr><tr><td align="left">S</td><td align="left">基本数据类型 short</td></tr><tr><td align="left">Z</td><td align="left">基本数据类型 boolean</td></tr><tr><td align="left">V</td><td align="left">代表 void 类型</td></tr><tr><td align="left">L</td><td align="left">对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td align="left">[</td><td align="left">数组类型，代表一维数组。比如：&#96;double[][][] is [[[D</td></tr></tbody></table><h4 id="Ⅲ-属性表集合"><a href="#Ⅲ-属性表集合" class="headerlink" title="Ⅲ. 属性表集合"></a>Ⅲ. 属性表集合</h4><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在 attribute_count 中，属性具体内容存放在 attributes 数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以常量属性为例，结构为：</span><br>ConstantValue_attribute&#123;<br>u2 attribute_name_index;<br>u4 attribute_length;<br>    u2 constantvalue_index;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明：对于常量属性而言，attribute_length 值恒为 2。</p><h2 id="1-9-方法表集合"><a href="#1-9-方法表集合" class="headerlink" title="1.9. 方法表集合"></a>1.9. 方法表集合</h2><p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p><ul><li>在字节码文件中，每一个 method_info 项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。</li><li>如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。</li><li>一方面，methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法&lt;clinit&gt;()和实例初始化方法&lt;init&gt;()）。</li></ul><p><strong>使用注意事项：</strong></p><p>在 Java 语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 class 文件中。</p><p>也就是说，尽管 Java 语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和 Java 语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p><h3 id="1-9-1-方法计数器"><a href="#1-9-1-方法计数器" class="headerlink" title="1.9.1. 方法计数器"></a>1.9.1. 方法计数器</h3><p><strong>methods_count（方法计数器）</strong></p><p>methods_count 的值表示当前 class 文件 methods 表的成员个数。使用两个字节来表示。</p><p>methods 表中每个成员都是一个 method_info 结构。</p><h3 id="1-9-2-方法表"><a href="#1-9-2-方法表" class="headerlink" title="1.9.2. 方法表"></a>1.9.2. 方法表</h3><p><strong>methods[]（方法表）</strong></p><p>methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所用的 Java 虚拟机指令。</p><p>method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</p><p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p><table><thead><tr><th align="left">标志名称</th><th align="left">标志值</th><th align="left">含义</th><th align="left">数量</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">access_flags</td><td align="left">访问标志</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">name_index</td><td align="left">方法名索引</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">descriptor_index</td><td align="left">描述符索引</td><td align="left">1</td></tr><tr><td align="left">u2</td><td align="left">attributes_count</td><td align="left">属性计数器</td><td align="left">1</td></tr><tr><td align="left">attribute_info</td><td align="left">attributes</td><td align="left">属性集合</td><td align="left">attributes_count</td></tr></tbody></table><p><strong>方法表访问标志</strong></p><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p><table><thead><tr><th align="left">标志名称</th><th align="left">标志值</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">ACC_PUBLIC</td><td align="left">0x0001</td><td align="left">public，方法可以从包外访问</td></tr><tr><td align="left">ACC_PRIVATE</td><td align="left">0x0002</td><td align="left">private，方法只能本类访问</td></tr><tr><td align="left">ACC_PROTECTED</td><td align="left">0x0004</td><td align="left">protected，方法在自身和子类可以访问</td></tr><tr><td align="left">ACC_STATIC</td><td align="left">0x0008</td><td align="left">static，静态方法</td></tr></tbody></table><h2 id="1-10-属性表集合"><a href="#1-10-属性表集合" class="headerlink" title="1.10. 属性表集合"></a>1.10. 属性表集合</h2><p>方法表集合之后的属性表集合，<mark>指的是 class 文件所携带的辅助信息</mark>，比如该 class 文件的源文件的名称。以及任何带有 RetentionPolicy.CLASS 或者 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，<mark>一般无须深入了解</mark>。</p><p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p><p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。</p><h3 id="1-10-1-属性计数器"><a href="#1-10-1-属性计数器" class="headerlink" title="1.10.1. 属性计数器"></a>1.10.1. 属性计数器</h3><p><strong>attributes_count（属性计数器）</strong></p><p>attributes_count 的值表示当前 class 文件属性表的成员个数。属性表中每一项都是一个 attribute_info 结构。</p><h3 id="1-10-2-属性表"><a href="#1-10-2-属性表" class="headerlink" title="1.10.2. 属性表"></a>1.10.2. 属性表</h3><p><strong>attributes[]（属性表）</strong></p><p>属性表的每个项的值必须是 attribute_info 结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p><p><strong>属性的通用格式</strong></p><table><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">数量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">attribute_name_index</td><td align="left">1</td><td align="left">属性名索引</td></tr><tr><td align="left">u4</td><td align="left">attribute_length</td><td align="left">1</td><td align="left">属性长度</td></tr><tr><td align="left">u1</td><td align="left">info</td><td align="left">attribute_length</td><td align="left">属性表</td></tr></tbody></table><p><strong>属性类型</strong></p><p>属性表实际上可以有很多类型，上面看到的 Code 属性只是其中一种，Java8 里面定义了 23 种属性。下面这些是虚拟机中预定义的属性：</p><table><thead><tr><th align="left">属性名称</th><th align="left">使用位置</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">Code</td><td align="left">方法表</td><td align="left">Java 代码编译成的字节码指令</td></tr><tr><td align="left">ConstantValue</td><td align="left">字段表</td><td align="left">final 关键字定义的常量池</td></tr><tr><td align="left">Deprecated</td><td align="left">类，方法，字段表</td><td align="left">被声明为 deprecated 的方法和字段</td></tr><tr><td align="left">Exceptions</td><td align="left">方法表</td><td align="left">方法抛出的异常</td></tr><tr><td align="left">EnclosingMethod</td><td align="left">类文件</td><td align="left">仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td align="left">InnerClass</td><td align="left">类文件</td><td align="left">内部类列表</td></tr><tr><td align="left">LineNumberTable</td><td align="left">Code 属性</td><td align="left">Java 源码的行号与字节码指令的对应关系</td></tr><tr><td align="left">LocalVariableTable</td><td align="left">Code 属性</td><td align="left">方法的局部变量描述</td></tr><tr><td align="left">StackMapTable</td><td align="left">Code 属性</td><td align="left">JDK1.6 中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td align="left">Signature</td><td align="left">类，方法表，字段表</td><td align="left">用于支持泛型情况下的方法签名</td></tr><tr><td align="left">SourceFile</td><td align="left">类文件</td><td align="left">记录源文件名称</td></tr><tr><td align="left">SourceDebugExtension</td><td align="left">类文件</td><td align="left">用于存储额外的调试信息</td></tr><tr><td align="left">Synthetic</td><td align="left">类，方法表，字段表</td><td align="left">标志方法或字段为编译器自动生成的</td></tr><tr><td align="left">LocalVariableTypeTable</td><td align="left">类</td><td align="left">是哟很难过特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td align="left">RuntimeVisibleAnnotations</td><td align="left">类，方法表，字段表</td><td align="left">为动态注解提供支持</td></tr><tr><td align="left">RuntimeInvisibleAnnotations</td><td align="left">类，方法表，字段表</td><td align="left">用于指明哪些注解是运行时不可见的</td></tr><tr><td align="left">RuntimeVisibleParameterAnnotation</td><td align="left">方法表</td><td align="left">作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象或方法</td></tr><tr><td align="left">RuntimeInvisibleParameterAnnotation</td><td align="left">方法表</td><td align="left">作用与 RuntimeInvisibleAnnotations 属性类似，只不过作用对象或方法</td></tr><tr><td align="left">AnnotationDefault</td><td align="left">方法表</td><td align="left">用于记录注解类元素的默认值</td></tr><tr><td align="left">BootstrapMethods</td><td align="left">类文件</td><td align="left">用于保存 invokeddynamic 指令引用的引导方法限定符</td></tr></tbody></table><p>或者（查看官网）</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271114575.png" alt="image-20210421235232911"></p><p><strong>部分属性详解</strong></p><p><strong>① ConstantValue 属性</strong></p><p>ConstantValue 属性表示一个常量字段的值。位于 field_info 结构的属性表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ConstantValue_attribute&#123;<br>u2 attribute_name_index;<br>u4 attribute_length;<br>u2 constantvalue_index;<span class="hljs-comment">//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是1ong型的，在常量池中便是CONSTANT_Long）</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>② Deprecated 属性</strong></p><p>Deprecated 属性是在 JDK1.1 为了支持注释中的关键词@deprecated 而引入的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Deprecated_attribute&#123;<br>u2 attribute_name_index;<br>u4 attribute_length;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>③ Code 属性</strong></p><p>Code 属性就是存放方法体里面的代码。但是，并非所有方法表都有 Code 属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有 Code 属性了。Code 属性表的结构，如下图：</p><table><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">数量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">attribute_name_index</td><td align="left">1</td><td align="left">属性名索引</td></tr><tr><td align="left">u4</td><td align="left">attribute_length</td><td align="left">1</td><td align="left">属性长度</td></tr><tr><td align="left">u2</td><td align="left">max_stack</td><td align="left">1</td><td align="left">操作数栈深度的最大值</td></tr><tr><td align="left">u2</td><td align="left">max_locals</td><td align="left">1</td><td align="left">局部变量表所需的存续空间</td></tr><tr><td align="left">u4</td><td align="left">code_length</td><td align="left">1</td><td align="left">字节码指令的长度</td></tr><tr><td align="left">u1</td><td align="left">code</td><td align="left">code_lenth</td><td align="left">存储字节码指令</td></tr><tr><td align="left">u2</td><td align="left">exception_table_length</td><td align="left">1</td><td align="left">异常表长度</td></tr><tr><td align="left">exception_info</td><td align="left">exception_table</td><td align="left">exception_length</td><td align="left">异常表</td></tr><tr><td align="left">u2</td><td align="left">attributes_count</td><td align="left">1</td><td align="left">属性集合计数器</td></tr><tr><td align="left">attribute_info</td><td align="left">attributes</td><td align="left">attributes_count</td><td align="left">属性集合</td></tr></tbody></table><p>可以看到：Code 属性表的前两项跟属性表是一致的，即 Code 属性表遵循属性表的结构，后面那些则是他自定义的结构。</p><p><strong>④ InnerClasses 属性</strong></p><p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个 CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的 ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK1.1 中为了支持内部类和内部接口而引入的，位于 ClassFile 结构的属性表。</p><p><strong>⑤ LineNumberTable 属性</strong></p><p>LineNumberTable 属性是可选变长属性，位于 Code 结构的属性表。</p><p>LineNumberTable 属性是<mark>用来描述 Java 源码行号与字节码行号之间的对应关系</mark>。这个属性可以用来在调试的时候定位代码执行的行数。</p><ul><li>start_pc，即字节码行号；1ine_number，即 Java 源代码行号。</li></ul><p>在 Code 属性的属性表中，LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable 属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LineNumberTable属性表结构：</span><br>LineNumberTable_attribute&#123;<br>    u2 attribute_name_index;<br>    u4 attribute_length;<br>    u2 line_number_table_length;<br>    &#123;<br>        u2 start_pc;<br>        u2 line_number;<br>    &#125; line_number_table[line_number_table_length];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>⑥ LocalVariableTable 属性</strong></p><p>LocalVariableTable 是可选变长属性，位于 Code 属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。</p><ul><li>start pc + length 表示这个变量在字节码中的生命周期起始和结束的偏移位置（this 生命周期从头 e 到结尾 10）</li><li>index 就是这个变量在局部变量表中的槽位<mark>（槽位可复用）</mark></li><li>name 就是变量名</li><li>Descriptor 表示局部变量类型描述</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LocalVariableTable属性表结构：</span><br>LocalVariableTable_attribute&#123;<br>    u2 attribute_name_index;<br>    u4 attribute_length;<br>    u2 local_variable_table_length;<br>    &#123;<br>        u2 start_pc;<br>        u2 length;<br>        u2 name_index;<br>        u2 descriptor_index;<br>        u2 index;<br>    &#125; local_variable_table[local_variable_table_length];<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>⑦ Signature 属性</strong></p><p>Signature 属性是可选的定长属性，位于 ClassFile，field_info 或 method_info 结构的属性表中。在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。</p><p><strong>⑧ SourceFile 属性</strong></p><p>SourceFile 属性结构</p><table><thead><tr><th align="left">类型</th><th align="left">名称</th><th align="left">数量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">u2</td><td align="left">attribute_name_index</td><td align="left">1</td><td align="left">属性名索引</td></tr><tr><td align="left">u4</td><td align="left">attribute_length</td><td align="left">1</td><td align="left">属性长度</td></tr><tr><td align="left">u2</td><td align="left">sourcefile index</td><td align="left">1</td><td align="left">源码文件素引</td></tr></tbody></table><p>可以看到，其长度总是固定的 8 个字节。</p><p><strong>⑨ 其他属性</strong></p><p>Java 虚拟机中预定义的属性有 20 多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第12章-垃圾回收器</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC12%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC12%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="GC-分类与性能指标"><a href="#GC-分类与性能指标" class="headerlink" title="GC 分类与性能指标"></a>GC 分类与性能指标</h2><h3 id="垃圾回收器概述"><a href="#垃圾回收器概述" class="headerlink" title="垃圾回收器概述"></a>垃圾回收器概述</h3><ol><li><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。</p></li><li><p>由于JDK的版本处于高速迭代过程中，因此Java发展至今已经衍生了众多的GC版本。</p></li><li><p>从不同角度分析垃圾收集器，可以将GC分为不同的类型。</p></li></ol><p><strong>Java不同版本新特性</strong></p><ol><li>语法层面：Lambda表达式、switch、自动拆箱装箱、enum、泛型</li><li>API层面：Stream API、新的日期时间、Optional、String、集合框架</li><li>底层优化：JVM优化、GC的变化、元空间、静态域、字符串常量池等</li></ol><h3 id="垃圾回收器分类"><a href="#垃圾回收器分类" class="headerlink" title="垃圾回收器分类"></a>垃圾回收器分类</h3><p><strong>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器。</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823822.png"><ol><li>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。<ol><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li></ol></li><li>和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</li></ol><p><strong>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器。</strong></p><ol><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823823.png"><p><strong>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</strong></p><ol><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。再分配对象空间使用指针碰撞</li><li>非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表</li></ol><p><strong>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</strong></p><h3 id="评估-GC-的性能指标"><a href="#评估-GC-的性能指标" class="headerlink" title="评估 GC 的性能指标"></a>评估 GC 的性能指标</h3><p><strong>指标</strong></p><ol><li><p>吞吐量：运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</p></li><li><p>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</p></li><li><p>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</p></li><li><p>收集频率：相对于应用程序的执行，收集操作发生的频率。</p></li><li><p>内存占用：Java堆区所占的内存大小。</p></li><li><p>快速：一个对象从诞生到被回收所经历的时间。</p></li><li><p>吞吐量、暂停时间、内存占用这三者共同构成一个“不可能三角”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p></li><li><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p></li><li><p>简单来说，主要抓住两点：</p><ul><li>吞吐量</li><li>暂停时间</li></ul></li></ol><p><strong>吞吐量（throughput）</strong></p><ol><li>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间 &#x2F;（运行用户代码时间+垃圾收集时间）<ul><li>比如：虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</li></ul></li><li>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</li><li>吞吐量优先，意味着在单位时间内，STW的时间最短：0.2+0.2&#x3D;0.4</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823824.png"><p><strong>暂停时间（pause time）</strong></p><ol><li>“暂停时间”是指一个时间段内应用程序线程暂停，让GC线程执行的状态。<ul><li>例如，GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的</li></ul></li><li>暂停时间优先，意味着尽可能让单次STW的时间最短：0.1+0.1 + 0.1+ 0.1+ 0.1&#x3D;0.5，但是总的GC时间可能会长</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823825.png"><p><strong>吞吐量 vs 暂停时间</strong></p><ol><li><p><strong>高吞吐量较好</strong>因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p></li><li><p>低暂停时间（低延迟）较好，是从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有较低的暂停时间是非常重要的，特别是对于一个交互式应用程序（就是和用户交互比较多的场景）。</p></li><li><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><ul><li>因为如果选择以吞吐量优先，那么<strong>必然需要降低内存回收的执行频率</strong>，但是这样会导致GC需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul></li><li><p>在设计（或使用）GC算法时，我们必须确定我们的目标：一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p></li><li><p>现在标准：<strong>在最大吞吐量优先的情况下，降低停顿时间</strong></p></li></ol><h2 id="不同的垃圾回收器概述"><a href="#不同的垃圾回收器概述" class="headerlink" title="不同的垃圾回收器概述"></a>不同的垃圾回收器概述</h2><ol><li>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</li><li>那么，Java常见的垃圾收集器有哪些？</li></ol><h3 id="垃圾收集器发展史"><a href="#垃圾收集器发展史" class="headerlink" title="垃圾收集器发展史"></a>垃圾收集器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是Garbage Collection，对应的产品我们称为Garbage Collector。</p><ol><li>1999年随JDK1.3.1一起来的是串行方式的Serial GC，它是第一款GC。ParNew垃圾收集器是Serial收集器的多线程版本</li><li>2002年2月26日，Parallel GC和Concurrent Mark Sweep GC跟随JDK1.4.2一起发布·</li><li>Parallel GC在JDK6之后成为HotSpot默认GC。</li><li>2012年，在JDK1.7u4版本中，G1可用。</li><li>2017年，JDK9中G1变成默认的垃圾收集器，以替代CMS。</li><li>2018年3月，JDK10中G1垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018年9月，JDK11发布。引入Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019年3月，JDK12发布。增强G1，自动返回未用堆内存给操作系统。同时，引入Shenandoah GC：低停顿时间的GC（Experimental）。</li><li>2019年9月，JDK13发布。增强ZGC，自动返回未用堆内存给操作系统。</li><li>2020年3月，JDK14发布。删除CMS垃圾回收器。扩展ZGC在macOS和Windows上的应用</li></ol><h3 id="7款经典的垃圾收集器"><a href="#7款经典的垃圾收集器" class="headerlink" title="7款经典的垃圾收集器"></a>7款经典的垃圾收集器</h3><ol><li>串行回收器：Serial、Serial old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823826.png"><p><strong>官方文档</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823827.jpg"><p><strong>7款经典回收器与垃圾分代之间的关系</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823828.png"><ol><li><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p></li><li><p>老年代收集器：Serial old、Parallel old、CMS；</p></li><li><p>整堆收集器：G1；</p></li></ol><h3 id="垃圾收集器的组合关系"><a href="#垃圾收集器的组合关系" class="headerlink" title="垃圾收集器的组合关系"></a>垃圾收集器的组合关系</h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823829.png"><ol><li><p>两个收集器间有连线，表明它们可以搭配使用：</p><ul><li>Serial&#x2F;Serial old</li><li>Serial&#x2F;CMS    （JDK9废弃）</li><li>ParNew&#x2F;Serial Old （JDK9废弃）</li><li>ParNew&#x2F;CMS</li><li>Parallel Scavenge&#x2F;Serial Old  （预计废弃）</li><li>Parallel Scavenge&#x2F;Parallel Old</li><li>G1</li></ul></li><li><p>其中Serial Old作为CMS出现”Concurrent Mode Failure”失败的后备预案。</p></li><li><p>（红色虚线）由于维护和兼容性测试的成本，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃（JEP173），并在JDK9中完全取消了这些组合的支持（JEP214），即：移除。</p></li><li><p>（绿色虚线）JDK14中：弃用Parallel Scavenge和Serial Old GC组合（JEP366）</p></li><li><p>（青色虚线）JDK14中：删除CMS垃圾回收器（JEP363）</p></li><li><p>为什么要有很多收集器，一个不够吗？因为Java的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p></li><li><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<strong>我们选择的只是对具体应用最合适的收集器</strong>。</p></li></ol><h3 id="查看默认垃圾收集器"><a href="#查看默认垃圾收集器" class="headerlink" title="查看默认垃圾收集器"></a>查看默认垃圾收集器</h3><ol><li>-XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</li><li>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</li></ol><h4 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h4><p><strong>在 JDK 8 下，设置 JVM 参数</strong></p><p>-XX:+PrintCommandLineFlags</p><p>程序打印输出：-XX:+UseParallelGC 表示使用使用 ParallelGC ，ParallelGC 默认和 Parallel Old 绑定使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-XX:InitialHeapSize=<span class="hljs-number">266620736</span> -XX:MaxHeapSize=<span class="hljs-number">4265931776</span> -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC <br></code></pre></td></tr></table></figure><p><strong>通过命令行指令查看</strong></p><p>命令行命令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">jps<br>jinfo -flag UseParallelGC 进程id<br>jinfo -flag UseParallelOldGC 进程id<br></code></pre></td></tr></table></figure><p>JDK 8 中默认使用 ParallelGC 和 ParallelOldGC 的组合</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823830.png"><h4 id="JDK9"><a href="#JDK9" class="headerlink" title="JDK9"></a>JDK9</h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823831.png"><h2 id="Serial-回收器：串行回收"><a href="#Serial-回收器：串行回收" class="headerlink" title="Serial 回收器：串行回收"></a>Serial 回收器：串行回收</h2><p><strong>Serial 回收器：串行回收</strong></p><ol><li><p>Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。</p></li><li><p>Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。</p></li><li><p>Serial收集器采用复制算法、串行回收和”Stop-the-World”机制的方式执行内存回收。</p></li><li><p>除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial old收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</p></li><li><p>Serial Old是运行在Client模式下默认的老年代的垃圾回收器，Serial Old在Server模式下主要有两个用途：①与新生代的Parallel Scavenge配合使用②作为老年代CMS收集器的后备垃圾收集方案</p></li></ol><p>这个收集器是一个单线程的收集器，“单线程”的意义：它只会使用一个CPU（串行）或一条收集线程去完成垃圾收集工作。更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（Stop The World）</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823832.png"><p><strong>Serial 回收器的优势</strong></p><ol><li>优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在Client模式下的虚拟机是个不错的选择。</li><li>在用户的桌面应用场景中，可用内存一般不大（几十MB至一两百MB），可以在较短时间内完成垃圾收集（几十ms至一百多ms），只要不频繁发生，使用串行回收器是可以接受的。</li><li>在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。<ul><li>等价于新生代用Serial GC，且老年代用Serial Old GC</li></ul></li></ol><p><strong>总结</strong></p><ol><li><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核CPU才可以用。现在都不是单核的了。</p></li><li><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的。一般在Java Web应用程序中是不会采用串行垃圾收集器的。</p></li></ol><h2 id="ParNew-回收器：并行回收"><a href="#ParNew-回收器：并行回收" class="headerlink" title="ParNew 回收器：并行回收"></a>ParNew 回收器：并行回收</h2><ol><li>如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。<ul><li>Par是Parallel的缩写，New：只能处理新生代</li></ul></li><li>ParNew 收集器除了采用<strong>并行回收</strong>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、”Stop-the-World”机制。</li><li>ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823833.png"><ol><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）</li></ol><p><strong>ParNew 回收器与 Serial 回收器比较</strong></p><p>Q：由于ParNew收集器基于并行回收，那么是否可以断定ParNew收集器的回收效率在任何场景下都会比Serial收集器更高效？</p><p>A：<strong>不能</strong></p><ol><li>ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li><li>除Serial外，目前只有ParNew GC能与CMS收集器配合工作</li></ol><p><strong>设置 ParNew 垃圾回收器</strong></p><ol><li><p>在程序中，开发人员可以通过选项”-XX:+UseParNewGC”手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p></li><li><p>-XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。</p></li></ol><h2 id="Parallel-回收器：吞吐量优先"><a href="#Parallel-回收器：吞吐量优先" class="headerlink" title="Parallel 回收器：吞吐量优先"></a>Parallel 回收器：吞吐量优先</h2><p><strong>Parallel Scavenge 回收器：吞吐量优先</strong></p><ol><li><p>HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了复制算法、并行回收和”Stop the World”机制。</p></li><li><p>那么Parallel收集器的出现是否多此一举？</p><ul><li>和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个<strong>可控制的吞吐量</strong>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。（动态调整内存分配情况，以达到一个最优的吞吐量或低延迟）</li></ul></li><li><p>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，<strong>主要适合在后台运算而不需要太多交互的任务</strong>。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。</p></li><li><p>Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。</p></li><li><p>Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和”Stop-the-World”机制。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823834.png"><ol><li>在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在server模式下的内存回收性能很不错。</li><li><strong>在Java8中，默认是此垃圾收集器。</strong></li></ol><p><strong>Parallel Scavenge 回收器参数设置</strong></p><ol><li><p>-XX:+UseParallelGC 手动指定年轻代使用Parallel并行收集器执行内存回收任务。</p></li><li><p>-XX:+UseParallelOldGC：手动指定老年代都是使用并行回收收集器。</p><ul><li><p>分别适用于新生代和老年代</p></li><li><p>上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。默认开启一个，另一个也会被开启。（互相激活）</p></li></ul></li><li><p>-XX:ParallelGCThreads：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</p><ol><li><p>在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。</p></li><li><p>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]&#x2F;8]</p></li></ol></li><li><p>-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间（即STW的时间）。单位是毫秒。</p><ol><li>为了尽可能地把停顿时间控制在XX:MaxGCPauseMillis 以内，收集器在工作时会调整Java堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。</li><li>该参数使用需谨慎。</li></ol></li><li><p>-XX:GCTimeRatio垃圾收集时间占总时间的比例，即等于 1 &#x2F; (N+1) ，用于衡量吞吐量的大小。</p><ol><li><p>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。</p></li><li><p>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性，STW暂停时间越长，Radio参数就容易超过设定的比例。</p></li></ol></li><li><p>-XX:+UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有<strong>自适应调节策略</strong></p><ol><li><p>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</p></li><li><p>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。</p></li></ol></li></ol><h2 id="CMS-回收器：低延迟"><a href="#CMS-回收器：低延迟" class="headerlink" title="CMS 回收器：低延迟"></a>CMS 回收器：低延迟</h2><h3 id="CMS-回收器"><a href="#CMS-回收器" class="headerlink" title="CMS 回收器"></a>CMS 回收器</h3><ol><li>在JDK1.5时期，Hotspot推出了一款在**强交互应用中（就是和用户打交道的引用）**几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<strong>这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</strong></li><li>CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。<ul><li>目前很大一部分的Java应用集中在互联网站或者B&#x2F;S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</li></ul></li><li>CMS的垃圾收集算法采用标记-清除算法，并且也会”Stop-the-World”</li><li>不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作（因为实现的框架不一样，没办法兼容使用），所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。</li><li>在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。</li></ol><h3 id="CMS-工作原理（过程）"><a href="#CMS-工作原理（过程）" class="headerlink" title="CMS 工作原理（过程）"></a>CMS 工作原理（过程）</h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823835.png"><p>CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)</p><ol><li>初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，<strong>这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象</strong>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<strong>速度非常快</strong>。</li><li>并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是<strong>不需要停顿用户线程</strong>，<strong>可以与垃圾收集线程一起并发运行</strong>。</li><li>重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，**因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，**这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短。</li><li>并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。<strong>由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</strong></li></ol><h3 id="CMS分析"><a href="#CMS分析" class="headerlink" title="CMS分析"></a>CMS分析</h3><ol><li>尽管CMS收集器采用的是并发回收（非独占式），<strong>但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</strong>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。</li><li><strong>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</strong>。</li><li>另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，<strong>而是当堆内存使用率达到某一阈值时，便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次**“Concurrent Mode Failure”** 失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li><li>CMS收集器的垃圾收集算法采用的是<strong>标记清除算法</strong>，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，<strong>不可避免地将会产生一些内存碎片</strong>。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823836.png"><p><strong>为什么 CMS 不采用标记-压缩算法呢？</strong></p><p>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”这种场景下使用</p><h3 id="CMS-的优点与弊端"><a href="#CMS-的优点与弊端" class="headerlink" title="CMS 的优点与弊端"></a>CMS 的优点与弊端</h3><p><strong>优点</strong></p><ol><li>并发收集</li><li>低延迟</li></ol><p><strong>弊端</strong></p><ol><li><strong>会产生内存碎片</strong>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。</li><li><strong>CMS收集器对CPU资源非常敏感</strong>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li><strong>CMS收集器无法处理浮动垃圾</strong>。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在并发清理阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，<mark>那么在并发清理阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</mark>，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ol><h3 id="CMS-参数配置"><a href="#CMS-参数配置" class="headerlink" title="CMS 参数配置"></a>CMS 参数配置</h3><ul><li><p>-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。</p><p>开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）的组合。</p></li><li><p>-XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p></li></ul><ol><li><p>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</p></li><li><p>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</p></li></ol><ul><li><p>-XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p></li><li><p>-XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理。</p></li><li><p>-XX:ParallelCMSThreads：设置CMS的线程数量。</p></li></ul><ol><li>CMS默认启动的线程数是 (ParallelGCThreads + 3) &#x2F; 4，ParallelGCThreads是年轻代并行收集器的线程数，可以当做是 CPU 最大支持的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>HotSpot有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC这三个GC有什么不同呢？</p><ol><li>如果你想要最小化地使用内存和并行开销，请选Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选Parallel GC；</li><li>如果你想要最小化GC的中断或停顿时间，请选CMS GC。</li></ol><h3 id="JDK-后续版本中-CMS-的变化"><a href="#JDK-后续版本中-CMS-的变化" class="headerlink" title="JDK 后续版本中 CMS 的变化"></a>JDK 后续版本中 CMS 的变化</h3><ol><li>JDK9新特性：CMS被标记为Deprecate了（JEP291）<ul><li>如果对JDK9及以上版本的HotSpot虚拟机使用参数-XX:+UseConcMarkSweepGC来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃。</li></ul></li><li>JDK14新特性：删除CMS垃圾回收器（JEP363）移除了CMS垃圾收集器，<ul><li>如果在JDK14中使用XX:+UseConcMarkSweepGC的话，JVM不会报错，只是给出一个warning信息，但是不会exit。JVM会自动回退以默认GC方式启动JVM</li></ul></li></ol><h2 id="G1-回收器：区域化分代式"><a href="#G1-回收器：区域化分代式" class="headerlink" title="G1 回收器：区域化分代式"></a>G1 回收器：区域化分代式</h2><h3 id="为什么还需要G1"><a href="#为什么还需要G1" class="headerlink" title="为什么还需要G1"></a>为什么还需要G1</h3><p><strong>既然我们已经有了前面几个强大的 GC ，为什么还要发布 Garbage First（G1）GC？</strong></p><ol><li>原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li><li>G1（Garbage-First）垃圾回收器是在Java7 update4之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</li><li>与此同时，<strong>为了适应现在不断扩大的内存和不断增加的处理器数量</strong>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</li><li>官方给G1设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</li></ol><h3 id="为什么名字叫Garbage-First-G1-呢？"><a href="#为什么名字叫Garbage-First-G1-呢？" class="headerlink" title="为什么名字叫Garbage First(G1)呢？"></a>为什么名字叫Garbage First(G1)呢？</h3><ol><li>因为G1是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的Region来表示Eden、幸存者0区，幸存者1区，老年代等。</li><li>G1 GC有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region。</strong></li><li>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给G1一个名字：垃圾优先（Garbage First）。</li><li>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。</li><li>在JDK1.7版本正式启用，移除了Experimental的标识，<strong>是JDK9以后的默认垃圾回收器</strong>，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为**“全功能的垃圾收集器”**。</li><li>与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。<strong>G1在JDK8中还不是默认的垃圾回收器</strong>，需要使用-XX:+UseG1GC来启用。</li></ol><h3 id="G1-回收器的优势"><a href="#G1-回收器的优势" class="headerlink" title="G1 回收器的优势"></a>G1 回收器的优势</h3><p>与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：</p><ol><li><strong>并行与并发兼备</strong><ul><li>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</li><li>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul></li><li><strong>分代收集</strong><ul><li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代。</li><li>和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul></li></ol><p>G1的分代，已经不是下面这样的了</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823837.png"><p>G1的分区是这样的一个区域</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823838.png"><p><strong>空间整合</strong></p><ol><li>CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理</li><li>G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。<strong>Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法</strong>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。</li></ol><h3 id="可预测的停顿时间模型"><a href="#可预测的停顿时间模型" class="headerlink" title="可预测的停顿时间模型"></a>可预测的停顿时间模型</h3><p><strong>可预测的停顿时间模型（即：软实时soft real-time）</strong></p><p>这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p><ol><li>由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<strong>每次根据允许的收集时间，优先回收价值最大的Region</strong>。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。</li></ol><h3 id="G1-回收器的缺点"><a href="#G1-回收器的缺点" class="headerlink" title="G1 回收器的缺点"></a>G1 回收器的缺点</h3><ol><li>相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</li><li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li></ol><h3 id="G1-参数设置"><a href="#G1-参数设置" class="headerlink" title="G1 参数设置"></a>G1 参数设置</h3><ul><li><p>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</p></li><li><p>-XX:G1HeapRegionSize：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000。</p></li><li><p>-XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标，JVM会尽力实现，但不保证达到。默认值是200ms</p></li><li><p>-XX:+ParallelGCThread：设置STW工作线程数的值。最多设置为8</p></li><li><p>-XX:ConcGCThreads：设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGcThreads）的1&#x2F;4左右。</p></li><li><p>-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</p></li></ul><h3 id="G1-收集器的常见操作步骤"><a href="#G1-收集器的常见操作步骤" class="headerlink" title="G1 收集器的常见操作步骤"></a>G1 收集器的常见操作步骤</h3><p>G1的设计原则就是简化JVM性能调优，开发人员只需要简单的三步即可完成调优：</p><ol><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ol><p>G1中提供了三种垃圾回收模式：YoungGC、Mixed GC和Full GC，在不同的条件下被触发。</p><h3 id="G1-的适用场景"><a href="#G1-的适用场景" class="headerlink" title="G1 的适用场景"></a>G1 的适用场景</h3><ol><li>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</li><li>最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；</li><li>如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。</li><li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：<ul><li>超过50%的Java堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC停顿时间过长（长于0.5至1秒）</li></ul></li><li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</li></ol><h3 id="分区-Region"><a href="#分区-Region" class="headerlink" title="分区 Region"></a>分区 Region</h3><p><strong>分区 Region：化整为零</strong></p><ol><li><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过</p></li><li><p>XX:G1HeapRegionSize设定。<strong>所有的Region大小相同，且在JVM生命周期内不会被改变。</strong></p></li><li><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p></li><li><p>一个Region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p></li><li><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过0.5个Region，就放到H。</p></li></ol><blockquote><p>纠错：尚硅谷视频里这里写的是超过1.5个region。根据<a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html">官方文档</a>:  <strong>The G1 Garbage Collector Step by Step</strong></p><p>As shown regions can be allocated into Eden, survivor, and old generation regions. In addition, there is a fourth type of object known as Humongous regions. These regions are designed to hold objects that are 50% the size of a standard region or larger. They are stored as a set of contiguous regions. Finally the last type of regions would be the unused areas of the heap.</p><p>翻译：</p><p>如图所示，可以将区域分配到Eden，幸存者和旧时代区域。 此外，还有第四种类型的物体被称为巨大区域。 这些区域旨在容纳标准区域大小的50％或更大的对象。 它们存储为一组连续区域。 最后，最后一种区域类型是堆的未使用区域。</p></blockquote><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823839.png"><p><strong>设置 H 的原因</strong></p><p>对于堆中的大对象，默认直接会被分配到老年代，但是如果<strong>它是一个短期存在的大对象</strong>就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如<strong>果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储</strong>。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</p><p><strong>Regio的细节</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823840.png"><ol><li>每个Region都是通过指针碰撞来分配空间</li><li>G1为每一个Region设 计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。</li><li>TLAB还是用来保证并发性</li></ol><h3 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h3><p>G1 GC的垃圾回收过程主要包括如下三个环节：</p><ul><li>年轻代GC（Young GC）</li><li>老年代并发标记过程（Concurrent Marking）</li><li>混合回收（Mixed GC）</li><li>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823841.png"><p>顺时针，Young GC –&gt; Young GC+Concurrent Marking –&gt; Mixed GC顺序，进行垃圾回收</p><p><strong>回收流程</strong></p><ol><li>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</li><li>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。</li><li>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，<strong>G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了</strong>。同时，这个老年代Region是和年轻代一起被回收的。</li><li>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</li></ol><h3 id="Remembered-Set（记忆集）"><a href="#Remembered-Set（记忆集）" class="headerlink" title="Remembered Set（记忆集）"></a>Remembered Set（记忆集）</h3><blockquote><p>之前讲过</p></blockquote><ol><li><p>一个对象被不同区域引用的问题</p></li><li><p>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</p></li><li><p>在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）</p></li><li><p>回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率</p></li></ol><p><strong>解决方法：</strong></p><ol><li><p>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全堆扫描；</p></li><li><p>每个Region都有一个对应的Remembered Set</p></li><li><p>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作；</p></li><li><p>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p></li><li><p>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；</p></li><li><p>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823842.png"><ol><li>在回收 Region 时，为了不进行全堆的扫描，引入了 Remembered Set</li><li>Remembered Set 记录了当前 Region 中的对象被哪个对象引用了</li><li>这样在进行 Region 复制时，就不要扫描整个堆，只需要去 Remembered Set 里面找到引用了当前 Region 的对象</li><li>Region 复制完毕后，修改 Remembered Set 中对象的引用即可</li></ol><h3 id="G1回收过程一：年轻代-GC"><a href="#G1回收过程一：年轻代-GC" class="headerlink" title="G1回收过程一：年轻代 GC"></a>G1回收过程一：年轻代 GC</h3><ol><li>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</li><li>年轻代回收只回收Eden区和Survivor区</li><li>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823843.png"><p>图的大致意思就是：</p><p>1、回收完E和S区，剩余存活的对象会复制到新的S区</p><p>2、S区达到一定的阈值可以晋升为O区</p><p><strong>细致过程：</strong></p><p><strong>然后开始如下回收过程：</strong></p><ol><li><p>第一阶段，扫描根</p><p> 根是指GC Roots，根引用连同RSet记录的外部引用作为扫描存活对象的入口。</p></li><li><p>第二阶段，更新RSet</p></li><li><p>第三阶段，处理RSet</p><p> 识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</p></li><li><p>第四阶段，复制对象。</p><ul><li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象</li><li>如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。</li><li>如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li></ul></li><li><p>第五阶段，处理引用</p><p> 处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</p></li></ol><p><strong>备注：</strong></p><ol><li>对于应用程序的引用赋值语句 oldObject.field（这个是老年代）&#x3D;object（这个是新生代），JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li><li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li></ol><h3 id="G1回收过程二：并发标记过程"><a href="#G1回收过程二：并发标记过程" class="headerlink" title="G1回收过程二：并发标记过程"></a>G1回收过程二：并发标记过程</h3><ol><li>初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间。</li><li>根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。</li><li>并发标记（Concurrent Marking）：<ol><li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。</li><li><strong>在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。</strong></li><li>同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li></ol></li><li>再次标记（Remark）：由于应用程序持续进行，需要修正上一次的标记结果。是STW的。G1中采用了比CMS更快的原始快照算法：Snapshot-At-The-Beginning（SATB）。</li><li>独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li><li>并发清理阶段：识别并清理完全空闲的区域。</li></ol><h3 id="G1回收过程三：混合回收过程"><a href="#G1回收过程三：混合回收过程" class="headerlink" title="G1回收过程三：混合回收过程"></a>G1回收过程三：混合回收过程</h3><p>当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823844.png"><p><strong>混合回收的细节</strong></p><ol><li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。【意思就是一个Region会被分为8个内存段】</li><li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</li><li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</li><li>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。</li></ol><h3 id="G1-回收可选的过程四：Full-GC"><a href="#G1-回收可选的过程四：Full-GC" class="headerlink" title="G1 回收可选的过程四：Full GC"></a>G1 回收可选的过程四：Full GC</h3><ol><li><p>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用<strong>单线程</strong>的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p></li><li><p>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。</p></li></ol><p>导致G1 Full GC的原因可能有两个：</p><ol><li>EVacuation的时候没有足够的to-space来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ol><h3 id="G1补充"><a href="#G1补充" class="headerlink" title="G1补充"></a>G1补充</h3><p>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，**而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。**另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><p><strong>G1 回收器的优化建议</strong></p><ol><li>年轻代大小<ul><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整</li></ul></li><li>暂停时间目标不要太过严苛<ul><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul></li></ol><h2 id="垃圾回收器总结"><a href="#垃圾回收器总结" class="headerlink" title="垃圾回收器总结"></a>垃圾回收器总结</h2><h3 id="7-种垃圾回收器的比较"><a href="#7-种垃圾回收器的比较" class="headerlink" title="7 种垃圾回收器的比较"></a>7 种垃圾回收器的比较</h3><p>截止JDK1.8，一共有7款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823845.jpg"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823846.png"><h3 id="怎么选择垃圾回收器"><a href="#怎么选择垃圾回收器" class="headerlink" title="怎么选择垃圾回收器"></a>怎么选择垃圾回收器</h3><p>Java垃圾收集器的配置对于JVM优化来说是一个很重要的选择，选择合适的垃圾收集器可以让JVM的性能有一个很大的提升。怎么选择垃圾收集器？</p><ol><li>优先调整堆的大小让JVM自适应完成。</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li><li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1。</li></ol><p>最后需要明确一个观点：</p><ol><li>没有最好的收集器，更没有万能的收集算法</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><p><strong>面试</strong></p><ol><li>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。</li><li>这里较通用、基础性的部分如下：<ul><li>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</li><li>垃圾收集器工作的基本流程。</li></ul></li><li>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</li></ol><h2 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h2><h3 id="常用参数配置"><a href="#常用参数配置" class="headerlink" title="常用参数配置"></a>常用参数配置</h3><blockquote><p><strong>GC 日志参数设置</strong></p></blockquote><p><strong>通过阅读GC日志，我们可以了解Java虚拟机内存分配与回收策略。</strong></p><p>内存分配与垃圾回收的参数列表</p><ol><li>-XX:+PrintGC ：输出GC日志。类似：-verbose:gc</li><li>-XX:+PrintGCDetails ：输出GC的详细日志</li><li>-XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDatestamps ：输出GC的时间戳（以日期的形式，如2013-05-04T21: 53: 59.234 +0800）</li><li>-XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</li><li>-Xloggc:…&#x2F;logs&#x2F;gc.log ：日志文件的输出路径</li></ol><blockquote><p><strong>verbose:gc</strong></p></blockquote><p>1、JVM 参数</p><p><code>-verbose:gc</code></p><p>2、这个只会显示总的GC堆的变化，如下：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823847.png"><p>3、参数解析</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823848.png"><blockquote><p><strong>PrintGCDetails</strong></p></blockquote><p>1、JVM 参数</p><p><code>-XX:+PrintGCDetails</code></p><p>2、输入信息如下</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823849.png"><p>3、参数解析</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823850.png"><blockquote><p><strong>PrintGCTimestamps 和 PrintGCDatestamps</strong></p></blockquote><p>1、JVM 参数</p><p><code>-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps</code></p><p>2、输出信息如下</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823851.png"><p>3、说明：日志带上了日期和时间</p><h3 id="GC-日志补充说明"><a href="#GC-日志补充说明" class="headerlink" title="GC 日志补充说明"></a>GC 日志补充说明</h3><ol><li><p>“[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了”Stop The World”</p></li><li><p>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</p></li><li><p>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</p></li><li><p>使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen”</p></li><li><p>老年代的收集和新生代道理一样，名字也是收集器决定的</p></li><li><p>使用G1收集器的话，会显示为”garbage-first heap”</p></li><li><p>Allocation Failure表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p></li><li><p>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)</p><ul><li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li><li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul></li><li><p>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间</p></li></ol><h4 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823852.png"><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823853.png"><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在jdk7 和 jdk8中分别执行</span><br><span class="hljs-comment"> * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+UseSerialGC</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCLogTest1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1MB</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAllocation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">byte</span>[] allocation1, allocation2, allocation3, allocation4;<br>        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>        allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>        allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">2</span> * _1MB];<br>        allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">4</span> * _1MB];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] agrs)</span> &#123;<br>        testAllocation();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>JDK7 中的情况</strong></p><p>1、首先我们会将3个2M的数组存放到Eden区，然后后面4M的数组来了后，将无法存储，因为Eden区只剩下2M的剩余空间了，那么将会进行一次Young GC操作，将原来Eden区的内容，存放到Survivor区，但是Survivor区也存放不下，那么就会直接晋级存入Old 区</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823854.png"><p>2、然后我们将4M对象存入到Eden区中</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823855.png"><p>老年代图画的有问题，free应该是4M</p><p><strong>JDK8 中的情况</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">com.atguigu.java.GCLogTest1<br>[GC (Allocation Failure) [DefNew: 6322K-&gt;668K(9216K), <span class="hljs-number">0.0034812</span> secs] 6322K-&gt;4764K(19456K), <span class="hljs-number">0.0035169</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>Heap<br> def <span class="hljs-keyword">new</span> <span class="hljs-title class_">generation</span>   total 9216K, used 7050K [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  eden space 8192K,  <span class="hljs-number">77</span>% used [<span class="hljs-number">0x00000000fec00000</span>, <span class="hljs-number">0x00000000ff23b668</span>, <span class="hljs-number">0x00000000ff400000</span>)<br>  from space 1024K,  <span class="hljs-number">65</span>% used [<span class="hljs-number">0x00000000ff500000</span>, <span class="hljs-number">0x00000000ff5a71d8</span>, <span class="hljs-number">0x00000000ff600000</span>)<br>  to   space 1024K,   <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff400000</span>, <span class="hljs-number">0x00000000ff500000</span>)<br> tenured generation   total 10240K, used 4096K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>   the space 10240K,  <span class="hljs-number">40</span>% used [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffa00020</span>, <span class="hljs-number">0x00000000ffa00200</span>, <span class="hljs-number">0x0000000100000000</span>)<br> Metaspace       used 3469K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 381K, capacity 388K, committed 512K, reserved 1048576K<br><br>Process finished with exit code <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823856.jpg"><p>与 JDK7 不同的是，JDK8 直接判定 4M 的数组为大对象，直接怼到老年区去了</p><h3 id="常用日志分析工具"><a href="#常用日志分析工具" class="headerlink" title="常用日志分析工具"></a>常用日志分析工具</h3><p><strong>保存日志文件</strong></p><p><strong>JVM参数</strong>：<code>-XLoggc:./logs/gc.log</code>，  .&#x2F; 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录</p><p>可以用一些工具去分析这些GC日志，常用的日志分析工具有：</p><p>GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat等</p><p><strong>推荐：GCeasy</strong></p><p>在线分析网址：gceasy.io</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823857.jpg"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823858.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823859.png"><h2 id="垃圾回收器的新发展"><a href="#垃圾回收器的新发展" class="headerlink" title="垃圾回收器的新发展"></a>垃圾回收器的新发展</h2><h3 id="垃圾回收器的发展过程"><a href="#垃圾回收器的发展过程" class="headerlink" title="垃圾回收器的发展过程"></a>垃圾回收器的发展过程</h3><ol><li>GC仍然处于飞速发展之中，目前的默认选项G1 GC在不断的进行改进，很多我们原来认为的缺点，例如串行的Full GC、Card Table扫描的低效等，都已经被大幅改进，例如，JDK10以后，Fu11GC已经是并行运行，在很多场景下，其表现还略优于ParallelGC的并行Ful1GC实现。</li><li>即使是SerialGC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是GC相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，在serverless等新的应用场景下，Serial Gc找到了新的舞台。</li><li>比较不幸的是CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在JDK9中已经被标记为废弃，并在JDK14版本中移除</li><li>现在G1回收器已成为默认回收器好几年了。我们还看到了引入了两个新的收集器：ZGC（JDK11出现）和Shenandoah（Open JDK12），其特点：主打低停顿时间</li></ol><h3 id="Shenandoah-GC"><a href="#Shenandoah-GC" class="headerlink" title="Shenandoah GC"></a>Shenandoah GC</h3><p><strong>Open JDK12的Shenandoash GC：低停顿时间的GC（实验性）</strong></p><ol><li><p>Shenandoah无疑是众多GC中最孤独的一个。是第一款不由Oracle公司团队领导开发的Hotspot垃圾收集器。不可避免的受到官方的排挤。比如号称openJDK和OracleJDK没有区别的Oracle公司仍拒绝在OracleJDK12中支持Shenandoah。</p></li><li><p>Shenandoah垃圾回收器最初由RedHat进行的一项垃圾收集器研究项目Pauseless GC的实现，旨在针对JVM上的内存回收实现低停顿的需求。在2014年贡献给OpenJDK。</p></li><li><p>Red Hat研发Shenandoah团队对外宣称，Shenandoah垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为200MB还是200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。不过实际使用性能将取决于实际工作堆的大小和工作负载。</p></li></ol><p>这是RedHat在2016年发表的论文数据，测试内容是使用ES对200GB的维基百科数据进行索引。从结果看：</p><ol><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823860.png"><p>总结</p><ol><li>Shenandoah GC的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC的强项：低延迟时间。</li></ol><h3 id="令人震惊、革命性的-ZGC"><a href="#令人震惊、革命性的-ZGC" class="headerlink" title="令人震惊、革命性的 ZGC"></a>令人震惊、革命性的 ZGC</h3><ol><li><p>官方文档：<a href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></p></li><li><p>ZGC与Shenandoah目标高度相似，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</p></li><li><p>《深入理解Java虚拟机》一书中这样定义ZGC：ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-压缩算法的，以低延迟为首要目标的一款垃圾收集器。</p></li><li><p>ZGC的工作过程可以分为4个阶段：并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射 等。</p></li><li><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p></li></ol><p><strong>吞吐量</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823861.png"><p>max-JOPS：以低延迟为首要前提下的数据</p><p>critical-JOPS：不考虑低延迟下的数据</p><p><strong>低延迟</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823862.png"><p>在ZGC的强项停顿时间测试上，它毫不留情的将Parallel、G1拉开了两个数量级的差距。无论平均停顿、95%停顿、998停顿、99. 98停顿，还是最大停顿时间，ZGC都能毫不费劲控制在10毫秒以内。</p><p>虽然ZGC还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823863.png"><ol><li><p>JDK14之前，ZGC仅Linux才支持。</p></li><li><p>尽管许多使用ZGC的用户都使用类Linux的环境，但在Windows和macOS上，人们也需要ZGC进行开发部署和测试。许多桌面应用也可以从ZGC中受益。因此，ZGC特性被移植到了Windows和macOS上。</p></li><li><p>现在mac或Windows上也能使用ZGC了，示例如下：</p><p>-XX:+UnlockExperimentalVMOptions-XX：+UseZGC</p></li></ol><h3 id="面向大堆的-AliGC"><a href="#面向大堆的-AliGC" class="headerlink" title="面向大堆的 AliGC"></a>面向大堆的 AliGC</h3><p>AliGC是阿里巴巴JVM团队基于G1算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271823864.png">]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第11章-垃圾回收相关概念</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC11%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC11%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收相关概念"><a href="#垃圾回收相关概念" class="headerlink" title="垃圾回收相关概念"></a>垃圾回收相关概念</h1><h2 id="System-gc-的理解"><a href="#System-gc-的理解" class="headerlink" title="System.gc() 的理解"></a>System.gc() 的理解</h2><ol><li><p>在默认情况下，通过System.gc()者Runtime.getRuntime().gc() 的调用，<strong>会显式触发Full GC</strong>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p></li><li><p>然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用(不能确保立即生效)</p></li><li><p>JVM实现者可以通过System.gc() 调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，**无须手动触发，否则就太过于麻烦了。**在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()</p></li></ol><p><strong>代码示例：手动执行 GC 操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SystemGCTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemGCTest</span>();<br>        System.gc();<span class="hljs-comment">//提醒jvm的垃圾回收器执行gc,但是不确定是否马上执行gc</span><br>        <span class="hljs-comment">//与Runtime.getRuntime().gc();的作用一样。</span><br><br><span class="hljs-comment">//        System.runFinalization();//强制调用使用引用的对象的finalize()方法</span><br>    &#125;<br>    <span class="hljs-comment">//如果发生了GC，这个finalize()一定会被调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-built_in">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;SystemGCTest 重写了finalize()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果不确定：有时候会调用 finalize() 方法，有时候并不会调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">SystemGCTest 重写了finalize()<br>或<br>空<br></code></pre></td></tr></table></figure><h3 id="手动-GC-理解不可达对象的回收行为"><a href="#手动-GC-理解不可达对象的回收行为" class="headerlink" title="手动 GC 理解不可达对象的回收行为"></a>手动 GC 理解不可达对象的回收行为</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//加上参数：  -XX:+PrintGCDetails</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVarGC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<span class="hljs-comment">//10MB</span><br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        buffer = <span class="hljs-literal">null</span>;<br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC3</span><span class="hljs-params">()</span> &#123;<br>        &#123;<br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        &#125;<br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC4</span><span class="hljs-params">()</span> &#123;<br>        &#123;<br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localvarGC5</span><span class="hljs-params">()</span> &#123;<br>        localvarGC1();<br>        System.gc();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LocalVarGC</span> <span class="hljs-variable">local</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVarGC</span>();<br>        <span class="hljs-comment">//通过在main方法调用这几个方法进行测试</span><br>        local.localvarGC1();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>JVM参数：</p><p><code>-Xms256m -Xmx256m -XX:+PrintGCDetails -XX:PretenureSizeThreshold=15m</code></p><p>1、第四个参数是设置大对象直接进入老年代的阈值，由于我的电脑8G和视频里老师的电脑16G不太一样。我测试的时候10M的数组都是直接进入到了老年代，为了保持一样的效果，我同时设置了堆内存和大对象阈值，尽量和宋红康老师保持一致</p><p>2、我也查过了大对象阈值的默认值</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822000.png"><p>我不太懂这个默认值为啥是0，我猜测可能是代表什么比例，目前也没有搜到相关的东西。这个不太重要，暂时就没有太深究，希望读者有知道的可以告知我一声。</p><blockquote><p>看不懂GC日志请看笔者的  <strong>堆</strong>那篇文章</p></blockquote><p><strong>1、调用 localvarGC1() 方法</strong></p><p>执行 System.gc() 仅仅是将年轻代的 buffer 数组对象放到了老年代，buffer对象仍然没有回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 15492K-&gt;10728K(76288K)] 15492K-&gt;11000K(251392K), <span class="hljs-number">0.0066473</span> secs] [Times: user=<span class="hljs-number">0.08</span> sys=<span class="hljs-number">0.02</span>, real=<span class="hljs-number">0.01</span> secs] <br>[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 10728K-&gt;0K(76288K)] [ParOldGen: 272K-&gt;10911K(175104K)] 11000K-&gt;10911K(251392K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0097940</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>Heap<br> PSYoungGen      total 76288K, used 655K [<span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space 65536K, <span class="hljs-number">1</span>% used [<span class="hljs-number">0x00000000fab00000</span>,<span class="hljs-number">0x00000000faba3ee8</span>,<span class="hljs-number">0x00000000feb00000</span>)<br>  from space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000ff580000</span>)<br>  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x0000000100000000</span>)<br> ParOldGen       total 175104K, used 10911K [<span class="hljs-number">0x00000000f0000000</span>, <span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x00000000fab00000</span>)<br>  object space 175104K, <span class="hljs-number">6</span>% used [<span class="hljs-number">0x00000000f0000000</span>,<span class="hljs-number">0x00000000f0aa7d08</span>,<span class="hljs-number">0x00000000fab00000</span>)<br> Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576K<br></code></pre></td></tr></table></figure><p><strong>2、调用 localvarGC2() 方法</strong></p><p>由于 buffer 数组对象没有引用指向它，执行 System.gc() 将被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 15492K-&gt;808K(76288K)] 15492K-&gt;816K(251392K), <span class="hljs-number">0.0294475</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.04</span> secs] <br>[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0K(76288K)] [ParOldGen: 8K-&gt;640K(175104K)] 816K-&gt;640K(251392K), [Metaspace: 3385K-&gt;3385K(1056768K)], <span class="hljs-number">0.0054210</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>Heap<br> PSYoungGen      total 76288K, used 1966K [<span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space 65536K, <span class="hljs-number">3</span>% used [<span class="hljs-number">0x00000000fab00000</span>,<span class="hljs-number">0x00000000faceb9e0</span>,<span class="hljs-number">0x00000000feb00000</span>)<br>  from space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000ff580000</span>)<br>  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x0000000100000000</span>)<br> ParOldGen       total 175104K, used 640K [<span class="hljs-number">0x00000000f0000000</span>, <span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x00000000fab00000</span>)<br>  object space 175104K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000f0000000</span>,<span class="hljs-number">0x00000000f00a01a8</span>,<span class="hljs-number">0x00000000fab00000</span>)<br> Metaspace       used 3392K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 379K, capacity 388K, committed 512K, reserved 1048576K<br></code></pre></td></tr></table></figure><p><strong>3、调用 localvarGC3() 方法</strong></p><p>虽然出了代码块的作用域，但是 buffer 数组对象并没有被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 15492K-&gt;840K(76288K)] 15492K-&gt;11088K(251392K), <span class="hljs-number">0.0070281</span> secs] [Times: user=<span class="hljs-number">0.08</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 10248K-&gt;10900K(175104K)] 11088K-&gt;10900K(251392K), [Metaspace: 3386K-&gt;3386K(1056768K)], <span class="hljs-number">0.0084464</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>Heap<br> PSYoungGen      total 76288K, used 1966K [<span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space 65536K, <span class="hljs-number">3</span>% used [<span class="hljs-number">0x00000000fab00000</span>,<span class="hljs-number">0x00000000faceb9e0</span>,<span class="hljs-number">0x00000000feb00000</span>)<br>  from space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000ff580000</span>)<br>  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x0000000100000000</span>)<br> ParOldGen       total 175104K, used 10900K [<span class="hljs-number">0x00000000f0000000</span>, <span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x00000000fab00000</span>)<br>  object space 175104K, <span class="hljs-number">6</span>% used [<span class="hljs-number">0x00000000f0000000</span>,<span class="hljs-number">0x00000000f0aa52e8</span>,<span class="hljs-number">0x00000000fab00000</span>)<br> Metaspace       used 3393K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 379K, capacity 388K, committed 512K, reserved 1048576K<br></code></pre></td></tr></table></figure><p><strong>原因：</strong></p><p>1、来看看字节码：实例方法局部变量表第一个变量肯定是 this</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822001.png"><p>2、你有没有看到，局部变量表的大小是 2。但是局部变量表里只有一个索引为0的啊？那索引为1的是哪个局部变量呢？实际上索引为1的位置是buffer在占用着，执行 System.gc() 时，栈中还有 buffer 变量指向堆中的字节数组，所以没有进行GC</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822002.png"><p>3、那么这种代码块的情况，什么时候会被GC呢？我们来看第四个方法</p><p><strong>4、调用 localvarGC4() 方法</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">15492</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">776</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">15492</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">784</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0009430</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-built_in">Full</span> <span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">System</span><span class="hljs-operator">.</span><span class="hljs-variable">gc</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">776</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">0</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">ParOldGen</span><span class="hljs-operator">:</span> <span class="hljs-number">8</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">784</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">646</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">251392</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">Metaspace</span><span class="hljs-operator">:</span> <span class="hljs-number">3485</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">3485</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0065829</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.02</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.01</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-variable">Heap</span><br> <span class="hljs-variable">PSYoungGen</span>      <span class="hljs-variable">total</span> <span class="hljs-number">76288</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">1966</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fab00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">eden</span> <span class="hljs-variable">space</span> <span class="hljs-number">65536</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fab00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000faceb9f8</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000feb00000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">from</span> <span class="hljs-variable">space</span> <span class="hljs-number">10752</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000feb00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000feb00000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff580000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">to</span>   <span class="hljs-variable">space</span> <span class="hljs-number">10752</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff580000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000ff580000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x0000000100000000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">ParOldGen</span>       <span class="hljs-variable">total</span> <span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">used</span> <span class="hljs-number">646</span><span class="hljs-built_in">K</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000f0000000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000fab00000</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-variable">x00000000fab00000</span><span class="hljs-punctuation">)</span><br>  <span class="hljs-variable">object</span> <span class="hljs-variable">space</span> <span class="hljs-number">175104</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-number">0</span><span class="hljs-operator">%</span> <span class="hljs-variable">used</span> <span class="hljs-punctuation">[</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000f0000000</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000f00a1b88</span><span class="hljs-operator">,</span><span class="hljs-number">0</span><span class="hljs-variable">x00000000fab00000</span><span class="hljs-punctuation">)</span><br> <span class="hljs-variable">Metaspace</span>       <span class="hljs-variable">used</span> <span class="hljs-number">3498</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">4498</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">4864</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1056768</span><span class="hljs-built_in">K</span><br>  <span class="hljs-variable">class</span> <span class="hljs-variable">space</span>    <span class="hljs-variable">used</span> <span class="hljs-number">387</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">capacity</span> <span class="hljs-number">390</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">committed</span> <span class="hljs-number">512</span><span class="hljs-built_in">K</span><span class="hljs-operator">,</span> <span class="hljs-variable">reserved</span> <span class="hljs-number">1048576</span><span class="hljs-built_in">K</span><br></code></pre></td></tr></table></figure><p>Q：就多定义了一个局部变量 value ，就可以把字节数组回收了呢？</p><p>A：局部变量表长度为 2 ，这说明了出了代码块时，buffer 就出了其作用域范围，此时没有为 value 开启新的槽，value 变量直接占据了 buffer 变量的槽（Slot），导致堆中的字节数组没有引用再指向它，执行 System.gc() 时被回收。看，value 位于局部变量表中索引为 1 的位置。value这个局部变量把原本属于buffer的slot给占用了，这样栈上就没有buffer变量指向<code>new byte[10 * 1024 * 1024]</code>实例了。</p><blockquote><p>这点看不懂的可以看我前面的文章：虚拟机栈 –&gt; Slot的重复利用</p></blockquote><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822003.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822004.png"><p><strong>调用 localvarGC5() 方法</strong></p><p>局部变量除了方法范围就是失效了，堆中的字节数组铁定被回收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 15492K-&gt;840K(76288K)] 15492K-&gt;11088K(251392K), <span class="hljs-number">0.0070281</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 840K-&gt;0K(76288K)] [ParOldGen: 10248K-&gt;10911K(175104K)] 11088K-&gt;10911K(251392K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0082011</span> secs] [Times: user=<span class="hljs-number">0.03</span> sys=<span class="hljs-number">0.03</span>, real=<span class="hljs-number">0.01</span> secs] <br>[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(76288K)] 10911K-&gt;10911K(251392K), <span class="hljs-number">0.0004440</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 0K-&gt;0K(76288K)] [ParOldGen: 10911K-&gt;671K(175104K)] 10911K-&gt;671K(251392K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0108555</span> secs] [Times: user=<span class="hljs-number">0.08</span> sys=<span class="hljs-number">0.02</span>, real=<span class="hljs-number">0.01</span> secs] <br>Heap<br> PSYoungGen      total 76288K, used 655K [<span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space 65536K, <span class="hljs-number">1</span>% used [<span class="hljs-number">0x00000000fab00000</span>,<span class="hljs-number">0x00000000faba3ee8</span>,<span class="hljs-number">0x00000000feb00000</span>)<br>  from space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x00000000ff580000</span>,<span class="hljs-number">0x0000000100000000</span>)<br>  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000feb00000</span>,<span class="hljs-number">0x00000000ff580000</span>)<br> ParOldGen       total 175104K, used 671K [<span class="hljs-number">0x00000000f0000000</span>, <span class="hljs-number">0x00000000fab00000</span>, <span class="hljs-number">0x00000000fab00000</span>)<br>  object space 175104K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000f0000000</span>,<span class="hljs-number">0x00000000f00a7cf8</span>,<span class="hljs-number">0x00000000fab00000</span>)<br> Metaspace       used 3499K, capacity 4502K, committed 4864K, reserved 1056768K<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576K<br></code></pre></td></tr></table></figure><h2 id="内存溢出与内存泄漏"><a href="#内存溢出与内存泄漏" class="headerlink" title="内存溢出与内存泄漏"></a>内存溢出与内存泄漏</h2><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><ol><li>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</li><li>由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况。</li><li>大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。</li><li>Javadoc中对OutofMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。</li></ol><p><strong>内存溢出（OOM）原因分析</strong></p><p>首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：</p><ol><li><p>Java虚拟机的堆内存设置不够。</p><ul><li>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms 、-Xmx来调整。</li></ul></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p><ul><li>对于老版本的Oracle JDK，因为永久代的大小是有限的，并且JVM对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见。尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关：“java.lang.OutOfMemoryError:PermGen space”。</li><li>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM，异常信息则变成了：“java.lang.OutofMemoryError:Metaspace”。直接内存不足，也会导致OOM。</li></ul></li><li><p>这里面隐含着一层意思是，在抛出OutofMemoryError之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>例如：在引用机制分析中，涉及到JVM会去尝试<strong>回收软引用指向的对象</strong>等。</li><li>在java.nio.Bits.reserveMemory()方法中，我们能清楚的看到，System.gc()会被调用，以清理空间。</li></ul></li><li><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM可以判断出垃圾收集并不能解决这个问题，所以直接抛出OutofMemoryError。</li></ul></li></ol><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><ol><li><p>也称作“存储渗漏”。严格来说，<strong>只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。</strong></p></li><li><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM，也可以叫做宽泛意义上的“内存泄漏”。</p></li><li><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutofMemory异常，导致程序崩溃。</p></li><li><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p></li></ol><p><strong>内存泄露官方例子</strong></p><p>左边的图：Java使用可达性分析算法，最上面的数据不可达，就是需要被回收的对象。</p><p>右边的图：后期有一些对象不用了，按道理应该断开引用，但是存在一些链没有断开（图示中的Forgotten Reference Memory Leak），从而导致没有办法被回收。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822005.png"><p><strong>常见例子</strong></p><ol><li>单例模式<ul><li>单例的生命周期和应用程序是一样长的，所以在单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</li></ul></li><li>一些提供close()的资源未关闭导致内存泄漏<ul><li>数据库连接 dataSourse.getConnection()，网络连接socket和io连接必须手动close，否则是不能被回收的。</li></ul></li></ol><h2 id="Stop-the-World"><a href="#Stop-the-World" class="headerlink" title="Stop the World"></a>Stop the World</h2><ol><li><p>Stop-the-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>，有点像卡死的感觉，这个停顿称为STW。</p></li><li><p>可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿，为什么需要停顿所有 Java 执行线程呢？</p><ul><li><p>分析工作必须在一个能确保一致性的快照中进行</p></li><li><p>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</p></li><li><p><strong>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</strong></p></li></ul></li><li><p>被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。</p></li><li><p>STW事件和采用哪款GC无关，所有的GC都有这个事件。</p></li><li><p>哪怕是G1也不能完全避免Stop-the-world情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p></li><li><p>STW是JVM在<strong>后台自动发起和自动完成</strong>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p></li><li><p>开发中不要用System.gc() ，这会导致Stop-the-World的发生。</p></li></ol><h3 id="代码感受-Stop-the-World"><a href="#代码感受-Stop-the-World" class="headerlink" title="代码感受 Stop the World"></a>代码感受 Stop the World</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StopTheWorldDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        List&lt;<span class="hljs-type">byte</span>[]&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-type">byte</span>[]&gt;();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">1000</span>;i++)&#123;<br>                        <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>                        list.add(buffer);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span>(list.size() &gt; <span class="hljs-number">10000</span>)&#123;<br>                        list.clear();<br>                        System.gc();<span class="hljs-comment">//会触发full gc，进而会出现STW事件</span><br>                     <br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                ex.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">// 每秒打印时间信息</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - startTime;<br>                    System.out.println(t / <span class="hljs-number">1000</span> + <span class="hljs-string">&quot;.&quot;</span> + t % <span class="hljs-number">1000</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                ex.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WorkThread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkThread</span>();<br>        <span class="hljs-type">PrintThread</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintThread</span>();<br>        w.start();<br>        p.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>关闭工作线程 w ，观察输出：当前时间间隔与上次时间间隔<strong>基本</strong>是每隔1秒打印一次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0.1</span><br><span class="hljs-number">1.1</span><br><span class="hljs-number">2.2</span><br><span class="hljs-number">3.2</span><br><span class="hljs-number">4.3</span><br><span class="hljs-number">5.3</span><br><span class="hljs-number">6.3</span><br><span class="hljs-number">7.3</span><br><br>Process finished with exit code -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>开启工作线程 w ，观察打印输出：当前时间间隔与上次时间间隔相差 1.3s ，可以明显感受到 Stop the World 的存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0.1</span><br><span class="hljs-number">1.4</span><br><span class="hljs-number">2.7</span><br><span class="hljs-number">3.8</span><br><span class="hljs-number">4.12</span><br><span class="hljs-number">5.13</span><br><br>Process finished with exit code -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="垃圾回收的并行与并发"><a href="#垃圾回收的并行与并发" class="headerlink" title="垃圾回收的并行与并发"></a>垃圾回收的并行与并发</h2><h3 id="并发的概念"><a href="#并发的概念" class="headerlink" title="并发的概念"></a>并发的概念</h3><ol><li><p>在操作系统中，是指<strong>一个时间段</strong>中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</p></li><li><p>并发不是真正意义上的“同时进行”，只是CPU把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换。由于CPU处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822006.png"><h3 id="并行的概念"><a href="#并行的概念" class="headerlink" title="并行的概念"></a>并行的概念</h3><ol><li><p>当系统有一个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以<strong>同时</strong>进行，我们称之为并行（Parallel）</p></li><li><p>其实决定并行的因素不是CPU的数量，而是CPU的核心数量，比如一个CPU多个核也可以并行</p></li><li><p>适合科学计算，后台处理等弱交互场景</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822007.png"><blockquote><p><strong>并发与并行的对比</strong></p></blockquote><ol><li>并发，指的是多个事情，在同一时间段内同时发生了。</li><li>并行，指的是多个事情，在同一时间点上（或者说同一时刻）同时发生了。</li><li>并发的多个任务之间是互相抢占资源的。并行的多个任务之间是不互相抢占资源的。</li><li>只有在多CPU或者一个CPU多核的情况中，才会发生并行。否则，看似同时发生的事情，其实都是并发执行的。</li></ol><h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><ol><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。<ul><li>如ParNew、Parallel Scavenge、Parallel Old</li></ul></li><li>串行（Serial）<ul><li>相较于并行的概念，单线程执行。</li><li>如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收（单线程）</li></ul></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822008.png"><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><ol><li>并发（Concurrent）：指<strong>用户线程与垃圾收集线程同时执行</strong>（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。<ul><li>比如用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上；</li></ul></li><li>典型垃圾回收器：CMS、G1</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822009.png"><h2 id="HotSpot的算法实现细节"><a href="#HotSpot的算法实现细节" class="headerlink" title="HotSpot的算法实现细节"></a>HotSpot的算法实现细节</h2><h3 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h3><p>1、固定可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，现在Java应用越做越庞大，光是方法区的大小就常有数百上千兆，里面的类、常量等更是恒河沙数，若要逐个检查以这里为起源的引用肯定得消耗不少时间。 </p><p>2、迄今为止，<strong>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</strong>，因此毫无疑问根节点 枚举与之前提及的整理内存碎片一样会面临相似的“Stop The World”的困扰。现在可达性分析算法耗时 最长的查找引用链的过程已经可以做到与用户线程一起并发，<strong>但根节点枚举始终还 是必须在一个能保障一致性的快照中才得以进行</strong>——这里“一致性”的意思是整个枚举期间执行子系统 看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化 的情况，若这点不能满足的话，分析结果准确性也就无法保证。这是导致垃圾收集过程必须停顿所有 用户线程的其中一个重要原因，即使是号称停顿时间可控，或者（几乎）不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。</p><p>3、由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有 执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。在HotSpot 的解决方案里，是使用一组称为<strong>OopMap的数据结构</strong>来达到这个目的。一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也 会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信 息了，<strong>并不需要真正一个不漏地从方法区等GC Roots开始查找</strong>。</p><p>4、Exact VM因它使用<strong>准确式内存管理</strong>（Exact Memory Management，也可以叫Non-Con- servative&#x2F;Accurate Memory Management）而得名。准确式内存管理是指虚拟机可以知道内存中某个位 置的数据具体是什么类型。譬如内存中有一个32bit的整数123456，虚拟机将有能力分辨出它到底是一 个指向了123456的内存地址的引用类型还是一个数值为123456的整数，准确分辨出哪些内存是引用类 型，这也是在垃圾收集时准确判断堆上的数据是否还可能被使用的前提。【<strong>这个不是特别重要，了解一下即可</strong>】</p><blockquote><p>常考面试：<strong>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举</strong></p></blockquote><h3 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h3><p><strong>安全点（Safepoint）</strong></p><ol><li><p>程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。</p></li><li><p>Safe Point的选择很重要，<strong>如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题</strong>。大部分指令的执行时间都非常短暂，通常会根据“<strong>是否具有让程序长时间执行的特征</strong>”为标准。比如：选择一些执行时间较长的指令作为Safe Point，<strong>如方法调用、循环跳转和异常跳转等</strong>。</p></li></ol><p><strong>如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢？</strong></p><ol><li>抢先式中断：（目前没有虚拟机采用了）首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。</li><li>主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候<strong>主动轮询</strong>这个标志，如果中断标志为真，则将自己进行中断挂起。</li></ol><p><strong>安全区域（Safe Region）</strong></p><ol><li>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？</li><li>例如线程处于Sleep状态或Blocked 状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</li><li><strong>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的</strong>。我们也可以把Safe Region看做是被扩展了的Safepoint。</li></ol><p><strong>安全区域的执行流程</strong></p><ol><li>当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region，如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程</li><li>当线程即将离开Safe Region时，会检查JVM是否已经完成根节点枚举（即GC Roots的枚举），如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止；</li></ol><h3 id="记忆集与卡表"><a href="#记忆集与卡表" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h3><h4 id="什么是跨代引用？"><a href="#什么是跨代引用？" class="headerlink" title="什么是跨代引用？"></a>什么是跨代引用？</h4><p>1、一般的垃圾回收算法至少会划分出两个年代，年轻代和老年代。但是单纯的分代理论在垃圾回收的时候存在一个巨大的缺陷：为了找到年轻代中的存活对象，却不得不遍历整个老年代，反过来也是一样的。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822010.png"><p>2、如果我们从年轻代开始遍历，那么可以断定N, S, P, Q都是存活对象。但是，V却不会被认为是存活对象，其占据的内存会被回收了。这就是一个惊天的大漏洞！因为U本身是老年代对象，而且有外部引用指向它，也就是说U是存活对象，而U指向了V，也就是说V也应该是存活对象才是！而这都是因为我们只遍历年轻代对象！</p><p>3、所以，为了解决这种跨代引用的问题，最笨的办法就是遍历老年代的对象，找出这些跨代引用来。这种方案存在极大的性能浪费。因为从两个分代假说里面，其实隐含了一个推论：跨代引用是极少的。也就是为了找出那么一点点跨代引用，我们却得遍历整个老年代！从上图来说，很显然的是，我们根本不必遍历R。</p><p>4、因此，为了避免这种遍历老年代的性能开销，通常的分代垃圾回收器会引入一种称为<strong>记忆集</strong>的技术。<strong>简单来说，记忆集就是用来记录跨代引用的表。</strong></p><h4 id="记忆集与卡表-1"><a href="#记忆集与卡表-1" class="headerlink" title="记忆集与卡表"></a>记忆集与卡表</h4><p>1、为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建 立了名为<strong>记忆集（Remembered Set）的数据结构</strong>，用以避免把整个老年代加进GC Roots扫描范围。事实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集（Partial GC）行为的 垃圾收集器，典型的如G1、ZGC和Shenandoah收集器，都会面临相同的问题，因此我们有必要进一步 理清记忆集的原理和实现方式，以便在后续章节里介绍几款最新的收集器相关知识时能更好地理解。</p><p>2、记忆集是一种用于记录<strong>从非收集区域指向收集区域的指针集合的抽象数据结构</strong>。如果我们不考虑效率和成本的话，最简单的实现可以用非收集区域中所有含跨代引用的对象数组来实现这个数据结构。</p><blockquote><p>比如说我们有老年代（非收集区域）和年轻代（收集区域）的对象之间有一条引用链</p></blockquote><p>3、这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾 收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针 就可以了，并不需要了解这些跨代指针的全部细节。那设计者在实现记忆集的时候，便可以选择更为 粗犷的记录粒度来节省记忆集的存储和维护成本，下面列举了一些可供选择（当然也可以选择这个范 围以外的）的记录精度：</p><ul><li>字长精度：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。 </li><li>对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。 </li><li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul><p>4、其中，第三种“卡精度”所指的是用一种称为“卡表”（Card Table）的方式去实现记忆集，这也是 目前最常用的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈。前面定义中提到记 忆集其实是一种“抽象”的数据结构，抽象的意思是只定义了记忆集的行为意图，并没有定义其行为的 具体实现。卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 关于卡表与记忆集的关系，读者不妨按照Java语言中HashMap与Map的关系来类比理解。 卡表最简单的形式可以只是一个字节数组，而HotSpot虚拟机确实也是这样做的</p><blockquote><p>读者只需要知道有这个东西，面试的时候能说出来，再细致一点的就需要看周志明老师的第三版书了</p></blockquote><h2 id="再谈引用概述"><a href="#再谈引用概述" class="headerlink" title="再谈引用概述"></a>再谈引用概述</h2><ol><li><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p></li><li><p>既偏门又非常高频的面试题：强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p></li><li><p>在JDK1.2版之后，Java对引用的概念进行了扩充，将引用分为：</p><ul><li>强引用（Strong Reference）</li><li>软引用（Soft Reference）</li><li>弱引用（Weak Reference）</li><li>虚引用（Phantom Reference）</li></ul></li><li><p>这4种引用强度依次逐渐减弱。除强引用外，其他3种引用均可以在java.lang.ref包中找到它们的身影。如下图，显示了这3种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822011.png" ><p>Reference子类中只有终结器引用是包内可见的，其他3种引用类型均为public，可以在应用程序中直接使用</p><ol><li>强引用（StrongReference）：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>object obj=new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。宁可报OOM，也不会GC强引用</li><li>软引用（SoftReference）：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用（WeakReference）：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li>虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ol><h2 id="再谈引用：强引用"><a href="#再谈引用：强引用" class="headerlink" title="再谈引用：强引用"></a>再谈引用：强引用</h2><ol><li><p>在Java程序中，最常见的引用类型是强引用（普通系统99%以上都是强引用），也就是我们最常见的普通对象引用，<strong>也是默认的引用类型</strong>。</p></li><li><p>当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p></li><li><p>**只要强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。**只要强引用的对象是可达的，jvm宁可报OOM，也不会回收强引用。</p></li><li><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p></li><li><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。</p></li></ol><p><strong>强引用代码举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrongReferenceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span> (<span class="hljs-string">&quot;Hello,尚硅谷&quot;</span>);<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> str;<br><br>        str = <span class="hljs-literal">null</span>;<br>        System.gc();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(str1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Hello,尚硅谷<br></code></pre></td></tr></table></figure><p>局部变量str指向stringBuffer实例所在堆空间，通过str可以操作该实例，那么str就是stringBuffer实例的强引用对应内存结构：</p><p><code>StringBuffer str = new StringBuffer(&quot;hello,尚硅谷&quot;);</code></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271822012.png"><p><strong>总结</strong></p><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ol><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ol><h2 id="再谈引用：软引用"><a href="#再谈引用：软引用" class="headerlink" title="再谈引用：软引用"></a>再谈引用：软引用</h2><p><strong>软引用（Soft Reference）：内存不足即回收</strong></p><ol><li><p>软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。注意，这里的第一次回收是不可达的对象</p></li><li><p>软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p></li><li><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p></li><li><p>类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p></li><li><p>一句话概括：当内存足够时，不会回收软引用可达的对象。内存不够时，会回收软引用的可达对象</p></li></ol><p>在JDK1.2版之后提供了SoftReference类来实现软引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">// 声明强引用</span><br>SoftReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(obj);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">//销毁强引用</span><br></code></pre></td></tr></table></figure><p><strong>软引用代码举例</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftReferenceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.id = id;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>        <span class="hljs-keyword">public</span> String name;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[id=&quot;</span> + id + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;] &quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建对象，建立软引用</span><br><span class="hljs-comment">//        SoftReference&lt;User&gt; userSoftRef = new SoftReference&lt;User&gt;(new User(1, &quot;songhk&quot;));</span><br>        <span class="hljs-comment">//上面的一行代码，等价于如下的三行代码</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">u1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;songhk&quot;</span>);<br>        SoftReference&lt;User&gt; userSoftRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;User&gt;(u1);<br>        u1 = <span class="hljs-literal">null</span>;<span class="hljs-comment">//取消强引用</span><br><br><br>        <span class="hljs-comment">//从软引用中重新获得强引用对象</span><br>        System.out.println(userSoftRef.get());<br><br>        System.out.println(<span class="hljs-string">&quot;---目前内存还不紧张---&quot;</span>);<br>        System.gc();<br>        System.out.println(<span class="hljs-string">&quot;After GC:&quot;</span>);<br><span class="hljs-comment">//        //垃圾回收之后获得软引用中的对象</span><br>        System.out.println(userSoftRef.get());<span class="hljs-comment">//由于堆空间内存足够，所有不会回收软引用的可达对象。</span><br>        System.out.println(<span class="hljs-string">&quot;---下面开始内存紧张了---&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//让系统认为内存资源紧张、不够</span><br><span class="hljs-comment">//            byte[] b = new byte[1024 * 1024 * 7];</span><br>            <span class="hljs-type">byte</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">7168</span> - <span class="hljs-number">635</span> * <span class="hljs-number">1024</span>];<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//再次从软引用中获取数据</span><br>            System.out.println(userSoftRef.get());<span class="hljs-comment">//在报OOM之前，垃圾回收器会回收软引用的可达对象。</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>JVM参数</p><p><code>-Xms10m -Xmx10m</code></p><p>在 JVM 内存不足时，会清理软引用对象</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">[id=<span class="hljs-number">1</span>, name=songhk] <br>---目前内存还不紧张---<br>After GC:<br>[id=<span class="hljs-number">1</span>, name=songhk] <br>---下面开始内存紧张了---<br><span class="hljs-literal">null</span><br>java.lang.OutOfMemoryError: Java heap space<br>at com.atguigu.java1.SoftReferenceTest.main(SoftReferenceTest.java:<span class="hljs-number">48</span>)<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="再谈引用：弱引用"><a href="#再谈引用：弱引用" class="headerlink" title="再谈引用：弱引用"></a>再谈引用：弱引用</h2><blockquote><p><strong>弱引用（Weak Reference）发现即回收</strong></p></blockquote><ol><li><p>弱引用也是用来描述那些非必需对象，<strong>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象</strong>。</p></li><li><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。</p></li><li><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p></li><li><p>软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</p></li></ol><p>在JDK1.2版之后提供了WeakReference类来实现弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>WeakReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(obj);<br>obj = <span class="hljs-literal">null</span>; <span class="hljs-comment">//销毁强引用</span><br></code></pre></td></tr></table></figure><p>弱引用对象与软引用对象的最大不同就在于，当GC在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC总是进行回收。弱引用对象更容易、更快被GC回收。</p><p><strong>面试题：你开发中使用过WeakHashMap吗？</strong></p><p><strong>弱引用代码举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakReferenceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>            <span class="hljs-built_in">this</span>.id = id;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>        <span class="hljs-keyword">public</span> String name;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[id=&quot;</span> + id + <span class="hljs-string">&quot;, name=&quot;</span> + name + <span class="hljs-string">&quot;] &quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//构造了弱引用</span><br>        WeakReference&lt;User&gt; userWeakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;User&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;songhk&quot;</span>));<br>        <span class="hljs-comment">//从弱引用中重新获取对象</span><br>        System.out.println(userWeakRef.get());<br><br>        System.gc();<br>        <span class="hljs-comment">// 不管当前内存空间足够与否，都会回收它的内存</span><br>        System.out.println(<span class="hljs-string">&quot;After GC:&quot;</span>);<br>        <span class="hljs-comment">//重新尝试从弱引用中获取对象</span><br>        System.out.println(userWeakRef.get());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行垃圾回收后，软引用对象必定被清除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[id=<span class="hljs-number">1</span>, name=songhk] <br>After GC:<br><span class="hljs-literal">null</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="再谈引用：虚引用"><a href="#再谈引用：虚引用" class="headerlink" title="再谈引用：虚引用"></a>再谈引用：虚引用</h2><p><strong>虚引用（Phantom Reference）：对象回收跟踪</strong></p><ol><li><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个</p></li><li><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p></li><li><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null 。<strong>即通过虚引用无法获取到我们的数据</strong></p></li><li><p><strong>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</strong></p></li><li><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p></li><li><p>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</p></li></ol><p>在JDK1.2版之后提供了PhantomReference类来实现虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 声明强引用</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">// 声明引用队列</span><br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">phantomQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br><span class="hljs-comment">// 声明虚引用（还需要传入引用队列）</span><br>PhantomReference&lt;Object&gt; sf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);<br>obj = <span class="hljs-literal">null</span>; <br></code></pre></td></tr></table></figure><p><strong>虚引用代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhantomReferenceTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PhantomReferenceTest obj;<span class="hljs-comment">//当前类对象的声明</span><br>    <span class="hljs-keyword">static</span> ReferenceQueue&lt;PhantomReferenceTest&gt; phantomQueue = <span class="hljs-literal">null</span>;<span class="hljs-comment">//引用队列</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CheckRefQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (phantomQueue != <span class="hljs-literal">null</span>) &#123;<br>                    PhantomReference&lt;PhantomReferenceTest&gt; objt = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        objt = (PhantomReference&lt;PhantomReferenceTest&gt;) phantomQueue.remove();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (objt != <span class="hljs-literal">null</span>) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;追踪垃圾回收过程：PhantomReferenceTest实例被GC了&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; <span class="hljs-comment">//finalize()方法只能被调用一次！</span><br>        <span class="hljs-built_in">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;调用当前类的finalize()方法&quot;</span>);<br>        obj = <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CheckRefQueue</span>();<br>        t.setDaemon(<span class="hljs-literal">true</span>);<span class="hljs-comment">//设置为守护线程：当程序中没有非守护线程时，守护线程也就执行结束。</span><br>        t.start();<br><br>        phantomQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;PhantomReferenceTest&gt;();<br>        obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReferenceTest</span>();<br>        <span class="hljs-comment">//构造了 PhantomReferenceTest 对象的虚引用，并指定了引用队列</span><br>        PhantomReference&lt;PhantomReferenceTest&gt; phantomRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;PhantomReferenceTest&gt;(obj, phantomQueue);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//不可获取虚引用中的对象</span><br>            System.out.println(phantomRef.get());<br>System.out.println(<span class="hljs-string">&quot;第 1 次 gc&quot;</span>);<br>            <span class="hljs-comment">//将强引用去除</span><br>            obj = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">//第一次进行GC,由于对象可复活，GC无法回收该对象</span><br>            System.gc();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj 是 null&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj 可用&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;第 2 次 gc&quot;</span>);<br>            obj = <span class="hljs-literal">null</span>;<br>            System.gc(); <span class="hljs-comment">//一旦将obj对象回收，就会将此虚引用存放到引用队列中。</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj 是 null&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj 可用&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、第一次尝试获取虚引用的值，发现无法获取的，这是因为虚引用是无法直接获取对象的值，然后进行第一次GC，因为会调用finalize方法，将对象复活了，所以对象没有被回收</p><p>2、但是调用第二次GC操作的时候，因为finalize方法只能执行一次，所以就触发了GC操作，将对象回收了，同时将会触发第二个操作就是将待回收的对象存入到引用队列中。</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-literal">null</span><br>第 <span class="hljs-number">1</span> 次 gc<br>调用当前类的finalize()方法<br>obj 可用<br>第 <span class="hljs-number">2</span> 次 gc<br>追踪垃圾回收过程：PhantomReferenceTest实例被GC了<br>obj 是 <span class="hljs-literal">null</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="再谈引用：终结器引用（了解）"><a href="#再谈引用：终结器引用（了解）" class="headerlink" title="再谈引用：终结器引用（了解）"></a>再谈引用：终结器引用（了解）</h2><ol><li><p>它用于实现对象的finalize() 方法，也可以称为终结器引用</p></li><li><p>无需手动编码，其内部配合引用队列使用</p></li><li><p>在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象调用它的finalize()方法，第二次GC时才回收被引用的对象</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第10章-垃圾回收概述和相关算法</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC10%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%92%8C%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC10%E7%AB%A0-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%92%8C%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821118.png"><ol><li><p>Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。</p></li><li><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</p></li><li><p>关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul></li><li><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p></li></ol><h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><h3 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h3><ol><li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？</li><li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li><li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li><li>GC的两种判定方法？CMS收集器与G1收集器的特点</li></ol><h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ol><li>说一下GC算法，分代回收说下</li><li>垃圾收集策略和算法</li></ol><h3 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h3><ol><li>JVM GC原理，JVM怎么回收内存</li><li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li></ol><h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><ol><li>Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li></ol><h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><ol><li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1，</li><li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li></ol><h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3><ol><li>讲一讲垃圾回收算法。</li><li>什么情况下触发垃圾回收？</li><li>如何选择合适的垃圾收集算法？</li><li>JVM有哪三种垃圾回收器？</li></ol><h3 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h3><ol><li>常见的垃圾回收器算法有哪些，各有什么优劣？</li><li>System.gc()和Runtime.gc()会做什么事情？</li><li>Java GC机制？GC Roots有哪些？</li><li>Java对象的回收方式，回收算法。</li><li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li><li>CMS回收停顿了几次，为什么要停顿两次?</li></ol><h2 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h2><ol><li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li><li>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</li><li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li></ol><p><strong>十几年前磁盘碎片整理的日子</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821119.jpg"><h2 id="为什么需要GC？"><a href="#为什么需要GC？" class="headerlink" title="为什么需要GC？"></a>为什么需要GC？</h2><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p><ol><li><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p></li><li><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</p></li><li><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p></li></ol><h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><ol><li>在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</li></ol>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">MibBridge *pBridge= <span class="hljs-keyword">new</span> cmBaseGroupBridge（）；<br><span class="hljs-comment">//如果注册失败，使用Delete释放该对象所占内存区域</span><br><span class="hljs-keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）<br><span class="hljs-keyword">delete</span> pBridge；<br></code></pre></td></tr></table></figure><ol start="2"><li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p></li><li><p>有了垃圾回收机制后，上述代码极有可能变成这样</p></li></ol>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">MibBridge *pBridge=<span class="hljs-keyword">new</span> <span class="hljs-built_in">cmBaseGroupBridge</span>(); <br>pBridge-&gt;<span class="hljs-built_in">Register</span>(kDestroy);<br></code></pre></td></tr></table></figure><ol start="4"><li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</li></ol><h2 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h2><h3 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h3><blockquote><p><strong>官网介绍</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p></blockquote><p><strong>自动内存管理的优点</strong></p><ol><li><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p></li><li><p>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</p></li><li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p></li></ol><p><strong>关于自动内存管理的担忧</strong></p><ol><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li><li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li></ol><h3 id="应该关心哪些区域的回收？"><a href="#应该关心哪些区域的回收？" class="headerlink" title="应该关心哪些区域的回收？"></a>应该关心哪些区域的回收？</h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821121.png"><ol><li><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，</p></li><li><p>其中，<strong>Java堆是垃圾收集器的工作重点</strong></p></li><li><p>从次数上讲：</p><ol><li>频繁收集Young区</li><li>较少收集Old区</li><li>基本不收集Perm区（元空间）</li></ol></li></ol><h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><h3 id="标记阶段的目的"><a href="#标记阶段的目的" class="headerlink" title="标记阶段的目的"></a>标记阶段的目的</h3><p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p><ol><li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。<strong>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为</strong>垃圾标记阶段</strong>。</li><li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li><li>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</li></ol><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ol><li>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</li><li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li><li>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li><li>缺点：<ol><li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li><li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li></ol></li></ol><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821122.png"><p>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏</p><h3 id="证明：java使用的不是引用计数算法"><a href="#证明：java使用的不是引用计数算法" class="headerlink" title="证明：java使用的不是引用计数算法"></a>证明：java使用的不是引用计数算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -XX:+PrintGCDetails</span><br><span class="hljs-comment"> * 证明：java使用的不是引用计数算法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RefCountGC</span> &#123;<br>    <span class="hljs-comment">//这个成员属性唯一的作用就是占用一点内存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] bigSize = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">5</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<span class="hljs-comment">//5MB</span><br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">reference</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">RefCountGC</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefCountGC</span>();<br>        <span class="hljs-type">RefCountGC</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RefCountGC</span>();<br><br>        obj1.reference = obj2;<br>        obj2.reference = obj1;<br><br>        obj1 = <span class="hljs-literal">null</span>;<br>        obj2 = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//显式的执行垃圾回收行为</span><br>        <span class="hljs-comment">//这里发生GC，obj1和obj2能否被回收？</span><br>        System.gc();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821123.png"><ul><li>如果不小心直接把<code>obj1.reference</code>和<code>obj2.reference</code>置为null。则在Java堆中的两块内存依然保持着互相引用，无法被回收</li></ul><p><strong>没有进行GC时</strong></p><p>把下面的几行代码注释掉，让它来不及</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.gc();<span class="hljs-comment">//把这行代码注释掉</span><br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Heap<br> PSYoungGen      total <span class="hljs-number">38400</span>K, used <span class="hljs-number">14234</span>K [<span class="hljs-number">0x00000000d5f80000</span>, <span class="hljs-number">0x00000000d8a00000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space <span class="hljs-number">33280</span>K, <span class="hljs-number">42</span>% used [<span class="hljs-number">0x00000000d5f80000</span>,<span class="hljs-number">0x00000000d6d66be8</span>,<span class="hljs-number">0x00000000d8000000</span>)<br>  <span class="hljs-keyword">from</span> space <span class="hljs-number">5120</span>K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000d8500000</span>,<span class="hljs-number">0x00000000d8500000</span>,<span class="hljs-number">0x00000000d8a00000</span>)<br>  to   space <span class="hljs-number">5120</span>K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000d8000000</span>,<span class="hljs-number">0x00000000d8000000</span>,<span class="hljs-number">0x00000000d8500000</span>)<br> ParOldGen       total <span class="hljs-number">87552</span>K, used <span class="hljs-number">0</span>K [<span class="hljs-number">0x0000000081e00000</span>, <span class="hljs-number">0x0000000087380000</span>, <span class="hljs-number">0x00000000d5f80000</span>)<br>  object space <span class="hljs-number">87552</span>K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x0000000081e00000</span>,<span class="hljs-number">0x0000000081e00000</span>,<span class="hljs-number">0x0000000087380000</span>)<br> Metaspace       used <span class="hljs-number">3496</span>K, capacity <span class="hljs-number">4498</span>K, committed <span class="hljs-number">4864</span>K, reserved <span class="hljs-number">1056768</span>K<br>  <span class="hljs-keyword">class</span> <span class="hljs-symbol">space</span>    <span class="hljs-symbol">used</span> <span class="hljs-symbol">387K, <span class="hljs-symbol">capacity</span></span> <span class="hljs-symbol">390K, <span class="hljs-symbol">committed</span></span> <span class="hljs-symbol">512K, <span class="hljs-symbol">reserved</span></span> <span class="hljs-symbol">1048576K</span><br><br><span class="hljs-symbol">Process</span> <span class="hljs-symbol">finished</span> <span class="hljs-symbol">with</span> <span class="hljs-symbol">exit</span> <span class="hljs-symbol">code</span> <span class="hljs-symbol">0</span><br></code></pre></td></tr></table></figure><p><strong>进行GC</strong></p><p>打开那行代码的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (System.gc()) [PSYoungGen: 13569K-&gt;808K(38400K)] 13569K-&gt;816K(125952K), <span class="hljs-number">0.0012717</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;670K(87552K)] 816K-&gt;670K(125952K), [Metaspace: 3491K-&gt;3491K(1056768K)], <span class="hljs-number">0.0051769</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>Heap<br> PSYoungGen      total 38400K, used 333K [<span class="hljs-number">0x00000000d5f80000</span>, <span class="hljs-number">0x00000000d8a00000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space 33280K, <span class="hljs-number">1</span>% used [<span class="hljs-number">0x00000000d5f80000</span>,<span class="hljs-number">0x00000000d5fd34a8</span>,<span class="hljs-number">0x00000000d8000000</span>)<br>  from space 5120K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000d8000000</span>,<span class="hljs-number">0x00000000d8000000</span>,<span class="hljs-number">0x00000000d8500000</span>)<br>  to   space 5120K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000d8500000</span>,<span class="hljs-number">0x00000000d8500000</span>,<span class="hljs-number">0x00000000d8a00000</span>)<br> ParOldGen       total 87552K, used 670K [<span class="hljs-number">0x0000000081e00000</span>, <span class="hljs-number">0x0000000087380000</span>, <span class="hljs-number">0x00000000d5f80000</span>)<br>  object space 87552K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x0000000081e00000</span>,<span class="hljs-number">0x0000000081ea7990</span>,<span class="hljs-number">0x0000000087380000</span>)<br> Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576K<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>1、从打印日志就可以明显看出来，已经进行了GC</p><p>2、如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li><li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li><li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li><li>Python如何解决循环引用？<ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li><li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li></ul></li></ol><h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><p><strong>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</strong></p><ol><li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li><li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li></ol><h3 id="可达性分析实现思路"><a href="#可达性分析实现思路" class="headerlink" title="可达性分析实现思路"></a>可达性分析实现思路</h3><ul><li><p>所谓”GCRoots”根集合就是一组必须活跃的引用</p></li><li><p>其基本思路如下：</p></li></ul><ol><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821124.png"><h3 id="GC-Roots可以是哪些元素？"><a href="#GC-Roots可以是哪些元素？" class="headerlink" title="GC Roots可以是哪些元素？"></a>GC Roots可以是哪些元素？</h3><ol><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（StringTable）里的引用</li></ul></li><li>所有被同步锁synchronized持有的对象</li><li>Java虚拟机内部的引用。<ul><li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li></ul></li><li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821125.png"><ol><li>总结一句话就是，堆空间的周边，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</li><li>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和局部回收（PartialGC）。<ul><li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li></ul></li></ol><p><strong>小技巧</strong></p><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li><li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li></ol><h2 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h2><h3 id="finalize-方法机制"><a href="#finalize-方法机制" class="headerlink" title="finalize() 方法机制"></a>finalize() 方法机制</h3><p><strong>对象销毁前的回调函数：finalize()</strong></p><ol><li><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</p></li><li><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p></li><li><p>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p></li></ol><p>Object 类中 finalize() 源码</p><pre><code class="hljs">// 等待被重写protected void finalize() throws Throwable &#123; &#125;</code></pre><ol><li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ol><li>在finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li><li>一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环</li></ol></li><li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在<strong>本质上不同于C++中的析构函数</strong>。</li><li>finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ol><h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态。</strong></p><ol><li>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：<ol><li>可触及的：从根节点开始，可以到达这个对象。</li><li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li><li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li></ol></li><li>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</li></ol><h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p><ol><li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li><li>进行筛选，判断此对象是否有必要执行finalize()方法<ol><li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li><li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li><li>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。</li></ol></li></ol><p><strong>通过 JVisual VM 查看 Finalizer 线程</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821126.png"><h3 id="代码演示-finalize-方法可复活对象"><a href="#代码演示-finalize-方法可复活对象" class="headerlink" title="代码演示 finalize() 方法可复活对象"></a>代码演示 finalize() 方法可复活对象</h3><p>我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CanReliveObj</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CanReliveObj obj;<span class="hljs-comment">//类变量，属于 GC Root</span><br><br><br>    <span class="hljs-comment">//此方法只能被调用一次</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-built_in">super</span>.finalize();<br>        System.out.println(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);<br>        obj = <span class="hljs-built_in">this</span>;<span class="hljs-comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span><br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CanReliveObj</span>();<br>            <span class="hljs-comment">// 对象第一次成功拯救自己</span><br>            obj = <span class="hljs-literal">null</span>;<br>            System.gc();<span class="hljs-comment">//调用垃圾回收器</span><br>            System.out.println(<span class="hljs-string">&quot;第1次 gc&quot;</span>);<br>            <span class="hljs-comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span><br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;第2次 gc&quot;</span>);<br>            <span class="hljs-comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span><br>            obj = <span class="hljs-literal">null</span>;<br>            System.gc();<br>            <span class="hljs-comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span><br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj is dead&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;obj is still alive&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>如果注释掉finalize()方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//此方法只能被调用一次</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>       <span class="hljs-built_in">super</span>.finalize();<br>       System.out.println(<span class="hljs-string">&quot;调用当前类重写的finalize()方法&quot;</span>);<br>       obj = <span class="hljs-built_in">this</span>;<span class="hljs-comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">第<span class="hljs-number">1</span>次 gc<br>obj is dead<br>第<span class="hljs-number">2</span>次 gc<br>obj is dead<br></code></pre></td></tr></table></figure><p><strong>放开finalize()方法</strong></p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">第<span class="hljs-number">1</span>次 gc<br>调用当前类重写的finalize()方法<br>obj is still alive<br>第<span class="hljs-number">2</span>次 gc<br>obj is dead<br><br></code></pre></td></tr></table></figure><p>第一次自救成功，但由于 finalize() 方法只会执行一次，所以第二次自救失败</p><h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT-介绍"><a href="#MAT-介绍" class="headerlink" title="MAT 介绍"></a>MAT 介绍</h3><ol><li>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</li><li>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</li><li>大家可以在<a href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT">http://www.eclipse.org/mat/下载并使用MAT</a></li></ol><blockquote><p>1、虽然Jvisualvm很强大，但是在内存分析方面，还是MAT更好用一些</p><p>2、此小节主要是为了实时分析GC Roots是哪些东西，中间需要用到一个dump的文件</p></blockquote><h3 id="获取-dump-文件方式"><a href="#获取-dump-文件方式" class="headerlink" title="获取 dump 文件方式"></a>获取 dump 文件方式</h3><p><strong>方式一：命令行使用 jmap</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821127.png"><p><strong>方式二：使用JVisualVM</strong></p><ol><li>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</li><li>操作步骤下面演示</li></ol><h3 id="捕捉-dump-示例"><a href="#捕捉-dump-示例" class="headerlink" title="捕捉 dump 示例"></a>捕捉 dump 示例</h3><h4 id="使用JVisualVM捕捉-heap-dump"><a href="#使用JVisualVM捕捉-heap-dump" class="headerlink" title="使用JVisualVM捕捉 heap dump"></a>使用JVisualVM捕捉 heap dump</h4><p>代码：</p><ul><li>numList 和 birth 在第一次捕捉内存快照的时候，为 GC Roots</li><li>之后 numList 和 birth 置为 null ，对应的引用对象被回收，在第二次捕捉内存快照的时候，就不再是 GC Roots</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCRootsTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Object&gt; numList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">birth</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            numList.add(String.valueOf(i));<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;数据添加完毕，请操作：&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).next();<br>        numList = <span class="hljs-literal">null</span>;<br>        birth = <span class="hljs-literal">null</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;numList、birth已置空，请操作：&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).next();<br><br>        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>如何捕捉堆内存快照</strong></p><p>1、先执行第一步，然后停下来，去生成此步骤dump文件</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821128.png"><p>2、 点击【堆 Dump】</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821129.png"><p>3、右键 –&gt; 另存为即可</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821130.jpg"><p>4、输入命令，继续执行程序</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821131.png"><p>5、我们接着捕获第二张堆内存快照</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821132.jpg"><h4 id="使用-MAT-查看堆内存快照"><a href="#使用-MAT-查看堆内存快照" class="headerlink" title="使用 MAT 查看堆内存快照"></a>使用 MAT 查看堆内存快照</h4><p>1、打开 MAT ，选择File –&gt; Open File，打开刚刚的两个dump文件，<strong>我们先打开第一个dump文件</strong></p><blockquote><p>点击Open Heap Dump也行</p></blockquote><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821133.png"><p>2、选择Java Basics –&gt; GC Roots</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821134.png"><p>3、第一次捕捉堆内存快照时，GC Roots 中包含我们定义的两个局部变量，类型分别为 ArrayList 和 Date，Total:21</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821135.jpg"><p>4、打开第二个dump文件，第二次捕获内存快照时，由于两个局部变量引用的对象被释放，所以这两个局部变量不再作为 GC Roots ，从 Total Entries &#x3D; 19 也可以看出（少了两个 GC Roots）</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821136.jpg"><h3 id="JProfiler-GC-Roots-溯源"><a href="#JProfiler-GC-Roots-溯源" class="headerlink" title="JProfiler GC Roots 溯源"></a>JProfiler GC Roots 溯源</h3><p>1、在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<strong>GC Roots 溯源</strong></p><p>2、下面我们使用使用 JProfiler 进行 GC Roots 溯源演示</p><p>依然用下面这个代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCRootsTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;Object&gt; numList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">birth</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            numList.add(String.valueOf(i));<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;数据添加完毕，请操作：&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).next();<br>        numList = <span class="hljs-literal">null</span>;<br>        birth = <span class="hljs-literal">null</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;numList、birth已置空，请操作：&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in).next();<br><br>        System.out.println(<span class="hljs-string">&quot;结束&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>1、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821137.jpg"><p>2、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821138.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821139.jpg"><p>可以发现颜色变绿了，可以动态的看变化</p><p>3、右击对象，选择 Show Selection In Heap Walker，单独的查看某个对象</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821140.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821141.png"><p>4、选择Incoming References，表示追寻 GC Roots 的源头</p><p>点击Show Paths To GC Roots，在弹出界面中选择默认设置即可</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821142.jpg"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821143.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821144.png"><h3 id="JProfiler-分析-OOM"><a href="#JProfiler-分析-OOM" class="headerlink" title="JProfiler 分析 OOM"></a>JProfiler 分析 OOM</h3><blockquote><p>这里是简单的讲一下，后面篇章会详解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -Xms8m -Xmx8m </span><br><span class="hljs-comment"> * -XX:+HeapDumpOnOutOfMemoryError  这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapOOM</span> &#123;<br>    <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<span class="hljs-comment">//1MB</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;HeapOOM&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HeapOOM</span>());<br>                count++;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (Throwable e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">com.atguigu.java.HeapOOM<br>java.lang.OutOfMemoryError: Java heap space<br>Dumping heap to java_pid14608.hprof ...<br>java.lang.OutOfMemoryError: Java heap space<br>at com.atguigu.java.HeapOOM.&lt;init&gt;(HeapOOM.java:<span class="hljs-number">12</span>)<br>at com.atguigu.java.HeapOOM.main(HeapOOM.java:<span class="hljs-number">20</span>)<br>Heap dump file created [<span class="hljs-number">7797849</span> bytes in <span class="hljs-number">0.010</span> secs]<br>count = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>打开这个dump文件</p><p>1、看这个超大对象</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821145.png"><p>2、揪出 main() 线程中出问题的代码</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821146.png"><h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p><strong>垃圾清除阶段</strong></p><ul><li>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</li></ul><ol><li>标记-清除算法（Mark-Sweep）</li><li>复制算法（Copying）</li><li>标记-压缩算法（Mark-Compact）</li></ol><p><strong>背景</strong></p><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p><p><strong>执行过程</strong></p><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ol><li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<ul><li>注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</li></ul></li><li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821147.png"><p><strong>标记-清除算法的缺点</strong></p><ol><li>标记清除算法的效率不算高</li><li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li></ol><p><strong>注意：何为清除？</strong></p><p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。</p><p>关于空闲列表是在为对象分配内存的时候提过：</p><ol><li>如果内存规整<ul><li>采用指针碰撞的方式进行内存分配</li></ul></li><li>如果内存不规整<ul><li>虚拟机需要维护一个空闲列表</li><li>采用空闲列表分配内存</li></ul></li></ol><h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><p><strong>背景</strong></p><ol><li>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</li></ol><p><strong>核心思想</strong></p><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821148.png"><p>新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区</p><p><strong>复制算法的优缺点</strong></p><p><strong>优点</strong></p><ol><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ol><p><strong>缺点</strong></p><ol><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li></ol><p><strong>复制算法的应用场景</strong></p><ol><li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，效率较高</li><li>老年代大量的对象存活，那么复制的对象将会有很多，效率会很低</li><li>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821149.png"><h2 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h2><p><strong>标记-压缩（或标记-整理、Mark - Compact）算法</strong></p><p><strong>背景</strong></p><ol><li><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法。</strong></p></li><li><p>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p></li><li><p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p></li></ol><p><strong>执行过程</strong></p><ol><li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p></li><li><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821150.png"><p><strong>标记-压缩算法与标记-清除算法的比较</strong></p><ol><li><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p></li><li><p>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p></li><li><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p></li></ol><p><strong>标记-压缩算法的优缺点</strong></p><p><strong>优点</strong></p><ol><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ol><p><strong>缺点</strong></p><ol><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ol><h2 id="垃圾回收算法小结"><a href="#垃圾回收算法小结" class="headerlink" title="垃圾回收算法小结"></a>垃圾回收算法小结</h2><blockquote><p><strong>对比三种清除阶段的算法</strong></p></blockquote><ol><li><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p></li><li><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p></li></ol><table><thead><tr><th></th><th>标记清除</th><th>标记整理</th><th>复制</th></tr></thead><tbody><tr><td><strong>速率</strong></td><td>中等</td><td>最慢</td><td>最快</td></tr><tr><td><strong>空间开销</strong></td><td>少（但会堆积碎片）</td><td>少（不堆积碎片）</td><td>通常需要活对象的2倍空间（不堆积碎片）</td></tr><tr><td><strong>移动对象</strong></td><td>否</td><td>是</td><td>是</td></tr></tbody></table><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>Q：难道就没有一种最优的算法吗？</p><p>A：无，没有最好的算法，只有最合适的算法</p><p><strong>为什么要使用分代收集算法</strong></p><ol><li><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p></li><li><p>分代收集算法，是基于这样一个事实：**不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。**一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p></li><li><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:</p><ul><li>比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。</li><li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li></ul></li></ol><p><strong>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</strong></p><p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p><ol><li><p>年轻代（Young Gen）</p><ul><li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li><li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li></ul></li><li><p>老年代（Tenured Gen）</p><ul><li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。<ul><li><p>Mark阶段的开销与存活对象的数量成正比。</p></li><li><p>Sweep阶段的开销与所管理区域的大小成正相关。</p></li><li><p>Compact阶段的开销与存活对象的数据成正比。</p></li></ul></li></ul></li><li><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p></li><li><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p></li></ol><h2 id="增量收集算法和分区算法"><a href="#增量收集算法和分区算法" class="headerlink" title="增量收集算法和分区算法"></a>增量收集算法和分区算法</h2><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><p><strong>增量收集算法基本思想</strong></p><ol><li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。<strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></li><li>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></li></ol><p><strong>增量收集算法的缺点</strong></p><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p><h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><blockquote><p>主要针对G1收集器来说的</p></blockquote><ol><li>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li><li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271821151.png"><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第9章-StringTable(字符串常量池)</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC9%E7%AB%A0-StringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC9%E7%AB%A0-StringTable(%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)/</url>
    
    <content type="html"><![CDATA[<h1 id="StringTable（字符串常量池）"><a href="#StringTable（字符串常量池）" class="headerlink" title="StringTable（字符串常量池）"></a>StringTable（字符串常量池）</h1><h2 id="String的基本特性"><a href="#String的基本特性" class="headerlink" title="String的基本特性"></a>String的基本特性</h2><ol><li>String：字符串，使用一对 “” 引起来表示</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu&quot;</span> ;   <span class="hljs-comment">// 字面量的定义方式</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);     <span class="hljs-comment">// new 对象的方式</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>String被声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</p></li><li><p>String在jdk8及以前内部定义了<code>final char value[]</code>用于存储字符串数据。JDK9时改为<code>byte[]</code></p></li></ol><h2 id="为什么-JDK9-改变了-String-的结构"><a href="#为什么-JDK9-改变了-String-的结构" class="headerlink" title="为什么 JDK9 改变了 String 的结构"></a>为什么 JDK9 改变了 String 的结构</h2><blockquote><p> <strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/254">http://openjdk.java.net/jeps/254</a></p></blockquote><p><strong>为什么改为 byte[] 存储？</strong></p><ol><li>String类的当前实现将字符存储在char数组中，每个字符使用两个字节(16位)。</li><li>从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数字符串对象只包含拉丁字符（Latin-1）。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中有一半的空间将不会使用，产生了大量浪费。</li><li>之前 String 类使用 UTF-16 的 char[] 数组存储，现在改为 byte[] 数组 外加一个编码标识存储。该编码表示如果你的字符是ISO-8859-1或者Latin-1，那么只需要一个字节存。如果你是其它字符集，比如UTF-8，你仍然用两个字节存</li><li>结论：String再也不用char[] 来存储了，改成了byte [] 加上编码标记，节约了一些空间</li><li>同时基于String的数据结构，例如StringBuffer和StringBuilder也同样做了修改</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 之前</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[];<br><span class="hljs-comment">// 之后</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] value<br></code></pre></td></tr></table></figure><h3 id="String-的基本特性"><a href="#String-的基本特性" class="headerlink" title="String 的基本特性"></a>String 的基本特性</h3><ul><li>String：代表不可变的字符序列。简称：不可变性。</li></ul><ol><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li></ol><ul><li>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</li></ul><p><strong>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//字面量定义的方式，&quot;abc&quot;存储在字符串常量池中</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>       s1 = <span class="hljs-string">&quot;hello&quot;</span>;<br><br>       System.out.println(s1 == s2);<span class="hljs-comment">//判断地址：true  --&gt; false</span><br><br>       System.out.println(s1);<span class="hljs-comment">//</span><br>       System.out.println(s2);<span class="hljs-comment">//abc</span><br><br>   &#125;<br></code></pre></td></tr></table></figure><p>字节码指令</p><ul><li>取字符串 “abc” 时，使用的是同一个符号引用：#2</li><li>取字符串 “hello” 时，使用的是另一个符号引用：#3</li></ul><p><strong>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>       s2 += <span class="hljs-string">&quot;def&quot;</span>;<br>       System.out.println(s2);<span class="hljs-comment">//abcdef</span><br>       System.out.println(s1);<span class="hljs-comment">//abc</span><br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>当调用string的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;m&#x27;</span>);<br>    System.out.println(s1);<span class="hljs-comment">//abc</span><br>    System.out.println(s2);<span class="hljs-comment">//mbc</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一道笔试题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExer</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;good&quot;</span>);<br>    <span class="hljs-type">char</span>[] ch = &#123;<span class="hljs-string">&#x27;t&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;t&#x27;</span>&#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String str, <span class="hljs-type">char</span> ch[])</span> &#123;<br>        str = <span class="hljs-string">&quot;test ok&quot;</span>;<br>        ch[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringExer</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringExer</span>();<br>        ex.change(ex.str, ex.ch);<br>        System.out.println(ex.str);<span class="hljs-comment">//good</span><br>        System.out.println(ex.ch);<span class="hljs-comment">//best</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>str 的内容并没有变：“test ok” 位于字符串常量池中的另一个区域（地址），进行赋值操作并没有修改原来 str 指向的引用的内容</p><h3 id="String-的底层结构"><a href="#String-的底层结构" class="headerlink" title="String 的底层结构"></a>String 的底层结构</h3><p><strong>字符串常量池是不会存储相同内容的字符串的</strong></p><ol><li>String的String Pool（字符串常量池）是一个固定大小的Hashtable，默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()方法时性能会大幅下降。</li><li>使用-XX:StringTablesize可设置StringTable的长度</li><li>在JDK6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快，StringTablesize设置没有要求</li><li>在JDK7中，StringTable的长度默认值是60013，StringTablesize设置没有要求</li><li>在JDK8中，StringTable的长度默认值是60013，StringTable可以设置的最小值为1009</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818512.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818513.png"><p><strong>测试不同 StringTable 长度下，程序的性能</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 产生10万个长度不超过10的字符串，包含a-z,A-Z</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenerateString</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">FileWriter</span> <span class="hljs-variable">fw</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(<span class="hljs-string">&quot;words.txt&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            <span class="hljs-comment">//1 - 10</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * (<span class="hljs-number">10</span> - <span class="hljs-number">1</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>);<br>            fw.write(getString(length) + <span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br><br>        fw.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getString</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">//65 - 90, 97-122</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(Math.random() * (<span class="hljs-number">90</span> - <span class="hljs-number">65</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">65</span>) + (<span class="hljs-type">int</span>)(Math.random() * <span class="hljs-number">2</span>) * <span class="hljs-number">32</span>;<br>            str += (<span class="hljs-type">char</span>)num;<br>        &#125;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            br = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;words.txt&quot;</span>));<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            String data;<br>            <span class="hljs-keyword">while</span>((data = br.readLine()) != <span class="hljs-literal">null</span>)&#123;<br>                data.intern(); <span class="hljs-comment">//如果字符串常量池中没有对应data的字符串的话，则在常量池中生成</span><br>            &#125;<br><br>            <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>            System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));<span class="hljs-comment">//1009:143ms  100009:47ms</span><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span>(br != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    br.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>-XX:StringTableSize&#x3D;1009 ：程序耗时 143ms</p></li><li><p>-XX:StringTableSize&#x3D;100009 ：程序耗时 47ms</p></li></ul><h2 id="String-的内存分配"><a href="#String-的内存分配" class="headerlink" title="String 的内存分配"></a>String 的内存分配</h2><ol><li><p>在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p></li><li><p>常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。</p><ul><li><p>直接使用双引号声明出来的String对象会直接存储在常量池中。比如：<code>String info=&quot;atguigu.com&quot;;</code></p></li><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern()方法。这个后面重点谈</p></li></ul></li><li><p>Java 6及以前，字符串常量池存放在永久代</p></li><li><p>Java 7中 Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内</p><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。</li></ul></li><li><p>Java8元空间，字符串常量在堆</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818514.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818515.png"><h3 id="StringTable-为什么要调整？"><a href="#StringTable-为什么要调整？" class="headerlink" title="StringTable 为什么要调整？"></a>StringTable 为什么要调整？</h3><blockquote><p><strong>官方文档</strong>:<a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes</a></p></blockquote><ol><li>为什么要调整位置？<ul><li>永久代的默认空间大小比较小</li><li>永久代垃圾回收频率低，大量的字符串无法及时回收，容易进行Full GC产生STW或者容易产生OOM：PermGen Space</li><li>堆中空间足够大，字符串可被及时回收</li></ul></li><li>在JDK 7中，interned字符串不再在Java堆的永久代中分配，而是在Java堆的主要部分（称为年轻代和年老代）中分配，与应用程序创建的其他对象一起分配。</li><li>此更改将导致驻留在主Java堆中的数据更多，驻留在永久生成中的数据更少，因此可能需要调整堆大小。</li></ol><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * jdk6中：</span><br><span class="hljs-comment"> * -XX:PermSize=6m -XX:MaxPermSize=6m -Xms6m -Xmx6m</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * jdk8中：</span><br><span class="hljs-comment"> * -XX:MetaspaceSize=6m -XX:MaxMetaspaceSize=6m -Xms6m -Xmx6m</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//使用Set保持着常量池引用，避免full gc回收常量池行为</span><br>        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<br>        <span class="hljs-comment">//在short可以取值的范围内足以让6MB的PermSize或heap产生OOM了。</span><br>        <span class="hljs-type">short</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            set.add(String.valueOf(i++).intern());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：我真没骗你，字符串真的在堆中（JDK8）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space<br>at java.util.HashMap.resize(HashMap.java:<span class="hljs-number">703</span>)<br>at java.util.HashMap.putVal(HashMap.java:<span class="hljs-number">662</span>)<br>at java.util.HashMap.put(HashMap.java:<span class="hljs-number">611</span>)<br>at java.util.HashSet.add(HashSet.java:<span class="hljs-number">219</span>)<br>at com.atguigu.java.StringTest3.main(StringTest3.java:<span class="hljs-number">22</span>)<br><br>Process finished with exit code <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="String-的基本操作"><a href="#String-的基本操作" class="headerlink" title="String 的基本操作"></a>String 的基本操作</h2><p>Java语言规范里要求完全相同的字符串字面量，应该包含同样的Unicode字符序列（包含同一份码点序列的常量），并且必须是指向同一个String类实例。</p><h3 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest4</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println();<span class="hljs-comment">//2293</span><br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//2294</span><br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;5&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;6&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;7&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;8&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;9&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;10&quot;</span>);<span class="hljs-comment">//2303</span><br>        <span class="hljs-comment">//如下的字符串&quot;1&quot; 到 &quot;10&quot;不会再次加载</span><br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//2304</span><br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<span class="hljs-comment">//2304</span><br>        System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;5&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;6&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;7&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;8&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;9&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;10&quot;</span>);<span class="hljs-comment">//2304</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析字符串常量池的变化</p><p>1、程序启动时已经加载了 2293 个字符串常量</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818516.png"><p>2、加载了一个换行符（println），所以多了一个</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818517.jpg"><p>3、加载了字符串常量 “1”~“9”</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818518.jpg"><p>4、加载字符串常量 “10”</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818519.jpg"><p>5、之后的字符串”1” 到 “10”不会再次加载</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818520.png"><h3 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//官方示例代码</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<span class="hljs-comment">//line 1</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//line 2</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<span class="hljs-comment">//line 3</span><br>        <span class="hljs-type">Memory</span> <span class="hljs-variable">mem</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Memory</span>();<span class="hljs-comment">//line 4</span><br>        mem.foo(obj);<span class="hljs-comment">//line 5</span><br>    &#125;<span class="hljs-comment">//line 9</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(Object param)</span> &#123;<span class="hljs-comment">//line 6</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> param.toString();<span class="hljs-comment">//line 7</span><br>        System.out.println(str);<br>    &#125;<span class="hljs-comment">//line 8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>分析运行时内存（foo() 方法是实例方法，其实图中少了一个 this 局部变量）</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818521.png"><h2 id="字符串拼接操作"><a href="#字符串拼接操作" class="headerlink" title="字符串拼接操作"></a>字符串拼接操作</h2><h3 id="先说结论"><a href="#先说结论" class="headerlink" title="先说结论"></a>先说结论</h3><ol><li>常量与常量的拼接结果在常量池，原理是编译期优化</li><li>常量池中不会存在相同内容的变量</li><li>拼接前后，只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder</li><li>如果拼接的结果调用intern()方法，根据该字符串是否在常量池中存在，分为：<ul><li>如果存在，则返回字符串在常量池中的地址</li><li>如果字符串常量池中不存在该字符串，则在常量池中创建一份，并返回此对象的地址</li></ul></li></ol><p><strong>1、常量与常量的拼接结果在常量池，原理是编译期优化</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>;<span class="hljs-comment">//编译期优化：等同于&quot;abc&quot;</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">//&quot;abc&quot;一定是放在字符串常量池中，将此地址赋给s2</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 最终.java编译成.class,再执行.class</span><br><span class="hljs-comment">         * String s1 = &quot;abc&quot;;</span><br><span class="hljs-comment">         * String s2 = &quot;abc&quot;</span><br><span class="hljs-comment">         */</span><br>        System.out.println(s1 == s2); <span class="hljs-comment">//true</span><br>        System.out.println(s1.equals(s2)); <span class="hljs-comment">//true</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>从字节码指令看出：编译器做了优化，将 “a” + “b” + “c” 优化成了 “abc”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> ldc #<span class="hljs-number">2</span> &lt;abc&gt;<br><span class="hljs-number">2</span> astore_1<br><span class="hljs-number">3</span> ldc #<span class="hljs-number">2</span> &lt;abc&gt;<br><span class="hljs-number">5</span> astore_2<br><span class="hljs-number">6</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">9</span> aload_1<br><span class="hljs-number">10</span> aload_2<br><span class="hljs-number">11</span> if_acmpne <span class="hljs-number">18</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">14</span> iconst_1<br><span class="hljs-number">15</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">19</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">18</span> iconst_0<br><span class="hljs-number">19</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">22</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">25</span> aload_1<br><span class="hljs-number">26</span> aload_2<br><span class="hljs-number">27</span> invokevirtual #<span class="hljs-number">5</span> &lt;java/lang/String.equals&gt;<br><span class="hljs-number">30</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">33</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>IDEA 反编译 class 文件后，来看这个问题</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818522.png"><p><strong>2、拼接前后，只要其中有一个是变量，结果就在堆中</strong></p><p><strong>调用 intern() 方法，则主动将字符串对象存入字符串常量池中，并将其地址返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hadoop&quot;</span>;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEEhadoop&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span> + <span class="hljs-string">&quot;hadoop&quot;</span>;<span class="hljs-comment">//编译期优化</span><br>        <span class="hljs-comment">//如果拼接符号的前后出现了变量，则相当于在堆空间中new String()，具体的内容为拼接的结果：javaEEhadoop</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> s1 + <span class="hljs-string">&quot;hadoop&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span> + s2;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s7</span> <span class="hljs-operator">=</span> s1 + s2;<br><br>        System.out.println(s3 == s4);<span class="hljs-comment">//true</span><br>        System.out.println(s3 == s5);<span class="hljs-comment">//false</span><br>        System.out.println(s3 == s6);<span class="hljs-comment">//false</span><br>        System.out.println(s3 == s7);<span class="hljs-comment">//false</span><br>        System.out.println(s5 == s6);<span class="hljs-comment">//false</span><br>        System.out.println(s5 == s7);<span class="hljs-comment">//false</span><br>        System.out.println(s6 == s7);<span class="hljs-comment">//false</span><br>        <span class="hljs-comment">//intern():判断字符串常量池中是否存在javaEEhadoop值，如果存在，则返回常量池中javaEEhadoop的地址；</span><br>        <span class="hljs-comment">//如果字符串常量池中不存在javaEEhadoop，则在常量池中加载一份javaEEhadoop，并返回次对象的地址。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s8</span> <span class="hljs-operator">=</span> s6.intern();<br>        System.out.println(s3 == s8);<span class="hljs-comment">//true</span><br>    &#125;<br><br></code></pre></td></tr></table></figure><p>从字节码角度来看：拼接前后有变量，都会使用到 StringBuilder 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> ldc #<span class="hljs-number">6</span> &lt;javaEE&gt;<br><span class="hljs-number">2</span> astore_1<br><span class="hljs-number">3</span> ldc #<span class="hljs-number">7</span> &lt;hadoop&gt;<br><span class="hljs-number">5</span> astore_2<br><span class="hljs-number">6</span> ldc #<span class="hljs-number">8</span> &lt;javaEEhadoop&gt;<br><span class="hljs-number">8</span> astore_3<br><span class="hljs-number">9</span> ldc #<span class="hljs-number">8</span> &lt;javaEEhadoop&gt;<br><span class="hljs-number">11</span> astore <span class="hljs-number">4</span><br><span class="hljs-number">13</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder&gt;<br><span class="hljs-number">16</span> dup<br><span class="hljs-number">17</span> invokespecial #<span class="hljs-number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<br><span class="hljs-number">20</span> aload_1<br><span class="hljs-number">21</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">24</span> ldc #<span class="hljs-number">7</span> &lt;hadoop&gt;<br><span class="hljs-number">26</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">29</span> invokevirtual #<span class="hljs-number">12</span> &lt;java/lang/StringBuilder.toString&gt;<br><span class="hljs-number">32</span> astore <span class="hljs-number">5</span><br><span class="hljs-number">34</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder&gt;<br><span class="hljs-number">37</span> dup<br><span class="hljs-number">38</span> invokespecial #<span class="hljs-number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<br><span class="hljs-number">41</span> ldc #<span class="hljs-number">6</span> &lt;javaEE&gt;<br><span class="hljs-number">43</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">46</span> aload_2<br><span class="hljs-number">47</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">50</span> invokevirtual #<span class="hljs-number">12</span> &lt;java/lang/StringBuilder.toString&gt;<br><span class="hljs-number">53</span> astore <span class="hljs-number">6</span><br><span class="hljs-number">55</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder&gt;<br><span class="hljs-number">58</span> dup<br><span class="hljs-number">59</span> invokespecial #<span class="hljs-number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<br><span class="hljs-number">62</span> aload_1<br><span class="hljs-number">63</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">66</span> aload_2<br><span class="hljs-number">67</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">70</span> invokevirtual #<span class="hljs-number">12</span> &lt;java/lang/StringBuilder.toString&gt;<br><span class="hljs-number">73</span> astore <span class="hljs-number">7</span><br><span class="hljs-number">75</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">78</span> aload_3<br><span class="hljs-number">79</span> aload <span class="hljs-number">4</span><br><span class="hljs-number">81</span> if_acmpne <span class="hljs-number">88</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">84</span> iconst_1<br><span class="hljs-number">85</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">89</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">88</span> iconst_0<br><span class="hljs-number">89</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">92</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">95</span> aload_3<br><span class="hljs-number">96</span> aload <span class="hljs-number">5</span><br><span class="hljs-number">98</span> if_acmpne <span class="hljs-number">105</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">101</span> iconst_1<br><span class="hljs-number">102</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">106</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">105</span> iconst_0<br><span class="hljs-number">106</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">109</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">112</span> aload_3<br><span class="hljs-number">113</span> aload <span class="hljs-number">6</span><br><span class="hljs-number">115</span> if_acmpne <span class="hljs-number">122</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">118</span> iconst_1<br><span class="hljs-number">119</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">123</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">122</span> iconst_0<br><span class="hljs-number">123</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">126</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">129</span> aload_3<br><span class="hljs-number">130</span> aload <span class="hljs-number">7</span><br><span class="hljs-number">132</span> if_acmpne <span class="hljs-number">139</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">135</span> iconst_1<br><span class="hljs-number">136</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">140</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">139</span> iconst_0<br><span class="hljs-number">140</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">143</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">146</span> aload <span class="hljs-number">5</span><br><span class="hljs-number">148</span> aload <span class="hljs-number">6</span><br><span class="hljs-number">150</span> if_acmpne <span class="hljs-number">157</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">153</span> iconst_1<br><span class="hljs-number">154</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">158</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">157</span> iconst_0<br><span class="hljs-number">158</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">161</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">164</span> aload <span class="hljs-number">5</span><br><span class="hljs-number">166</span> aload <span class="hljs-number">7</span><br><span class="hljs-number">168</span> if_acmpne <span class="hljs-number">175</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">171</span> iconst_1<br><span class="hljs-number">172</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">176</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">175</span> iconst_0<br><span class="hljs-number">176</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">179</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">182</span> aload <span class="hljs-number">6</span><br><span class="hljs-number">184</span> aload <span class="hljs-number">7</span><br><span class="hljs-number">186</span> if_acmpne <span class="hljs-number">193</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">189</span> iconst_1<br><span class="hljs-number">190</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">194</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">193</span> iconst_0<br><span class="hljs-number">194</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">197</span> aload <span class="hljs-number">6</span><br><span class="hljs-number">199</span> invokevirtual #<span class="hljs-number">13</span> &lt;java/lang/String.intern&gt;<br><span class="hljs-number">202</span> astore <span class="hljs-number">8</span><br><span class="hljs-number">204</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">207</span> aload_3<br><span class="hljs-number">208</span> aload <span class="hljs-number">8</span><br><span class="hljs-number">210</span> if_acmpne <span class="hljs-number">217</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">213</span> iconst_1<br><span class="hljs-number">214</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">218</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">217</span> iconst_0<br><span class="hljs-number">218</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">221</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><h3 id="字符串拼接的底层细节"><a href="#字符串拼接的底层细节" class="headerlink" title="字符串拼接的底层细节"></a>字符串拼接的底层细节</h3><p><strong>举例1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    如下的s1 + s2 的执行细节：(变量s是我临时定义的）</span><br><span class="hljs-comment">    ① StringBuilder s = new StringBuilder();</span><br><span class="hljs-comment">    ② s.append(&quot;a&quot;)</span><br><span class="hljs-comment">    ③ s.append(&quot;b&quot;)</span><br><span class="hljs-comment">    ④ s.toString()  --&gt; 约等于 new String(&quot;ab&quot;)，但不等价</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    补充：在jdk5.0之后使用的是StringBuilder,在jdk5.0之前使用的是StringBuffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;<span class="hljs-comment">//</span><br>    System.out.println(s3 == s4);<span class="hljs-comment">//false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> ldc #<span class="hljs-number">14</span> &lt;a&gt;<br><span class="hljs-number">2</span> astore_1<br><span class="hljs-number">3</span> ldc #<span class="hljs-number">15</span> &lt;b&gt;<br><span class="hljs-number">5</span> astore_2<br><span class="hljs-number">6</span> ldc #<span class="hljs-number">16</span> &lt;ab&gt;<br><span class="hljs-number">8</span> astore_3<br><span class="hljs-number">9</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder&gt;<br><span class="hljs-number">12</span> dup<br><span class="hljs-number">13</span> invokespecial #<span class="hljs-number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<br><span class="hljs-number">16</span> aload_1<br><span class="hljs-number">17</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">20</span> aload_2<br><span class="hljs-number">21</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">24</span> invokevirtual #<span class="hljs-number">12</span> &lt;java/lang/StringBuilder.toString&gt;<br><span class="hljs-number">27</span> astore <span class="hljs-number">4</span><br><span class="hljs-number">29</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">32</span> aload_3<br><span class="hljs-number">33</span> aload <span class="hljs-number">4</span><br><span class="hljs-number">35</span> if_acmpne <span class="hljs-number">42</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">38</span> iconst_1<br><span class="hljs-number">39</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">43</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">42</span> iconst_0<br><span class="hljs-number">43</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">46</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p><strong>举例2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    1. 字符串拼接操作不一定使用的是StringBuilder!</span><br><span class="hljs-comment">       如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译期优化，即非StringBuilder的方式。</span><br><span class="hljs-comment">    2. 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;<br>        System.out.println(s3 == s4);<span class="hljs-comment">//true</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>从字节码角度来看：为变量 s4 赋值时，直接使用 #16 符号引用，即字符串常量 “ab”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> ldc #<span class="hljs-number">14</span> &lt;a&gt;<br><span class="hljs-number">2</span> astore_1<br><span class="hljs-number">3</span> ldc #<span class="hljs-number">15</span> &lt;b&gt;<br><span class="hljs-number">5</span> astore_2<br><span class="hljs-number">6</span> ldc #<span class="hljs-number">16</span> &lt;ab&gt;<br><span class="hljs-number">8</span> astore_3<br><span class="hljs-number">9</span> ldc #<span class="hljs-number">16</span> &lt;ab&gt;<br><span class="hljs-number">11</span> astore <span class="hljs-number">4</span><br><span class="hljs-number">13</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">16</span> aload_3<br><span class="hljs-number">17</span> aload <span class="hljs-number">4</span><br><span class="hljs-number">19</span> if_acmpne <span class="hljs-number">26</span> (+<span class="hljs-number">7</span>)<br><span class="hljs-number">22</span> iconst_1<br><span class="hljs-number">23</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">27</span> (+<span class="hljs-number">4</span>)<br><span class="hljs-number">26</span> iconst_0<br><span class="hljs-number">27</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">30</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p><strong>拼接操作与 append 操作的效率对比</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test6</span><span class="hljs-params">()</span>&#123;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br><span class="hljs-comment">//        method1(100000);//4014</span><br>        method2(<span class="hljs-number">100000</span>);<span class="hljs-comment">//7</span><br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> highLevel)</span>&#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; highLevel;i++)&#123;<br>            src = src + <span class="hljs-string">&quot;a&quot;</span>;<span class="hljs-comment">//每次循环都会创建一个StringBuilder、String</span><br>        &#125;<br><span class="hljs-comment">//        System.out.println(src);</span><br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(<span class="hljs-type">int</span> highLevel)</span>&#123;<br>        <span class="hljs-comment">//只需要创建一个StringBuilder</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; highLevel; i++) &#123;<br>            src.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br><span class="hljs-comment">//        System.out.println(src);</span><br>    &#125;<br></code></pre></td></tr></table></figure><ol><li><p>体会执行效率：通过StringBuilder的append()的方式添加字符串的效率要远高于使用String的字符串拼接方式！</p></li><li><p>原因：</p><ol><li>StringBuilder的append()的方式：<ul><li>自始至终中只创建过一个StringBuilder的对象</li></ul></li><li>使用String的字符串拼接方式：<ul><li>创建过多个StringBuilder和String（调的toString方法）的对象，内存占用更大；</li><li>如果进行GC，需要花费额外的时间（在拼接的过程中产生的一些中间字符串可能永远也用不到，会产生大量垃圾字符串）。</li></ul></li></ol></li><li><p>改进的空间：</p><ul><li>在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值highLevel的情况下，建议使用构造器实例化：</li><li><code>StringBuilder s = new StringBuilder(highLevel); //new char[highLevel]</code></li><li>这样可以避免频繁扩容</li></ul></li></ol><h2 id="intern-的使用"><a href="#intern-的使用" class="headerlink" title="intern() 的使用"></a>intern() 的使用</h2><h3 id="intern-方法的说明"><a href="#intern-方法的说明" class="headerlink" title="intern() 方法的说明"></a>intern() 方法的说明</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">intern</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><ol><li><p>intern是一个native方法，调用的是底层C的方法</p></li><li><p>字符串常量池池最初是空的，由String类私有地维护。在调用intern方法时，如果池中已经包含了由equals(object)方法确定的与该字符串内容相等的字符串，则返回池中的字符串地址。否则，该字符串对象将被添加到池中，并返回对该字符串对象的地址。（这是源码里的大概翻译）</p></li><li><p>如果不是用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。比如：</p><pre><code class="hljs">String myInfo = new string(&quot;I love atguigu&quot;).intern();</code></pre></li><li><p>也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true</p><pre><code class="hljs">(&quot;a&quot;+&quot;b&quot;+&quot;c&quot;).intern()==&quot;abc&quot;</code></pre></li><li><p>通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p></li></ol><h3 id="new-String-的说明"><a href="#new-String-的说明" class="headerlink" title="new String() 的说明"></a>new String() 的说明</h3><h4 id="new-String-“ab”-会创建几个对象？"><a href="#new-String-“ab”-会创建几个对象？" class="headerlink" title="new String(“ab”)会创建几个对象？"></a>new String(“ab”)会创建几个对象？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 题目：</span><br><span class="hljs-comment"> * new String(&quot;ab&quot;)会创建几个对象？看字节码，就知道是两个。</span><br><span class="hljs-comment"> *     一个对象是：new关键字在堆空间创建的</span><br><span class="hljs-comment"> *     另一个对象是：字符串常量池中的对象&quot;ab&quot;。 字节码指令：ldc</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringNewTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/String&gt;<br><span class="hljs-number">3</span> dup<br><span class="hljs-number">4</span> ldc #<span class="hljs-number">3</span> &lt;ab&gt;<br><span class="hljs-number">6</span> invokespecial #<span class="hljs-number">4</span> &lt;java/lang/String.&lt;init&gt;&gt;<br><span class="hljs-number">9</span> astore_1<br><span class="hljs-number">10</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p><code>0 new #2 &lt;java/lang/String&gt;</code>：在堆中创建了一个 String 对象</p><p><code>4 ldc #3 &lt;ab&gt;</code> ：在字符串常量池中放入 “ab”（如果之前字符串常量池中没有 “ab” 的话）</p><h4 id="new-String-“a”-new-String-“b”-会创建几个对象？"><a href="#new-String-“a”-new-String-“b”-会创建几个对象？" class="headerlink" title="new String(“a”) + new String(“b”) 会创建几个对象？"></a>new String(“a”) + new String(“b”) 会创建几个对象？</h4><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 思考：</span><br><span class="hljs-comment"> * new String(&quot;a&quot;) + new String(&quot;b&quot;)呢？</span><br><span class="hljs-comment"> *  对象1：new StringBuilder()</span><br><span class="hljs-comment"> *  对象2： new String(&quot;a&quot;)</span><br><span class="hljs-comment"> *  对象3： 常量池中的&quot;a&quot;</span><br><span class="hljs-comment"> *  对象4： new String(&quot;b&quot;)</span><br><span class="hljs-comment"> *  对象5： 常量池中的&quot;b&quot;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  深入剖析： StringBuilder的toString():</span><br><span class="hljs-comment"> *      对象6 ：new String(&quot;ab&quot;)</span><br><span class="hljs-comment"> *       强调一下，toString()的调用，在字符串常量池中，没有生成&quot;ab&quot;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringNewTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/StringBuilder&gt;<br><span class="hljs-number">3</span> dup<br><span class="hljs-number">4</span> invokespecial #<span class="hljs-number">3</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<br><span class="hljs-number">7</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java/lang/String&gt;<br><span class="hljs-number">10</span> dup<br><span class="hljs-number">11</span> ldc #<span class="hljs-number">5</span> &lt;a&gt;<br><span class="hljs-number">13</span> invokespecial #<span class="hljs-number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;<br><span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">19</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java/lang/String&gt;<br><span class="hljs-number">22</span> dup<br><span class="hljs-number">23</span> ldc #<span class="hljs-number">8</span> &lt;b&gt;<br><span class="hljs-number">25</span> invokespecial #<span class="hljs-number">6</span> &lt;java/lang/String.&lt;init&gt;&gt;<br><span class="hljs-number">28</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">31</span> invokevirtual #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder.toString&gt;<br><span class="hljs-number">34</span> astore_1<br><span class="hljs-number">35</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p><strong>答案是4个或5个或6个</strong></p><p>字节码指令分析：</p><ol><li><code>0 new #2 &lt;java/lang/StringBuilder&gt;</code> ：拼接字符串会创建一个 StringBuilder 对象</li><li><code>7 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“a”)</li><li><code>11 ldc #5 &lt;a&gt;</code> ：在字符串常量池中放入 “a”（如果之前字符串常量池中没有 “a” 的话）</li><li><code>19 new #4 &lt;java/lang/String&gt;</code> ：创建 String 对象，对应于 new String(“b”)</li><li><code>23 ldc #8 &lt;b&gt;</code> ：在字符串常量池中放入 “b”（如果之前字符串常量池中没有 “b” 的话）</li><li><code>31 invokevirtual #9 &lt;java/lang/StringBuilder.toString&gt;</code> ：调用 StringBuilder 的 toString() 方法，会生成一个 String 对象</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818523.png"><h3 id="有点难的面试题"><a href="#有点难的面试题" class="headerlink" title="有点难的面试题"></a>有点难的面试题</h3><blockquote><p><strong>有点难的面试题</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">**<br> * 如何保证变量s指向的是字符串常量池中的数据呢？<br> * 有两种方式：<br> * 方式一： <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;shkstart&quot;</span>;<span class="hljs-comment">//字面量定义的方式</span><br> * 方式二： 调用intern()<br> *         <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;shkstart&quot;</span>).intern();<br> *         <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;shkstart&quot;</span>).toString().intern();<br> *<br> */<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringIntern</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        s.intern();<span class="hljs-comment">//调用此方法之前，字符串常量池中已经存在了&quot;1&quot;</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        System.out.println(s == s2);<span class="hljs-comment">//jdk6：false   jdk7/8：false</span><br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         1、s3变量记录的地址为：new String(&quot;11&quot;)</span><br><span class="hljs-comment">         2、经过上面的分析，我们已经知道执行完pos_1的代码，在堆中有了一个new String(&quot;11&quot;)</span><br><span class="hljs-comment">         这样的String对象。但是在字符串常量池中没有&quot;11&quot;</span><br><span class="hljs-comment">         3、接着执行s3.intern()，在字符串常量池中生成&quot;11&quot;</span><br><span class="hljs-comment">           3-1、在JDK6的版本中，字符串常量池还在永久代，所以直接在永久代生成&quot;11&quot;,也就有了新的地址</span><br><span class="hljs-comment">           3-2、而在JDK7的后续版本中，字符串常量池被移动到了堆中，此时堆里已经有new String（&quot;11&quot;）了</span><br><span class="hljs-comment">           出于节省空间的目的，直接将堆中的那个字符串的引用地址储存在字符串常量池中。没错，字符串常量池</span><br><span class="hljs-comment">           中存的是new String（&quot;11&quot;）在堆中的地址</span><br><span class="hljs-comment">         4、所以在JDK7后续版本中，s3和s4指向的完全是同一个地址。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//pos_1</span><br>    s3.intern();<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11&quot;</span>;<span class="hljs-comment">//s4变量记录的地址：使用的是上一行代码代码执行时，在常量池中生成的&quot;11&quot;的地址</span><br>        System.out.println(s3 == s4);<span class="hljs-comment">//jdk6：false  jdk7/8：true</span><br>    &#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>解释的已经比较清楚了，下面看一下内存图</p><p><strong>内存分析</strong></p><p>JDK6 ：正常眼光判断即可</p><ul><li>new String() 即在堆中</li><li>str.intern() 则把字符串放入常量池中</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818524.png"><p>JDK7及后续版本，<strong>注意大坑</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818526.png"><h4 id="面试题的拓展"><a href="#面试题的拓展" class="headerlink" title="面试题的拓展"></a>面试题的拓展</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * StringIntern.java中练习的拓展：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringIntern1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//执行完下一行代码以后，字符串常量池中，是否存在&quot;11&quot;呢？答案：不存在！！</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//new String(&quot;11&quot;)</span><br>        <span class="hljs-comment">//在字符串常量池中生成对象&quot;11&quot;，代码顺序换一下，实打实的在字符串常量池里有一个&quot;11&quot;对象</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;11&quot;</span>;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> s3.intern();<br><br>        <span class="hljs-comment">// s3 是堆中的 &quot;ab&quot; ，s4 是字符串常量池中的 &quot;ab&quot;</span><br>        System.out.println(s3 == s4);<span class="hljs-comment">//false</span><br><br>        <span class="hljs-comment">// s5 是从字符串常量池中取回来的引用，当然和 s4 相等</span><br>        System.out.println(s5 == s4);<span class="hljs-comment">//true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="intern-方法的练习"><a href="#intern-方法的练习" class="headerlink" title="intern() 方法的练习"></a>intern() 方法的练习</h3><p><strong>练习 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//new String(&quot;ab&quot;)</span><br>        <span class="hljs-comment">//在上一行代码执行完以后，字符串常量池中并没有&quot;ab&quot;</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1、jdk6中：在字符串常量池（此时在永久代）中创建一个字符串&quot;ab&quot;</span><br><span class="hljs-comment">        2、jdk8中：字符串常量池（此时在堆中）中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，  将此引用返回</span><br><span class="hljs-comment">        3、详解看上面</span><br><span class="hljs-comment">*/</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern();<br><br>        System.out.println(s2 == <span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//jdk6:true  jdk8:true</span><br>        System.out.println(s == <span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//jdk6:false  jdk8:true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>JDK6</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818527.png" alt="image-20201116113423492"></p><p><strong>JDK7&#x2F;8</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818528.png"><p><strong>练习2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExer1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//加一行这个</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//new String(&quot;ab&quot;)</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern();<br><br>        System.out.println(s2 == <span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//jdk6:true  jdk8:true</span><br>        System.out.println(s == <span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//jdk6:false  jdk8:true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818529.png"><p><strong>练习3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExer2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);<span class="hljs-comment">//执行完以后，会在字符串常量池中会生成&quot;ab&quot;</span><br><br>        s1.intern();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        System.out.println(s1 == s2);<span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>验证</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringExer2</span> &#123;<br>    <span class="hljs-comment">// 对象内存地址可以使用System.identityHashCode(object)方法获取</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//执行完以后，不会在字符串常量池中会生成&quot;ab&quot;</span><br>        System.out.println(System.identityHashCode(s1));<br>        s1.intern();<br>        System.out.println(System.identityHashCode(s1));<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;<br>        System.out.println(System.identityHashCode(s2));<br>        System.out.println(System.identityHashCode(<span class="hljs-string">&quot;ab&quot;</span>));<br>        System.out.println(s1 == s2); <span class="hljs-comment">// true</span><br>        System.out.println(s1 == <span class="hljs-string">&quot;ab&quot;</span>);<br>        System.out.println(s2 == <span class="hljs-string">&quot;ab&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">168423058</span><br><span class="hljs-number">168423058</span><br><span class="hljs-number">168423058</span><br><span class="hljs-number">168423058</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br><span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="intern-的效率测试（空间角度）"><a href="#intern-的效率测试（空间角度）" class="headerlink" title="intern() 的效率测试（空间角度）"></a>intern() 的效率测试（空间角度）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用intern()测试执行效率：空间使用上</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 结论：对于程序中大量存在存在的字符串，尤其其中存在很多重复字符串时，使用intern()可以节省内存空间。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringIntern2</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[MAX_COUNT];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_COUNT; i++) &#123;<br><span class="hljs-comment">//            arr[i] = new String(String.valueOf(data[i % data.length]));</span><br>            arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(String.valueOf(data[i % data.length])).intern();<br><br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.gc();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、直接 new String ：由于每个 String 对象都是 new 出来的，所以程序需要维护大量存放在堆空间中的 String 实例，程序内存占用也会变高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(String.valueOf(data[i % data.length]));<br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818530.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818531.png"><p>2、使用 intern() 方法：由于数组中字符串的引用都指向字符串常量池中的字符串，所以程序需要维护的 String 对象更少，内存占用也更低</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//调用了intern()方法使用了字符串常量池里的字符串，那么前面堆里的字符串便会被GC掉，这也是intern省内存的关键原因</span><br>arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(String.valueOf(data[i % data.length])).intern();<br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818532.png" ><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818533.png"><p><strong>结论</strong>：</p><ol><li>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用intern()方法能够节省很大的内存空间。</li><li>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用intern() 方法，就会很明显降低内存的大小。</li></ol><h2 id="StringTable-的垃圾回收"><a href="#StringTable-的垃圾回收" class="headerlink" title="StringTable 的垃圾回收"></a>StringTable 的垃圾回收</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * String的垃圾回收:</span><br><span class="hljs-comment"> * -Xms15m -Xmx15m -XX:+PrintStringTableStatistics -XX:+PrintGCDetails</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringGCTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100000</span>; j++) &#123;<br>            String.valueOf(j).intern();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><ul><li>在 PSYoungGen 区发生了垃圾回收</li><li>Number of entries 和 Number of literals 明显没有 100000</li><li>以上两点均说明 StringTable 区发生了垃圾回收</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818534.jpg"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818535.jpg"/><h2 id="G1-中的-String-去重操作"><a href="#G1-中的-String-去重操作" class="headerlink" title="G1 中的 String 去重操作"></a>G1 中的 String 去重操作</h2><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/192">http://openjdk.java.net/jeps/192</a></p></blockquote><p>暂时了解一下，后面会详解垃圾回收器</p><p><strong>String去重操作的背景</strong></p><blockquote><p>注意不是字符串常量池的去重操作，字符串常量池本身就没有重复的</p></blockquote><ol><li>背景：对许多Java应用（有大的也有小的）做的测试得出以下结果：<ul><li>堆存活数据集合里面String对象占了25%</li><li>堆存活数据集合里面重复的String对象有13.5%</li><li>String对象的平均长度是45</li></ul></li><li>许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半String对象是重复的，重复的意思是说：<code>str1.equals(str2)= true</code>。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的String对象进行去重，这样就能避免浪费内存。</li></ol><p><strong>String 去重的的实现</strong></p><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。</li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。</li><li>使用一个Hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个Hashtable，来看堆上是否已经存在一个一模一样的char数组。</li><li>如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char数组会被插入到Hashtable，这样以后的时候就可以共享这个数组了。</li></ol><p><strong>命令行选项</strong></p><ol><li>UseStringDeduplication(bool) ：开启String去重，默认是不开启的，需要手动开启。</li><li>PrintStringDeduplicationStatistics(bool) ：打印详细的去重统计信息</li><li>stringDeduplicationAgeThreshold(uintx) ：达到这个年龄的String对象被认为是去重的候选对象</li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第8章-执行引擎</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC8%E7%AB%A0-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC8%E7%AB%A0-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h1><h2 id="执行引擎概述"><a href="#执行引擎概述" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h2><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818529.png"><h3 id="执行引擎概述-1"><a href="#执行引擎概述-1" class="headerlink" title="执行引擎概述"></a>执行引擎概述</h3><ol><li>执行引擎是Java虚拟机核心的组成部分之一。</li><li>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<strong>虚拟机的执行引擎则是由软件自行实现的</strong>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<strong>能够执行那些不被硬件直接支持的指令集格式</strong>。</li><li>JVM的主要任务是负责<strong>装载字节码到其内部</strong>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。</li><li>那么，如果想要让一个Java程序运行起来，执行引擎（Execution Engine）的任务就是<strong>将字节码指令解释&#x2F;编译为对应平台上的本地机器指令才可以</strong>。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818530.png"><p>1、前端编译：从Java程序员-字节码文件的这个过程叫前端编译</p><p>2、执行引擎这里有两种行为：一种是解释执行，一种是编译执行（这里的是后端编译）。</p><h3 id="执行引擎工作过程"><a href="#执行引擎工作过程" class="headerlink" title="执行引擎工作过程"></a>执行引擎工作过程</h3><blockquote><p><strong>执行引擎工作过程</strong></p></blockquote><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。</li><li>每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li><li>从外观上来看，所有的Java虚拟机的执行引擎输入、处理、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行、即时编译的等效过程，输出的是执行过程。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818531.png"><h2 id="Java代码编译和执行过程"><a href="#Java代码编译和执行过程" class="headerlink" title="Java代码编译和执行过程"></a>Java代码编译和执行过程</h2><h3 id="解释执行和即时编译"><a href="#解释执行和即时编译" class="headerlink" title="解释执行和即时编译"></a>解释执行和即时编译</h3><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过下图中的各个步骤：</p><ol><li><p>前面橙色部分是编译生成生成字节码文件的过程（javac编译器来完成，也就是前端编译器），和JVM没有关系。</p></li><li><p>后面绿色（解释执行）和蓝色（即时编译）才是JVM需要考虑的过程</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818532.png">    <ol start="3"><li><p>javac编译器（前端编译器）流程图如下所示：</p> <img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818533.png"> </li><li><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示</p> <img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818534.png"></li></ol><h3 id="什么是解释器？什么是JIT编译器？"><a href="#什么是解释器？什么是JIT编译器？" class="headerlink" title="什么是解释器？什么是JIT编译器？"></a>什么是解释器？什么是JIT编译器？</h3><ol><li>解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用<strong>逐行</strong>解释的方式<strong>执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li><li>JIT（Just In Time Compiler）编译器：就是虚拟机将源代码<strong>一次性直接</strong>编译成和本地机器平台相关的机器语言，<strong>但并不是马上执行</strong>。</li></ol><p><strong>为什么Java是半编译半解释型语言？</strong></p><ol><li>JDK1.0时代，将Java语言定位为“解释执行”还是比较准确的。再后来，Java也发展出可以直接生成本地代码的编译器。</li><li>现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</li><li>JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的JIT 代码缓存中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。</li></ol><p><strong>用图总结一下</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818535.png"><h2 id="机器码-指令-汇编语言"><a href="#机器码-指令-汇编语言" class="headerlink" title="机器码 指令 汇编语言"></a>机器码 指令 汇编语言</h2><h3 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h3><ol><li>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</li><li>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</li><li>用它编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言编的程序相比，执行速度最快。</li><li>机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同。</li></ol><h3 id="指令和指令集"><a href="#指令和指令集" class="headerlink" title="指令和指令集"></a>指令和指令集</h3><p><strong>指令</strong></p><ol><li><p>由于机器码是由0和1组成的二进制序列，可读性实在太差，于是人们发明了指令。</p></li><li><p>指令就是把机器码中特定的0和1序列，简化成对应的指令（一般为英文简写，如mov，inc等），可读性稍好</p></li><li><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如mov），对应的机器码也可能不同。</p></li></ol><p><strong>指令集</strong></p><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。如常见的</p><ol><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ol><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ol><li>由于指令的可读性还是太差，于是人们又发明了汇编语言。</li><li>在汇编语言中，用助记符（Mnemonics）代替机器指令的操作码，用地址符号（Symbol）或标号（Label）代替指令或操作数的地址。</li><li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</li><li>由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译（汇编）成机器指令码，计算机才能识别和执行。</li></ol><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ol><li><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言更接近人的语言</p></li><li><p>当计算机执行高级语言编写的程序时，仍然需要把程序解释和编译成机器的指令码。完成这个过程的程序就叫做解释程序或编译程序。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818536.png"><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><ol><li><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p></li><li><p>字节码主要为了实现特定软件运行和软件环境、与硬件环境无关。</p></li><li><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。</p></li><li><p>字节码典型的应用为：Java bytecode</p></li></ol><h3 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h3><p><strong>编译过程又可以分成两个阶段：编译和汇编。</strong></p><ol><li><p>编译过程：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p></li><li><p>汇编过程：实际上指把汇编语言代码翻译成目标机器指令的过程。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818537.png"><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><h3 id="为什么要有解释器"><a href="#为什么要有解释器" class="headerlink" title="为什么要有解释器"></a>为什么要有解释器</h3><ol><li><p>JVM设计者们的初衷仅仅只是单纯地为了满足Java程序实现跨平台特性，因此避免采用静态编译的方式由高级语言直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法（也就是产生了一个中间产品<strong>字节码</strong>）。</p></li><li><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p></li><li><p>当一条字节码指令被解释执行完成后，接着再根据PC寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818538.png"><h3 id="解释器的分类"><a href="#解释器的分类" class="headerlink" title="解释器的分类"></a>解释器的分类</h3><ol><li>在Java的发展历史里，一共有两套解释执行器，即古老的<strong>字节码解释器</strong>、现在普遍使用的<strong>模板解释器</strong>。<ul><li>字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。</li><li>而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul></li><li>在HotSpot VM中，解释器主要由Interpreter模块和Code模块构成。<ul><li>Interpreter模块：实现了解释器的核心功能</li><li>Code模块：用于管理HotSpot VM在运行时生成的本地机器指令</li></ul></li></ol><h3 id="解释器的现状"><a href="#解释器的现状" class="headerlink" title="解释器的现状"></a>解释器的现状</h3><ol><li><p>由于解释器在设计和实现上非常简单，因此除了Java语言之外，还有许多高级语言同样也是基于解释器执行的，比如Python、Perl、Ruby等。但是在今天，基于解释器执行已经沦落为低效的代名词，并且时常被一些C&#x2F;C++程序员所调侃。</p></li><li><p>为了解决这个问题，JVM平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可，这种方式可以使执行效率大幅度提升。</p></li><li><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p></li></ol><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><h3 id="Java-代码执行的分类"><a href="#Java-代码执行的分类" class="headerlink" title="Java 代码执行的分类"></a>Java 代码执行的分类</h3><ol><li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p></li><li><p>第二种是编译执行（直接编译成机器码）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p></li><li><p>HotSpot VM是目前市面上高性能虚拟机的代表作之一。<strong>它采用解释器与即时编译器并存的架构</strong>。在Java虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p></li><li><p>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++ 程序一较高下的地步。</p></li></ol><h3 id="为啥我们还需要解释器呢？"><a href="#为啥我们还需要解释器呢？" class="headerlink" title="为啥我们还需要解释器呢？"></a>为啥我们还需要解释器呢？</h3><ol><li><p>有些开发人员会感觉到诧异，既然HotSpot VM中已经内置JIT编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？比如JRockit VM内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p></li><li><p>JRockit虚拟机是砍掉了解释器，也就是只采及时编译器。那是因为呢JRockit只部署在服务器上，一般已经有时间让他进行指令编译的过程了，对于响应来说要求不高，等及时编译器的编译完成后，就会提供更好的性能</p></li></ol><p><strong>首先明确两点：</strong></p><ol><li>当程序启动后，解释器可以马上发挥作用，<strong>响应速度快</strong>，省去编译的时间，立即执行。</li><li>编译器要想发挥作用，把代码编译成本地代码，<strong>需要一定的执行时间</strong>，但编译为本地代码后，执行效率高。</li></ol><p><strong>所以：</strong></p><ol><li>尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。</li><li>在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</li><li>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。</li></ol><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>当虚拟机启动的时候，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率。</li></ul><ol><li><p>注意解释执行与编译执行在线上环境微妙的辩证关系。<strong>机器在热机状态（已经运行了一段时间叫热机状态）可以承受的负载要大于冷机状态（刚启动的时候叫冷机状态）</strong>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p></li><li><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的1&#x2F;8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的JVM均是解释执行，还没有进行热点代码统计和JIT动态编译，导致机器启动之后，当前1&#x2F;2发布成功的服务器马上全部宕机，此故障说明了JIT的存在。—<strong>阿里团队</strong></p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818539.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JITTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            list.add(<span class="hljs-string">&quot;让天下没有难学的技术&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 JVisualVM 查看 JIT 编译器执行的编译次数</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818540.png"><h3 id="JIT编译器相关概念"><a href="#JIT编译器相关概念" class="headerlink" title="JIT编译器相关概念"></a>JIT编译器相关概念</h3><ol><li>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程。</li><li>也可能是指虚拟机的后端运行期编译器（JIT编译器，Just In Time Compiler）把字节码转变成机器码的过程。</li><li>还可能是指使用静态提前编译器（AOT编译器，Ahead of Time Compiler）直接把.java文件编译成本地机器代码的过程。（可能是后续发展的趋势）</li></ol><p><strong>典型的编译器：</strong></p><ol><li>前端编译器：Sun的javac、Eclipse JDT中的增量式编译器（ECJ）。</li><li>JIT编译器：HotSpot VM的C1、C2编译器。</li><li>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</li></ol><h3 id="热点代码及探测方式"><a href="#热点代码及探测方式" class="headerlink" title="热点代码及探测方式"></a>热点代码及探测方式</h3><ol><li>当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用<strong>执行的频率</strong>而定。</li><li>关于那些需要被编译为本地代码的字节码，也被称之为**“热点代码”<strong>，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出</strong>深度优化**，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。</li><li>一个被多次调用的方法，或者是一-个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。</li><li>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。</li><li><strong>目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测</strong>。</li><li>采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。<ol><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ol></li></ol><h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><ol><li><p>这个计数器就用于统计方法被调用的次数，它的默认阀值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。</p></li><li><p>这个阀值可以通过虚拟机参数 -XX:CompileThreshold 来人为设定。</p></li><li><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本</p><ul><li>如果存在，则优先使用编译后的本地代码来执行</li><li>如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阀值。<ul><li>如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</li><li>如果未超过阈值，则使用解释器对字节码文件解释执行</li></ul></li></ul></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818541.png"><h4 id="热度衰减"><a href="#热度衰减" class="headerlink" title="热度衰减"></a>热度衰减</h4><ol><li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<strong>一段时间之内方法被调用的次数</strong>。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）</li><li>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</li><li>另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。</li></ol><h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发OSR编译。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818542.png"><h3 id="HotSpotVM可以设置程序执行方法"><a href="#HotSpotVM可以设置程序执行方法" class="headerlink" title="HotSpotVM可以设置程序执行方法"></a>HotSpotVM可以设置程序执行方法</h3><p>缺省情况下HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：</p><ol><li>-Xint：完全采用解释器模式执行程序；</li><li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li>-Xmixed：采用解释器+即时编译器的混合模式共同执行程序。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271818543.png"><p><strong>代码测试</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试解释器模式和JIT编译模式</span><br><span class="hljs-comment"> *  -Xint  : 6520ms</span><br><span class="hljs-comment"> *  -Xcomp : 950ms</span><br><span class="hljs-comment"> *  -Xmixed : 936ms</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntCompTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        testPrimeNumber(<span class="hljs-number">1000000</span>);<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        System.out.println(<span class="hljs-string">&quot;花费的时间为：&quot;</span> + (end - start));<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPrimeNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            <span class="hljs-comment">//计算100以内的质数</span><br>            label:<span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;j &lt;= <span class="hljs-number">100</span>;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;k &lt;= Math.sqrt(j);k++)&#123;<br>                    <span class="hljs-keyword">if</span>(j % k == <span class="hljs-number">0</span>)&#123;<br>                        <span class="hljs-keyword">continue</span> label;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">//System.out.println(j);</span><br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>结论：只用解释器执行是真的慢</p><h3 id="HotSpotVM-JIT-分类"><a href="#HotSpotVM-JIT-分类" class="headerlink" title="HotSpotVM JIT 分类"></a>HotSpotVM JIT 分类</h3><p>在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多数情况下我们简称为C1编译器 和 C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ol><li>-client：指定Java虚拟机运行在Client模式下，并使用C1编译器；<ul><li>C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。</li></ul></li><li>-server：指定Java虚拟机运行在server模式下，并使用C2编译器。<ul><li>C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）</li></ul></li></ol><h3 id="C1和C2编译器不同的优化策略"><a href="#C1和C2编译器不同的优化策略" class="headerlink" title="C1和C2编译器不同的优化策略"></a>C1和C2编译器不同的优化策略</h3><ol><li>在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、元余消除。<ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现樊进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul></li><li>C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在C2上有如下几种优化：<ul><li>标量替换：用标量值代替聚合对象的属性值</li><li>栈上分配：对于未逃逸的对象分配对象在栈而不是堆</li><li>同步消除：清除同步操作，通常指synchronized</li></ul></li></ol><blockquote><p>也就是说之前的逃逸分析，只有在C2（server模式下）才会触发。那是否说明C1就用不了了？</p></blockquote><h3 id="分层编译策略"><a href="#分层编译策略" class="headerlink" title="分层编译策略"></a>分层编译策略</h3><ol><li><p>分层编译（Tiered Compilation）策略：程序解释执行（不开启性能监控）可以触发C1编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2编译会根据性能监控信息进行激进优化。</p></li><li><p>不过在Java7版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由C1编译器和C2编译器相互协作共同来执行编译任务。</p></li><li><p>一般来讲，JIT编译出来的机器码性能比解释器解释执行的性能高</p></li><li><p>C2编译器启动时长比C1慢，系统稳定执行以后，C2编译器执行速度远快于C1编译器</p></li></ol><h4 id="Graal-编译器"><a href="#Graal-编译器" class="headerlink" title="Graal 编译器"></a>Graal 编译器</h4><ul><li><p>自JDK10起，HotSpot又加入了一个全新的即时编译器：Graal编译器</p></li><li><p>编译效果短短几年时间就追平了G2编译器，未来可期（对应还出现了Graal虚拟机，是有可能替代Hotspot的虚拟机的）</p></li><li><p>目前，带着实验状态标签，需要使用开关参数去激活才能使用</p><p>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</p></li></ul><h4 id="AOT编译器"><a href="#AOT编译器" class="headerlink" title="AOT编译器"></a>AOT编译器</h4><ol><li><p>jdk9引入了AoT编译器（静态提前编译器，Ahead of Time Compiler）</p></li><li><p>Java 9引入了实验性AOT编译工具jaotc。它借助了Graal编译器，将所输入的Java类文件转换为机器码，并存放至生成的动态共享库之中。</p></li><li><p>所谓AOT编译，是与即时编译相对立的一个概念。我们知道，即时编译指的是<strong>在程序的运行过程中</strong>，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。而AOT编译指的则是，<strong>在程序运行之前</strong>，便将字节码转换为机器码的过程。</p><p> .java -&gt; .class -&gt; (使用jaotc) -&gt; .so</p></li></ol><p><strong>AOT编译器编译器的优缺点</strong></p><p><strong>最大的好处：</strong></p><ol><li>Java虚拟机加载已经预编译成二进制库，可以直接执行。</li><li>不必等待即时编译器的预热，减少Java应用给人带来“第一次运行慢” 的不良体验</li></ol><p><strong>缺点：</strong></p><ol><li>破坏了 java “ 一次编译，到处运行”，必须为每个不同的硬件，OS编译对应的发行包</li><li>降低了Java链接过程的动态性，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持Linux X64 java base</li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第7章-对象的实例化内存布局与访问定位</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC7%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC7%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="对象的实例化内存布局与访问定位"><a href="#对象的实例化内存布局与访问定位" class="headerlink" title="对象的实例化内存布局与访问定位"></a>对象的实例化内存布局与访问定位</h1><h2 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h2><p><strong>大厂面试题</strong></p><p>美团：</p><ol><li>对象在<code>JVM</code>中是怎么存储的？</li><li>对象头信息里面有哪些东西？</li></ol><p>蚂蚁金服：</p><p>二面：<code>java</code>对象头里有什么</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271817426.png"><h3 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h3><ol><li>new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法</li><li>Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器，并且权限必须为 public</li><li>Constructor的newInstance(Xxxx)：反射的方式，可以调用空参的，或者带参的构造器</li><li>使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone方法</li><li>使用序列化：从文件中，从网络中获取一个对象的二进制流，序列化一般用于Socket的网络传输</li><li>第三方库 Objenesis</li></ol><h3 id="对象创建的步骤"><a href="#对象创建的步骤" class="headerlink" title="对象创建的步骤"></a>对象创建的步骤</h3><blockquote><p><strong>从字节码看待对象的创建过程</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.<span class="hljs-type">String</span>[])</span></span>;<br>    descriptor: ([Ljava/lang/<span class="hljs-type">String</span>;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/lang/Object</span><br>         <span class="hljs-number">3</span>: dup           <br>         <span class="hljs-number">4</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">7</span>: astore_1<br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">10</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/<span class="hljs-type">String</span>;<br>            <span class="hljs-number">8</span>       <span class="hljs-number">1</span>     <span class="hljs-number">1</span>   obj   Ljava/lang/Object;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>1、判断对象对应的类是否加载、链接、初始化</strong></p><ol><li>虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。</li><li>如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。</li></ol><p><strong>2、为对象分配内存</strong></p><ol><li>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小</li><li>如果内存规整：采用指针碰撞分配内存<ul><li>如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。</li><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。</li><li>如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。</li><li>标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域</li></ul></li><li>如果内存不规整<ul><li>如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。</li><li>意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”</li><li>选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</li><li>标记清除算法清理过后的堆内存，就会存在很多内存碎片。</li></ul></li></ol><p><strong>3、处理并发问题</strong></p><ol><li>采用CAS+失败重试保证更新的原子性</li><li>每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）</li><li>在Eden区给每个线程分配一块区域</li></ol><p><strong>4、初始化分配到的空间</strong></p><ul><li><p>所有属性设置默认值，保证对象实例字段在不赋值可以直接使用</p></li><li><p>给对象属性赋值的顺序：</p></li></ul><ol><li>属性的默认值初始化</li><li>显示初始化&#x2F;代码块初始化（并列关系，谁先谁后看代码编写的顺序）</li><li>构造器初始化</li></ol><p><strong>5、设置对象的对象头</strong></p><p>将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。</p><p><strong>6、执行init方法进行初始化</strong></p><ol><li><p>在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量</p></li><li><p>因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p></li></ol><blockquote><p><strong>从字节码角度看 init 方法</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试对象实例化的过程</span><br><span class="hljs-comment"> *  ① 加载类元信息 - ② 为对象分配内存 - ③ 处理并发问题  - ④ 属性的默认初始化（零值初始化）</span><br><span class="hljs-comment"> *  - ⑤ 设置对象头的信息 - ⑥ 属性的显式初始化、代码块中初始化、构造器中初始化</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  给对象的属性赋值的操作：</span><br><span class="hljs-comment"> *  ① 属性的默认初始化 - ② 显式初始化 / ③ 代码块中初始化 - ④ 构造器中初始化</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1001</span>;<br>    String name;<br>    Account acct;<br><br>    &#123;<br>        name = <span class="hljs-string">&quot;匿名客户&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">()</span>&#123;<br>        acct = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Customer类的字节码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> aload_0<br> <span class="hljs-number">1</span> invokespecial #<span class="hljs-number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;<br> <span class="hljs-number">4</span> aload_0<br> <span class="hljs-number">5</span> sipush <span class="hljs-number">1001</span><br> <span class="hljs-number">8</span> putfield #<span class="hljs-number">2</span> &lt;com/atguigu/java/Customer.id&gt;<br><span class="hljs-number">11</span> aload_0<br><span class="hljs-number">12</span> ldc #<span class="hljs-number">3</span> &lt;匿名客户&gt;<br><span class="hljs-number">14</span> putfield #<span class="hljs-number">4</span> &lt;com/atguigu/java/Customer.name&gt;<br><span class="hljs-number">17</span> aload_0<br><span class="hljs-number">18</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">5</span> &lt;com/atguigu/java/Account&gt;<br><span class="hljs-number">21</span> dup<br><span class="hljs-number">22</span> invokespecial #<span class="hljs-number">6</span> &lt;com/atguigu/java/Account.&lt;init&gt;&gt;<br><span class="hljs-number">25</span> putfield #<span class="hljs-number">7</span> &lt;com/atguigu/java/Customer.acct&gt;<br><span class="hljs-number">28</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>init() 方法的字节码指令：<ul><li>属性的默认值初始化：<code>id = 1001;</code></li><li>显示初始化&#x2F;代码块初始化：<code>name = &quot;匿名客户&quot;;</code></li><li>构造器初始化：<code>acct = new Account();</code></li></ul></li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271817427.png"><blockquote><p><strong>内存布局总结</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1001</span>;<br>    String name;<br>    Account acct;<br><br>    &#123;<br>        name = <span class="hljs-string">&quot;匿名客户&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Customer</span><span class="hljs-params">()</span>&#123;<br>        acct = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>();<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Customer</span> <span class="hljs-variable">cust</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Customer</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>图解内存布局</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271817428.png"><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p><strong>JVM是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271817429.png"><p>定位，通过栈上reference访问</p><p><strong>对象的两种访问方式：句柄访问和直接指针</strong></p><p><strong>1、句柄访问</strong></p><ol><li>缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低</li><li>优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271817430.png"><p><strong>2、直接指针（HotSpot采用）</strong></p><ol><li>优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</li><li>缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271817431.png">]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第6章-方法区</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC6%E7%AB%A0-%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC6%E7%AB%A0-%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h1><h2 id="栈、堆、方法区的交互关系"><a href="#栈、堆、方法区的交互关系" class="headerlink" title="栈、堆、方法区的交互关系"></a>栈、堆、方法区的交互关系</h2><p><strong>从线程共享与否的角度来看</strong></p><p>ThreadLocal：如何保证多个线程在并发环境下的安全性？典型场景就是数据库连接管理，以及会话管理。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816037.png"><p><strong>栈、堆、方法区的交互关系</strong></p><p><strong>下面涉及了对象的访问定位</strong></p><ol><li>Person 类的 .class 信息存放在方法区中</li><li>person 变量存放在 Java 栈的局部变量表中</li><li>真正的 person 对象存放在 Java 堆中</li><li>在 person 对象中，有个指针指向方法区中的 person 类型数据，表明这个 person 对象是用方法区中的 Person 类 new 出来的</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816039.png"><h2 id="方法区的理解"><a href="#方法区的理解" class="headerlink" title="方法区的理解"></a>方法区的理解</h2><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4</a></p></blockquote><h3 id="方法区在哪里？"><a href="#方法区在哪里？" class="headerlink" title="方法区在哪里？"></a>方法区在哪里？</h3><ol><li>《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap（非堆），目的就是要和堆分开。</li><li>所以，<strong>方法区可以看作是一块独立于Java堆的内存空间</strong>。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816040.png"><h3 id="方法区的基本理解"><a href="#方法区的基本理解" class="headerlink" title="方法区的基本理解"></a>方法区的基本理解</h3><p><strong>方法区主要存放的是 Class，而堆中主要存放的是实例化的对象</strong></p><ol><li>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。多个线程同时加载统一个类时，只能有一个线程能加载该类，其他线程只能等等待该线程加载完毕，然后直接使用该类，即类只能加载一次。</li><li>方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutofMemoryError:PermGen space</code>或者<code>java.lang.OutOfMemoryError:Metaspace</code><ul><li>加载大量的第三方的jar包</li><li>Tomcat部署的工程过多（30~50个）</li><li>大量动态的生成反射类</li></ul></li><li>关闭JVM就会释放这个区域的内存。</li></ol><p><strong>代码举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;start...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>简单的程序，加载了1600多个类</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816041.png"><h3 id="HotSpot方法区演进"><a href="#HotSpot方法区演进" class="headerlink" title="HotSpot方法区演进"></a>HotSpot方法区演进</h3><ol><li>在 JDK7 及以前，习惯上把方法区，称为永久代。JDK8开始，使用元空间取代了永久代。我们可以将方法区类比为Java中的接口，将永久代或元空间类比为Java中具体的实现类</li><li>本质上，方法区和永久代并不等价。仅是对Hotspot而言的可以看作等价。《Java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEAJRockit &#x2F; IBM J9 中不存在永久代的概念。<ul><li>现在来看，当年使用永久代，不是好的idea。导致Java程序更容易OOm（超过-XX:MaxPermsize上限）</li></ul></li><li>而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替</li><li>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代最大的区别在于：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存</strong>。</li><li>永久代、元空间二者并不只是名字变了，内部结构也调整了</li><li>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出OOM异常</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816042.png"><h2 id="设置方法区大小与-OOM"><a href="#设置方法区大小与-OOM" class="headerlink" title="设置方法区大小与 OOM"></a>设置方法区大小与 OOM</h2><p>方法区的大小不必是固定的，JVM可以根据应用的需要动态调整。</p><h3 id="JDK7及以前-永久代"><a href="#JDK7及以前-永久代" class="headerlink" title="JDK7及以前(永久代)"></a>JDK7及以前(永久代)</h3><ol><li>通过-XX:Permsize来设置永久代初始分配空间。默认值是20.75M</li><li>-XX:MaxPermsize来设定永久代最大可分配空间。32位机器默认是64M，64位机器模式是82M</li><li>当JVM加载的类信息容量超过了这个值，会报异常OutofMemoryError:PermGen space。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816043.png"><h3 id="JDK8及以后-元空间"><a href="#JDK8及以后-元空间" class="headerlink" title="JDK8及以后(元空间)"></a>JDK8及以后(元空间)</h3><blockquote><p><strong>JDK8 版本设置元空间大小</strong></p></blockquote><ol><li><p>元数据区大小可以使用参数 <strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong> 指定</p></li><li><p>默认值依赖于平台，Windows下，-XX:MetaspaceSize 约为21M，-XX:MaxMetaspaceSize的值是-1，即没有限制。</p></li><li><p>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutOfMemoryError:Metaspace</p></li><li><p>-XX:MetaspaceSize：设置初始的元空间大小。对于一个 64位 的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值。</p></li><li><p>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。</p></li></ol><h3 id="方法区OOM"><a href="#方法区OOM" class="headerlink" title="方法区OOM"></a>方法区OOM</h3><p>举例：</p><p>代码：OOMTest 类继承 ClassLoader 类，获得 defineClass() 方法，可自己进行类的加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * jdk6/7中：</span><br><span class="hljs-comment"> * -XX:PermSize=10m -XX:MaxPermSize=10m</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * jdk8中：</span><br><span class="hljs-comment"> * -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=10m</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">OOMTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OOMTest</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                <span class="hljs-comment">//创建ClassWriter对象，用于生成类的二进制字节码</span><br>                <span class="hljs-type">ClassWriter</span> <span class="hljs-variable">classWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWriter</span>(<span class="hljs-number">0</span>);<br>                <span class="hljs-comment">//指明版本号，修饰符，类名，包名，父类，接口</span><br>                classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="hljs-string">&quot;Class&quot;</span> + i, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;java/lang/Object&quot;</span>, <span class="hljs-literal">null</span>);<br>                <span class="hljs-comment">//返回byte[]</span><br>                <span class="hljs-type">byte</span>[] code = classWriter.toByteArray();<br>                <span class="hljs-comment">//类的加载</span><br>                test.defineClass(<span class="hljs-string">&quot;Class&quot;</span> + i, code, <span class="hljs-number">0</span>, code.length);<span class="hljs-comment">//Class对象</span><br>                j++;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(j);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>不设置元空间的上限</strong></p><p>使用默认的 JVM 参数，元空间不设置上限</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><p><strong>设置元空间的上限</strong></p><p>JVM 参数</p><p>-XX:MetaspaceSize&#x3D;10m -XX:MaxMetaspaceSize&#x3D;10m</p><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">8531</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Metaspace<br>at java.lang.ClassLoader.defineClass1(Native Method)<br>at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="hljs-number">763</span>)<br>at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="hljs-number">642</span>)<br>at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="hljs-number">29</span>)<br></code></pre></td></tr></table></figure><h3 id="如何解决OOM"><a href="#如何解决OOM" class="headerlink" title="如何解决OOM"></a>如何解决OOM</h3><blockquote><p>这个属于调优的问题，这里先简单的说一下</p></blockquote><ol><li>要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Ec1ipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</li><li><strong>内存泄漏</strong>就是有大量的引用指向某些对象，但是这些对象以后不会使用了，但是因为它们还和GC ROOT有关联，所以导致以后这些对象也不会被回收，这就是内存泄漏的问题</li><li>如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。</li><li>如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</li></ol><h2 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h2><h3 id="方法区存储什么？"><a href="#方法区存储什么？" class="headerlink" title="方法区存储什么？"></a>方法区存储什么？</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816044.png"><p>《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的<strong>类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816045.png"><p><strong>类型信息</strong></p><p>对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称（全名&#x3D;包名.类名）</li><li>这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><p><strong>域（Field）信息</strong></p><blockquote><p>也就是我们常说的成员变量，域信息是比较官方的称呼</p></blockquote><ol><li><p>JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p></li><li><p>域的相关信息包括：域名称，域类型，域修饰符（public，private，protected，static，final，volatile，transient的某个子集）</p></li></ol><p><strong>方法（Method）信息</strong></p><p>JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法名称</li><li>方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）</li><li>异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">**<br> * 测试方法区的内部构成<br> */<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodInnerStrucTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;String&gt;,Serializable &#123;<br>    <span class="hljs-comment">//属性</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;测试方法的内部结构&quot;</span>;<br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + count);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">int</span> cal)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>            result = value / cal;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(String o)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>javap -v -p MethodInnerStrucTest.class &gt; test.txt</code></p><ul><li>反编译字节码文件，并输出值文本文件中，便于查看。参数 -p 确保能查看 private 权限类型的字段或方法</li></ul><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter09/com/atguigu/java/MethodInnerStrucTest.<span class="hljs-keyword">class</span><br>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">13</span>; size <span class="hljs-number">1626</span> bytes<br>  MD5 checksum 0d0fcb54854d4ce183063df985141ad0<br>  Compiled from <span class="hljs-string">&quot;MethodInnerStrucTest.java&quot;</span><br><span class="hljs-comment">//类型信息      </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java.MethodInnerStrucTest <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Object <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">18.</span>#<span class="hljs-number">52</span>        <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">17.</span>#<span class="hljs-number">53</span>        <span class="hljs-comment">// com/atguigu/java/MethodInnerStrucTest.num:I</span><br>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">54.</span>#<span class="hljs-number">55</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">4</span> = Class              #<span class="hljs-number">56</span>            <span class="hljs-comment">// java/lang/StringBuilder</span><br>   #<span class="hljs-number">5</span> = Methodref          #<span class="hljs-number">4.</span>#<span class="hljs-number">52</span>         <span class="hljs-comment">// java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">6</span> = String             #<span class="hljs-number">57</span>            <span class="hljs-comment">// count =</span><br>   #<span class="hljs-number">7</span> = Methodref          #<span class="hljs-number">4.</span>#<span class="hljs-number">58</span>         <span class="hljs-comment">// java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br>   #<span class="hljs-number">8</span> = Methodref          #<span class="hljs-number">4.</span>#<span class="hljs-number">59</span>         <span class="hljs-comment">// java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br>   #<span class="hljs-number">9</span> = Methodref          #<span class="hljs-number">4.</span>#<span class="hljs-number">60</span>         <span class="hljs-comment">// java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br>  #<span class="hljs-number">10</span> = Methodref          #<span class="hljs-number">61.</span>#<span class="hljs-number">62</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>  #<span class="hljs-number">11</span> = Class              #<span class="hljs-number">63</span>            <span class="hljs-comment">// java/lang/Exception</span><br>  #<span class="hljs-number">12</span> = Methodref          #<span class="hljs-number">11.</span>#<span class="hljs-number">64</span>        <span class="hljs-comment">// java/lang/Exception.printStackTrace:()V</span><br>  #<span class="hljs-number">13</span> = Class              #<span class="hljs-number">65</span>            <span class="hljs-comment">// java/lang/String</span><br>  #<span class="hljs-number">14</span> = Methodref          #<span class="hljs-number">17.</span>#<span class="hljs-number">66</span>        <span class="hljs-comment">// com/atguigu/java/MethodInnerStrucTest.compareTo:(Ljava/lang/String;)I</span><br>  #<span class="hljs-number">15</span> = String             #<span class="hljs-number">67</span>            <span class="hljs-comment">// 测试方法的内部结构</span><br>  #<span class="hljs-number">16</span> = Fieldref           #<span class="hljs-number">17.</span>#<span class="hljs-number">68</span>        <span class="hljs-comment">// com/atguigu/java/MethodInnerStrucTest.str:Ljava/lang/String;</span><br>  #<span class="hljs-number">17</span> = Class              #<span class="hljs-number">69</span>            <span class="hljs-comment">// com/atguigu/java/MethodInnerStrucTest</span><br>  #<span class="hljs-number">18</span> = Class              #<span class="hljs-number">70</span>            <span class="hljs-comment">// java/lang/Object</span><br>  #<span class="hljs-number">19</span> = Class              #<span class="hljs-number">71</span>            <span class="hljs-comment">// java/lang/Comparable</span><br>  #<span class="hljs-number">20</span> = Class              #<span class="hljs-number">72</span>            <span class="hljs-comment">// java/io/Serializable</span><br>  #<span class="hljs-number">21</span> = Utf8               num<br>  #<span class="hljs-number">22</span> = Utf8               I<br>  #<span class="hljs-number">23</span> = Utf8               str<br>  #<span class="hljs-number">24</span> = Utf8               Ljava/lang/String;<br>  #<span class="hljs-number">25</span> = Utf8               &lt;init&gt;<br>  #<span class="hljs-number">26</span> = Utf8               ()V<br>  #<span class="hljs-number">27</span> = Utf8               Code<br>  #<span class="hljs-number">28</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">29</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">30</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">31</span> = Utf8               Lcom/atguigu/java/MethodInnerStrucTest;<br>  #<span class="hljs-number">32</span> = Utf8               test1<br>  #<span class="hljs-number">33</span> = Utf8               count<br>  #<span class="hljs-number">34</span> = Utf8               test2<br>  #<span class="hljs-number">35</span> = Utf8               (I)I<br>  #<span class="hljs-number">36</span> = Utf8               value<br>  #<span class="hljs-number">37</span> = Utf8               e<br>  #<span class="hljs-number">38</span> = Utf8               Ljava/lang/Exception;<br>  #<span class="hljs-number">39</span> = Utf8               cal<br>  #<span class="hljs-number">40</span> = Utf8               result<br>  #<span class="hljs-number">41</span> = Utf8               StackMapTable<br>  #<span class="hljs-number">42</span> = Class              #<span class="hljs-number">63</span>            <span class="hljs-comment">// java/lang/Exception</span><br>  #<span class="hljs-number">43</span> = Utf8               compareTo<br>  #<span class="hljs-number">44</span> = Utf8               (Ljava/lang/String;)I<br>  #<span class="hljs-number">45</span> = Utf8               o<br>  #<span class="hljs-number">46</span> = Utf8               (Ljava/lang/Object;)I<br>  #<span class="hljs-number">47</span> = Utf8               &lt;clinit&gt;<br>  #<span class="hljs-number">48</span> = Utf8               Signature<br>  #<span class="hljs-number">49</span> = Utf8               Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;<br>  #<span class="hljs-number">50</span> = Utf8               SourceFile<br>  #<span class="hljs-number">51</span> = Utf8               MethodInnerStrucTest.java<br>  #<span class="hljs-number">52</span> = NameAndType        #<span class="hljs-number">25</span>:#<span class="hljs-number">26</span>        <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">53</span> = NameAndType        #<span class="hljs-number">21</span>:#<span class="hljs-number">22</span>        <span class="hljs-comment">// num:I</span><br>  #<span class="hljs-number">54</span> = Class              #<span class="hljs-number">73</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">55</span> = NameAndType        #<span class="hljs-number">74</span>:#<span class="hljs-number">75</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">56</span> = Utf8               java/lang/StringBuilder<br>  #<span class="hljs-number">57</span> = <span class="hljs-type">Utf8</span>               <span class="hljs-variable">count</span> <span class="hljs-operator">=</span><br>  #<span class="hljs-number">58</span> = NameAndType        #<span class="hljs-number">76</span>:#<span class="hljs-number">77</span>        <span class="hljs-comment">// append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br>  #<span class="hljs-number">59</span> = NameAndType        #<span class="hljs-number">76</span>:#<span class="hljs-number">78</span>        <span class="hljs-comment">// append:(I)Ljava/lang/StringBuilder;</span><br>  #<span class="hljs-number">60</span> = NameAndType        #<span class="hljs-number">79</span>:#<span class="hljs-number">80</span>        <span class="hljs-comment">// toString:()Ljava/lang/String;</span><br>  #<span class="hljs-number">61</span> = Class              #<span class="hljs-number">81</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">62</span> = NameAndType        #<span class="hljs-number">82</span>:#<span class="hljs-number">83</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>  #<span class="hljs-number">63</span> = Utf8               java/lang/Exception<br>  #<span class="hljs-number">64</span> = NameAndType        #<span class="hljs-number">84</span>:#<span class="hljs-number">26</span>        <span class="hljs-comment">// printStackTrace:()V</span><br>  #<span class="hljs-number">65</span> = Utf8               java/lang/String<br>  #<span class="hljs-number">66</span> = NameAndType        #<span class="hljs-number">43</span>:#<span class="hljs-number">44</span>        <span class="hljs-comment">// compareTo:(Ljava/lang/String;)I</span><br>  #<span class="hljs-number">67</span> = Utf8               测试方法的内部结构<br>  #<span class="hljs-number">68</span> = NameAndType        #<span class="hljs-number">23</span>:#<span class="hljs-number">24</span>        <span class="hljs-comment">// str:Ljava/lang/String;</span><br>  #<span class="hljs-number">69</span> = Utf8               com/atguigu/java/MethodInnerStrucTest<br>  #<span class="hljs-number">70</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">71</span> = Utf8               java/lang/Comparable<br>  #<span class="hljs-number">72</span> = Utf8               java/io/Serializable<br>  #<span class="hljs-number">73</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">74</span> = Utf8               out<br>  #<span class="hljs-number">75</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">76</span> = Utf8               append<br>  #<span class="hljs-number">77</span> = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;<br>  #<span class="hljs-number">78</span> = Utf8               (I)Ljava/lang/StringBuilder;<br>  #<span class="hljs-number">79</span> = Utf8               toString<br>  #<span class="hljs-number">80</span> = Utf8               ()Ljava/lang/String;<br>  #<span class="hljs-number">81</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">82</span> = Utf8               println<br>  #<span class="hljs-number">83</span> = Utf8               (Ljava/lang/String;)V<br>  #<span class="hljs-number">84</span> = Utf8               printStackTrace<br>&#123;<br><span class="hljs-comment">//域信息</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> num;<br>    descriptor: I<br>    flags: ACC_PUBLIC<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.lang.String str;<br>    descriptor: Ljava/lang/String;<br>    flags: ACC_PRIVATE, ACC_STATIC<br><br>  <span class="hljs-comment">//方法信息</span><br>  <span class="hljs-keyword">public</span> com.atguigu.java.MethodInnerStrucTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: aload_0<br>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">10</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">4</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">11</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">20</span><br>         <span class="hljs-number">2</span>: istore_1<br>         <span class="hljs-number">3</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">6</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>         <span class="hljs-number">9</span>: dup<br>        <span class="hljs-number">10</span>: invokespecial #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">13</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String count =</span><br>        <span class="hljs-number">15</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br>        <span class="hljs-number">18</span>: iload_1<br>        <span class="hljs-number">19</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br>        <span class="hljs-number">22</span>: invokevirtual #<span class="hljs-number">9</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br>        <span class="hljs-number">25</span>: invokevirtual #<span class="hljs-number">10</span>                 <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">17</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">19</span>: <span class="hljs-number">28</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">29</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;<br>            <span class="hljs-number">3</span>      <span class="hljs-number">26</span>     <span class="hljs-number">1</span> count   I<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test2</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br>    descriptor: (I)I<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: iconst_0<br>         <span class="hljs-number">1</span>: istore_1<br>         <span class="hljs-number">2</span>: bipush        <span class="hljs-number">30</span><br>         <span class="hljs-number">4</span>: istore_2<br>         <span class="hljs-number">5</span>: iload_2<br>         <span class="hljs-number">6</span>: iload_0<br>         <span class="hljs-number">7</span>: idiv<br>         <span class="hljs-number">8</span>: istore_1<br>         <span class="hljs-number">9</span>: <span class="hljs-keyword">goto</span>          <span class="hljs-number">17</span><br>        <span class="hljs-number">12</span>: astore_2<br>        <span class="hljs-number">13</span>: aload_2<br>        <span class="hljs-number">14</span>: invokevirtual #<span class="hljs-number">12</span>                 <span class="hljs-comment">// Method java/lang/Exception.printStackTrace:()V</span><br>        <span class="hljs-number">17</span>: iload_1<br>        <span class="hljs-number">18</span>: ireturn<br>      Exception table:<br>         from    to  target type<br>             <span class="hljs-number">2</span>     <span class="hljs-number">9</span>    <span class="hljs-number">12</span>   Class java/lang/Exception<br>      LineNumberTable:<br>        line <span class="hljs-number">21</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">23</span>: <span class="hljs-number">2</span><br>        line <span class="hljs-number">24</span>: <span class="hljs-number">5</span><br>        line <span class="hljs-number">27</span>: <span class="hljs-number">9</span><br>        line <span class="hljs-number">25</span>: <span class="hljs-number">12</span><br>        line <span class="hljs-number">26</span>: <span class="hljs-number">13</span><br>        line <span class="hljs-number">28</span>: <span class="hljs-number">17</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">5</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span> value   I<br>           <span class="hljs-number">13</span>       <span class="hljs-number">4</span>     <span class="hljs-number">2</span>     e   Ljava/lang/Exception;<br>            <span class="hljs-number">0</span>      <span class="hljs-number">19</span>     <span class="hljs-number">0</span>   cal   I<br>            <span class="hljs-number">2</span>      <span class="hljs-number">17</span>     <span class="hljs-number">1</span> result   I<br>      StackMapTable: number_of_entries = <span class="hljs-number">2</span><br>        frame_type = <span class="hljs-number">255</span> <span class="hljs-comment">/* full_frame */</span><br>          offset_delta = <span class="hljs-number">12</span><br>          locals = [ <span class="hljs-type">int</span>, <span class="hljs-type">int</span> ]<br>          stack = [ <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>/lang/Exception ]<br>        frame_type = <span class="hljs-number">4</span> <span class="hljs-comment">/* same */</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(java.lang.String)</span>;<br>    descriptor: (Ljava/lang/String;)I<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span><br>         <span class="hljs-number">0</span>: iconst_0<br>         <span class="hljs-number">1</span>: ireturn<br>      LineNumberTable:<br>        line <span class="hljs-number">33</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">2</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;<br>            <span class="hljs-number">0</span>       <span class="hljs-number">2</span>     <span class="hljs-number">1</span>     o   Ljava/lang/String;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(java.lang.Object)</span>;<br>    descriptor: (Ljava/lang/Object;)I<br>    flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: aload_1<br>         <span class="hljs-number">2</span>: checkcast     #<span class="hljs-number">13</span>                 <span class="hljs-comment">// class java/lang/String</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">14</span>                 <span class="hljs-comment">// Method compareTo:(Ljava/lang/String;)I</span><br>         <span class="hljs-number">8</span>: ireturn<br>      LineNumberTable:<br>        line <span class="hljs-number">10</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;<br><br>  <span class="hljs-keyword">static</span> &#123;&#125;;<br>    descriptor: ()V<br>    flags: ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span><br>         <span class="hljs-number">0</span>: ldc           #<span class="hljs-number">15</span>                 <span class="hljs-comment">// String 测试方法的内部结构</span><br>         <span class="hljs-number">2</span>: putstatic     #<span class="hljs-number">16</span>                 <span class="hljs-comment">// Field str:Ljava/lang/String;</span><br>         <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">13</span>: <span class="hljs-number">0</span><br>&#125;<br>Signature: #<span class="hljs-number">49</span>                          <span class="hljs-comment">// Ljava/lang/Object;Ljava/lang/Comparable&lt;Ljava/lang/String;&gt;;Ljava/io/Serializable;</span><br>SourceFile: <span class="hljs-string">&quot;MethodInnerStrucTest.java&quot;</span><br><br></code></pre></td></tr></table></figure><p><strong>类型信息</strong></p><p>在运行时方法区中，类信息中记录了哪个加载器加载了该类，同时类加载器也记录了它加载了哪些类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//类型信息      </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java.MethodInnerStrucTest <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Object <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.lang.Comparable&lt;java.lang.String&gt;, java.io.Serializable<br></code></pre></td></tr></table></figure><p><strong>域信息</strong></p><ol><li>descriptor: I 表示字段类型为 Integer</li><li>flags: ACC_PUBLIC 表示字段权限修饰符为 public</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//域信息</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> num;<br>    descriptor: I<br>    flags: ACC_PUBLIC<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> java.lang.String str;<br>    descriptor: Ljava/lang/String;<br>    flags: ACC_PRIVATE, ACC_STATIC<br></code></pre></td></tr></table></figure><p><strong>方法信息</strong></p><ol><li>descriptor: ()V 表示方法返回值类型为 void</li><li>flags: ACC_PUBLIC 表示方法权限修饰符为 public</li><li>stack&#x3D;3 表示操作数栈深度为 3</li><li>locals&#x3D;2 表示局部变量个数为 2 个（实力方法包含 this）</li><li>test1() 方法虽然没有参数，但是其 args_size&#x3D;1 ，这时因为将 this 作为了参数</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">20</span><br>         <span class="hljs-number">2</span>: istore_1<br>         <span class="hljs-number">3</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">6</span>: <span class="hljs-keyword">new</span>           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// class java/lang/StringBuilder</span><br>         <span class="hljs-number">9</span>: dup<br>        <span class="hljs-number">10</span>: invokespecial #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br>        <span class="hljs-number">13</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String count =</span><br>        <span class="hljs-number">15</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br>        <span class="hljs-number">18</span>: iload_1<br>        <span class="hljs-number">19</span>: invokevirtual #<span class="hljs-number">8</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br>        <span class="hljs-number">22</span>: invokevirtual #<span class="hljs-number">9</span>                  <span class="hljs-comment">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br>        <span class="hljs-number">25</span>: invokevirtual #<span class="hljs-number">10</span>                 <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">17</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">19</span>: <span class="hljs-number">28</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">29</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/MethodInnerStrucTest;<br>            <span class="hljs-number">3</span>      <span class="hljs-number">26</span>     <span class="hljs-number">1</span> count   I<br><br></code></pre></td></tr></table></figure><h3 id="non-final-类型的类变量"><a href="#non-final-类型的类变量" class="headerlink" title="non-final 类型的类变量"></a>non-final 类型的类变量</h3><ol><li><p>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</p></li><li><p>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</p></li></ol><p><strong>举例</strong></p><ol><li>如下代码所示，即使我们把order设置为null，也不会出现空指针异常</li><li>这更加表明了 static 类型的字段和方法随着类的加载而加载，并不属于特定的类实例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        order.hello();<br>        System.out.println(order.count);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">hello!<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="全局常量：static-final"><a href="#全局常量：static-final" class="headerlink" title="全局常量：static final"></a>全局常量：static final</h4><ol><li><p>全局常量就是使用 static final 进行修饰</p></li><li><p>被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p></li></ol><p>查看上面代码，这部分的字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    ...<br>&#125;    <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count;<br>    descriptor: I<br>    flags: ACC_PUBLIC, ACC_STATIC<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> number;<br>    descriptor: I<br>    flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL<br>    ConstantValue: <span class="hljs-type">int</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>可以发现 staitc和final同时修饰的number 的值在编译上的时候已经写死在字节码文件中了。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><h4 id="运行时常量池-VS-常量池"><a href="#运行时常量池-VS-常量池" class="headerlink" title="运行时常量池 VS 常量池"></a>运行时常量池 VS 常量池</h4><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p>后面会细讲常量池，这里为了讲清楚方法区，简单带一下。</p></blockquote><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816046.png"><ol><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池。（之前的字节码文件中已经看到了很多Constant pool的东西，这个就是常量池）</li><li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池。</li></ol><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><ol><li>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外。还包含一项信息就是<strong>常量池表</strong>（<strong>Constant Pool Table</strong>），包括各种字面量和对类型、域和方法的符号引用。</li><li>字面量： 10 ， “我是某某”这种数字和字符串都是字面量</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816047.png"><p><strong>为什么需要常量池？</strong></p><ol><li>一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池。这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍</li></ol><p>比如：如下的代码：</p><pre><code class="hljs">public class SimpleClass &#123;    public void sayHello() &#123;        System.out.println(&quot;hello&quot;);    &#125;&#125;</code></pre><ol><li>虽然上述代码只有194字节，但是里面却使用了String、System、PrintStream及Object等结构。</li><li>比如说我们这个文件中有6个地方用到了”hello”这个字符串，如果不用常量池，就需要在6个地方全写一遍，造成臃肿。我们可以将”hello”等所需用到的结构信息记录在常量池中，并通过<strong>引用的方式</strong>，来加载、调用所需的结构</li><li>这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816048.png"><p><strong>常量池中有啥？</strong></p><ol><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ol><p>MethodInnerStrucTest 的 test1方法的字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> bipush <span class="hljs-number">20</span><br> <span class="hljs-number">2</span> istore_1<br> <span class="hljs-number">3</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br> <span class="hljs-number">6</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java/lang/StringBuilder&gt;<br> <span class="hljs-number">9</span> dup<br><span class="hljs-number">10</span> invokespecial #<span class="hljs-number">5</span> &lt;java/lang/StringBuilder.&lt;init&gt;&gt;<br><span class="hljs-number">13</span> ldc #<span class="hljs-number">6</span> &lt;count = &gt;<br><span class="hljs-number">15</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">18</span> iload_1<br><span class="hljs-number">19</span> invokevirtual #<span class="hljs-number">8</span> &lt;java/lang/StringBuilder.append&gt;<br><span class="hljs-number">22</span> invokevirtual #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder.toString&gt;<br><span class="hljs-number">25</span> invokevirtual #<span class="hljs-number">10</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">28</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>1、#3，#5等等这些带# 的，都是引用了常量池。</p><p><strong>常量池总结</strong></p><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型。</p><h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ol><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li>常量池表（Constant Pool Table）是Class字节码文件的一部分，用于存放编译期生成的各种字面量与符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。（运行时常量池就是常量池在程序运行时的称呼）</li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li><li>JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。<strong>此时不再是常量池中的符号地址了，这里换为真实地址</strong>。</li></ol><ul><li>运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。</li></ul><ol start="6"><li>运行时常量池类似于传统编程语言中的符号表（symbol table），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutofMemoryError异常。</li></ol><h2 id="方法区的使用举例"><a href="#方法区的使用举例" class="headerlink" title="方法区的使用举例"></a>方法区的使用举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodAreaDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> x / y;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>        System.out.println(a + b);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java1.MethodAreaDemo<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">51</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">5.</span>#<span class="hljs-number">24</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">3</span> = Methodref          #<span class="hljs-number">27.</span>#<span class="hljs-number">28</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span><br>   #<span class="hljs-number">4</span> = Class              #<span class="hljs-number">29</span>            <span class="hljs-comment">// com/atguigu/java1/MethodAreaDemo</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">30</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">6</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">7</span> = Utf8               ()V<br>   #<span class="hljs-number">8</span> = Utf8               Code<br>   #<span class="hljs-number">9</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">10</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">11</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">12</span> = Utf8               Lcom/atguigu/java1/MethodAreaDemo;<br>  #<span class="hljs-number">13</span> = Utf8               main<br>  #<span class="hljs-number">14</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">15</span> = Utf8               args<br>  #<span class="hljs-number">16</span> = Utf8               [Ljava/lang/String;<br>  #<span class="hljs-number">17</span> = Utf8               x<br>  #<span class="hljs-number">18</span> = Utf8               I<br>  #<span class="hljs-number">19</span> = Utf8               y<br>  #<span class="hljs-number">20</span> = Utf8               a<br>  #<span class="hljs-number">21</span> = Utf8               b<br>  #<span class="hljs-number">22</span> = Utf8               SourceFile<br>  #<span class="hljs-number">23</span> = Utf8               MethodAreaDemo.java<br>  #<span class="hljs-number">24</span> = NameAndType        #<span class="hljs-number">6</span>:#<span class="hljs-number">7</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">25</span> = Class              #<span class="hljs-number">31</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">32</span>:#<span class="hljs-number">33</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">27</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">28</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// println:(I)V</span><br>  #<span class="hljs-number">29</span> = Utf8               com/atguigu/java1/MethodAreaDemo<br>  #<span class="hljs-number">30</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">31</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">32</span> = Utf8               out<br>  #<span class="hljs-number">33</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">34</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">35</span> = Utf8               println<br>  #<span class="hljs-number">36</span> = Utf8               (I)V<br>&#123;<br>  <span class="hljs-keyword">public</span> com.atguigu.java1.MethodAreaDemo();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/MethodAreaDemo;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: sipush        <span class="hljs-number">500</span><br>         <span class="hljs-number">3</span>: istore_1<br>         <span class="hljs-number">4</span>: bipush        <span class="hljs-number">100</span><br>         <span class="hljs-number">6</span>: istore_2<br>         <span class="hljs-number">7</span>: iload_1<br>         <span class="hljs-number">8</span>: iload_2<br>         <span class="hljs-number">9</span>: idiv<br>        <span class="hljs-number">10</span>: istore_3<br>        <span class="hljs-number">11</span>: bipush        <span class="hljs-number">50</span><br>        <span class="hljs-number">13</span>: istore        <span class="hljs-number">4</span><br>        <span class="hljs-number">15</span>: getstatic     #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-number">18</span>: iload_3<br>        <span class="hljs-number">19</span>: iload         <span class="hljs-number">4</span><br>        <span class="hljs-number">21</span>: iadd<br>        <span class="hljs-number">22</span>: invokevirtual #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>        <span class="hljs-number">25</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">9</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">10</span>: <span class="hljs-number">4</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">7</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">11</span><br>        line <span class="hljs-number">13</span>: <span class="hljs-number">15</span><br>        line <span class="hljs-number">14</span>: <span class="hljs-number">25</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">26</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">4</span>      <span class="hljs-number">22</span>     <span class="hljs-number">1</span>     x   I<br>            <span class="hljs-number">7</span>      <span class="hljs-number">19</span>     <span class="hljs-number">2</span>     y   I<br>           <span class="hljs-number">11</span>      <span class="hljs-number">15</span>     <span class="hljs-number">3</span>     a   I<br>           <span class="hljs-number">15</span>      <span class="hljs-number">11</span>     <span class="hljs-number">4</span>     b   I<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;MethodAreaDemo.java&quot;</span><br><br></code></pre></td></tr></table></figure><h4 id="图解字节码指令执行流程"><a href="#图解字节码指令执行流程" class="headerlink" title="图解字节码指令执行流程"></a>图解字节码指令执行流程</h4><p>1、初始状态</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816049.png"><p>2、首先将操作数500压入操作数栈中</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816050.png"><p>3、然后操作数 500 从操作数栈中取出，存储到局部变量表中索引为 1 的位置</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816051.png"><p>4、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816052.png"><p>5、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816053.png"><p>6、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816054.png"><p>7、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816055.png"><p>8、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816056.png"><p>9、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816057.png"><p>10、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816058.png"><p>11、图片写错了是#25和#26（获得System类）</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816059.png"><p>12、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816060.png"><p>13、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816061.png"><p>15、执行加法运算后，将计算结果放在操作数栈顶</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816062.png"><p>16、就是真正的打印</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816063.png"><p>17、</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816064.png"><p><strong>符号引用 –&gt; 直接饮用</strong></p><ol><li>上面代码调用 System.out.println() 方法时，首先需要看看 System 类有没有加载，再看看 PrintStream 类有没有加载</li><li>如果没有加载，则执行加载，执行时，将常量池中的符号引用（字面量）转换为运行时常量池的直接引用（真正的地址值）</li></ol><h2 id="方法区演进细节"><a href="#方法区演进细节" class="headerlink" title="方法区演进细节"></a>方法区演进细节</h2><h3 id="永久代演进过程"><a href="#永久代演进过程" class="headerlink" title="永久代演进过程"></a>永久代演进过程</h3><ol><li><p>首先明确：只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一</p></li><li><p>Hotspot中方法区的变化：</p></li></ol><table><thead><tr><th>JDK1.6及以前</th><th>有永久代（permanent generation），静态变量存储在永久代上</th></tr></thead><tbody><tr><td>JDK1.7</td><td>有永久代，但已经逐步 “去永久代”，<strong>字符串常量池，静态变量移除，保存在堆中</strong></td></tr><tr><td>JDK1.8</td><td>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</td></tr></tbody></table><p><strong>JDK6</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存（虚拟的内存）</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816065.png"><p><strong>JDK7</strong></p><p>方法区由永久代实现，使用 JVM 虚拟机内存</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816066.png"><p><strong>JDK8</strong></p><p>方法区由元空间实现，使用物理机本地内存</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816067.png"><h3 id="永久代为什么要被元空间替代？"><a href="#永久代为什么要被元空间替代？" class="headerlink" title="永久代为什么要被元空间替代？"></a>永久代为什么要被元空间替代？</h3><blockquote><p><strong>官方文档</strong>：<a href="http://openjdk.java.net/jeps/122">http://openjdk.java.net/jeps/122</a></p></blockquote><ol><li>随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。</li><li>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</li><li>这项改动是很有必要的，原因有：<ol><li>为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。<code>Exception in thread &#39;dubbo client x.x connector&#39; java.lang.OutOfMemoryError:PermGen space</code>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</li><li>对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低<strong>Full GC</strong><ol><li>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</li><li>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</li></ol></li></ol></li></ol><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p><strong>字符串常量池 StringTable 为什么要调整位置？</strong></p><ul><li><p>JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。</p></li><li><p>这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p></li></ul><h3 id="静态变量放在哪里"><a href="#静态变量放在哪里" class="headerlink" title="静态变量放在哪里"></a>静态变量放在哪里</h3><h4 id="对象实体在哪里放着？"><a href="#对象实体在哪里放着？" class="headerlink" title="对象实体在哪里放着？"></a>对象实体在哪里放着？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 结论：</span><br><span class="hljs-comment"> * 1、静态引用对应的对象实体(也就是这个new byte[1024 * 1024 * 100])始终都存在堆空间，</span><br><span class="hljs-comment"> * 2、只是那个变量(相当于下面的arr变量名)在JDK6,JDK7,JDK8存放位置中有所变化</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * jdk7：</span><br><span class="hljs-comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span><br><span class="hljs-comment"> * jdk 8：</span><br><span class="hljs-comment"> * -Xms200m -Xmx200m -XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticFieldTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">100</span>];<span class="hljs-comment">//100MB</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(StaticFieldTest.arr);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>JDK6环境下</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816068.png" alt="image-20201113224231761" /><p>JDK7环境下</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816069.png"><p>JDK8环境</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816070.png"><h4 id="变量-名-存放在哪里？"><a href="#变量-名-存放在哪里？" class="headerlink" title="变量(名)存放在哪里？"></a>变量(名)存放在哪里？</h4><p>这个问题需要用JHSDB工具来进行分析，这个工具是JDK9开始自带的(JDK9以前没有)，在bin目录下可以找到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.atguigu.java1;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 《深入理解Java虚拟机》中的案例：</span><br><span class="hljs-comment"> * staticObj、instanceObj、localObj存放在哪里？</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticObjTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">ObjectHolder</span> <span class="hljs-variable">staticObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectHolder</span>();<br>        <span class="hljs-type">ObjectHolder</span> <span class="hljs-variable">instanceObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectHolder</span>();<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ObjectHolder</span> <span class="hljs-variable">localObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectHolder</span>();<br>            System.out.println(<span class="hljs-string">&quot;done&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectHolder</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticObjTest</span>.Test();<br>        test.foo();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>JDK6环境下</strong></p><p>1、staticObj随着Test的类型信息存放在方法区</p><p>2、instanceObj随着Test的对象实例存放在Java堆</p><p>3、localObject则是存放在foo()方法栈帧的局部变量表中。</p><p>4、测试发现：三个对象的数据在内存中的地址都落在Eden区范围内，所以结论：<strong>只要是对象实例必然会在Java堆中分配</strong>。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816071.png"><blockquote><p>1、0x00007f32c7800000(Eden区的起始地址)    —-   0x00007f32c7b50000(Eden区的终止地址)  </p><p>2、可以发现三个变量都在这个范围内</p><p>3、所以可以得到上面结论</p></blockquote><p>5、接着，找到了一个引用该staticObj对象的地方，是在一个java.lang.Class的实例里，并且给出了这个实例的地址，通过Inspector查看该对象实例，可以清楚看到这确实是一个java.lang.Class类型的对象实例，里面有一个名为staticobj的实例字段：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816072.png"><p>从《Java虚拟机规范》所定义的概念模型来看，所有Class相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。JDK7及其以后版本的HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，<strong>存储于Java堆之中</strong>，从我们的实验中也明确验证了这一点</p><h2 id="方法区的垃圾回收"><a href="#方法区的垃圾回收" class="headerlink" title="方法区的垃圾回收"></a>方法区的垃圾回收</h2><ol><li><p>有些人认为方法区（如Hotspot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区<strong>类型卸载</strong>的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。</p></li><li><p>一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p></li><li><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p></li><li><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li><li><p>HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p></li><li><p>回收废弃常量与回收Java堆中的对象非常类似。（关于常量的回收比较简单，重点是类的回收）</p></li></ol><p>下面也称作<strong>类卸载</strong></p><p>1、判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</p></li><li><p>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p></li><li><p>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>2、Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX：+TraceClass-Loading</code>、<code>-XX：+TraceClassUnLoading</code>查看类加载和卸载信息</p><p>3、在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。</p><h2 id="运行时数据区总结"><a href="#运行时数据区总结" class="headerlink" title="运行时数据区总结"></a>运行时数据区总结</h2><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816073.png"><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="直接内存概述"><a href="#直接内存概述" class="headerlink" title="直接内存概述"></a>直接内存概述</h3><ol><li><p>不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。</p></li><li><p>直接内存是在Java堆外的、直接向系统申请的内存区间。</p></li><li><p>来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存</p></li><li><p>通常，访问直接内存的速度会优于Java堆。即读写性能高。</p></li><li><p>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</p></li><li><p>Java的NIO库允许Java程序使用直接内存，用于数据缓冲区</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  IO                  NIO (New IO / Non-Blocking IO)</span><br><span class="hljs-comment"> *  byte[] / char[]     Buffer</span><br><span class="hljs-comment"> *  Stream              Channel</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 查看直接内存的占用与释放</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BUFFER</span> <span class="hljs-operator">=</span> <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<span class="hljs-comment">//1GB</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//直接分配本地内存空间</span><br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(BUFFER);<br>        System.out.println(<span class="hljs-string">&quot;直接内存分配完毕，请求指示！&quot;</span>);<br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        scanner.next();<br><br>        System.out.println(<span class="hljs-string">&quot;直接内存开始释放！&quot;</span>);<br>        byteBuffer = <span class="hljs-literal">null</span>;<br>        System.gc();<br>        scanner.next();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>直接占用了 1G 的本地内存</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816074.jpg"><h3 id="BIO-与-NIO"><a href="#BIO-与-NIO" class="headerlink" title="BIO 与 NIO"></a>BIO 与 NIO</h3><p><strong>非直接缓存区（BIO）</strong></p><p>原来采用BIO的架构，在读写本地文件时，我们需要从用户态切换成内核态</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816075.png"><p><strong>直接缓冲区（NIO）</strong></p><p>NIO 直接操作物理磁盘，省去了中间过程</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816076.png"><h3 id="直接内存与-OOM"><a href="#直接内存与-OOM" class="headerlink" title="直接内存与 OOM"></a>直接内存与 OOM</h3><ol><li><p>直接内存也可能导致OutofMemoryError异常</p></li><li><p>由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p></li><li><p>直接内存的缺点为：</p><ul><li>分配回收成本较高</li><li>不受JVM内存回收管理</li></ul></li><li><p>直接内存大小可以通过MaxDirectMemorySize设置</p></li><li><p>如果不指定，默认与堆的最大值-Xmx参数值一致</p></li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本地内存的OOM:  OutOfMemoryError: Direct buffer memory</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> BufferTest2 &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BUFFER = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">20</span>;<span class="hljs-comment">//20MB</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<br>        ArrayList&lt;ByteBuffer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>                ByteBuffer byteBuffer = ByteBuffer.allocateDirect(BUFFER);<br>                list.add(byteBuffer);<br>                <span class="hljs-keyword">count</span>++;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-keyword">count</span>);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Direct buffer memory<br>at java.nio.Bits.reserveMemory(Bits.java:<span class="hljs-number">694</span>)<br>at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="hljs-number">123</span>)<br>at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="hljs-number">311</span>)<br>at com.atguigu.java.BufferTest2.main(BufferTest2.java:<span class="hljs-number">21</span>)<br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816077.jpg"><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol><li>百度<ul><li>三面：说一下JVM内存模型吧，有哪些区？分别干什么的？</li></ul></li><li>蚂蚁金服：<ul><li>Java8的内存分代改进</li><li>JVM内存分哪几个区，每个区的作用是什么？</li><li>一面：JVM内存分布&#x2F;内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？</li><li>二面：Eden和survior的比例分配</li></ul></li><li>小米：<ul><li>jvm内存分区，为什么要有新生代和老年代</li></ul></li><li>字节跳动：<ul><li>二面：Java的内存分区</li><li>二面：讲讲vm运行时数据库区</li><li>什么时候对象会进入老年代？</li></ul></li><li>京东：<ul><li>JVM的内存结构，Eden和Survivor比例。</li><li>JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和survivor。</li></ul></li><li>天猫：<ul><li>一面：Jvm内存模型以及分区，需要详细到每个区放什么。</li><li>一面：JVM的内存模型，Java8做了什么改</li></ul></li><li>拼多多：<ul><li>JVM内存分哪几个区，每个区的作用是什么？</li></ul></li><li>美团：<ul><li>java内存分配</li><li>jvm的永久代中会发生垃圾回收吗？</li><li>一面：jvm内存分区，为什么要有新生代和老年代？</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第5章-堆</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC5%E7%AB%A0-%E5%A0%86/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC5%E7%AB%A0-%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的核心概述"><a href="#堆的核心概述" class="headerlink" title="堆的核心概述"></a>堆的核心概述</h2><h3 id="堆与进程"><a href="#堆与进程" class="headerlink" title="堆与进程"></a>堆与进程</h3><ol><li>堆针对一个JVM进程来说是唯一的。也就是<strong>一个进程只有一个JVM实例</strong>，一个JVM实例中就有一个运行时数据区，一个运行时数据区只有一个堆和一个方法区。</li><li>但是<strong>进程包含多个线程，他们是共享同一堆空间的</strong>。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816168.png"><ol><li><p>一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。</p></li><li><p>Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。</p></li><li><p>《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。</p></li><li><p>所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，<strong>TLAB</strong>）。</p></li><li><p>《Java虚拟机规范》中对Java堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。（The heap is the run-time data area from which memory for all class instances and arrays is allocated）</p><ul><li>从实际使用角度看：“几乎”所有的对象实例都在堆分配内存，但并非全部。因为还有一些对象是在栈上分配的（逃逸分析，标量替换）</li></ul></li><li><p>数组和对象可能永远不会存储在栈上（<strong>不一定</strong>），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。</p></li><li><p>在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。</p><ul><li>也就是触发了GC的时候，才会进行回收</li><li>如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word</li></ul></li><li><p>堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。</p></li></ol><blockquote><p>随着JVM的迭代升级，原来一些绝对的事情，在后续版本中也开始有了特例，变的不再那么绝对。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleHeap</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<span class="hljs-comment">//属性、成员变量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;My ID is &quot;</span> + id);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SimpleHeap</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleHeap</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">SimpleHeap</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleHeap</span>(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>];<br><br>        Object[] arr1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816170.png"><h3 id="堆内存细分"><a href="#堆内存细分" class="headerlink" title="堆内存细分"></a>堆内存细分</h3><p>现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：</p><ol><li>Java7 及之前堆内存逻辑上分为三部分：新生区+养老区+永久区<ul><li>Young Generation Space    新生区      Young&#x2F;New<ul><li>又被划分为Eden区和Survivor区</li></ul></li><li>Old generation space    养老区           Old&#x2F;Tenure</li><li>Permanent Space   永久区                   Perm</li></ul></li><li>Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间<ul><li>Young Generation Space 新生区，又被划分为Eden区和Survivor区</li><li>Old generation space 养老区</li><li>Meta Space 元空间 Meta</li></ul></li></ol><p>约定：新生区 &lt;–&gt; 新生代 &lt;–&gt; 年轻代 、 养老区 &lt;–&gt; 老年区 &lt;–&gt; 老年代、 永久区 &lt;–&gt; 永久代</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816171.png"><ol start="2"><li>堆空间内部结构，JDK1.8之前从永久代 替换成 元空间</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816172.png"><h2 id="JVisualVM可视化查看堆内存"><a href="#JVisualVM可视化查看堆内存" class="headerlink" title="JVisualVM可视化查看堆内存"></a>JVisualVM可视化查看堆内存</h2><p>运行下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;start...&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.MINUTES.sleep(<span class="hljs-number">30</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;end...&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>1、双击jdk目录下的这个文件</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816173.png"><p>2、工具 -&gt; 插件 -&gt; 安装Visual GC插件</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816174.png"><p>3、运行上面的代码</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816175.png"><h2 id="设置堆内存大小与-OOM"><a href="#设置堆内存大小与-OOM" class="headerlink" title="设置堆内存大小与 OOM"></a>设置堆内存大小与 OOM</h2><h3 id="设置堆内存"><a href="#设置堆内存" class="headerlink" title="设置堆内存"></a>设置堆内存</h3><ol><li><p>Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xms”和”-Xmx”来进行设置。</p><ul><li><strong>-Xms</strong>用于表示堆区的起始内存，等价于**-XX:InitialHeapSize**</li><li><strong>-Xmx</strong>则用于表示堆区的最大内存，等价于**-XX:MaxHeapSize**</li></ul></li><li><p>一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutofMemoryError异常。</p></li><li><p>通常会将-Xms和-Xmx两个参数配置相同的值</p></li></ol><ul><li>原因：假设两个不一样，初始内存小，最大内存大。在运行期间如果堆内存不够用了，会一直扩容直到最大内存。如果内存够用且多了，也会不断的缩容释放。频繁的扩容和释放造成不必要的压力，避免在GC之后调整堆内存给服务器带来压力。</li><li>如果两个设置一样的就少了频繁扩容和缩容的步骤。内存不够了就直接报OOM</li></ul><ol start="4"><li><p>默认情况下:</p><ul><li>初始内存大小：物理电脑内存大小&#x2F;64</li><li>最大内存大小：物理电脑内存大小&#x2F;4</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1. 设置堆空间大小的参数</span><br><span class="hljs-comment"> * -Xms 用来设置堆空间（年轻代+老年代）的初始内存大小</span><br><span class="hljs-comment"> *      -X 是jvm的运行参数</span><br><span class="hljs-comment"> *      ms 是memory start</span><br><span class="hljs-comment"> * -Xmx 用来设置堆空间（年轻代+老年代）的最大内存大小</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. 默认堆空间的大小</span><br><span class="hljs-comment"> *    初始内存大小：物理电脑内存大小 / 64</span><br><span class="hljs-comment"> *             最大内存大小：物理电脑内存大小 / 4</span><br><span class="hljs-comment"> * 3. 手动设置：-Xms600m -Xmx600m</span><br><span class="hljs-comment"> *     开发中建议将初始堆内存和最大的堆内存设置成相同的值。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. 查看设置的参数：方式一： jps   /  jstat -gc 进程id</span><br><span class="hljs-comment"> *                  方式二：-XX:+PrintGCDetails</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSpaceInitial</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//返回Java虚拟机中的堆内存总量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">initialMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-comment">//返回Java虚拟机试图使用的最大堆内存量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;-Xms : &quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;系统内存大小为：&quot;</span> + initialMemory * <span class="hljs-number">64.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;系统内存大小为：&quot;</span> + maxMemory * <span class="hljs-number">4.0</span> / <span class="hljs-number">1024</span> + <span class="hljs-string">&quot;G&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xms : 123M<br>-Xmx : 1794M<br>系统内存大小为：<span class="hljs-number">7.</span>6875G<br>系统内存大小为：<span class="hljs-number">7.</span>0078125G<br></code></pre></td></tr></table></figure><p>1、笔者电脑内存大小是8G，不足8G的原因是操作系统自身还占据了一些。</p><p>2、两个不一样的原因待会再说</p><p>设置下参数再看</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816176.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapSpaceInitial</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//返回Java虚拟机中的堆内存总量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">initialMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().totalMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-comment">//返回Java虚拟机试图使用的最大堆内存量</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">maxMemory</span> <span class="hljs-operator">=</span> Runtime.getRuntime().maxMemory() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;-Xms : &quot;</span> + initialMemory + <span class="hljs-string">&quot;M&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-Xmx : &quot;</span> + maxMemory + <span class="hljs-string">&quot;M&quot;</span>);<br><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xms : 575M<br>-Xmx : 575M<br></code></pre></td></tr></table></figure><p>为什么会少25M</p><p><strong>方式一： jps   &#x2F;  jstat -gc 进程id</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816177.png"><blockquote><p>jps：查看java进程</p><p>jstat：查看某进程内存使用情况</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">SOC: S0区总共容量<br>S1C: S1区总共容量<br>S0U: S0区使用的量<br>S1U: S1区使用的量<br>EC: 伊甸园区总共容量<br>EU: 伊甸园区使用的量<br>OC: 老年代总共容量<br>OU: 老年代使用的量<br></code></pre></td></tr></table></figure><p>1、</p><p>25600+25600+153600+409600 &#x3D; 614400K</p><p>614400 &#x2F;1024 &#x3D; 600M</p><p>2、</p><p>25600+153600+409600 &#x3D; 588800K</p><p>588800 &#x2F;1024 &#x3D; 575M</p><p>3、</p><p>并非巧合，S0区和S1区两个只有一个能使用，另一个用不了（后面会详解）</p><p> <strong>方式二：-XX:+PrintGCDetails</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816178.png"><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OOMTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ArrayList&lt;Picture&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Picture</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Picture</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] pixels;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Picture</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pixels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>1、设置虚拟机参数</p><p><code>-Xms600m -Xmx600m</code></p><p>最终输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.OutOfMemoryError: Java heap space<br>at com.atguigu.java.Picture.&lt;init&gt;(OOMTest.java:<span class="hljs-number">29</span>)<br>at com.atguigu.java.OOMTest.main(OOMTest.java:<span class="hljs-number">20</span>)<br><br>Process finished with exit code <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>2、堆内存变化图</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816179.png"><p>3、原因：大对象导致堆内存溢出</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816180.png"><h2 id="年轻代与老年代"><a href="#年轻代与老年代" class="headerlink" title="年轻代与老年代"></a>年轻代与老年代</h2><p>1、存储在JVM中的Java对象可以被划分为两类：</p><pre><code class="hljs">- 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速- 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致</code></pre><p>2、Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>3、其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816181.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816182.png"><ul><li><p>配置新生代与老年代在堆结构的占比</p><ul><li><p>默认**-XX:NewRatio**&#x3D;2，表示新生代占1，老年代占2，新生代占整个堆的1&#x2F;3</p></li><li><p>可以修改**-XX:NewRatio**&#x3D;4，表示新生代占1，老年代占4，新生代占整个堆的1&#x2F;5</p></li></ul></li></ul><ol><li><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8 : 1 : 1，</p></li><li><p>当然开发人员可以通过选项**-XX:SurvivorRatio**调整这个空间比例。比如-XX:SurvivorRatio&#x3D;8</p></li><li><p>几乎所有的Java对象都是在Eden区被new出来的。</p></li><li><p>绝大部分的Java对象的销毁都在新生代进行了（有些大的对象在Eden区无法存储时候，将直接进入老年代），IBM公司的专门研究表明，新生代中80%的对象都是“朝生夕死”的。</p></li><li><p>可以使用选项”-Xmn”设置新生代最大内存大小，但这个参数一般使用默认值就可以了。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816183.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -Xms600m -Xmx600m</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -XX:NewRatio ： 设置新生代与老年代的比例。默认值是2.</span><br><span class="hljs-comment"> * -XX:SurvivorRatio ：设置新生代中Eden区与Survivor区的比例。默认值是8</span><br><span class="hljs-comment"> * -XX:-UseAdaptiveSizePolicy ：关闭自适应的内存分配策略  （暂时用不到）</span><br><span class="hljs-comment"> * -Xmn:设置新生代的空间的大小。 （一般不设置）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart  shkstart@126.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020  17:23</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EdenSurvivorTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我只是来打个酱油~&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="图解对象分配过程"><a href="#图解对象分配过程" class="headerlink" title="图解对象分配过程"></a>图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。</p><p><strong>具体过程</strong></p><ol><li>new的对象先放伊甸园区。此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区。</li><li>然后将伊甸园中的剩余对象移动到幸存者0区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区。</li><li>如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。可以设置新生区进入养老区的年龄限制，设置 JVM 参数：<strong>-XX:MaxTenuringThreshold</strong>&#x3D;N 进行设置</li><li>在养老区，相对悠闲。当养老区内存不足时，再次触发GC：Major GC，进行养老区的内存清理</li><li>若养老区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。</li></ol><h3 id="图解对象分配（一般情况）"><a href="#图解对象分配（一般情况）" class="headerlink" title="图解对象分配（一般情况）"></a>图解对象分配（一般情况）</h3><p>1、我们创建的对象，一般都是存放在Eden区的，<strong>当我们Eden区满了后，就会触发GC操作</strong>，一般被称为 YGC &#x2F; Minor GC操作</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816184.png"><p>2、当我们进行一次垃圾收集后，红色的对象将会被回收，而绿色的独享还被占用着，存放在S0(Survivor From)区。同时我们给每个对象设置了一个年龄计数器，经过一次回收后还存在的对象，将其年龄加 1。</p><p>3、同时Eden区继续存放对象，当Eden区再次存满的时候，又会触发一个MinorGC操作，此时GC将会把 Eden和Survivor From中的对象进行一次垃圾收集，把存活的对象放到 Survivor To（S1）区，同时让存活的对象年龄 + 1</p><blockquote><p>下一次再进行GC的时候，</p><p>1、这一次的s0区为空，所以成为下一次GC的S1区</p><p>2、这一次的s1区则成为下一次GC的S0区</p><p>3、也就是说s0区和s1区在互相转换。</p></blockquote><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816185.png"><p>4、我们继续不断的进行对象生成和垃圾回收，当Survivor中的对象的年龄达到15的时候，将会触发一次 Promotion 晋升的操作，也就是将年轻代中的对象晋升到老年代中</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816186.png"><p>关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间收集。</p><h3 id="特殊情况说明"><a href="#特殊情况说明" class="headerlink" title="特殊情况说明"></a>特殊情况说明</h3><p><strong>对象分配的特殊情况</strong></p><ol><li>如果来了一个新对象，先看看 Eden 是否放的下？<ul><li>如果 Eden 放得下，则直接放到 Eden 区</li><li>如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？</li></ul></li><li>将对象放到老年区又有两种情况：<ul><li>如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代</li><li>那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM</li></ul></li><li>如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816187.png"><h3 id="常用调优工具"><a href="#常用调优工具" class="headerlink" title="常用调优工具"></a>常用调优工具</h3><ol><li>JDK命令行</li><li>Eclipse：Memory Analyzer Tool</li><li>Jconsole</li><li>Visual VM（实时监控，推荐）</li><li>Jprofiler（IDEA插件）</li><li>Java Flight Recorder（实时监控）</li><li>GCViewer</li><li>GCEasy</li></ol><h2 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h2><ol><li><p>我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，<strong>而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上</strong></p></li><li><p>JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p></li></ol><ul><li><p>部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：</p><ul><li><strong>新生代收集</strong>（Minor GC&#x2F;Young GC）：只是新生代（Eden，s0，s1）的垃圾收集</li><li><strong>老年代收集</strong>（Major GC&#x2F;Old GC）：只是老年代的圾收集。</li><li>目前，只有CMS GC会有单独收集老年代的行为。</li><li>注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。</li><li>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为</li></ul></li><li><p><strong>整堆收集</strong>（Full GC）：收集整个java堆和方法区的垃圾收集。</p></li></ul><blockquote><p>由于历史原因，外界各种解读，majorGC和Full GC有些混淆。</p></blockquote><h3 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h3><p><strong>年轻代 GC（Minor GC）触发机制</strong></p><ol><li><p>当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）</p></li><li><p>因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p></li><li><p>Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816188.png"><h3 id="Major-Full-GC"><a href="#Major-Full-GC" class="headerlink" title="Major&#x2F;Full GC"></a>Major&#x2F;Full GC</h3><blockquote><p>Full GC有争议，后续详解两者区别，暂时先看着</p></blockquote><p><strong>老年代GC（MajorGC）触发机制</strong></p><ol><li><p>指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了</p></li><li><p>出现了MajorGc，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发Minor GC（哈？我有点迷？），如果之后空间还不足，则触发Major GC</li></ul></li><li><p>Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。</p></li><li><p>如果Major GC后，内存还不足，就报OOM了</p></li></ol><p><strong>Full GC 触发机制（后面细讲）</strong></p><p><strong>触发Full GC执行的情况有如下五种：</strong></p><ol><li>调用System.gc()时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p>说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些</p><h3 id="GC日志分析"><a href="#GC日志分析" class="headerlink" title="GC日志分析"></a>GC日志分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试MinorGC 、 MajorGC、FullGC</span><br><span class="hljs-comment"> * -Xms9m -Xmx9m -XX:+PrintGCDetails</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart  shkstart@126.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020  14:19</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GCTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.com&quot;</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                list.add(a);<br>                a = a + a;<br>                i++;<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            t.printStackTrace();<br>            System.out.println(<span class="hljs-string">&quot;遍历次数为：&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="hljs-number">0.0455865</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.06</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 2246K-&gt;496K(2560K)] 2470K-&gt;1506K(9728K), <span class="hljs-number">0.0009094</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 2294K-&gt;488K(2560K)] 3305K-&gt;2210K(9728K), <span class="hljs-number">0.0009568</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 1231K-&gt;488K(2560K)] 7177K-&gt;6434K(9728K), <span class="hljs-number">0.0005594</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 488K-&gt;472K(2560K)] 6434K-&gt;6418K(9728K), <span class="hljs-number">0.0005890</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(Allocation Failure)</span> [PSYoungGen: 472K-&gt;0K(2560K)] [ParOldGen: 5946K-&gt;4944K(7168K)] 6418K-&gt;4944K(9728K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0045270</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.01</span> secs] <br>[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(1536K)] 4944K-&gt;4944K(8704K), <span class="hljs-number">0.0004954</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.00</span> secs] <br>[Full <span class="hljs-title function_">GC</span> <span class="hljs-params">(Allocation Failure)</span> java.lang.OutOfMemoryError: Java heap space<br>at java.util.Arrays.copyOf(Arrays.java:<span class="hljs-number">3332</span>)<br>at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:<span class="hljs-number">124</span>)<br>at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:<span class="hljs-number">448</span>)<br>at java.lang.StringBuilder.append(StringBuilder.java:<span class="hljs-number">136</span>)<br>at com.atguigu.java1.GCTest.main(GCTest.java:<span class="hljs-number">20</span>)<br>[PSYoungGen: 0K-&gt;0K(1536K)] [ParOldGen: 4944K-&gt;4877K(7168K)] 4944K-&gt;4877K(8704K), [Metaspace: 3492K-&gt;3492K(1056768K)], <span class="hljs-number">0.0076061</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.02</span>, real=<span class="hljs-number">0.01</span> secs] <br>遍历次数为：<span class="hljs-number">16</span><br>Heap<br> PSYoungGen      total 1536K, used 60K [<span class="hljs-number">0x00000000ffd00000</span>, <span class="hljs-number">0x0000000100000000</span>, <span class="hljs-number">0x0000000100000000</span>)<br>  eden space 1024K, <span class="hljs-number">5</span>% used [<span class="hljs-number">0x00000000ffd00000</span>,<span class="hljs-number">0x00000000ffd0f058</span>,<span class="hljs-number">0x00000000ffe00000</span>)<br>  from space 512K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x00000000fff80000</span>,<span class="hljs-number">0x0000000100000000</span>)<br>  to   space 1024K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000ffe00000</span>,<span class="hljs-number">0x00000000fff00000</span>)<br> ParOldGen       total 7168K, used 4877K [<span class="hljs-number">0x00000000ff600000</span>, <span class="hljs-number">0x00000000ffd00000</span>, <span class="hljs-number">0x00000000ffd00000</span>)<br>  object space 7168K, <span class="hljs-number">68</span>% used [<span class="hljs-number">0x00000000ff600000</span>,<span class="hljs-number">0x00000000ffac3408</span>,<span class="hljs-number">0x00000000ffd00000</span>)<br> Metaspace       used 3525K, capacity 4502K, committed 4864K, reserved 1056768K<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">space</span>    used 391K, capacity 394K, committed 512K, reserved 1048576K<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure) [PSYoungGen: 2037K-&gt;504K(2560K)] 2037K-&gt;728K(9728K), <span class="hljs-number">0.0455865</span> secs] [Times: user=<span class="hljs-number">0.00</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.06</span> secs] <br><br></code></pre></td></tr></table></figure><ul><li><p>[PSYoungGen: 2037K-&gt;504K(2560K)]：年轻代总空间为 2560K ，当前占用 2037K ，经过垃圾回收后剩余504K</p></li><li><p>2037K-&gt;728K(9728K)：堆内存总空间为 9728K ，当前占用2037K ，经过垃圾回收后剩余728K</p></li></ul><h2 id="堆空间分代思想"><a href="#堆空间分代思想" class="headerlink" title="堆空间分代思想"></a>堆空间分代思想</h2><p>为什么要把Java堆分代？不分代就不能正常工作了吗？经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><ul><li>新生代：有Eden、两块大小相同的survivor（又称为from&#x2F;to或s0&#x2F;s1）构成，to总为空。</li><li>老年代：存放新生代中经历多次GC仍然存活的对象。</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816189.png"><p>其实不分代完全可以，分代的唯一理由就是优化GC性能。</p><ul><li>如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。（性能低）</li></ul><ul><li>而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当GC的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。（多回收新生代，少回收老年代，性能会提高很多）</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816190.png"><h2 id="对象内存分配策略"><a href="#对象内存分配策略" class="headerlink" title="对象内存分配策略"></a>对象内存分配策略</h2><ol><li>如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。</li><li>对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，其实每个JVM、每个GC都有所不同）时，就会被晋升到老年代</li><li>对象晋升老年代的年龄阀值，可以通过选项**-XX:MaxTenuringThreshold**来设置</li></ol><p><strong>针对不同年龄段的对象分配原则如下所示：</strong></p><ol><li><strong>优先分配到Eden</strong>：开发中比较长的字符串或者数组，会直接存在老年代，但是因为新创建的对象都是朝生夕死的，所以这个大对象可能也很快被回收，但是因为老年代触发Major GC的次数比 Minor GC要更少，因此可能回收起来就会比较慢</li><li><strong>大对象直接分配到老年代</strong>：尽量避免程序中出现过多的大对象</li><li><strong>长期存活的对象分配到老年代</strong></li><li><strong>动态对象年龄判断</strong>：如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</li><li><strong>空间分配担保</strong>： -XX:HandlePromotionFailure 。</li></ol><blockquote><p>一些细节放在后面说</p></blockquote><h2 id="TLAB为对象分配内存（保证线程安全）"><a href="#TLAB为对象分配内存（保证线程安全）" class="headerlink" title="TLAB为对象分配内存（保证线程安全）"></a>TLAB为对象分配内存（保证线程安全）</h2><h3 id="为什么有-TLAB"><a href="#为什么有-TLAB" class="headerlink" title="为什么有 TLAB"></a>为什么有 TLAB</h3><ol start="2"><li>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的</li><li>为避免多个线程操作同一地址，需要使用<strong>加锁等机制</strong>，进而影响分配速度。</li></ol><h3 id="什么是-TLAB"><a href="#什么是-TLAB" class="headerlink" title="什么是 TLAB"></a>什么是 TLAB</h3><p>TLAB（Thread Local Allocation Buffer）</p><ol><li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内</strong>。</li><li>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<strong>快速分配策略</strong>。</li><li>据我所知所有OpenJDK衍生出来的JVM都提供了TLAB的设计。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816191.png"><p>1、每个线程都有一个TLAB空间</p><p>2、当一个线程的TLAB存满时，可以使用公共区域（蓝色）的</p><h3 id="TLAB再说明"><a href="#TLAB再说明" class="headerlink" title="TLAB再说明"></a>TLAB再说明</h3><ol><li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但<strong>JVM确实是将TLAB作为内存分配的首选</strong>。</p></li><li><p>在程序中，开发人员可以通过选项“<strong>-XX:UseTLAB</strong>”设置是否开启TLAB空间。</p></li><li><p>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“<strong>-XX:TLABWasteTargetPercent</strong>”设置TLAB空间所占用Eden空间的百分比大小。</p></li><li><p>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在Eden空间中分配内存。</p></li></ol><blockquote><p>1、哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，<strong>分配新的缓存区时才需要同步锁定</strong>                   —-这是《深入理解JVM》–第三版里说的</p><p>2、和这里讲的有点不同。我猜测说的意思是某一次分配，如果TLAB用完了，那么<strong>这一次</strong>先在Eden区直接分配。空闲下来后再加锁分配新的TLAB（TLAB内存较大，分配时间应该较长）</p></blockquote><p><strong>TLAB 分配过程</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271816192.png"><h2 id="堆空间参数设置"><a href="#堆空间参数设置" class="headerlink" title="堆空间参数设置"></a>堆空间参数设置</h2><h3 id="常用参数设置"><a href="#常用参数设置" class="headerlink" title="常用参数设置"></a>常用参数设置</h3><blockquote><p><strong>官方文档</strong>：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p><p>我们只说常用的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试堆空间常用的jvm参数：</span><br><span class="hljs-comment"> * -XX:+PrintFlagsInitial : 查看所有的参数的默认初始值</span><br><span class="hljs-comment"> * -XX:+PrintFlagsFinal  ：查看所有的参数的最终值（可能会存在修改，不再是初始值）</span><br><span class="hljs-comment"> *      具体查看某个参数的指令： jps：查看当前运行中的进程</span><br><span class="hljs-comment"> *                             jinfo -flag SurvivorRatio 进程id</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * -Xms：初始堆空间内存 （默认为物理内存的1/64）</span><br><span class="hljs-comment"> * -Xmx：最大堆空间内存（默认为物理内存的1/4）</span><br><span class="hljs-comment"> * -Xmn：设置新生代的大小。(初始值及最大值)</span><br><span class="hljs-comment"> * -XX:NewRatio：配置新生代与老年代在堆结构的占比</span><br><span class="hljs-comment"> * -XX:SurvivorRatio：设置新生代中Eden和S0/S1空间的比例</span><br><span class="hljs-comment"> * -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄</span><br><span class="hljs-comment"> * -XX:+PrintGCDetails：输出详细的GC处理日志</span><br><span class="hljs-comment"> * 打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</span><br><span class="hljs-comment"> * -XX:HandlePromotionFailure：是否设置空间分配担保</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>1、在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。</p><ul><li>如果大于，则此次Minor GC是安全的</li><li>如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。<ul><li>如果HandlePromotionFailure&#x3D;true，那么会继续检查<strong>老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小</strong>。<ul><li>如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；</li><li>如果小于，则进行一次Full GC。</li></ul></li><li>如果HandlePromotionFailure&#x3D;false，则进行一次Full GC。</li></ul></li></ul><p><strong>历史版本</strong></p><ol><li>在JDK6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察openJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。</li><li>JDK6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC</strong>，否则将进行Full GC。即 HandlePromotionFailure&#x3D;true</li></ol><h2 id="堆是分配对象的唯一选择么？"><a href="#堆是分配对象的唯一选择么？" class="headerlink" title="堆是分配对象的唯一选择么？"></a>堆是分配对象的唯一选择么？</h2><p><strong>在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：</strong></p><ol><li><p>随着JIT编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换</strong>优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p></li><li><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<strong>如果经过逃逸分析（Escape Analysis）后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。</p></li><li><p>此外，前面提到的基于OpenJDK深度定制的TaoBao VM，其中创新的GCIH（GC invisible heap）技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的。</p></li></ol><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><ol><li>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</li><li>这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</li><li>通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</li><li>逃逸分析的基本行为就是分析对象动态作用域：<ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul></li></ol><p><strong>逃逸分析举例</strong></p><p>1、没有发生逃逸的对象，则可以分配到栈（无线程安全问题）上，随着方法执行的结束，栈空间就被移除（也就无需GC）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">my_method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">V</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">V</span>();<br>    <span class="hljs-comment">// use v</span><br>    <span class="hljs-comment">// ....</span><br>    v = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、下面代码中的 StringBuffer sb 发生了逃逸，不能在栈上分配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuffer <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、如果想要StringBuffer sb不发生逃逸，可以这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createStringBuffer</span><span class="hljs-params">(String s1, String s2)</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 逃逸分析</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  如何快速的判断是否发生了逃逸分析，大家就看new的对象实体是否有可能在方法外被调用。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EscapeAnalysis</span> &#123;<br><br>    <span class="hljs-keyword">public</span> EscapeAnalysis obj;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    方法返回EscapeAnalysis对象，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> EscapeAnalysis <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> obj == <span class="hljs-literal">null</span>? <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>() : obj;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    为成员属性赋值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setObj</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();<br>    &#125;<br>    <span class="hljs-comment">//思考：如果当前的obj引用声明为static的？仍然会发生逃逸。</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    对象的作用域仅在当前方法中有效，没有发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EscapeAnalysis</span>();<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    引用成员变量的值，发生逃逸</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useEscapeAnalysis1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">EscapeAnalysis</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> getInstance();<br>        <span class="hljs-comment">//getInstance().xxx()同样会发生逃逸</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>逃逸分析参数设置</strong></p><ol><li><p>在JDK 1.7 版本之后，HotSpot中默认就已经开启了逃逸分析</p></li><li><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“-XX:+DoEscapeAnalysis”显式开启逃逸分析</li><li>通过选项“-XX:+PrintEscapeAnalysis”查看逃逸分析的筛选结果</li></ul></li></ol><p><strong>总结</strong></p><p>开发中能使用局部变量的，就不要使用在方法外定义。</p><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><ol><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</li><li><strong>同步省略</strong>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</li></ol><h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><ol><li>JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</li><li>常见的栈上分配的场景：在逃逸分析中，已经说明了，分别是给成员变量赋值、方法返回值、实例引用传递。</li></ol><p><strong>栈上分配举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 栈上分配测试</span><br><span class="hljs-comment"> * -Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackAllocation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-comment">// 查看执行时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>        <span class="hljs-comment">// 为了方便查看堆内存中对象个数，线程sleep</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e1) &#123;<br>            e1.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<span class="hljs-comment">//未发生逃逸</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">33280</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">38400</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">33280</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">125952</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0483350</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.06</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">34088</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">38400</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">34096</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">125952</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0008411</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">34088</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">792</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">38400</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">34096</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">800</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">125952</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0008427</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">[</span><span class="hljs-variable">GC</span> <span class="hljs-punctuation">(</span><span class="hljs-variable">Allocation</span> <span class="hljs-built_in">Failure</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">[</span><span class="hljs-variable">PSYoungGen</span><span class="hljs-operator">:</span> <span class="hljs-number">34072</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">808</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">38400</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span> <span class="hljs-number">34080</span><span class="hljs-built_in">K</span><span class="hljs-operator">-&gt;</span><span class="hljs-number">816</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">(</span><span class="hljs-number">125952</span><span class="hljs-built_in">K</span><span class="hljs-punctuation">)</span><span class="hljs-operator">,</span> <span class="hljs-number">0.0012223</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <span class="hljs-punctuation">[</span><span class="hljs-built_in">Times</span><span class="hljs-operator">:</span> <span class="hljs-variable">user</span><span class="hljs-operator">=</span><span class="hljs-number">0.08</span> <span class="hljs-variable">sys</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span><span class="hljs-operator">,</span> <span class="hljs-variable">real</span><span class="hljs-operator">=</span><span class="hljs-number">0.00</span> <span class="hljs-variable">secs</span><span class="hljs-punctuation">]</span> <br>花费的时间为： <span class="hljs-number">114</span> <span class="hljs-variable">ms</span><br></code></pre></td></tr></table></figure><p>1、JVM 参数设置</p><p>-Xmx128m -Xms128m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails</p><p>2、日志打印：发生了 GC ，耗时 114ms</p><p><strong>开启逃逸分析的情况</strong></p><p>输出结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">花费的时间为：<span class="hljs-number"> 5 </span>ms<br></code></pre></td></tr></table></figure><p>1、参数设置</p><p>-Xmx128m -Xms128m -XX:+DoEscapeAnalysis -XX:+PrintGCDetails</p><p>2、日志打印：并没有发生 GC ，耗时5ms 。</p><h3 id="同步省略（同步消除）"><a href="#同步省略（同步消除）" class="headerlink" title="同步省略（同步消除）"></a>同步省略（同步消除）</h3><ol><li><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p></li><li><p>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来<strong>判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</strong>。</p></li><li><p>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个<strong>取消同步的过程就叫同步省略，也叫锁消除</strong>。</p></li></ol><p>例如下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hollis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span>(hollis) &#123;<br>        System.out.println(hollis);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中对hollis这个对象加锁，但是hollis对象的生命周期只在f()方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>System.out.println(hellis);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>字节码分析</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Object</span> hollis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-title function_">synchronized</span>(<span class="hljs-params">hollis</span>) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(hollis);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/Object&gt;<br> <span class="hljs-number">3</span> dup<br> <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">1</span> &lt;java/lang/Object.&lt;init&gt;&gt;<br> <span class="hljs-number">7</span> astore_1<br> <span class="hljs-number">8</span> aload_1<br> <span class="hljs-number">9</span> dup<br><span class="hljs-number">10</span> astore_2<br><span class="hljs-number">11</span> monitorenter<br><span class="hljs-number">12</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">15</span> aload_1<br><span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">19</span> aload_2<br><span class="hljs-number">20</span> monitorexit<br><span class="hljs-number">21</span> <span class="hljs-keyword">goto</span> <span class="hljs-number">29</span> (+<span class="hljs-number">8</span>)<br><span class="hljs-number">24</span> astore_3<br><span class="hljs-number">25</span> aload_2<br><span class="hljs-number">26</span> monitorexit<br><span class="hljs-number">27</span> aload_3<br><span class="hljs-number">28</span> athrow<br><span class="hljs-number">29</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>注意：字节码文件中并没有进行优化，可以看到加锁和释放锁的操作依然存在，<strong>同步省略操作是在解释运行时发生的</strong></p><h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p><strong>分离对象或标量替换</strong></p><ol><li><p>标量（scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</p></li><li><p>相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p></li><li><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p></li></ol><p><strong>标量替换举例</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>    alloc();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Point</span> <span class="hljs-variable">point</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>    System.out.println(<span class="hljs-string">&quot;point.x&quot;</span> + point.x + <span class="hljs-string">&quot;;point.y&quot;</span> + point.y);<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    System.out.println(<span class="hljs-string">&quot;point.x = &quot;</span> + x + <span class="hljs-string">&quot;; point.y=&quot;</span> + y);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。</li><li>那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为一旦不需要创建对象了，那么就不再需要分配堆内存了。</li><li>标量替换为栈上分配提供了很好的基础。</li></ol><p><strong>标量替换参数设置</strong></p><p>参数 -XX:+ElimilnateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上。</p><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 标量替换测试</span><br><span class="hljs-comment"> *  -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shkstart  shkstart@126.com</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2020  12:01</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScalarReplace</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> id;<br>        <span class="hljs-keyword">public</span> String name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">u</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<span class="hljs-comment">//未发生逃逸</span><br>        u.id = <span class="hljs-number">5</span>;<br>        u.name = <span class="hljs-string">&quot;www.atguigu.com&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;花费的时间为： &quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>未开启标量替换</strong></p><p>1、JVM 参数</p><p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</p><p>2、日志</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">[GC (Allocation Failure)  25600K-&gt;880K(98304K), <span class="hljs-number">0.0012658</span> secs]<br>[GC (Allocation Failure)  26480K-&gt;832K(98304K), <span class="hljs-number">0.0012124</span> secs]<br>[GC (Allocation Failure)  26432K-&gt;784K(98304K), <span class="hljs-number">0.0009719</span> secs]<br>[GC (Allocation Failure)  26384K-&gt;832K(98304K), <span class="hljs-number">0.0009071</span> secs]<br>[GC (Allocation Failure)  26432K-&gt;768K(98304K), <span class="hljs-number">0.0010643</span> secs]<br>[GC (Allocation Failure)  26368K-&gt;824K(101376K), <span class="hljs-number">0.0012354</span> secs]<br>[GC (Allocation Failure)  32568K-&gt;712K(100864K), <span class="hljs-number">0.0011291</span> secs]<br>[GC (Allocation Failure)  32456K-&gt;712K(100864K), <span class="hljs-number">0.0006368</span> secs]<br>花费的时间为： <span class="hljs-number">99</span> ms<br></code></pre></td></tr></table></figure><p><strong>开启标量替换</strong></p><p>1、JVM 参数</p><p>-Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</p><p>2、日志：时间减少很多，且无GC</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">花费的时间为：<span class="hljs-number"> 6 </span>ms<br></code></pre></td></tr></table></figure><p>上述代码在主函数中调用了1亿次alloc()方法，进行对象创建由于User对象实例需要占据约16字节的空间，因此累计分配空间达到将近1.5GB。如果堆空间小于这个值，就必然会发生GC。使用如下参数运行上述代码：</p><p><code>-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</code></p><p>这里设置参数如下：</p><ol><li>参数 -server：启动Server模式，因为在server模式下，才可以启用逃逸分析。</li><li>参数 -XX:+DoEscapeAnalysis：启用逃逸分析</li><li>参数 -Xmx10m：指定了堆空间最大为10MB</li><li>参数 -XX:+PrintGC：将打印GC日志。</li><li>参数 -XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ol><h3 id="逃逸分析的不足"><a href="#逃逸分析的不足" class="headerlink" title="逃逸分析的不足"></a>逃逸分析的不足</h3><ol><li>关于逃逸分析的论文在1999年就已经发表了，但直到JDK1.6才有实现，而且这项技术到如今也并不是十分成熟的。</li><li>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</li><li>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</li><li>虽然这项技术并不十分成熟，但是它也是即时编译器优化技术中一个十分重要的手段。</li><li>注意到有一些观点，认为通过逃逸分析，JVM会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于JVM设计者的选择。据我所知，<strong>Oracle Hotspot JVM中并未这么做</strong>（刚刚演示的效果，是因为HotSpot实现了标量替换），这一点在逃逸分析相关的文档里已经说明，<strong>所以可以明确在HotSpot虚拟机上，所有的对象实例都是创建在堆上</strong>。</li><li>目前很多书籍还是基于JDK7以前的版本，JDK已经发生了很大变化，intern字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是<strong>intern字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配</strong>，<strong>所以这一点同样符合前面一点的结论：对象实例都是分配在堆上</strong>。</li></ol><blockquote><p><strong>堆是分配对象的唯一选择么？</strong></p></blockquote><p>综上：<strong>对象实例都是分配在堆上</strong>。What the fuck？</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p></li><li><p>老年代放置长生命周期的对象，通常都是从Survivor区域筛选拷贝过来的Java对象。</p></li><li><p>当然，也有特殊情况，我们知道普通的对象可能会被分配在TLAB上；</p></li><li><p>如果对象较大，无法分配在 TLAB 上，则JVM会试图直接分配在Eden其他位置上；</p></li><li><p>如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM就会直接分配到老年代。</p></li><li><p>当GC只发生在年轻代中，回收年轻代对象的行为被称为Minor GC。</p></li><li><p>当GC发生在老年代时则被称为Major GC或者Full GC。</p></li><li><p>一般的，Minor GC的发生频率要比Major GC高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第4章-虚拟机栈</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC4%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="虚拟机栈的出现背景"><a href="#虚拟机栈的出现背景" class="headerlink" title="虚拟机栈的出现背景"></a>虚拟机栈的出现背景</h3><ol><li>由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的【如果设计成基于寄存器的，耦合度高，性能会有所提升，因为可以对具体的CPU架构进行优化，但是跨平台性大大降低】。</li><li>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</li></ol><h3 id="内存中的栈与堆"><a href="#内存中的栈与堆" class="headerlink" title="内存中的栈与堆"></a>内存中的栈与堆</h3><ol><li>首先栈是运行时的单位，而堆是存储的单位。</li><li>即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814638.png"><h3 id="虚拟机栈基本内容"><a href="#虚拟机栈基本内容" class="headerlink" title="虚拟机栈基本内容"></a>虚拟机栈基本内容</h3><ul><li><p>Java虚拟机栈是什么？</p><ul><li>Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<strong>对应着一次次的Java方法调用</strong>，栈是线程私有的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StackTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StackTest</span>();<br>        test.methodA();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><br>        methodB();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814639.png"><ul><li><p>虚拟机栈的生命周期</p><ul><li>生命周期和线程一致，也就是线程结束了，该虚拟机栈也销毁了</li></ul></li><li><p>虚拟机栈的作用</p><ul><li>主管Java程序的运行，它保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回。</li><li>局部变量，它是相比于成员变量来说的（或属性）</li><li>基本数据类型变量 VS 引用类型变量（类、数组、接口）</li></ul></li></ul><h3 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h3><ul><li><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p></li><li><p>JVM直接对Java栈的操作只有两个：</p><ul><li>每个方法执行，伴随着<strong>进栈</strong>（入栈、压栈）</li><li>执行结束后的<strong>出栈</strong>工作</li></ul></li><li><p>对于栈来说不存在垃圾回收问题</p><ul><li>栈不需要GC，但是可能存在OOM</li></ul></li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814640.png"><h3 id="虚拟机栈的异常"><a href="#虚拟机栈的异常" class="headerlink" title="虚拟机栈的异常"></a>虚拟机栈的异常</h3><p><strong>面试题：栈中可能出现的异常？</strong></p><ul><li><p>Java 虚拟机规范允许Java栈的大小是动态的或者是固定不变的。</p><ul><li><p>如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个<strong>StackoverflowError</strong> 异常。</p></li><li><p>如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 <strong>OutofMemoryError</strong> 异常。</p></li></ul></li></ul><h3 id="设置栈内存大小"><a href="#设置栈内存大小" class="headerlink" title="设置栈内存大小"></a>设置栈内存大小</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>多去官方文档看看：<a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE</a></p><p>地址经常变</p></blockquote><p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。</p><blockquote><p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, and <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p><ul><li>Linux&#x2F;x64 (64-bit): 1024 KB</li><li>macOS (64-bit): 1024 KB</li><li>Oracle Solaris&#x2F;x64 (64-bit): 1024 KB</li><li>Windows: The default value depends on virtual memory</li></ul></blockquote><p>The following examples set the thread stack size to 1024 KB in different units:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">-Xss1m<br>-Xss1024k<br>-Xss1048576<br></code></pre></td></tr></table></figure><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackErrorTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(count);<br>        count++;<br>        main(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>没设置参数前</strong></p><p>部分输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11404</span><br><span class="hljs-number">11405</span><br><span class="hljs-number">11406</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError<br>at sun.nio.cs.UTF_8$Encoder.encodeLoop(UTF_8.java:<span class="hljs-number">691</span>)<br></code></pre></td></tr></table></figure><p>说明栈在11406这个深度溢出了</p><p><strong>设置栈参数之后</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814641.png"><p>部分输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2474</span><br><span class="hljs-number">2475</span><br><span class="hljs-number">2476</span><br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.StackOverflowError<br>at sun.nio.cs.UTF_8.updatePositions(UTF_8.java:<span class="hljs-number">77</span>)<br></code></pre></td></tr></table></figure><p>说明参数起作用了</p><h2 id="栈的存储单位"><a href="#栈的存储单位" class="headerlink" title="栈的存储单位"></a>栈的存储单位</h2><h3 id="栈中存储什么？"><a href="#栈中存储什么？" class="headerlink" title="栈中存储什么？"></a>栈中存储什么？</h3><ol><li>每个线程都有自己的栈，栈中的数据都是以<strong>栈帧</strong>（Stack Frame）的格式存在</li><li>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</li></ol><h3 id="栈运行原理"><a href="#栈运行原理" class="headerlink" title="栈运行原理"></a>栈运行原理</h3><ol><li><p>JVM直接对Java栈的操作只有两个，就是对栈帧的<strong>压栈和出栈</strong>，遵循先进后出（后进先出）原则</p></li><li><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的。这个栈帧被称为<strong>当前栈帧（Current Frame）</strong>，与当前栈帧相对应的方法就是<strong>当前方法（Current Method）</strong>，定义这个方法的类就是<strong>当前类（Current Class）</strong></p></li><li><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p></li><li><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814642.png"><ol><li><strong>不同线程中所包含的栈帧是不允许存在相互引用的</strong>，即不可能在一个栈帧之中引用另外一个线程的栈帧。</li><li>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</li><li>Java方法有两种返回函数的方式。<ul><li>一种是正常的函数返回，使用return指令。</li><li>另一种是方法执行中出现未捕获处理的异常，以抛出异常的方式结束。</li><li>但不管使用哪种方式，都会导致栈帧被弹出。</li></ul></li></ol><h3 id="栈帧的内部结构"><a href="#栈帧的内部结构" class="headerlink" title="栈帧的内部结构"></a>栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li><p>局部变量表（Local Variables）</p></li><li><p>操作数栈（Operand Stack）（或表达式栈）</p></li><li><p>动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）</p></li><li><p>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</p></li><li><p>一些附加信息</p></li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814643.png"><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814644.png"><h2 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h2><h3 id="认识局部变量表"><a href="#认识局部变量表" class="headerlink" title="认识局部变量表"></a>认识局部变量表</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ol><li>局部变量表也被称之为局部变量数组或本地变量表</li><li><strong>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</strong>，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。</li><li>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在数据安全问题</strong></li><li><strong>局部变量表所需的容量大小是在编译期确定下来的</strong>，并保存在方法的Code属性的<strong>maximum local variables</strong>数据项中。在方法运行期间是不会改变局部变量表的大小的。</li><li>方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。<ul><li>对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。</li><li>进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</li></ul></li><li>局部变量表中的变量只在当前方法调用中有效。<ul><li>在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。</li><li>当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</li></ul></li></ol><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LocalVariablesTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LocalVariablesTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariablesTest</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        test.test1();<br>    &#125;<br><br>    <span class="hljs-comment">//练习：</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStatic</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">LocalVariablesTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariablesTest</span>();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(count);<br>        <span class="hljs-comment">//因为this变量不存在于当前方法的局部变量表中！！</span><br><span class="hljs-comment">//        System.out.println(this.count);</span><br>    &#125;<br><br>    <span class="hljs-comment">//关于Slot的使用的理解</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LocalVariablesTest</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-built_in">this</span>.count = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;atguigu.com&quot;</span>;<br>        test2(date, name1);<br>        System.out.println(date + name1);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">(Date dateP, String name2)</span> &#123;<br>        dateP = <span class="hljs-literal">null</span>;<br>        name2 = <span class="hljs-string">&quot;songhongkang&quot;</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> <span class="hljs-number">130.5</span>;<span class="hljs-comment">//占据两个slot</span><br>        <span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br>        <span class="hljs-keyword">return</span> dateP + name2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.count++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            b = a + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814645.png"><p>看完字节码后，可得结论：所以局部变量表所需的容量大小是在编译期确定下来的。</p><h4 id="部分详解"><a href="#部分详解" class="headerlink" title="部分详解"></a>部分详解</h4><p>为了更好讲解，我们直接用jclasslib来看字节码，以main方法为例来讲解。一些一目了然的就不讲了</p><p>1、0-15  也就是有16行字节码</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814646.png"><p>2、方法异常信息表</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814647.png"><p>3、Misc</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814648.png"><p>4、行号表</p><p>Java代码的行号和字节码指令行号的对应关系</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814649.png"><p>5、注意：生效行数和剩余有效行数都是针对于字节码文件的行数</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814650.png"><p>1、图中圈的东西表示该局部变量的作用域</p><p>2、Start PC&#x3D;&#x3D;11表示在字节码的11行开始生效，也就是Java代码对应的第15行。而声明int num在java代码的是第14行，说明是从声明的下一行开始生效</p><p>3、Length&#x3D;&#x3D; 5表示局部变量剩余有效行数，main方法字节码指令总共有16行，从11行开始生效，那么剩下就是16-11 &#x3D;&#x3D;5。</p><p>4、<code>Ljava/lang/String</code>   前面的L表示引用类型</p><h3 id="关于Slot的理解"><a href="#关于Slot的理解" class="headerlink" title="关于Slot的理解"></a>关于Slot的理解</h3><ol><li>参数值的存放总是从局部变量数组索引 0 的位置开始，到数组长度-1的索引结束。</li><li>局部变量表，<strong>最基本的存储单元是Slot（变量槽）</strong>，局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress类型的变量。</li><li>在局部变量表里，<strong>32位以内的类型只占用一个slot</strong>（包括returnAddress类型），<strong>64位的类型占用两个slot</strong>（1ong和double）。<ul><li>byte、short、char在储存前被转换为int，boolean也被转换为int，0表示false，非0表示true</li><li>long和double则占据两个slot</li></ul></li><li>JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</li><li>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<strong>按照顺序被复制</strong>到局部变量表中的每一个slot上</li><li>如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量）</li><li>如果当前帧是由构造方法或者实例方法创建的，那么<strong>该对象引用this将会存放在index为0的slot处</strong>，其余的参数按照参数表顺序继续排列。（this也相当于一个变量）</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814651.png"><h3 id="Slot代码示例"><a href="#Slot代码示例" class="headerlink" title="Slot代码示例"></a>Slot代码示例</h3><p><strong>this 存放在 index &#x3D; 0 的位置：</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-built_in">this</span>.count++;<br>   &#125;<br></code></pre></td></tr></table></figure><p>局部变量表：this 存放在 index &#x3D; 0 的位置</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814652.png"><p><strong>64位的类型（1ong和double）占用两个slot</strong></p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">test2</span><span class="hljs-params">(Date dateP, String name2)</span> &#123;<br>      dateP = <span class="hljs-literal">null</span>;<br>      name2 = <span class="hljs-string">&quot;songhongkang&quot;</span>;<br>      <span class="hljs-type">double</span> <span class="hljs-variable">weight</span> <span class="hljs-operator">=</span> <span class="hljs-number">130.5</span>;<span class="hljs-comment">//占据两个slot</span><br>      <span class="hljs-type">char</span> <span class="hljs-variable">gender</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;男&#x27;</span>;<br>      <span class="hljs-keyword">return</span> dateP + name2;<br>  &#125;<br></code></pre></td></tr></table></figure><p>weight 为 double 类型，index 直接从 3 蹦到了 5</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814653.png"><p><strong>static 无法调用 this</strong></p><p>this 不存在与 static 方法的局部变量表中，所以无法调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testStatic</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">LocalVariablesTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalVariablesTest</span>();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        System.out.println(count);<br>        <span class="hljs-comment">//因为this变量不存在于当前方法的局部变量表中！！</span><br><span class="hljs-comment">//        System.out.println(this.count);</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="Slot的重复利用"><a href="#Slot的重复利用" class="headerlink" title="Slot的重复利用"></a>Slot的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明新的局部变量变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        b = a + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">//变量c使用之前已经销毁的变量b占据的slot的位置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>局部变量 c 重用了局部变量 b 的 slot 位置</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814654.png"><h3 id="静态变量与局部变量的对比"><a href="#静态变量与局部变量的对比" class="headerlink" title="静态变量与局部变量的对比"></a>静态变量与局部变量的对比</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">变量的分类：<br><span class="hljs-number">1</span>、按照数据类型分：① 基本数据类型  ② 引用数据类型<br><span class="hljs-number">2</span>、按照在类中声明的位置分：<br>  <span class="hljs-number">2</span>-<span class="hljs-number">1</span>、成员变量：在使用前，都经历过默认初始化赋值<br>       <span class="hljs-number">2</span>-<span class="hljs-number">1</span>-<span class="hljs-number">1</span>、类变量: linking的prepare阶段：给类变量默认赋值<br>              ---&gt; initial阶段：给类变量显式赋值即静态代码块赋值<br>       <span class="hljs-number">2</span>-<span class="hljs-number">1</span>-<span class="hljs-number">2</span>、实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值<br>  <span class="hljs-number">2</span>-<span class="hljs-number">2</span>、局部变量：在使用前，必须要进行显式赋值的！否则，编译不通过。<br></code></pre></td></tr></table></figure><ol><li>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</li><li>我们知道成员变量有两次初始化的机会**，**第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。</li><li>和类变量初始化不同的是，<strong>局部变量表不存在系统初始化的过程</strong>，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</li></ol><h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><ol><li><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p></li><li><p>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</p></li></ol><h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><h3 id="操作数栈的特点"><a href="#操作数栈的特点" class="headerlink" title="操作数栈的特点"></a>操作数栈的特点</h3><ol><li><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last - In - First -Out）的 操作数栈，也可以称之为<strong>表达式栈</strong>（Expression Stack）</p></li><li><p>操作数栈，在方法执行过程中，<strong>根据字节码指令，往栈中写入数据或提取数据</strong>，即入栈（push）和 出栈（pop）</p></li></ol><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈，</li><li>比如：执行复制、交换、求和等操作</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814655.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814656.png"><h3 id="操作数栈的作用"><a href="#操作数栈的作用" class="headerlink" title="操作数栈的作用"></a>操作数栈的作用</h3><ol><li><p>操作数栈，<strong>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</strong>。</p></li><li><p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这时方法的操作数栈是空的。</p></li><li><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为<strong>maxstack</strong>的值。</p></li><li><p>栈中的任何一个元素都是可以任意的Java数据类型</p><ul><li>32bit的类型占用一个栈单位深度</li><li>64bit的类型占用两个栈单位深度</li></ul></li><li><p>操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈和出栈操作来完成一次数据访问。<strong>只不过操作数栈是用数组这个结构来实现的而已</strong></p></li><li><p>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。</p></li><li><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p></li><li><p>另外，<strong>我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</strong>。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814657.jpg"><p>局部变量表就相当于食材</p><p>操作数栈就相当于做法步骤</p><h2 id="操作数栈代码追踪"><a href="#操作数栈代码追踪" class="headerlink" title="操作数栈代码追踪"></a>操作数栈代码追踪</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddOperation</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">//byte、short、char、boolean：都以int型来保存</span><br>       <span class="hljs-type">byte</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br><br>      <span class="hljs-comment">// int m = 800;</span><br><br>   &#125;<br></code></pre></td></tr></table></figure><p>对应字节码指令</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> bipush <span class="hljs-number">15</span><br> <span class="hljs-number">2</span> istore_1<br> <span class="hljs-number">3</span> bipush <span class="hljs-number">8</span><br> <span class="hljs-number">5</span> istore_2<br> <span class="hljs-number">6</span> iload_1<br> <span class="hljs-number">7</span> iload_2<br> <span class="hljs-number">8</span> iadd<br> <span class="hljs-number">9</span> istore_3<br><span class="hljs-number">10</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814658.png"><h3 id="一步一步看流程"><a href="#一步一步看流程" class="headerlink" title="一步一步看流程"></a>一步一步看流程</h3><p>1、首先执行第一条语句，PC寄存器指向的是0，也就是指令地址为0，然后使用bipush让操作数15入操作数栈。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814659.png"><p>2、执行完后，PC寄存器往下移，指向下一行代码，下一行代码就是将操作数栈的元素存储到局部变量表1的位置（istore_1），我们可以看到局部变量表的已经增加了一个元素。并且操作数栈为空了</p><ul><li>解释为什么局部变量表索引从 1 开始，因为该方法为实例方法，局部变量表索引为 0 的位置存放的是 this</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814660.png"><p>3、然后PC下移，指向的是下一行。让操作数8也入栈，同时执行store操作，存入局部变量表中</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814661.png"><p>4、然后从局部变量表中，依次将数据放在操作数栈中，等待执行 add 操作</p><p>iload_1：取出局部变量表中索引为1的数据入操作数栈</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814662.png"><p>5、然后将操作数栈中的两个元素执行相加操作，并存储在局部变量表3的位置</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814663.png"><h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p><strong>关于类型转换的说明</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814664.png"><ul><li>因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8</li><li>但是存储在局部变量的时候，会转成 int 类型的变量：istore_4</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814665.png"><ul><li>m改成800之后，byte存储不了，就成了short型，sipush 800</li></ul><p><strong>如果被调用的方法带有返回值，返回值入操作数栈</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> m + n;<br>      <span class="hljs-keyword">return</span> k;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetSum</span><span class="hljs-params">()</span>&#123;<br>      <span class="hljs-comment">//获取上一个栈桢返回的结果，并保存在操作数栈中</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> getSum();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>getSum() 方法字节码指令：最后带着个 ireturn</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814666.png"><p>testGetSum() 方法字节码指令：一上来就加载 getSum() 方法的返回值()</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814667.png"><h2 id="栈顶缓存技术"><a href="#栈顶缓存技术" class="headerlink" title="栈顶缓存技术"></a>栈顶缓存技术</h2><p><strong>栈顶缓存技术：Top Of Stack Cashing</strong></p><ol><li><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数（也就是你会发现指令很多）和导致内存读&#x2F;写次数多，效率不高。</p></li><li><p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<strong>将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率。</strong></p></li><li><p>寄存器的主要优点：指令更少，执行速度快，但是指令集（也就是指令种类）很多</p></li></ol><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p><strong>动态链接（或指向运行时常量池的方法引用）</strong></p><ol><li><p>每一个栈帧内部都包含<strong>一个指向运行时常量池中该栈帧所属方法的引用</strong>。包含这个引用的目的就是<strong>为了支持当前方法的代码能够实现动态链接</strong>（Dynamic Linking），比如：invokedynamic指令</p></li><li><p>在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicLinkingTest</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodA()....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;methodB()....&quot;</span>);<br><br>        methodA();<br><br>        num++;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter05/com/atguigu/java1/DynamicLinkingTest.<span class="hljs-keyword">class</span><br>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">10</span>; size <span class="hljs-number">712</span> bytes<br>  MD5 checksum e56913c945f897c7ee6c0a608629bca8<br>  Compiled from <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java1.DynamicLinkingTest<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">9.</span>#<span class="hljs-number">23</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = Fieldref           #<span class="hljs-number">8.</span>#<span class="hljs-number">24</span>         <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest.num:I</span><br>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">25.</span>#<span class="hljs-number">26</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">4</span> = String             #<span class="hljs-number">27</span>            <span class="hljs-comment">// methodA()....</span><br>   #<span class="hljs-number">5</span> = Methodref          #<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>   #<span class="hljs-number">6</span> = String             #<span class="hljs-number">30</span>            <span class="hljs-comment">// methodB()....</span><br>   #<span class="hljs-number">7</span> = Methodref          #<span class="hljs-number">8.</span>#<span class="hljs-number">31</span>         <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest.methodA:()V</span><br>   #<span class="hljs-number">8</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// com/atguigu/java1/DynamicLinkingTest</span><br>   #<span class="hljs-number">9</span> = Class              #<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span><br>  #<span class="hljs-number">10</span> = Utf8               num<br>  #<span class="hljs-number">11</span> = Utf8               I<br>  #<span class="hljs-number">12</span> = Utf8               &lt;init&gt;<br>  #<span class="hljs-number">13</span> = Utf8               ()V<br>  #<span class="hljs-number">14</span> = Utf8               Code<br>  #<span class="hljs-number">15</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">16</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">17</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">18</span> = Utf8               Lcom/atguigu/java1/DynamicLinkingTest;<br>  #<span class="hljs-number">19</span> = Utf8               methodA<br>  #<span class="hljs-number">20</span> = Utf8               methodB<br>  #<span class="hljs-number">21</span> = Utf8               SourceFile<br>  #<span class="hljs-number">22</span> = Utf8               DynamicLinkingTest.java<br>  #<span class="hljs-number">23</span> = NameAndType        #<span class="hljs-number">12</span>:#<span class="hljs-number">13</span>        <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">24</span> = NameAndType        #<span class="hljs-number">10</span>:#<span class="hljs-number">11</span>        <span class="hljs-comment">// num:I</span><br>  #<span class="hljs-number">25</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">27</span> = Utf8               <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>....<br>  #<span class="hljs-number">28</span> = Class              #<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">29</span> = NameAndType        #<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>  #<span class="hljs-number">30</span> = Utf8               <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>....<br>  #<span class="hljs-number">31</span> = NameAndType        #<span class="hljs-number">19</span>:#<span class="hljs-number">13</span>        <span class="hljs-comment">// methodA:()V</span><br>  #<span class="hljs-number">32</span> = Utf8               com/atguigu/java1/DynamicLinkingTest<br>  #<span class="hljs-number">33</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">34</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">35</span> = Utf8               out<br>  #<span class="hljs-number">36</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">37</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">38</span> = Utf8               println<br>  #<span class="hljs-number">39</span> = Utf8               (Ljava/lang/String;)V<br>&#123;<br>  <span class="hljs-type">int</span> num;<br>    descriptor: I<br>    flags:<br><br>  <span class="hljs-keyword">public</span> com.atguigu.java1.DynamicLinkingTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: aload_0<br>         <span class="hljs-number">5</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">7</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">9</span>: <span class="hljs-number">4</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">11</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">4</span>                  <span class="hljs-comment">// String methodA()....</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>         <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">12</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">13</span>: <span class="hljs-number">8</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">9</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>;<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">3</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: ldc           #<span class="hljs-number">6</span>                  <span class="hljs-comment">// String methodB()....</span><br>         <span class="hljs-number">5</span>: invokevirtual #<span class="hljs-number">5</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>         <span class="hljs-number">8</span>: aload_0<br>         <span class="hljs-number">9</span>: invokevirtual #<span class="hljs-number">7</span>                  <span class="hljs-comment">// Method methodA:()V</span><br>        <span class="hljs-number">12</span>: aload_0<br>        <span class="hljs-number">13</span>: dup<br>        <span class="hljs-number">14</span>: getfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">17</span>: iconst_1<br>        <span class="hljs-number">18</span>: iadd<br>        <span class="hljs-number">19</span>: putfield      #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Field num:I</span><br>        <span class="hljs-number">22</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">16</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">8</span><br>        line <span class="hljs-number">20</span>: <span class="hljs-number">12</span><br>        line <span class="hljs-number">21</span>: <span class="hljs-number">22</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">23</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java1/DynamicLinkingTest;<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;DynamicLinkingTest.java&quot;</span><br></code></pre></td></tr></table></figure><p>1、在字节码指令中，methodB() 方法中通过 invokevirtual #7 指令调用了方法 A ，那么 #7 是个啥呢？</p><p>2、往上面翻，找到常量池的定义：<code>#7 = Methodref #8.#31</code></p><ul><li>先找 #8 ：<ul><li><code>#8 = Class #32</code> ：去找 #32</li><li><code>#32 = Utf8 com/atguigu/java1/DynamicLinkingTest</code></li><li>结论：通过 #8 我们找到了 <code>DynamicLinkingTest</code> 这个类</li></ul></li><li>再来找 #31：<ul><li><code>#31 = NameAndType #19:#13</code> ：去找 #19 和 #13</li><li><code>#19 = Utf8 methodA</code> ：方法名为 methodA</li><li><code>#13 = Utf8 ()V</code> ：方法没有形参，返回值为 void</li></ul></li></ul><p>3、结论：通过 #7 我们就能找到需要调用的 methodA() 方法，并进行调用</p><p>4、在上面，其实还有很多符号引用，比如 Object、System、PrintStream 等等</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814668.png"><p><strong>为什么要用常量池呢？</strong></p><ol><li><p>因为在不同的方法，都可能调用常量或者方法，所以只需要存储一份即可，然后记录其引用即可，节省了空间。</p></li><li><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p></li></ol><h2 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h2><h3 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h3><p>在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><ul><li><strong>静态链接</strong>：</li></ul><p>当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期确定，且运行期保持不变时，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接</p><ul><li><strong>动态链接</strong>：</li></ul><p>如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用的方法的符号转换为直接引用，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><h3 id="早期绑定与晚期绑定"><a href="#早期绑定与晚期绑定" class="headerlink" title="早期绑定与晚期绑定"></a>早期绑定与晚期绑定</h3><blockquote><p>静态链接与动态链接针对的是方法。早期绑定和晚期绑定范围更广。早期绑定涵盖了静态链接，晚期绑定涵盖了动态链接。</p></blockquote><p>静态链接和动态链接对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次。</p><ul><li><strong>早期绑定</strong></li></ul><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就<strong>可以使用静态链接的方式将符号引用转换为直接引用</strong>。</p><ul><li><strong>晚期绑定</strong></li></ul><p>如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;动物进食&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Huntable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">hunt</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Huntable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;狗吃骨头&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hunt</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;捕食耗子，多管闲事&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Huntable</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<span class="hljs-comment">//表现为：早期绑定</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Cat</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>();<span class="hljs-comment">//表现为：早期绑定</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.eat();<span class="hljs-comment">//表现为：早期绑定</span><br>        System.out.println(<span class="hljs-string">&quot;猫吃鱼&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hunt</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;捕食耗子，天经地义&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAnimal</span><span class="hljs-params">(Animal animal)</span> &#123;<br>        animal.eat();<span class="hljs-comment">//表现为：晚期绑定</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showHunt</span><span class="hljs-params">(Huntable h)</span> &#123;<br>        h.hunt();<span class="hljs-comment">//表现为：晚期绑定</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>部分字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<br>  <span class="hljs-keyword">public</span> com.atguigu.java2.AnimalTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">54</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java2/AnimalTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showAnimal</span><span class="hljs-params">(com.atguigu.java2.Animal)</span>;<br>    descriptor: (Lcom/atguigu/java2/Animal;)V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span><br>         <span class="hljs-number">0</span>: aload_1<br>         <span class="hljs-number">1</span>: invokevirtual #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Method com/atguigu/java2/Animal.eat:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">56</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">57</span>: <span class="hljs-number">4</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java2/AnimalTest;<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">1</span> animal   Lcom/atguigu/java2/Animal;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showHunt</span><span class="hljs-params">(com.atguigu.java2.Huntable)</span>;<br>    descriptor: (Lcom/atguigu/java2/Huntable;)V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">2</span>, args_size=<span class="hljs-number">2</span><br>         <span class="hljs-number">0</span>: aload_1<br>         <span class="hljs-number">1</span>: invokeinterface #<span class="hljs-number">3</span>,  <span class="hljs-number">1</span>            <span class="hljs-comment">// InterfaceMethod com/atguigu/java2/Huntable.hunt:()V</span><br>         <span class="hljs-number">6</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">60</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">61</span>: <span class="hljs-number">6</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">7</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java2/AnimalTest;<br>            <span class="hljs-number">0</span>       <span class="hljs-number">7</span>     <span class="hljs-number">1</span>     h   Lcom/atguigu/java2/Huntable;<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;AnimalTest.java&quot;</span><br></code></pre></td></tr></table></figure><p>invokevirtual 体现为晚期绑定</p><p>invokeinterface 也体现为晚期绑定</p><p>invokespecial 体现为早期绑定</p><h3 id="多态与绑定"><a href="#多态与绑定" class="headerlink" title="多态与绑定"></a>多态与绑定</h3><ol><li><p>随着高级语言的横空出世，类似于Java一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然这一类的编程语言具备多态特性，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</p></li><li><p>Java中任何一个普通的方法其实都具备虚函数的特征，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</p></li></ol><h4 id="虚方法与非虚方法"><a href="#虚方法与非虚方法" class="headerlink" title="虚方法与非虚方法"></a>虚方法与非虚方法</h4><p><strong>虚方法与非虚方法的区别</strong></p><ol><li>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</li><li>静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。</li><li>其他方法称为虚方法。</li></ol><p><strong>子类对象的多态的使用前提：</strong></p><ol><li>类的继承关系</li><li>方法的重写</li></ol><p><strong>虚拟机中调用方法的指令</strong></p><ul><li><strong>普通指令：</strong></li></ul><ol><li>invokestatic：调用静态方法，解析阶段确定唯一方法版本</li><li>invokespecial：调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ol><ul><li><strong>动态调用指令</strong></li></ul><p>invokedynamic：动态解析出需要调用的方法，然后执行</p><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预。而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的（final修饰的除外）称为虚方法。</p><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Father</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;father的构造器&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showStatic</span><span class="hljs-params">(String str)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;father &quot;</span> + str);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showFinal</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;father show final&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showCommon</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;father 普通方法&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Son</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//invokespecial</span><br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Son</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-comment">//invokespecial</span><br>        <span class="hljs-built_in">this</span>();<br>    &#125;<br><br>    <span class="hljs-comment">//不是重写的父类的静态方法，因为静态方法不能被重写！</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showStatic</span><span class="hljs-params">(String str)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;son &quot;</span> + str);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showPrivate</span><span class="hljs-params">(String str)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;son private&quot;</span> + str);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//invokestatic</span><br>        showStatic(<span class="hljs-string">&quot;atguigu.com&quot;</span>);<br>        <span class="hljs-comment">//invokestatic</span><br>        <span class="hljs-built_in">super</span>.showStatic(<span class="hljs-string">&quot;good!&quot;</span>);<br>        <span class="hljs-comment">//invokespecial</span><br>        showPrivate(<span class="hljs-string">&quot;hello!&quot;</span>);<br>        <span class="hljs-comment">//invokespecial</span><br>        <span class="hljs-built_in">super</span>.showCommon();<br><br>        <span class="hljs-comment">//invokevirtual</span><br>        showFinal();<span class="hljs-comment">//因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法。</span><br>        <span class="hljs-comment">//虚方法如下：</span><br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        invokevirtual  你没有显示的加super.，编译器认为你可能调用子类的showCommon(即使son子类没有重写，也  会认为)，所以编译期间确定不下来，就是虚方法。</span><br><span class="hljs-comment">        */</span><br>        showCommon();<br>        info();<br><br>        <span class="hljs-type">MethodInterface</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//invokeinterface</span><br>        in.methodA();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(Father f)</span> &#123;<br>        f.showCommon();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Son</span> <span class="hljs-variable">so</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>        so.show();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MethodInterface</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Son 类中 show() 方法的字节码指令如下</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814669.png"><h4 id="关于-invokedynamic-指令"><a href="#关于-invokedynamic-指令" class="headerlink" title="关于 invokedynamic 指令"></a>关于 invokedynamic 指令</h4><ol><li><p>JVM字节码指令集一直比较稳定，一直到Java7中才增加了一个invokedynamic指令，这是Java为了实现【动态类型语言】支持而做的一种改进。</p></li><li><p>但是在Java7中并没有提供直接生成invokedynamic指令的方法，需要借助ASM这种底层字节码工具来产生invokedynamic指令。直到Java8的Lambda表达式的出现，invokedynamic指令的生成，在Java中才有了直接的生成方式。</p></li><li><p>Java7中增加的动态语言类型支持的本质是对Java虚拟机规范的修改，而不是对Java语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在Java平台的动态语言的编译器。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Func</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">func</span><span class="hljs-params">(String str)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lambda</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lambda</span><span class="hljs-params">(Func func)</span> &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Lambda</span> <span class="hljs-variable">lambda</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lambda</span>();<br><br>        <span class="hljs-type">Func</span> <span class="hljs-variable">func</span> <span class="hljs-operator">=</span> s -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br><br>        lambda.lambda(func);<br><br>        lambda.lambda(s -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814670.png"><h3 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h3><ol><li><p>动态类型语言和静态类型语言两者的区别就在于<strong>对类型的检查是在编译期还是在运行期</strong>，满足前者就是静态类型语言，反之是动态类型语言。</p></li><li><p>说的再直白一点就是，静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。</p></li></ol><p>Java：String info &#x3D; “mogu blog”;     (Java是静态类型语言的，会先编译就进行类型检查)<br>    JS：var name &#x3D; “shkstart”;    var name &#x3D; 10;（运行时才进行检查）</p><pre><code class="hljs">Python: info = 130.5 (运行时才检查)</code></pre><h3 id="Java语言中方法重写的本质"><a href="#Java语言中方法重写的本质" class="headerlink" title="Java语言中方法重写的本质"></a>Java语言中方法重写的本质</h3><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验。<ul><li>如果通过则返回这个方法的直接引用，查找过程结束</li><li>如果不通过，则返回java.lang.IllegalAccessError 异常</li></ul></li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li></ol><blockquote><p>上面这个过程称为<strong>动态分派</strong></p></blockquote><p><strong>IllegalAccessError介绍</strong></p><ol><li>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</li><li>比如，你把应该有的jar包放从工程中拿走了，或者Maven中存在jar包冲突</li></ol><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><ol><li><p>在面向对象的编程中，会很频繁的使用到<strong>动态分派</strong>，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，<strong>JVM采用在类的方法区建立一个虚方法表（virtual method table）来实现</strong>，非虚方法不会出现在表中。使用索引表来代替查找。【上面动态分派的过程，我们可以看到如果子类找不到，还要从下往上找其父类，非常耗时】</p></li><li><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p></li><li><p>虚方法表是什么时候被创建的呢？虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的虚方法表也初始化完毕。</p></li></ol><p><strong>例子1</strong></p><p>如图所示：如果类中重写了方法，那么调用的时候，就会直接在该类的虚方法表中查找</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814671.png"><p>1、比如说son在调用toString的时候，Son没有重写过，Son的父类Father也没有重写过，那就直接调用Object类的toString。那么就直接在虚方法表里指明toString直接指向Object类。</p><p>2、下次Son对象再调用toString就直接去找Object，不用先找Son–&gt;再找Father–&gt;最后才到Object的这样的一个过程。</p><p><strong>例子2</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814672.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814673.jpg"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814674.jpg"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814675.jpg"><h2 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h2><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814676.png"><blockquote><p>在一些帖子里，方法返回地址、动态链接、一些附加信息  也叫做帧数据区</p></blockquote><ol><li><p>存放调用该方法的pc寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul></li><li><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<strong>调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</strong>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p></li><li><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p></li><li><p>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</p></li></ol><p><strong>方法退出的两种方式</strong></p><p>当一个方法开始执行后，只有两种方式可以退出这个方法，</p><p><strong>正常退出：</strong></p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong>；</li><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含：<ul><li><p>ireturn：当返回值是boolean，byte，char，short和int类型时使用</p></li><li><p>lreturn：Long类型</p></li><li><p>freturn：Float类型</p></li><li><p>dreturn：Double类型</p></li><li><p>areturn：引用类型</p></li><li><p>return：返回值类型为void的方法、实例初始化方法、类和接口的初始化方法</p></li></ul></li></ol><p><strong>异常退出：</strong></p><ol><li><p>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<strong>异常完成出口</strong>。</p></li><li><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814677.png"><p>异常处理表：</p><ul><li>反编译字节码文件，可得到 Exception table</li><li>from ：字节码指令起始地址</li><li>to ：字节码指令结束地址</li><li>target ：出现异常跳转至地址为 11 的指令执行</li><li>type ：捕获异常的类型</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814678.png"><h2 id="一些附加信息"><a href="#一些附加信息" class="headerlink" title="一些附加信息"></a>一些附加信息</h2><p>栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="栈相关面试题"><a href="#栈相关面试题" class="headerlink" title="栈相关面试题"></a>栈相关面试题</h2><h3 id="举例栈溢出的情况？"><a href="#举例栈溢出的情况？" class="headerlink" title="举例栈溢出的情况？"></a>举例栈溢出的情况？</h3><p>SOF（StackOverflowError），栈大小分为固定的，和动态变化。如果是固定的就可能出现StackOverflowError。如果是动态变化的，内存不足时就可能出现OOM</p><h3 id="调整栈大小，就能保证不出现溢出么？"><a href="#调整栈大小，就能保证不出现溢出么？" class="headerlink" title="调整栈大小，就能保证不出现溢出么？"></a>调整栈大小，就能保证不出现溢出么？</h3><p>不能保证不溢出，只能保证SOF出现的几率小</p><h3 id="分配的栈内存越大越好么？"><a href="#分配的栈内存越大越好么？" class="headerlink" title="分配的栈内存越大越好么？"></a>分配的栈内存越大越好么？</h3><p>不是，一定时间内降低了OOM概率，但是会挤占其它的线程空间，因为整个虚拟机的内存空间是有限的</p><h3 id="垃圾回收是否涉及到虚拟机栈？"><a href="#垃圾回收是否涉及到虚拟机栈？" class="headerlink" title="垃圾回收是否涉及到虚拟机栈？"></a>垃圾回收是否涉及到虚拟机栈？</h3><p>不会</p><table><thead><tr><th>位置</th><th>是否有Error</th><th>是否存在GC</th></tr></thead><tbody><tr><td>PC计数器</td><td>无</td><td>不存在</td></tr><tr><td>虚拟机栈</td><td>有，SOF</td><td>不存在</td></tr><tr><td>本地方法栈(在HotSpot的实现中和虚拟机栈一样)</td><td></td><td></td></tr><tr><td>堆</td><td>有，OOM</td><td>存在</td></tr><tr><td>方法区</td><td>有</td><td>存在</td></tr></tbody></table><h3 id="方法中定义的局部变量是否线程安全？"><a href="#方法中定义的局部变量是否线程安全？" class="headerlink" title="方法中定义的局部变量是否线程安全？"></a>方法中定义的局部变量是否线程安全？</h3><p>具体问题具体分析</p><ol><li>如果只有一个线程才可以操作此数据，则必是线程安全的。</li><li>如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</li></ol><p><strong>具体问题具体分析：</strong></p><ul><li>如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 面试题：</span><br><span class="hljs-comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   何为线程安全？</span><br><span class="hljs-comment"> *      如果只有一个线程才可以操作此数据，则必是线程安全的。</span><br><span class="hljs-comment"> *      如果有多个线程操作此数据，则此数据是共享数据。如果不考虑同步机制的话，会存在线程安全问题。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderTest</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//s1的声明方式是线程安全的（只在方法内部用了）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//StringBuilder:线程不安全</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        s1.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        s1.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-comment">//sBuilder的操作过程：是线程不安全的（作为参数传进来，可能被其它线程操作）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">(StringBuilder sBuilder)</span>&#123;<br>        sBuilder.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        sBuilder.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>    <span class="hljs-comment">//s1的操作：是线程不安全的（有返回值，可能被其它线程操作）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title function_">method3</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        s1.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        s1.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-keyword">return</span> s1;<br>    &#125;<br>    <span class="hljs-comment">//s1的操作：是线程安全的（s1自己消亡了，最后返回的只是s1.toString的一个新对象）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">method4</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        s1.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        s1.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        <span class="hljs-keyword">return</span> s1.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            s.append(<span class="hljs-string">&quot;a&quot;</span>);<br>            s.append(<span class="hljs-string">&quot;b&quot;</span>);<br>        &#125;).start();<br><br>        method2(s);<br><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第3章-运行时数据区</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC3%E7%AB%A0-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>此章把运行时数据区里比较少的地方讲一下。虚拟机栈，堆，方法区这些地方后续再讲。</p></blockquote><h1 id="运行时数据区概述及线程"><a href="#运行时数据区概述及线程" class="headerlink" title="运行时数据区概述及线程"></a>运行时数据区概述及线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814443.png"><p>当我们通过前面的：类的加载 –&gt; 验证 –&gt; 准备 –&gt; 解析 –&gt; 初始化，这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814444.png"><p>类比一下也就是大厨做饭，我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814445.png"><h2 id="运行时数据区结构"><a href="#运行时数据区结构" class="headerlink" title="运行时数据区结构"></a>运行时数据区结构</h2><h3 id="运行时数据区与内存"><a href="#运行时数据区与内存" class="headerlink" title="运行时数据区与内存"></a>运行时数据区与内存</h3><ol><li><p>内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了JVM的高效稳定运行。<strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异</strong>。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。</p></li><li><p>我们通过磁盘或者网络IO得到的数据，都需要先加载到内存中，然后CPU从内存中获取数据进行读取，也就是说内存充当了CPU和磁盘之间的桥梁</p></li></ol><blockquote><p>下图来自阿里巴巴手册JDK8</p></blockquote><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814446.jpg"><h3 id="线程的内存空间"><a href="#线程的内存空间" class="headerlink" title="线程的内存空间"></a>线程的内存空间</h3><ol><li><p>Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区：其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p></li><li><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>线程独有：独立包括程序计数器、栈、本地方法栈</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814447.png"><h3 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h3><p><strong>每个JVM只有一个Runtime实例</strong>。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814448.png"><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="JVM-线程"><a href="#JVM-线程" class="headerlink" title="JVM 线程"></a>JVM 线程</h3><ol><li>线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行</li><li><strong>在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射</strong><ul><li>当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行终止后，本地线程也会回收</li></ul></li><li>操作系统负责将线程安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，它就会调用Java线程中的run()方法</li></ol><blockquote><p>关于线程，并发可以看笔者的Java并发系列</p></blockquote><h3 id="JVM-系统线程"><a href="#JVM-系统线程" class="headerlink" title="JVM 系统线程"></a>JVM 系统线程</h3><ul><li><p>如果你使用jconsole或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[])</code>的main线程以及所有这个main线程自己创建的线程。</p></li><li><p>这些主要的后台系统线程在Hotspot JVM里主要是以下几个：</p></li></ul><ol><li><strong>虚拟机线程</strong>：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变化。这种线程的执行类型括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销</li><li><strong>周期任务线程</strong>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行</li><li><strong>GC线程</strong>：这种线程对在JVM里不同种类的垃圾收集行为提供了支持</li><li><strong>编译线程</strong>：这种线程在运行时会将字节码编译成到本地代码</li><li><strong>信号调度线程</strong>：这种线程接收信号并发送给JVM，在它内部通过调用适当的方法进行处理</li></ol><h1 id="程序计数器-PC寄存器"><a href="#程序计数器-PC寄存器" class="headerlink" title="程序计数器(PC寄存器)"></a>程序计数器(PC寄存器)</h1><h2 id="PC寄存器介绍"><a href="#PC寄存器介绍" class="headerlink" title="PC寄存器介绍"></a>PC寄存器介绍</h2><blockquote><p>官方文档网址：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p></blockquote><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814449.png"><ol><li>JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，<strong>寄存器存储指令相关的现场信息</strong>。CPU只有把数据装载到寄存器才能够运行。</li><li>这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<strong>JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟</strong>。</li><li>它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。</li><li>在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong>。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。</li><li>它是<strong>程序控制流</strong>的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</li><li>它是<strong>唯一一个</strong>在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。</li></ol><h2 id="PC寄存器的作用"><a href="#PC寄存器的作用" class="headerlink" title="PC寄存器的作用"></a>PC寄存器的作用</h2><p>PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令，并执行该指令。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814450.png"><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PCRegisterTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>        System.out.println(i);<br>        System.out.println(k);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看字节码</p><blockquote><p>看字节码的方法：<a href="https://blog.csdn.net/21aspnet/article/details/88351875">https://blog.csdn.net/21aspnet/article/details/88351875</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java">Classfile /F:/IDEAWorkSpaceSourceCode/JVMDemo/out/production/chapter04/com/atguigu/java/PCRegisterTest.<span class="hljs-keyword">class</span><br>  <span class="hljs-title class_">Last</span> modified <span class="hljs-number">2020</span>-<span class="hljs-number">11</span>-<span class="hljs-number">2</span>; size <span class="hljs-number">675</span> bytes<br>  MD5 checksum 53b3ef104479ec9e9b7ce5319e5881d3<br>  Compiled from <span class="hljs-string">&quot;PCRegisterTest.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.atguigu.java.PCRegisterTest<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">52</span><br>  flags: ACC_PUBLIC, ACC_SUPER<br>Constant pool:<br>   #<span class="hljs-number">1</span> = Methodref          #<span class="hljs-number">6.</span>#<span class="hljs-number">26</span>         <span class="hljs-comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>   #<span class="hljs-number">2</span> = String             #<span class="hljs-number">27</span>            <span class="hljs-comment">// abc</span><br>   #<span class="hljs-number">3</span> = Fieldref           #<span class="hljs-number">28.</span>#<span class="hljs-number">29</span>        <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #<span class="hljs-number">4</span> = Methodref          #<span class="hljs-number">30.</span>#<span class="hljs-number">31</span>        <span class="hljs-comment">// java/io/PrintStream.println:(I)V</span><br>   #<span class="hljs-number">5</span> = Class              #<span class="hljs-number">32</span>            <span class="hljs-comment">// com/atguigu/java/PCRegisterTest</span><br>   #<span class="hljs-number">6</span> = Class              #<span class="hljs-number">33</span>            <span class="hljs-comment">// java/lang/Object</span><br>   #<span class="hljs-number">7</span> = Utf8               &lt;init&gt;<br>   #<span class="hljs-number">8</span> = Utf8               ()V<br>   #<span class="hljs-number">9</span> = Utf8               Code<br>  #<span class="hljs-number">10</span> = Utf8               LineNumberTable<br>  #<span class="hljs-number">11</span> = Utf8               LocalVariableTable<br>  #<span class="hljs-number">12</span> = Utf8               <span class="hljs-built_in">this</span><br>  #<span class="hljs-number">13</span> = Utf8               Lcom/atguigu/java/PCRegisterTest;<br>  #<span class="hljs-number">14</span> = Utf8               main<br>  #<span class="hljs-number">15</span> = Utf8               ([Ljava/lang/String;)V<br>  #<span class="hljs-number">16</span> = Utf8               args<br>  #<span class="hljs-number">17</span> = Utf8               [Ljava/lang/String;<br>  #<span class="hljs-number">18</span> = Utf8               i<br>  #<span class="hljs-number">19</span> = Utf8               I<br>  #<span class="hljs-number">20</span> = Utf8               j<br>  #<span class="hljs-number">21</span> = Utf8               k<br>  #<span class="hljs-number">22</span> = Utf8               s<br>  #<span class="hljs-number">23</span> = Utf8               Ljava/lang/String;<br>  #<span class="hljs-number">24</span> = Utf8               SourceFile<br>  #<span class="hljs-number">25</span> = Utf8               PCRegisterTest.java<br>  #<span class="hljs-number">26</span> = NameAndType        #<span class="hljs-number">7</span>:#<span class="hljs-number">8</span>          <span class="hljs-comment">// &quot;&lt;init&gt;&quot;:()V</span><br>  #<span class="hljs-number">27</span> = Utf8               abc<br>  #<span class="hljs-number">28</span> = Class              #<span class="hljs-number">34</span>            <span class="hljs-comment">// java/lang/System</span><br>  #<span class="hljs-number">29</span> = NameAndType        #<span class="hljs-number">35</span>:#<span class="hljs-number">36</span>        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #<span class="hljs-number">30</span> = Class              #<span class="hljs-number">37</span>            <span class="hljs-comment">// java/io/PrintStream</span><br>  #<span class="hljs-number">31</span> = NameAndType        #<span class="hljs-number">38</span>:#<span class="hljs-number">39</span>        <span class="hljs-comment">// println:(I)V</span><br>  #<span class="hljs-number">32</span> = Utf8               com/atguigu/java/PCRegisterTest<br>  #<span class="hljs-number">33</span> = Utf8               java/lang/Object<br>  #<span class="hljs-number">34</span> = Utf8               java/lang/System<br>  #<span class="hljs-number">35</span> = Utf8               out<br>  #<span class="hljs-number">36</span> = Utf8               Ljava/io/PrintStream;<br>  #<span class="hljs-number">37</span> = Utf8               java/io/PrintStream<br>  #<span class="hljs-number">38</span> = Utf8               println<br>  #<span class="hljs-number">39</span> = Utf8               (I)V<br>&#123;<br>  <span class="hljs-keyword">public</span> com.atguigu.java.PCRegisterTest();<br>    descriptor: ()V<br>    flags: ACC_PUBLIC<br>    Code:<br>      stack=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  <span class="hljs-built_in">this</span>   Lcom/atguigu/java/PCRegisterTest;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span>;<br>    descriptor: ([Ljava/lang/String;)V<br>    flags: ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>         <span class="hljs-number">2</span>: istore_1<br>         <span class="hljs-number">3</span>: bipush        <span class="hljs-number">20</span><br>         <span class="hljs-number">5</span>: istore_2<br>         <span class="hljs-number">6</span>: iload_1<br>         <span class="hljs-number">7</span>: iload_2<br>         <span class="hljs-number">8</span>: iadd<br>         <span class="hljs-number">9</span>: istore_3<br>        <span class="hljs-number">10</span>: ldc           #<span class="hljs-number">2</span>                  <span class="hljs-comment">// String abc</span><br>        <span class="hljs-number">12</span>: astore        <span class="hljs-number">4</span><br>        <span class="hljs-number">14</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-number">17</span>: iload_1<br>        <span class="hljs-number">18</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>        <span class="hljs-number">21</span>: getstatic     #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>        <span class="hljs-number">24</span>: iload_3<br>        <span class="hljs-number">25</span>: invokevirtual #<span class="hljs-number">4</span>                  <span class="hljs-comment">// Method java/io/PrintStream.println:(I)V</span><br>        <span class="hljs-number">28</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">10</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">11</span>: <span class="hljs-number">3</span><br>        line <span class="hljs-number">12</span>: <span class="hljs-number">6</span><br>        line <span class="hljs-number">14</span>: <span class="hljs-number">10</span><br>        line <span class="hljs-number">15</span>: <span class="hljs-number">14</span><br>        line <span class="hljs-number">16</span>: <span class="hljs-number">21</span><br>        line <span class="hljs-number">18</span>: <span class="hljs-number">28</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">29</span>     <span class="hljs-number">0</span>  args   [Ljava/lang/String;<br>            <span class="hljs-number">3</span>      <span class="hljs-number">26</span>     <span class="hljs-number">1</span>     i   I<br>            <span class="hljs-number">6</span>      <span class="hljs-number">23</span>     <span class="hljs-number">2</span>     j   I<br>           <span class="hljs-number">10</span>      <span class="hljs-number">19</span>     <span class="hljs-number">3</span>     k   I<br>           <span class="hljs-number">14</span>      <span class="hljs-number">15</span>     <span class="hljs-number">4</span>     s   Ljava/lang/String;<br>&#125;<br>SourceFile: <span class="hljs-string">&quot;PCRegisterTest.java&quot;</span><br></code></pre></td></tr></table></figure><ul><li>左边的数字代表<strong>指令地址（指令偏移）</strong>，即 PC 寄存器中可能存储的值，然后执行引擎读取 PC 寄存器中的值，并执行该指令</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814451.png"><h2 id="两个面试题"><a href="#两个面试题" class="headerlink" title="两个面试题"></a>两个面试题</h2><p><strong>使用PC寄存器存储字节码指令地址有什么用呢？<strong>或者问</strong>为什么使用 PC 寄存器来记录当前线程的执行地址呢？</strong></p><ol><li><p>因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行</p></li><li><p>JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814452.png"><p><strong>PC寄存器为什么被设定为私有的？</strong></p><ol><li>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<strong>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器</strong>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</li><li>由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</li><li>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</li></ol><blockquote><p>注意并行和并发的区别，笔者的并发系列有讲</p></blockquote><h2 id="CPU-时间片"><a href="#CPU-时间片" class="headerlink" title="CPU 时间片"></a>CPU 时间片</h2><ol><li><p>CPU时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p></li><li><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p></li><li><p>但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，<strong>每个程序轮流执行</strong>。</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814453.png"><h1 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h1><h2 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h2><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814454.png"><ol><li>简单地讲，<strong>一个Native Method是一个Java调用非Java代码的接囗</strong>一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern 告知C++编译器去调用一个C的函数。</li><li>“A native method is a Java method whose implementation is provided by non-java code.”（本地方法是一个非Java的方法，它的具体实现是非Java代码的实现）</li><li>在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。</li><li>本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C&#x2F;C++程序。</li></ol><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p>需要注意的是：标识符native可以与其它java标识符连用，但是abstract除外</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IHaveNatives</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Native1</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">Native2</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">float</span> <span class="hljs-title function_">Native3</span><span class="hljs-params">(Object o)</span>;<br><br>    <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Native4</span><span class="hljs-params">(<span class="hljs-type">int</span>[] ary)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="为什么要使用-Native-Method？"><a href="#为什么要使用-Native-Method？" class="headerlink" title="为什么要使用 Native Method？"></a>为什么要使用 Native Method？</h2><p>Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。</p><h3 id="与Java环境外交互"><a href="#与Java环境外交互" class="headerlink" title="与Java环境外交互"></a>与Java环境外交互</h3><p><strong>有时Java应用需要与Java外面的硬件环境交互，这是本地方法存在的主要原因</strong>。你可以想想Java需要与一些<strong>底层系统</strong>，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。</p><h3 id="与操作系统的交互"><a href="#与操作系统的交互" class="headerlink" title="与操作系统的交互"></a>与操作系统的交互</h3><ol><li>JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。</li><li>然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。</li><li><strong>通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的</strong>。</li><li>还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。</li></ol><h3 id="Sun’s-Java"><a href="#Sun’s-Java" class="headerlink" title="Sun’s Java"></a>Sun’s Java</h3><ol><li>Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。</li><li>例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部在Windows 95的平台上，这个本地方法最终将调用Win32 setpriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。</li></ol><h3 id="本地方法的现状"><a href="#本地方法的现状" class="headerlink" title="本地方法的现状"></a>本地方法的现状</h3><p>目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等，不多做介绍。</p><h1 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h1><ol><li><strong>Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用</strong>。</li><li>本地方法栈，也是线程私有的。</li><li>允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）<ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。</li></ul></li><li>本地方法一般是使用C语言或C++语言实现的。</li><li>它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271814455.png"><p><strong>注意事项</strong></p><ol><li>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。<ul><li>本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li>并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。</li><li>在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第2章-类加载子系统</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC2%E7%AB%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="第2章-类加载子系统"><a href="#第2章-类加载子系统" class="headerlink" title="第2章-类加载子系统"></a>第2章-类加载子系统</h1><h2 id="内存结构概述"><a href="#内存结构概述" class="headerlink" title="内存结构概述"></a>内存结构概述</h2><h3 id="简图"><a href="#简图" class="headerlink" title="简图"></a>简图</h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813854.png"><h3 id="详细图"><a href="#详细图" class="headerlink" title="详细图"></a>详细图</h3><p>英文版</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813855.jpg"><p>中文版</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813856.jpg"><p>注意：方法区只有HotSpot虚拟机有，J9，JRockit都没有</p><p>如果自己想手写一个Java虚拟机的话，主要考虑哪些结构呢？</p><ol><li>类加载器</li><li>执行引擎</li></ol><h2 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h2><p><strong>类加载器子系统作用：</strong></p><ol><li><p>类加载器子系统负责从文件系统或者网络中加载Class文件，class文件在文件开头有特定的文件标识。</p></li><li><p>ClassLoader只负责class文件的加载，至于它是否可以运行，则由Execution Engine决定。</p></li><li><p><strong>加载的类信息存放于一块称为方法区的内存空间</strong>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是Class文件中常量池部分的内存映射）</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813857.png"><h2 id="类加载器ClassLoader角色"><a href="#类加载器ClassLoader角色" class="headerlink" title="类加载器ClassLoader角色"></a>类加载器ClassLoader角色</h2><ol><li>class file（在下图中就是Car.class文件）存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到JVM当中来根据这个文件实例化出n个一模一样的实例。</li><li>class file加载到JVM中，被称为DNA元数据模板（在下图中就是内存中的Car Class），放在方法区。</li><li>在.class文件–&gt;JVM–&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器Class Loader），扮演一个快递员的角色。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813858.png"><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloLoader</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;谢谢ClassLoader加载我....&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;你的大恩大德，我下辈子再报！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的加载过程是怎么样的呢?</p><ul><li>执行 main() 方法（静态方法）就需要先加载main方法所在类 HelloLoader</li><li>加载成功，则进行链接、初始化等操作。完成后调用 HelloLoader 类中的静态方法 main</li><li>加载失败则抛出异常</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813859.png"><p>完整的流程图如下所示：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813860.png"><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><strong>加载：</strong></p><ol><li><p>通过一个类的全限定名获取定义此类的二进制字节流</p></li><li><p>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p></li><li><p><strong>在内存中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口</p></li></ol><p><strong>加载class文件的方式：</strong></p><ol><li>从本地系统中直接加载</li><li>通过网络获取，典型场景：Web Applet</li><li>从zip压缩包中读取，成为日后jar、war格式的基础</li><li>运行时计算生成，使用最多的是：动态代理技术</li><li>由其他文件生成，典型场景：JSP应用从专有数据库中提取.class文件，比较少见</li><li>从加密文件中获取，典型的防Class文件被反编译的保护措施</li></ol><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><p>链接分为三个子阶段：验证 -&gt; 准备 -&gt; 解析</p><h4 id="验证-Verify"><a href="#验证-Verify" class="headerlink" title="验证(Verify)"></a>验证(Verify)</h4><ol><li>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。</li></ol><p><strong>举例</strong></p><p>使用 BinaryViewer软件查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813861.png"><h4 id="准备-Prepare"><a href="#准备-Prepare" class="headerlink" title="准备(Prepare)"></a>准备(Prepare)</h4><ol><li>为类变量（static变量）分配内存并且设置该类变量的默认初始值，即零值</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配好了默认值，准备阶段会显式初始化</li><li>注意：这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中</li></ol><p><strong>举例</strong></p><p>代码：变量a在准备阶段会赋初始值，但不是1，而是0，在初始化阶段会被赋值为 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloApp</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//prepare：a = 0 ---&gt; initial : a = 1</span><br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解析-Resolve"><a href="#解析-Resolve" class="headerlink" title="解析(Resolve)"></a>解析(Resolve)</h4><ol><li><p><strong>将常量池内的符号引用转换为直接引用的过程</strong></p></li><li><p>事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行</p></li><li><p>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</p></li><li><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT Class info、CONSTANT Fieldref info、CONSTANT Methodref info等</p></li></ol><p><strong>符号引用</strong></p><ul><li>反编译 class 文件后可以查看符号引用，下面带# 的就是符号引用</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813862.png"/><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><h4 id="类的初始化时机"><a href="#类的初始化时机" class="headerlink" title="类的初始化时机"></a>类的初始化时机</h4><ol><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射（比如：Class.forName(“com.atguigu.Test”)）</li><li>初始化一个类的子类</li><li>Java虚拟机启动时被标明为启动类的类</li><li>JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化</li></ol><p>除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化，即不会执行初始化阶段（不会调用 clinit() 方法和 init() 方法）</p><h3 id="clinit"><a href="#clinit" class="headerlink" title="clinit()"></a>clinit()</h3><ol><li><p>初始化阶段就是执行类构造器方法<code>&lt;clinit&gt;()</code>的过程</p></li><li><p>此方法不需定义，是javac编译器自动收集类中的所有<strong>类变量</strong>的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含static变量的时候，就会有clinit方法</p></li><li><p><code>&lt;clinit&gt;()</code>方法中的指令按语句在源文件中出现的顺序执行</p></li><li><p><code>&lt;clinit&gt;()</code>不同于类的构造器。（关联：构造器是虚拟机视角下的<code>&lt;init&gt;()</code>）</p></li><li><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p></li><li><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p></li></ol><blockquote><p>IDEA 中安装 JClassLib Bytecode viewer 插件，可以很方便的看字节码。安装过程可以自行百度</p></blockquote><h4 id="1，2，3说明"><a href="#1，2，3说明" class="headerlink" title="1，2，3说明"></a>1，2，3说明</h4><p><strong>举例1：有static变量</strong></p><p>查看下面这个代码的字节码，可以发现有一个<code>&lt;clinit&gt;()</code>方法。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813863.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassInitTest</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>   <span class="hljs-keyword">static</span>&#123;<br>       num = <span class="hljs-number">2</span>;<br>       number = <span class="hljs-number">20</span>;<br>       System.out.println(num);<br>       <span class="hljs-comment">//System.out.println(number);//报错：非法的前向引用。</span><br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 1、linking之prepare: number = 0 --&gt; initial: 20 --&gt; 10</span><br><span class="hljs-comment">    * 2、这里因为静态代码块出现在声明变量语句前面，所以之前被准备阶段为0的number变量会</span><br><span class="hljs-comment">    * 首先被初始化为20，再接着被初始化成10（这也是面试时常考的问题哦）</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(ClassInitTest.num);<span class="hljs-comment">//2</span><br>        System.out.println(ClassInitTest.number);<span class="hljs-comment">//10</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>&lt;clint字节码&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> iconst_1<br> <span class="hljs-number">1</span> putstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;<br> <span class="hljs-number">4</span> iconst_2<br> <span class="hljs-number">5</span> putstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;<br> <span class="hljs-number">8</span> bipush <span class="hljs-number">20</span> <span class="hljs-comment">//先赋20</span><br><span class="hljs-number">10</span> putstatic #<span class="hljs-number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;<br><span class="hljs-number">13</span> getstatic #<span class="hljs-number">2</span> &lt;java/lang/System.out&gt;<br><span class="hljs-number">16</span> getstatic #<span class="hljs-number">3</span> &lt;com/atguigu/java/ClassInitTest.num&gt;<br><span class="hljs-number">19</span> invokevirtual #<span class="hljs-number">4</span> &lt;java/io/PrintStream.println&gt;<br><span class="hljs-number">22</span> bipush <span class="hljs-number">10</span><span class="hljs-comment">//再赋10</span><br><span class="hljs-number">24</span> putstatic #<span class="hljs-number">5</span> &lt;com/atguigu/java/ClassInitTest.number&gt;<br><span class="hljs-number">27</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>当我们代码中包含static变量的时候，就会有clinit方法</p><p><strong>举例2：无 static 变量</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813864.png"><p>加上之后就有了</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813865.png"><h4 id="4说明"><a href="#4说明" class="headerlink" title="4说明"></a>4说明</h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813866.png"><p>在构造器中：</p><ul><li>先将类变量 a 赋值为 10</li><li>再将局部变量赋值为 20</li></ul><h4 id="5说明"><a href="#5说明" class="headerlink" title="5说明"></a>5说明</h4><p>若该类具有父类，JVM会保证子类的<code>&lt;clinit&gt;()</code>执行前，父类的<code>&lt;clinit&gt;()</code>已经执行完毕</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813867.png"><p>如上代码，加载流程如下：</p><ul><li>首先，执行 main() 方法需要加载 ClinitTest1 类</li><li>获取 Son.B 静态变量，需要加载 Son 类</li><li>Son 类的父类是 Father 类，所以需要先执行 Father 类的加载，再执行 Son 类的加载</li></ul><h4 id="6说明"><a href="#6说明" class="headerlink" title="6说明"></a>6说明</h4><p>虚拟机必须保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程下被同步加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThreadTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始&quot;</span>);<br>            <span class="hljs-type">DeadThread</span> <span class="hljs-variable">dead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DeadThread</span>();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;结束&quot;</span>);<br>        &#125;;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r,<span class="hljs-string">&quot;线程2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadThread</span>&#123;<br>    <span class="hljs-keyword">static</span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;初始化当前类&quot;</span>);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">线程2开始<br>线程1开始<br>线程2初始化当前类<br><br>/然后程序卡死了<br></code></pre></td></tr></table></figure><p>程序卡死，分析原因：</p><ul><li>两个线程同时去加载 DeadThread 类，而 DeadThread 类中静态代码块中有一处死循环</li><li>先加载 DeadThread 类的线程抢到了同步锁，然后在类的静态代码块中执行死循环，而另一个线程在等待同步锁的释放</li><li>所以无论哪个线程先执行 DeadThread 类的加载，另外一个类也不会继续执行。（一个类只会被加载一次）</li></ul><h2 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ol><li><p>JVM严格来讲支持两种类型的类加载器 。分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）</p></li><li><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是<strong>将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器</strong></p></li><li><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示</p></li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813868.png"><p><strong>ExtClassLoader</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813869.png"><p><strong>AppClassLoader</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813870.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//获取系统类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">systemClassLoader</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader();<br>        System.out.println(systemClassLoader);<span class="hljs-comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>        <span class="hljs-comment">//获取其上层：扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">extClassLoader</span> <span class="hljs-operator">=</span> systemClassLoader.getParent();<br>        System.out.println(extClassLoader);<span class="hljs-comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><br>        <span class="hljs-comment">//获取其上层：获取不到引导类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bootstrapClassLoader</span> <span class="hljs-operator">=</span> extClassLoader.getParent();<br>        System.out.println(bootstrapClassLoader);<span class="hljs-comment">//null</span><br><br>        <span class="hljs-comment">//对于用户自定义类来说：默认使用系统类加载器进行加载</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ClassLoaderTest.class.getClassLoader();<br>        System.out.println(classLoader);<span class="hljs-comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span><br><br>        <span class="hljs-comment">//String类使用引导类加载器进行加载的。---&gt; Java的核心类库都是使用引导类加载器进行加载的。</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> String.class.getClassLoader();<br>        System.out.println(classLoader1);<span class="hljs-comment">//null</span><br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>我们尝试获取引导类加载器，获取到的值为 null ，这并不代表引导类加载器不存在，<strong>因为引导类加载器右 C&#x2F;C++ 语言，我们获取不到</strong></li><li>两次获取系统类加载器的值都相同：sun.misc.Launcher$AppClassLoader@18b4aac2 ，这说明<strong>系统类加载器是全局唯一的</strong></li></ul><h3 id="虚拟机自带的加载器"><a href="#虚拟机自带的加载器" class="headerlink" title="虚拟机自带的加载器"></a>虚拟机自带的加载器</h3><h4 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h4><blockquote><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p></blockquote><ol><li>这个类加载使用C&#x2F;C++语言实现的，嵌套在JVM内部</li><li>它用来加载Java的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类</li><li>并不继承自java.lang.ClassLoader，没有父加载器</li><li>加载扩展类和应用程序类加载器，并作为他们的父类加载器</li><li>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</li></ol><h4 id="扩展类加载器"><a href="#扩展类加载器" class="headerlink" title="扩展类加载器"></a>扩展类加载器</h4><blockquote><p><strong>扩展类加载器（Extension ClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为启动类加载器</li><li>从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre&#x2F;lib&#x2F;ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载</li></ol><h4 id="系统类加载器"><a href="#系统类加载器" class="headerlink" title="系统类加载器"></a>系统类加载器</h4><blockquote><p><strong>应用程序类加载器（也称为系统类加载器，AppClassLoader）</strong></p></blockquote><ol><li>Java语言编写，由sun.misc.LaunchersAppClassLoader实现</li><li>派生于ClassLoader类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库</li><li>该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载</li><li>通过classLoader.getSystemclassLoader()方法可以获取到该类加载器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;**********启动类加载器**************&quot;</span>);<br>        <span class="hljs-comment">//获取BootstrapClassLoader能够加载的api的路径</span><br>        URL[] urLs = sun.misc.Launcher.getBootstrapClassPath().getURLs();<br>        <span class="hljs-keyword">for</span> (URL element : urLs) &#123;<br>            System.out.println(element.toExternalForm());<br>        &#125;<br>        <span class="hljs-comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:引导类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Provider.class.getClassLoader();<br>        System.out.println(classLoader);<br><br>        System.out.println(<span class="hljs-string">&quot;***********扩展类加载器*************&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">extDirs</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String path : extDirs.split(<span class="hljs-string">&quot;;&quot;</span>)) &#123;<br>            System.out.println(path);<br>        &#125;<br><br>        <span class="hljs-comment">//从上面的路径中随意选择一个类,来看看他的类加载器是什么:扩展类加载器</span><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> CurveDB.class.getClassLoader();<br>        System.out.println(classLoader1);<span class="hljs-comment">//sun.misc.Launcher$ExtClassLoader@1540e19d</span><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">**********启动类加载器**************<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/resources.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/rt.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/sunrsasign.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jsse.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jce.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/charsets.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/lib/jfr.jar<br>file:/C:/Program%20Files/Java/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>/jre/classes<br><span class="hljs-literal">null</span><br>***********扩展类加载器*************<br>C:\Program Files\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_131</span>\jre\lib\ext<br>C:\Windows\Sun\Java\lib\ext<br>sun.misc.Launcher$ExtClassLoader@29453f44<br></code></pre></td></tr></table></figure><h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><h4 id="什么时候需要自定义类加载器？"><a href="#什么时候需要自定义类加载器？" class="headerlink" title="什么时候需要自定义类加载器？"></a>什么时候需要自定义类加载器？</h4><p>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那为什么还需要自定义类加载器？</p><ol><li>隔离加载类（比如说我假设现在Spring框架，和RocketMQ有包名路径完全一样的类，类名也一样，这个时候类就冲突了。不过一般的主流框架和中间件都会自定义类加载器，实现不同的框架，中间价之间是隔离的）</li><li>修改类加载的方式</li><li>扩展加载源（还可以考虑从数据库中加载类，路由器等等不同的地方）</li><li>防止源码泄漏（对字节码文件进行解密，自己用的时候通过自定义类加载器来对其进行解密）</li></ol><h4 id="如何自定义类加载器？"><a href="#如何自定义类加载器？" class="headerlink" title="如何自定义类加载器？"></a>如何自定义类加载器？</h4><ol><li>开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URIClassLoader类，这样就可以避免自己去编写findclass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ClassLoader</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] result = getClassFromCustomPath(name);<br>            <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileNotFoundException</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//defineClass和findClass搭配使用</span><br>                <span class="hljs-keyword">return</span> defineClass(name, result, <span class="hljs-number">0</span>, result.length);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassNotFoundException</span>(name);<br>    &#125;<br><span class="hljs-comment">//自定义流的获取方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] getClassFromCustomPath(String name) &#123;<br>        <span class="hljs-comment">//从自定义路径中加载指定类:细节略</span><br>        <span class="hljs-comment">//如果指定路径的字节码文件进行了加密，则需要在此方法中进行解密操作。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CustomClassLoader</span> <span class="hljs-variable">customClassLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomClassLoader</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;One&quot;</span>, <span class="hljs-literal">true</span>, customClassLoader);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> clazz.newInstance();<br>            System.out.println(obj.getClass().getClassLoader());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关于ClassLoader"><a href="#关于ClassLoader" class="headerlink" title="关于ClassLoader"></a>关于ClassLoader</h3><blockquote><p><strong>ClassLoader 类介绍</strong></p></blockquote><p>ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813871.png"><p>sun.misc.Launcher 它是一个java虚拟机的入口应用</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813872.png"><h4 id="获取ClassLoader途径"><a href="#获取ClassLoader途径" class="headerlink" title="获取ClassLoader途径"></a>获取ClassLoader途径</h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813873.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLoaderTest2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//1.</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;java.lang.String&quot;</span>).getClassLoader();<br>            System.out.println(classLoader);<br>            <span class="hljs-comment">//2.</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader1</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>            System.out.println(classLoader1);<br><br>            <span class="hljs-comment">//3.</span><br>            <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader2</span> <span class="hljs-operator">=</span> ClassLoader.getSystemClassLoader().getParent();<br>            System.out.println(classLoader2);<br><br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">null<br>sun.misc.Launcher<span class="hljs-variable">$AppClassLoader</span>@<span class="hljs-number">18</span>b4aac2<br>sun.misc.Launcher<span class="hljs-variable">$ExtClassLoader</span>@<span class="hljs-number">1540</span>e19d<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><h3 id="双亲委派机制原理"><a href="#双亲委派机制原理" class="headerlink" title="双亲委派机制原理"></a>双亲委派机制原理</h3><p>Java虚拟机对class文件采用的是<strong>按需加载</strong>的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式</p><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li><li>父类加载器一层一层往下分配任务，如果子类加载器能加载，则加载此类，如果将加载任务分配至系统类加载器也无法加载此类，则抛出异常</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813874.png"><h3 id="双亲委派机制代码演示"><a href="#双亲委派机制代码演示" class="headerlink" title="双亲委派机制代码演示"></a>双亲委派机制代码演示</h3><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><p>1、我们自己建立一个 java.lang.String 类，写上 static 代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是自定义的String类的静态代码块&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在另外的程序中加载 String 类，看看加载的 String 类是 JDK 自带的 String 类，还是我们自己编写的 String 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        java.lang.<span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.lang.String();<br>        System.out.println(<span class="hljs-string">&quot;hello,atguigu.com&quot;</span>);<br><br>        <span class="hljs-type">StringTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTest</span>();<br>        System.out.println(test.getClass().getClassLoader());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hello,atguigu<span class="hljs-selector-class">.com</span><br>sun<span class="hljs-selector-class">.misc</span>.Launcher<span class="hljs-variable">$AppClassLoader</span>@<span class="hljs-number">18</span>b4aac2<br></code></pre></td></tr></table></figure><p>程序并没有输出我们静态代码块中的内容，可见仍然加载的是 JDK 自带的 String 类。</p><p>把刚刚的类改一下，然后执行main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是自定义的String类的静态代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//错误: 在类 java.lang.String 中找不到 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello,String&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813875.png"><p>由于双亲委派机制一直找父类，所以最后找到了Bootstrap ClassLoader，Bootstrap ClassLoader找到的是 JDK 自带的 String 类，在那个String类中并没有 main() 方法，所以就报了上面的错误。</p><h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShkStart</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">java.lang.SecurityException: Prohibited <span class="hljs-keyword">package</span> name: java.lang<br>at java.lang.ClassLoader.preDefineClass(ClassLoader.java:<span class="hljs-number">662</span>)<br>at java.lang.ClassLoader.defineClass(ClassLoader.java:<span class="hljs-number">761</span>)<br>at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:<span class="hljs-number">142</span>)<br>at java.net.URLClassLoader.defineClass(URLClassLoader.java:<span class="hljs-number">467</span>)<br>at java.net.URLClassLoader.access$<span class="hljs-number">100</span>(URLClassLoader.java:<span class="hljs-number">73</span>)<br>at java.net.URLClassLoader$<span class="hljs-number">1.</span>run(URLClassLoader.java:<span class="hljs-number">368</span>)<br>at java.net.URLClassLoader$<span class="hljs-number">1.</span>run(URLClassLoader.java:<span class="hljs-number">362</span>)<br>at java.security.AccessController.doPrivileged(Native Method)<br>at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="hljs-number">361</span>)<br>at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">424</span>)<br>at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="hljs-number">335</span>)<br>at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="hljs-number">357</span>)<br>at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:<span class="hljs-number">495</span>)<br>Error: A JNI error has occurred, please check your installation and <span class="hljs-keyword">try</span> again<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> <br>Process finished with exit code <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>即使类名没有重复，也禁止使用java.lang这种包名。这是一种保护机制</p><h4 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h4><p>当我们加载jdbc.jar 用于实现数据库连接的时候</p><ol><li>我们现在程序中需要用到SPI接口，而SPI接口属于rt.jar包中Java核心api</li><li>然后使用双清委派机制，引导类加载器把rt.jar包加载进来，而rt.jar包中的SPI存在一些接口，接口我们就需要具体的实现类了</li><li>具体的实现类就涉及到了某些第三方的jar包了，比如我们加载SPI的实现类jdbc.jar包【首先我们需要知道的是 jdbc.jar是基于SPI接口进行实现的】</li><li>第三方的jar包中的类属于系统类加载器来加载</li><li>从这里面就可以看到SPI核心接口由引导类加载器来加载，SPI具体实现类由系统类加载器来加载</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271813876.png"><h3 id="双亲委派机制优势"><a href="#双亲委派机制优势" class="headerlink" title="双亲委派机制优势"></a>双亲委派机制优势</h3><p>通过上面的例子，我们可以知道，双亲机制可以</p><ol><li><p>避免类的重复加载</p></li><li><p>保护程序安全，防止核心API被随意篡改</p><ul><li>自定义类：自定义java.lang.String 没有被加载。</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）</li></ul></li></ol><h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a>沙箱安全机制</h2><ol><li>自定义String类时：在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件（rt.jar包中java.lang.String.class），报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。</li><li>这样可以保证对java核心源代码的保护，这就是沙箱安全机制。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="如何判断两个class对象是否相同？"><a href="#如何判断两个class对象是否相同？" class="headerlink" title="如何判断两个class对象是否相同？"></a>如何判断两个class对象是否相同？</h3><p>在JVM中表示两个class对象是否为同一个类存在两个必要条件：</p><ol><li>类的完整类名必须一致，包括包名</li><li><strong>加载这个类的ClassLoader（指ClassLoader实例对象）必须相同</strong></li><li>换句话说，在JVM中，即使这两个类对象（class对象）来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的</li></ol><h3 id="对类加载器的引用"><a href="#对类加载器的引用" class="headerlink" title="对类加载器的引用"></a>对类加载器的引用</h3><ol><li>JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的</li><li><strong>如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</strong></li><li>当解析一个类型到另一个类型的引用的时候，JVM需要保证这两个类型的类加载器是相同的（后面讲）</li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM系列-第1章-JVM与Java体系结构</title>
    <link href="/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC1%E7%AB%A0-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2025/02/27/JVM%E7%B3%BB%E5%88%97-%E7%AC%AC1%E7%AB%A0-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1、本系列博客，主要是面向Java8的虚拟机。如有特殊说明，会进行标注。</p><p>2、本系列博客主要参考<strong>尚硅谷的JVM视频教程</strong>，整理不易，所以图片打上了一些水印，还请读者见谅。后续可能会加上一些补充的东西。</p><p>3、尚硅谷的有些视频还不错（PS：不是广告，毕竟看了人家比较好的教程，得给人家打个call）</p><p>4、转载请注明出处，多谢~，希望大家一起能维护一个良好的开源环境。</p></blockquote><h1 id="第1章-JVM和Java体系架构"><a href="#第1章-JVM和Java体系架构" class="headerlink" title="第1章-JVM和Java体系架构"></a>第1章-JVM和Java体系架构</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是否也遇到过这些问题？</p><ol><li>运行着的线上系统突然卡死，系统无法访问，甚至直接OOM！</li><li>想解决线上JVM GC问题，但却无从下手。</li><li>新项目上线，对各种JVM参数设置一脸茫然，直接默认吧然后就JJ了。</li><li>每次面试之前都要重新背一遍JVM的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优VM参数，如何解决GC、OOM等问题，一脸懵逼。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812853.png"><p>大部分Java开发人员，除了会在项目中使用到与Java平台相关的各种高精尖技术，对于Java技术的核心Java虚拟机了解甚少。</p><h2 id="开发人员如何看待上层框架"><a href="#开发人员如何看待上层框架" class="headerlink" title="开发人员如何看待上层框架"></a>开发人员如何看待上层框架</h2><ol><li>一些有一定工作经验的开发人员，打心眼儿里觉得SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。</li><li>如果我们把核心类库的API比做数学公式的话，那么Java虚拟机的知识就好比公式的推导过程。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812854.png"><ul><li>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言。</li></ul><h2 id="架构师每天都在思考什么？"><a href="#架构师每天都在思考什么？" class="headerlink" title="架构师每天都在思考什么？"></a>架构师每天都在思考什么？</h2><ol><li>应该如何让我的系统更快？</li><li>如何避免系统出现瓶颈？</li></ol><p><strong>知乎上有条帖子：应该如何看招聘信息，直通年薪50万+？</strong></p><ol><li>参与现有系统的性能优化，重构，保证平台性能和稳定性</li><li>根据业务场景和需求，决定技术方向，做技术选型</li><li>能够独立架构和设计海量数据下高并发分布式解决方案，满足功能和非功能需求</li><li>解决各类潜在系统风险，核心功能的架构与代码编写</li><li>分析系统瓶颈，解决各种疑难杂症，性能调优等</li></ol><h2 id="我们为什么要学习JVM"><a href="#我们为什么要学习JVM" class="headerlink" title="我们为什么要学习JVM"></a>我们为什么要学习JVM</h2><ol><li>面试的需要（BATJ、TMD，PKQ等面试都爱问）</li><li>中高级程序员必备技能</li></ol><ul><li>项目管理、调优的需要</li></ul><ol start="3"><li>追求极客的精神，<ul><li>比如：垃圾回收算法、JIT、底层原理</li></ul></li></ol><h2 id="Java-VS-C"><a href="#Java-VS-C" class="headerlink" title="Java VS C++"></a>Java VS C++</h2><ol><li>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得JVM内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是Java工程师进阶的必备能力。</li><li>C++语言需要程序员自己来分配内存和回收内存，对于高手来说可能更加舒服，但是对于普通开发者，如果技术实力不够，很容易造成内存泄漏。而Java全部交给JVM进行内存分配和回收，这也是一种趋势，减少程序员的工作量。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812855.png"><h2 id="什么人需要学JVM？"><a href="#什么人需要学JVM？" class="headerlink" title="什么人需要学JVM？"></a>什么人需要学JVM？</h2><ol><li>拥有一定开发经验的Java开发人员，希望升职加薪</li><li>软件设计师，架构师</li><li>系统调优人员</li><li>虚拟机爱好者，JVM实践者</li></ol><h2 id="推荐及参考书籍"><a href="#推荐及参考书籍" class="headerlink" title="推荐及参考书籍"></a>推荐及参考书籍</h2><p><strong>官方文档</strong></p><p><strong>英文文档规范</strong>：<a href="https://docs.oracle.com/javase/specs/index.html">https://docs.oracle.com/javase/specs/index.html</a></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812856.png"><p><strong>中文书籍：</strong></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812857.png"><blockquote><p>周志明老师的这本书<strong>非常推荐看</strong>，不过只推荐看第三版，第三版较第二版更新了很多，个人觉得没必要再看第二版。</p></blockquote><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812858.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812859.png"><h2 id="TIOBE排行榜"><a href="#TIOBE排行榜" class="headerlink" title="TIOBE排行榜"></a>TIOBE排行榜</h2><p><strong>TIOBE 排行榜</strong>：<a href="https://www.tiobe.com/tiobe-index/">https://www.tiobe.com/tiobe-index/</a></p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812860.png"><ul><li>世界上没有最好的编程语言，只有最适用于具体应用场景的编程语言。</li><li>目前网上一直流传Java被python，go撼动Java第一的地位。学习者不需要太担心，Java强大的生态圈，也不是说是朝夕之间可以被撼动的。</li></ul><h2 id="Java生态圈"><a href="#Java生态圈" class="headerlink" title="Java生态圈"></a>Java生态圈</h2><p>Java是目前应用最为广泛的软件开发平台之一。随着Java以及Java社区的不断壮大Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ol><li>作为一个平台，Java虚拟机扮演着举足轻重的作用<ul><li>Groovy、Scala、JRuby、Kotlin等都是Java平台的一部分</li></ul></li><li>作为一种文化，Java几乎成为了“开源”的代名词。<ul><li>第三方开源软件和框架。如Tomcat、Struts，MyBatis，Spring等。</li><li>就连JDK和JVM自身也有不少开源的实现，如openJDK、Harmony。</li></ul></li><li>作为一个社区，Java拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到Java的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li></ol><h2 id="Java-跨平台的语言"><a href="#Java-跨平台的语言" class="headerlink" title="Java-跨平台的语言"></a>Java-跨平台的语言</h2><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812861.png"><h2 id="JVM-跨语言的平台"><a href="#JVM-跨语言的平台" class="headerlink" title="JVM-跨语言的平台"></a>JVM-跨语言的平台</h2><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812862.png"><ol><li>随着Java7的正式发布，Java虚拟机的设计者们通过JSR-292规范基本实现在Java虚拟机平台上运行非Java语言编写的程序。</li><li>Java虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，它只关心“字节码”文件。也就是说Java虚拟机拥有语言无关性，并不会单纯地与Java语言“终身绑定”，只要其他编程语言的编译结果满足并包含Java虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li></ol><ul><li>Java不是最强大的语言，但是JVM是最强大的虚拟机</li></ul><ol><li><p>我们平时说的java字节码，指的是用java语言编译成的字节码。准确的说任何能在jvm平台上执行的字节码格式都是一样的。所以应该统称为：jvm字节码。</p></li><li><p>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行。</p></li><li><p>Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件格式——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</p></li></ol><h2 id="多语言混合编程"><a href="#多语言混合编程" class="headerlink" title="多语言混合编程"></a>多语言混合编程</h2><ol><li><p>Java平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</p></li><li><p>试想一下，在一个项目之中，并行处理用Clojure语言编写，展示层使用JRuby&#x2F;Rails，中间层则是Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，各种语言之间的交互不存在任何困难，就像使用自己语言的原生API一样方便，因为它们最终都运行在一个虚拟机之上。</p></li><li><p>对这些运行于Java虚拟机之上、Java之外的语言，来自系统级的、底层的支持正在迅速增强，以JSR-292为核心的一系列项目和功能改进（如DaVinci Machine项目、Nashorn引擎、InvokeDynamic指令、java.lang.invoke包等），推动Java虚拟机从“Java语言的虚拟机”向 “多语言虚拟机”的方向发展。</p></li></ol><h2 id="如何真正搞懂JVM？"><a href="#如何真正搞懂JVM？" class="headerlink" title="如何真正搞懂JVM？"></a>如何真正搞懂JVM？</h2><ol><li>Java虚拟机非常复杂，要想真正理解它的工作原理，最好的方式就是自己动手编写一个！</li><li>自己动手写一个Java虚拟机，难吗？</li><li>天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812863.png"><h2 id="Java发展重大事件"><a href="#Java发展重大事件" class="headerlink" title="Java发展重大事件"></a>Java发展重大事件</h2><ul><li>1990年，在Sun计算机公司中，由Patrick Naughton、MikeSheridan及James Gosling领导的小组Green Team，开发出的新的程序语言，命名为Oak，后期命名为Java</li><li>1995年，Sun正式发布Java和HotJava产品，Java首次公开亮相。</li><li>1996年1月23日Sun Microsystems发布了JDK 1.0。</li><li>1998年，JDK1.2版本发布。同时，Sun发布了JSP&#x2F;Servlet、EJB规范，以及将Java分成了J2EE、J2SE和J2ME。这表明了Java开始向企业、桌面应用和移动设备应用3大领域挺进。</li><li>2000年，JDK1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。</li><li>2002年，JDK1.4发布，古老的Classic虚拟机退出历史舞台。</li><li>2003年年底，Java平台的scala正式发布，同年Groovy也加入了Java阵营。</li><li>2004年，JDK1.5发布。同时JDK1.5改名为JavaSE5.0。</li><li>2006年，JDK6发布。同年，Java开源并建立了OpenJDK。顺理成章，Hotspot虚拟机也成为了OpenJDK中的默认虚拟机。</li><li>2007年，Java平台迎来了新伙伴Clojure。</li><li>2008年，oracle收购了BEA，得到了JRockit虚拟机。</li><li>2009年，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是Java平台的又一次大规模应用。</li><li>2010年，Oracle收购了Sun，获得Java商标和最真价值的HotSpot虚拟机。此时，Oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit。JCP组织管理Java语言</li><li>2011年，JDK7发布。在JDK1.7u4中，正式启用了新的垃圾回收器G1。</li><li><strong>2017年，JDK9发布。将G1设置为默认GC，替代CMS</strong></li><li>同年，IBM的J9开源，形成了现在的Open J9社区</li><li>2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元</li><li>同年，Oracle宣告JavagE成为历史名词JDBC、JMS、Servlet赠予Eclipse基金会</li><li><strong>同年，JDK11发布，LTS版本的JDK，发布革命性的ZGC，调整JDK授权许可</strong></li><li>2019年，JDK12发布，加入RedHat领导开发的Shenandoah GC</li></ul><h2 id="Open-JDK和Oracle-JDK"><a href="#Open-JDK和Oracle-JDK" class="headerlink" title="Open JDK和Oracle JDK"></a>Open JDK和Oracle JDK</h2><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812864.png"><ul><li>在JDK11之前，Oracle JDK中还会存在一些Open JDK中没有的，闭源的功能。但在JDK11中，我们可以认为Open JDK和Oracle JDK代码实质上已经达到完全一致的程度了。</li><li>主要的区别就是两者更新周期不一样</li></ul><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="虚拟机概念"><a href="#虚拟机概念" class="headerlink" title="虚拟机概念"></a>虚拟机概念</h3><ul><li><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li>大名鼎鼎的Virtual Box，VMware就属于系统虚拟机，它们完全是对物理计算机硬件的仿真(模拟)，提供了一个可运行完整操作系统的软件平台。</li></ul><ul><li>程序虚拟机的典型代表就是Java虚拟机，它专门为执行单个计算机程序而设计，在Java虚拟机中执行的指令我们称为Java字节码指令。</li></ul></li><li><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p></li></ul><h3 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h3><ol><li>Java虚拟机是一台执行Java字节码的虚拟计算机，它拥有独立的运行机制，其运行的Java字节码也未必由Java语言编译而成。</li><li>JVM平台的各种语言可以共享Java虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li><strong>Java技术的核心就是Java虚拟机</strong>（JVM，Java Virtual Machine），因为所有的Java程序都运行在Java虚拟机内部。</li></ol><p><strong>作用：</strong></p><p>Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p><strong>特点：</strong></p><ol><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ol><h2 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h2><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812865.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812866.png"><h2 id="JVM的整体结构"><a href="#JVM的整体结构" class="headerlink" title="JVM的整体结构"></a>JVM的整体结构</h2><ol><li>HotSpot VM是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li><li>在今天，Java程序的运行性能早已脱胎换骨，已经达到了可以和C&#x2F;C++程序一较高下的地步。</li></ol><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812867.png"><h2 id="Java代码执行流程"><a href="#Java代码执行流程" class="headerlink" title="Java代码执行流程"></a>Java代码执行流程</h2><p>凡是能生成被Java虚拟机所能解释、运行的字节码文件，那么理论上我们就可以自己设计一套语言了</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271812868.png"><h2 id="JVM的架构模型"><a href="#JVM的架构模型" class="headerlink" title="JVM的架构模型"></a>JVM的架构模型</h2><p>Java编译器输入的指令流基本上是一种<strong>基于栈的指令集架构</strong>，另外一种指令集架构则是<strong>基于寄存器的指令集架构</strong>。具体来说：这两种架构之间的区别：</p><h3 id="基于栈的指令集架构"><a href="#基于栈的指令集架构" class="headerlink" title="基于栈的指令集架构"></a>基于栈的指令集架构</h3><p>基于栈式架构的特点：</p><ol><li>设计和实现更简单，适用于资源受限的系统；</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ol><h3 id="基于寄存器的指令级架构"><a href="#基于寄存器的指令级架构" class="headerlink" title="基于寄存器的指令级架构"></a>基于寄存器的指令级架构</h3><p>基于寄存器架构的特点：</p><ol><li>典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。</li><li>指令集架构则完全依赖硬件，与硬件的耦合度高，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li></ol><h3 id="两种架构的举例"><a href="#两种架构的举例" class="headerlink" title="两种架构的举例"></a>两种架构的举例</h3><p>同样执行2+3这种逻辑操作，其指令分别如下：</p><ul><li><p><strong>基于栈的计算流程（以Java虚拟机为例）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">iconst_2 <span class="hljs-comment">//常量2入栈</span><br>istore_1<br>iconst_3 <span class="hljs-comment">// 常量3入栈</span><br>istore_2<br>iload_1<br>iload_2<br>iadd <span class="hljs-comment">//常量2/3出栈，执行相加</span><br>istore_0 <span class="hljs-comment">// 结果5入栈</span><br></code></pre></td></tr></table></figure><p>8个指令</p></li><li><p><strong>而基于寄存器的计算流程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mov eax,<span class="hljs-number">2</span> <span class="hljs-comment">//将eax寄存器的值设为1</span><br>add eax,<span class="hljs-number">3</span> <span class="hljs-comment">//使eax寄存器的值加3</span><br></code></pre></td></tr></table></figure><p>2个指令</p></li></ul><blockquote><p>具体后面会讲</p></blockquote><h3 id="JVM架构总结"><a href="#JVM架构总结" class="headerlink" title="JVM架构总结"></a>JVM架构总结</h3><ol><li><p><strong>由于跨平台性的设计，Java的指令都是根据栈来设计的</strong>。不同平台CPU架构不同，所以不能设计为基于寄存器的。栈的优点：跨平台，指令集小，编译器容易实现，缺点是性能比寄存器差一些。</p></li><li><p>时至今日，尽管嵌入式平台已经不是Java程序的主流运行平台了（准确来说应该是HotSpot VM的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p></li></ol><ul><li>因为基于栈的架构跨平台性好、指令集小，虽然相对于基于寄存器的架构来说，基于栈的架构编译得到的指令更多，执行性能也不如基于寄存器的架构好，但考虑到其跨平台性与移植性，我们还是选用栈的架构</li></ul><h2 id="JVM的生命周期"><a href="#JVM的生命周期" class="headerlink" title="JVM的生命周期"></a>JVM的生命周期</h2><h3 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a>虚拟机的启动</h3><p>Java虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><h3 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a>虚拟机的执行</h3><ol><li>一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序</li><li>程序开始执行时他才运行，程序结束时他就停止</li><li><strong>执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程</strong></li></ol><h3 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a>虚拟机的退出</h3><p><strong>有如下的几种情况：</strong></p><ol><li><p>程序正常执行结束</p></li><li><p>程序在执行过程中遇到了异常或错误而异常终止</p></li><li><p>由于操作系统用现错误而导致Java虚拟机进程终止</p></li><li><p>某线程调用Runtime类或System类的exit()方法，或Runtime类的halt()方法，并且Java安全管理器也允许这次exit()或halt()操作。</p></li><li><p>除此之外，JNI（Java Native Interface）规范描述了用JNI Invocation API来加载或卸载 Java虚拟机时，Java虚拟机的退出情况。</p></li></ol><h2 id="JVM发展历程"><a href="#JVM发展历程" class="headerlink" title="JVM发展历程"></a>JVM发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ol><li>早在1996年Java1.0版本的时候，Sun公司发布了一款名为sun classic VM的Java虚拟机，它同时也是<strong>世界上第一款商用Java虚拟机</strong>，JDK1.4时完全被淘汰。</li><li>这款虚拟机内部只提供解释器，没有即时编译器，因此效率比较低。【即时编译器会把热点代码的本地机器指令缓存起来，那么以后使用热点代码的时候，效率就比较高】</li><li>如果使用JIT编译器，就需要进行外挂。但是一旦使用了JIT编译器，JIT就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作。<ul><li>我们将字节码指令翻译成机器指令也是需要花时间的，如果只使用JIT，就需要把所有字节码指令都翻译成机器指令，就会导致翻译时间过长，也就是说在程序刚启动的时候，等待时间会很长。</li><li>而解释器就是走到哪，解释到哪。</li></ul></li><li>现在Hotspot内置了此虚拟机。</li></ol><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ol><li><p>为了解决上一个虚拟机问题，jdk1.2时，Sun提供了此虚拟机。</p></li><li><p>Exact Memory Management：准确式内存管理</p><ul><li><p>也可以叫Non-Conservative&#x2F;Accurate Memory Management</p></li><li><p>虚拟机可以知道内存中某个位置的数据具体是什么类型。</p></li></ul></li><li><p>具备现代高性能虚拟机的维形</p><ul><li><p>热点探测（寻找出热点代码进行缓存）</p></li><li><p>编译器与解释器混合工作模式</p></li></ul></li><li><p>只在Solaris平台短暂使用，其他平台上还是classic vm，英雄气短，终被Hotspot虚拟机替换</p></li></ol><h3 id="HotSpot-VM（重点）"><a href="#HotSpot-VM（重点）" class="headerlink" title="HotSpot VM（重点）"></a>HotSpot VM（重点）</h3><ol><li><p>HotSpot历史</p><ul><li><p>最初由一家名为“Longview Technologies”的小公司设计</p></li><li><p>1997年，此公司被Sun收购；2009年，Sun公司被甲骨文收购。</p></li><li><p>JDK1.3时，HotSpot VM成为默认虚拟机</p></li></ul></li><li><p>目前<strong>Hotspot占有绝对的市场地位，称霸武林</strong>。</p><ul><li><p>不管是现在仍在广泛使用的JDK6，还是使用比例较多的JDK8中，默认的虚拟机都是HotSpot</p></li><li><p>Sun&#x2F;oracle JDK和openJDK的默认虚拟机</p></li><li><p>因此本课程中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。（比如其他两个商用虚机都没有方法区的概念）</p></li></ul></li><li><p>从服务器、桌面到移动端、嵌入式都有应用。</p></li><li><p>名称中的HotSpot指的就是它的热点代码探测技术。</p><ul><li><p>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</p></li><li><p>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</p></li></ul></li></ol><h3 id="JRockit（商用三大虚拟机之一）"><a href="#JRockit（商用三大虚拟机之一）" class="headerlink" title="JRockit（商用三大虚拟机之一）"></a>JRockit（商用三大虚拟机之一）</h3><ol><li><p>专注于服务器端应用：它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</p></li><li><p>大量的行业基准测试显示，JRockit JVM是世界上最快的JVM：使用JRockit产品，客户已经体验到了显著的性能提高（一些超过了70%）和硬件成本的减少（达50%）。</p></li><li><p>优势：全面的Java运行时解决方案组合</p><ul><li><p>JRockit面向延迟敏感型应用的解决方案JRockit Real Time提供以毫秒或微秒级的JVM响应时间，适合财务、军事指挥、电信网络的需要</p></li><li><p>Mission Control服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</p></li></ul></li><li><p>2008年，JRockit被Oracle收购。</p></li><li><p>Oracle表达了整合两大优秀虚拟机的工作，大致在JDK8中完成。整合的方式是在HotSpot的基础上，移植JRockit的优秀特性。</p></li><li><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p></li></ol><h3 id="IBM的J9（商用三大虚拟机之一）"><a href="#IBM的J9（商用三大虚拟机之一）" class="headerlink" title="IBM的J9（商用三大虚拟机之一）"></a>IBM的J9（商用三大虚拟机之一）</h3><ol><li><p>全称：IBM Technology for Java Virtual Machine，简称IT4J，内部代号：J9</p></li><li><p>市场定位与HotSpot接近，服务器端、桌面应用、嵌入式等多用途VM广泛用于IBM的各种Java产品。</p></li><li><p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的Java虚拟机。</p></li><li><p>2017年左右，IBM发布了开源J9VM，命名为openJ9，交给Eclipse基金会管理，也称为Eclipse OpenJ9</p></li><li><p>OpenJDK -&gt; 是JDK开源了，包括了虚拟机</p></li></ol><h3 id="KVM和CDC-CLDC-Hotspot"><a href="#KVM和CDC-CLDC-Hotspot" class="headerlink" title="KVM和CDC&#x2F;CLDC Hotspot"></a>KVM和CDC&#x2F;CLDC Hotspot</h3><ol><li><p>Oracle在Java ME产品线上的两款虚拟机为：CDC&#x2F;CLDC HotSpot Implementation VM </p></li><li><p>KVM（Kilobyte）是CLDC-HI早期产品</p></li><li><p>目前移动领域地位尴尬，智能机被Android和iOS二分天下。</p></li><li><p>KVM简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li><p>智能控制器、传感器</p></li><li><p>老人手机、经济欠发达地区的功能手机</p></li></ul></li><li><p>所有的虚拟机的原则：一次编译，到处运行。</p></li></ol><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ol><li>前面三大“高性能Java虚拟机”使用在<strong>通用硬件平台上</strong></li><li>这里Azul VW和BEA Liquid VM是与<strong>特定硬件平台绑定</strong>、软硬件配合的专有虚拟机：高性能Java虚拟机中的战斗机。</li><li>Azul VM是Azul Systems公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机。</li><li>每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</li><li>2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。</li></ol><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><ol><li>高性能Java虚拟机中的战斗机。</li><li>BEA公司开发的，直接运行在自家Hypervisor系统上</li><li>Liquid VM即是现在的JRockit VE（Virtual Edition）。<strong>Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等</strong>。</li><li>随着JRockit虚拟机终止开发，Liquid vM项目也停止了。</li></ol><h3 id="Apache-Marmony"><a href="#Apache-Marmony" class="headerlink" title="Apache Marmony"></a>Apache Marmony</h3><ol><li><p>Apache也曾经推出过与JDK1.5和JDK1.6兼容的Java运行平台Apache Harmony。</p></li><li><p>它是IElf和Intel联合开发的开源JVM，受到同样开源的Open JDK的压制，Sun坚决不让Harmony获得JCP认证，最终于2011年退役，IBM转而参与OpenJDK</p></li><li><p>虽然目前并没有Apache Harmony被大规模商用的案例，但是它的Java类库代码吸纳进了Android SDK。</p></li></ol><h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><ol><li><p>微软为了在IE3浏览器中支持Java Applets，开发了Microsoft JVM。</p></li><li><p>只能在window平台下运行。但确是当时Windows下性能最好的Java VM。</p></li><li><p>1997年，Sun以侵犯商标、不正当竞争罪名指控微软成功，赔了Sun很多钱。微软WindowsXP SP3中抹掉了其VM。现在Windows上安装的jdk都是HotSpot。</p></li></ol><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><ol><li><p>由AliJVM团队发布。阿里，国内使用Java最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p></li><li><p><strong>基于OpenJDK开发了自己的定制版本AlibabaJDK</strong>，简称AJDK。是整个阿里Java体系的基石。</p></li><li><p>基于OpenJDK Hotspot VM发布的国内第一个优化、深度定制且开源的高性能服务器版Java虚拟机。</p><ul><li>创新的GCIH（GCinvisible heap）技术实现了off-heap，<strong>即将生命周期较长的Java对象从heap中移到heap之外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的</strong>。</li><li>GCIH中的<strong>对象还能够在多个Java虚拟机进程中实现共享</strong></li><li>使用crc32指令实现JvM intrinsic降低JNI的调用开销</li><li>PMU hardware的Java profiling tool和诊断协助功能</li><li>针对大数据场景的ZenGC</li></ul></li><li><p>taobao vm应用在阿里产品上性能高，<strong>硬件严重依赖inte1的cpu，损失了兼容性，但提高了性能</strong></p></li></ol><ul><li>目前已经在淘宝、天猫上线，把Oracle官方JvM版本全部替换了。</li></ul><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><ol><li><p>谷歌开发的，应用于Android系统，并在Android2.2中提供了JIT，发展迅猛。</p></li><li><p><strong>Dalvik VM只能称作虚拟机，而不能称作“Java虚拟机”</strong>，它没有遵循 Java虚拟机规范</p></li><li><p>不能直接执行Java的Class文件</p></li><li><p>基于寄存器架构，不是jvm的栈架构。</p></li><li><p>执行的是编译以后的dex（Dalvik Executable）文件。执行效率比较高。</p></li></ol><ul><li>它执行的dex（Dalvik Executable）文件可以通过class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。</li></ul><ol start="7"><li>Android 5.0使用支持提前编译（Ahead of Time Compilation，AoT）的ART VM替换Dalvik VM。</li></ol><h3 id="Graal-VM（未来虚拟机）"><a href="#Graal-VM（未来虚拟机）" class="headerlink" title="Graal VM（未来虚拟机）"></a>Graal VM（未来虚拟机）</h3><ol><li><p>2018年4月，Oracle Labs公开了GraalvM，号称 “<strong>Run Programs Faster Anywhere</strong>”，勃勃野心。与1995年java的”write once，run anywhere”遥相呼应。</p></li><li><p>GraalVM在HotSpot VM基础上增强而成的**跨语言全栈虚拟机，可以作为“任何语言”**的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R等</p></li><li><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p></li><li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p></li><li><p><strong>如果说HotSpot有一天真的被取代，Graalvm希望最大</strong>。但是Java的软件生态没有丝毫变化。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体JVM的内存结构，其实取决于其实现，不同厂商的JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以Oracle HotSpot VM为默认虚拟机。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>1.内存与垃圾回收篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MYDB record</title>
    <link href="/2025/02/21/MYDB-record/"/>
    <url>/2025/02/21/MYDB-record/</url>
    
    <content type="html"><![CDATA[<h1 id="MYDB"><a href="#MYDB" class="headerlink" title="MYDB"></a><strong>MYDB</strong></h1><h1 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502211203817.jpg" alt="img"></p><ol><li>Transaction Manager（TM）</li><li>Data Manager（DM）</li><li>Version Manager（VM）</li><li>Index Manager（IM）</li><li>Table Manager（TBM）</li></ol><p>每个模块的职责如下：</p><ol><li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li><li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li><li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li><li>IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。</li><li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li></ol><h1 id="2-Transaction-Manager"><a href="#2-Transaction-Manager" class="headerlink" title="2. Transaction Manager"></a>2. Transaction Manager</h1><blockquote><p>TM模块通过维护一个XID文件来维护事务状态，并提供接口供其他模块来查询某个事务的状态</p></blockquote><h2 id="XID文件"><a href="#XID文件" class="headerlink" title="XID文件"></a>XID文件</h2><p>在 MYDB 中，每一个事务都有一个 XID，这个 ID 唯一标识了这个事务。事务的 XID 从 1 开始标号，并自增，不可重复。并特殊规定 <strong>XID 0 是一个超级事务（Super Transaction）</strong>。当一些操作想在没有申请事务的情况下进行，那么可以将操作的 XID 设置为 0。XID 为 0 的事务的状态永远是 committed。</p><p>TransactionManager 维护了一个 XID 格式的文件，用来记录各个事务的状态。MYDB 中，每个事务都有下面的三种状态：</p><ol><li><code>active</code>，正在进行，尚未结束</li><li><code>committed</code>，已提交</li><li><code>aborted</code>，已撤销（回滚）</li></ol><p>XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，<strong>事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处</strong>，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。（XID文件头8个字节用于记录此XID文件管理的事务数量，后面记录事务的状态）</p><h2 id="必要的常量及变量"><a href="#必要的常量及变量" class="headerlink" title="必要的常量及变量"></a>必要的常量及变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XID文件头长度</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LEN_XID_HEADER_LENGTH</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 每个事务的占用长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">XID_FIELD_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 事务的三种状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ACTIVE</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_COMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ABORTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 超级事务，永远为commited状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SUPER_XID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// XID 文件后缀</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">XID_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.xid&quot;</span>;<br><br><span class="hljs-comment">// 用于获取XID文件</span><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-comment">// 文件通道，用于文件的读写</span><br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-comment">// 用于记录XID文件中事务的数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> xidCounter;<br><span class="hljs-keyword">private</span> Lock counterLock;<br></code></pre></td></tr></table></figure><h2 id="XID文件校验"><a href="#XID文件校验" class="headerlink" title="XID文件校验"></a>XID文件校验</h2><p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，通过<strong>文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比</strong>。如果不同则认为 XID 文件不合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">fileLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 记录文件的实际长度</span><br>        fileLen = file.length();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br>  <span class="hljs-comment">// 文件实际长度比文件头的8字节还小，说明文件不合法</span><br>    <span class="hljs-keyword">if</span>(fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 设置FileChannel的position</span><br>        fc.position(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">// 从文件通道读取内容到ByteBuffer中</span><br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.xidCounter = Parser.parseLong(buf.array());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> getXidPosition(<span class="hljs-built_in">this</span>.xidCounter + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(end != fileLen) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 根据事务xid取得其在xid文件中对应的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getXidPosition</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-keyword">return</span> LEN_XID_HEADER_LENGTH + (xid-<span class="hljs-number">1</span>)*XID_FIELD_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="更新事务状态"><a href="#更新事务状态" class="headerlink" title="更新事务状态"></a>更新事务状态</h2><ul><li><code>begin()</code>：开启一个事务，首先设置<code>xid = xidCounter+1</code>的事务状态为<code>active</code>，随后<strong>xidCounter自增</strong></li><li><code>commit()</code>：提交一个事务，将<code>xid</code>事务的状态设置为<code>committed</code></li><li><code>abort()</code>：取消一个事务，将<code>xid</code>事务的状态设置为<code>aborted</code></li><li>这三个更新操作都可借助下面的<code>updateXID()</code>方法实现，同时开启事务还需要实现一个xidCounter自增的方法<code>incrXIDCounter()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 更新xid事务的状态为status</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">byte</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE];<br>    tmp[<span class="hljs-number">0</span>] = status;<br>  <span class="hljs-comment">// tmp数组包装成bytebuffer数组</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(tmp);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 将ByteBuffer中的内容写入到文件通道中的offset位置，即更改事务状态</span><br>        fc.position(offset);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 所有文件操作，在执行后都需要立刻刷入文件中，防止在崩溃后文件丢失数据，fileChannel 的 force() 方法，强制同步缓存内容到文件中。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。</span><br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将XID加一，并更新XID Header（开启一个新事务时需要此操作）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    xidCounter ++;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(<span class="hljs-number">0</span>);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="检查事务状态"><a href="#检查事务状态" class="headerlink" title="检查事务状态"></a>检查事务状态</h2><p><code>isActive()</code>、<code>isCommitted()</code> 和 <code>isAborted()</code> 都是检查一个 xid 的状态，可以用一个通用的方法解决：（检查时需要排除<code>SUPER_XID</code>的情况，因为该情况一定是<code>committed</code>的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检测XID事务是否处于status状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE]);<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf.array()[<span class="hljs-number">0</span>] == status;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建和打开XID文件"><a href="#创建和打开XID文件" class="headerlink" title="创建和打开XID文件"></a>创建和打开XID文件</h2><p>在接口中创建的两个静态方法<code>create()</code>和<code>open()</code></p><ul><li><code>create()</code>：创建一个XID文件，并创建TM（TM的构造器需要XID文件和FileChannel）</li><li><code>open()</code>：从一个已有的XID文件来创建TM</li></ul><h1 id="3-Data-Manager"><a href="#3-Data-Manager" class="headerlink" title="3. Data Manager"></a>3. Data Manager</h1><blockquote><p>DataManager（DM）功能归纳：</p><ul><li>上层模块和文件系统中的一个抽象层。向上，提供数据包装；向下，直接读写文件。</li><li>提供日志功能。</li></ul></blockquote><h2 id="计数缓存框架"><a href="#计数缓存框架" class="headerlink" title="计数缓存框架"></a>计数缓存框架</h2><blockquote><p>分页管理和数据项（DataItem）管理涉及缓存，故抽象出一个<strong>通用缓存框架</strong>。</p></blockquote><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>**引用计数法（Reference counting）**是一种内存管理技术，它通过计算每个对象被引用的次数来判断是否需要回收该对象。当对象被创建时，引用计数为 1，每当有一个新的引用指向该对象时，计数加 1，当引用失效时，计数减 1。<strong>当计数为 0 时，该对象就可以被回收</strong>。</p><p>在 MYDB 的实践中，需要的效果是，只有上层模块<strong>主动释放引用</strong>，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。于是，选择引用计数法。增加了一个方法 <code>release (key)</code>，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p><p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>**LRU（least recently used）**是一种缓存淘汰算法。它的特点是根据数据最近被访问的时间来决定哪些数据应该被保留，哪些数据应该被淘汰。当缓存达到一定容量时，会淘汰掉最近最少使用的数据。</p><p>如果使用 LRU 缓存，那么只需要设计一个<code>get (key)</code>接口即可，释放缓存可以在缓存满了之后自动完成。</p><p>however，当某时刻缓存满了，缓存驱逐一个资源，此时上层模块想将某个资源强制刷回数据源，这个资源恰恰是刚被驱逐的资源。此时的上层模块会发现，资源在缓存中消失了，那么，是否有必要做回源操作？</p><ul><li><strong>不回源</strong>。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li><li><strong>回源</strong>。如果数据项被驱逐时的数据和现在又是相同的，那就是一次<strong>无效回源</strong></li><li><strong>放回缓存里，等下次被驱逐时回源</strong>。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致<strong>缓存抖动</strong>问题。</li></ul><h3 id="必要的变量"><a href="#必要的变量" class="headerlink" title="必要的变量"></a>必要的变量</h3><p><code>AbstractCache&lt;T&gt;</code>是一个抽象类，内部有两个抽象方法，留给实现类去实现具体的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当资源不在缓存时的获取行为（去数据源中获取）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当资源被驱逐时的写回行为</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(T obj)</span>;<br></code></pre></td></tr></table></figure><p>由于我们选择使用的是引用计数法实现缓存，因此除了普通的缓存功能，还需要另外<strong>维护一个计数</strong>，用于记录资源被引用的个数。除此以外，为了应对<strong>多线程场景</strong>，还需要记录哪些资源正在从数据源获取中（<strong>从数据源获取资源是一个相对费时的操作</strong>）。于是有下面三个 Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="hljs-comment">// 实际缓存的数据</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="hljs-comment">// 资源的引用个数</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="hljs-comment">// 正在被获取的资源</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxResource;                            <span class="hljs-comment">// 缓存的最大缓存资源数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                              <span class="hljs-comment">// 缓存中元素的个数</span><br><span class="hljs-keyword">private</span> Lock lock;<br></code></pre></td></tr></table></figure><h3 id="get-方法获取资源"><a href="#get-方法获取资源" class="headerlink" title="get()方法获取资源"></a>get()方法获取资源</h3><ol><li>判断请求的资源是否正在被其他线程获取，若是，则过一段时间再来查看</li><li>没有其他线程在获取目标资源，到缓存中查看是否有需要的资源，若有，则直接返回</li><li>资源不在缓存中，且缓存已满，抛出<code>CacheFullException</code>异常</li><li>资源不在缓存中且缓存没满，尝试去数据源获取该资源</li><li>在数据源中没找到该资源，抛出异常</li><li>在数据源中找到需要的资源，添加到缓存中后返回</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        lock.lock();<br>        <span class="hljs-comment">// 1.1.首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看</span><br>        <span class="hljs-keyword">if</span>(getting.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 请求的资源正在被其他线程获取</span><br>            lock.unlock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 1.2.如果没有其他线程在获取这个资源，那么就可以尝试从缓存中获取了</span><br>        <span class="hljs-keyword">if</span>(cache.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 资源在缓存中，直接返回</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-comment">// 记得给资源的引用计数加一</span><br>            references.put(key, references.get(key) + <span class="hljs-number">1</span>);<br>            lock.unlock();<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br><br>        <span class="hljs-comment">// 1.3.尝试获取该资源</span><br>        <span class="hljs-comment">// a.判断缓存是否已满，如果已满，就抛出一个异常</span><br>        <span class="hljs-keyword">if</span>(maxResource &gt; <span class="hljs-number">0</span> &amp;&amp; count == maxResource) &#123;<br>            lock.unlock();<br>            <span class="hljs-keyword">throw</span> Error.CacheFullException;<br>        &#125;<br>        <span class="hljs-comment">// b.如果缓存未满，就在 getting 中注册一下，该线程准备从数据源获取资源了</span><br>        count ++;<br>        getting.put(key, <span class="hljs-literal">true</span>);<br>        lock.unlock();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.从数据源获取资源</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用抽象方法从数据源中获取资源</span><br>        obj = getForCache(key);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 如果获取失败，就把 getting 中的注册信息清除掉</span><br>        lock.lock();<br>        count --;<br>        getting.remove(key);<br>        lock.unlock();<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br><br>    lock.lock();<br>    getting.remove(key);       <span class="hljs-comment">// 获取完成要从 getting 中清除注册信息</span><br>    cache.put(key, obj);<br>    references.put(key, <span class="hljs-number">1</span>);<br>    lock.unlock();<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="release-方法释放资源"><a href="#release-方法释放资源" class="headerlink" title="release()方法释放资源"></a>release()方法释放资源</h3><p>当引用计数references减到0后，就可以回源并删除缓存中的相关结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3.释放资源</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 释放一个缓存时，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> references.get(key) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(ref == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-comment">// 调用抽象方法释放缓存</span><br>            releaseForCache(obj);<br>            <span class="hljs-comment">// 删除缓存中所有相关的结构</span><br>            references.remove(key);<br>            cache.remove(key);<br>            count --;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            references.put(key, ref);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="close-方法关闭缓存"><a href="#close-方法关闭缓存" class="headerlink" title="close()方法关闭缓存"></a>close()方法关闭缓存</h3><p>缓存应当还有以一个安全关闭的功能，在关闭时，需要将缓存中所有的资源强行回源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Set&lt;Long&gt; keys = cache.keySet();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> key : keys) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            releaseForCache(obj);<br>            references.remove(key);<br>            cache.remove(key);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，一个简单的缓存框架就实现完了，其他的缓存只需要继承这个类，并实现那两个抽象方法即可。</p><h2 id="数据页的缓存与管理"><a href="#数据页的缓存与管理" class="headerlink" title="数据页的缓存与管理"></a>数据页的缓存与管理</h2><h3 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h3><p>参考大部分数据库的设计，将<strong>默认数据页大小定为 8K</strong>。如果想要提升向数据库写入大量数据情况下的性能的话，也可以适当增大这个值。</p><p>上一节我们已经实现了一个通用的缓存框架，那么这一节我们需要缓存页面，就可以直接借用那个缓存的框架了。但是首先，需要<strong>定义出页面的结构</strong>。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。定义一个页面如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Page</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pageNumber;<span class="hljs-comment">// 页号，从1开始</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] data;<span class="hljs-comment">// 此页面实际包含的字节数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> dirty;<span class="hljs-comment">// 标识该页面是否是脏页面，在缓存驱逐的时候，脏页面需要被写回磁盘</span><br>    <span class="hljs-keyword">private</span> Lock lock;<br><br>    <span class="hljs-keyword">private</span> PageCache pc;<span class="hljs-comment">// 这里保存了一个 PageCache（还未定义）的引用，用来方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>页面缓存接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageCache</span> &#123;<br>  <br>  <span class="hljs-comment">// 页面大小8192</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PAGE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>;<br>  <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span>;<br>    Page <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Page page)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">truncateByBgno</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPgno)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getPageNumber</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">flushPage</span><span class="hljs-params">(Page pg)</span>;<br>  <br>  <span class="hljs-comment">// 创建一个新的.db文件</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageCacheImpl <span class="hljs-title function_">create</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> memory)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+PageCacheImpl.DB_SUFFIX);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(!f.createNewFile()) &#123;<br>                Panic.panic(Error.FileExistsException);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;<br>            Panic.panic(Error.FileCannotRWException);<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br>            fc = raf.getChannel();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageCacheImpl</span>(raf, fc, (<span class="hljs-type">int</span>)memory/PAGE_SIZE);<br>    &#125;<br><br>  <span class="hljs-comment">// 打开一个.db文件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageCacheImpl <span class="hljs-title function_">open</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> memory)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+PageCacheImpl.DB_SUFFIX);<br>        <span class="hljs-keyword">if</span>(!f.exists()) &#123;<br>            Panic.panic(Error.FileNotExistsException);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;<br>            Panic.panic(Error.FileCannotRWException);<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br>            fc = raf.getChannel();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageCacheImpl</span>(raf, fc, (<span class="hljs-type">int</span>)memory/PAGE_SIZE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>页面缓存的具体实现类<code>PageCacheImpl</code>，需要继承抽象缓存框架AbstractCache，并且实现<code>getForCache() </code>和 <code>releaseForCache() </code>两个抽象方法。由于数据源就是文件系统（<strong>.db文件</strong>），<code>getForCache() </code>直接从文件中读取，并包裹成 Page 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据pageNumber从数据库文件中读取页数据，并包裹成Page</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Page <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// 页号</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)key;<br>  <span class="hljs-comment">// 页号对应的页在文件中的位置</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageCacheImpl.pageOffset(pgno);<br><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(PAGE_SIZE);<br>    fileLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    fileLock.unlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, buf.array(), <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pageOffset</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> &#123;<br>    <span class="hljs-comment">// 页号从 1 开始</span><br>    <span class="hljs-keyword">return</span> (pgno-<span class="hljs-number">1</span>) * PAGE_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code> releaseForCache()</code>驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-keyword">if</span>(pg.isDirty()) &#123;<br>        flush(pg);<br>        pg.setDirty(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pg.getPageNumber();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> pageOffset(pgno);<br><br>    fileLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(pg.getData());<br>        fc.position(offset);<br>        fc.write(buf);<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        fileLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pageNumbers.incrementAndGet();<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, initData, <span class="hljs-literal">null</span>);<br>    flush(pg);  <span class="hljs-comment">// 新建的页面需要立刻写回</span><br>    <span class="hljs-keyword">return</span> pgno;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据页管理"><a href="#数据页管理" class="headerlink" title="数据页管理"></a>数据页管理</h3><h4 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h4><p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是<strong>用来做启动检查</strong>。具体的原理是，在每次数据库<strong>启动</strong>时，会生成一串随机字节，存储在 <strong>100 ~ 107</strong> 字节。在数据库<strong>正常关闭</strong>时，会将这串字节，拷贝到第一页的 1<strong>08 ~ 115</strong> 字节。</p><p>这样数据库在每次启动时，就会<strong>检查第一页两处的字节是否相同</strong>，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p><p>启动时设置初始字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(Page pg)</span> &#123;<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    setVcOpen(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="hljs-number">0</span>, raw, OF_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭时拷贝字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(Page pg)</span> &#123;<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    setVcClose(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure><p>校验字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-keyword">return</span> checkVc(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    <span class="hljs-keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="hljs-number">2</span>*LEN_VC));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="普通页"><a href="#普通页" class="headerlink" title="普通页"></a>普通页</h4><p>一个普通页面以一个 <strong>2 字节无符号数</strong>起始，表示<strong>这一页的空闲位置的偏移</strong>。剩下的部分都是实际存储的数据。对普通页的管理，基本都是围绕着对 <strong>FSO（Free Space Offset）进行的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageX</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">short</span> <span class="hljs-variable">OF_FREE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">short</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">// 数据起始位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_FREE_SPACE</span> <span class="hljs-operator">=</span> PageCache.PAGE_SIZE - OF_DATA;<span class="hljs-comment">// 页面最大空闲空间</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] initRaw() &#123;<br>        <span class="hljs-type">byte</span>[] raw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[PageCache.PAGE_SIZE];<br>        setFSO(raw, OF_DATA);<br>        <span class="hljs-keyword">return</span> raw;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> ofData)</span> &#123;<br>        System.arraycopy(Parser.short2Byte(ofData), <span class="hljs-number">0</span>, raw, OF_FREE, OF_DATA);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取pg的FSO</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(Page pg)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFSO(pg.getData());<br>    &#125;<br><span class="hljs-comment">// 获取页面数据row的前两个字节（这两个字节标识空闲位置的起始位置）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>        <span class="hljs-keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中，返回插入位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>        setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset + raw.length));<br>        <span class="hljs-keyword">return</span> offset;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取页面的空闲空间大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFreeSpace</span><span class="hljs-params">(Page pg)</span> &#123;<br>        <span class="hljs-keyword">return</span> PageCache.PAGE_SIZE - (<span class="hljs-type">int</span>)getFSO(pg.getData());<br>    &#125;<br><br>  <span class="hljs-comment">// 下面两个函数在updateLog 和 insertLog 的重做和撤销处理中涉及，用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用</span><br>    <span class="hljs-comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverInsert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br><br>        <span class="hljs-type">short</span> <span class="hljs-variable">rawFSO</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>        <span class="hljs-keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;<br>            setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset+raw.length));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中的offset位置，不更新update</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverUpdate</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="日志文件与恢复策略"><a href="#日志文件与恢复策略" class="headerlink" title="日志文件与恢复策略"></a>日志文件与恢复策略</h2><blockquote><p>MYDB 提供了崩溃后的数据恢复功能。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库崩溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 必要的常量及变量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SEED</span> <span class="hljs-operator">=</span> <span class="hljs-number">13331</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 单条记录Size的起始位置：0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_CHECKSUM</span> <span class="hljs-operator">=</span> OF_SIZE + <span class="hljs-number">4</span>;<span class="hljs-comment">// 单条记录CheckSum起始位置：4</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> OF_CHECKSUM + <span class="hljs-number">4</span>;<span class="hljs-comment">// 单条记录数据起始位置：8</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOG_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.log&quot;</span>;<span class="hljs-comment">// 日志文件后缀</span><br><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-keyword">private</span> Lock lock;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> position;  <span class="hljs-comment">// 当前日志指针的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> fileSize;  <span class="hljs-comment">// 初始化时记录，log操作不更新</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> xChecksum;  <span class="hljs-comment">// 总校验和</span><br></code></pre></td></tr></table></figure><h3 id="日志读写"><a href="#日志读写" class="headerlink" title="日志读写"></a>日志读写</h3><h4 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h4><p>日志的二进制文件，按照如下的格式排布：</p><blockquote><p>[<code>XCheckSum</code>] [<code>Log1</code>] [<code>Log2</code>] [<code>Log3</code>] … [<code>LogN</code>] [<code>BadTail</code>]</p></blockquote><p>其中 <code>XChecksum</code> 是一个四字节的整数int，是<strong>对后续所有日志计算的校验和</strong>。<code>Log1</code> ~ <code>LogN</code> 是常规的日志数据，<code>BadTail</code> 是在数据库崩溃时，<strong>没有来得及写完的日志数据</strong>，这个 <code>BadTail</code> 不一定存在。</p><p>每条日志的格式如下：</p><blockquote><p>[<code>Size</code>] [<code>CheckSum</code>] [<code>Data</code>]</p></blockquote><p>其中，Size 是一个四字节整数int，标识了 <strong>Data 段的字节数</strong>。Checksum 则是<strong>该条日志的校验和int</strong>。单条日志的校验和，其实就是通过一个指定的种子实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calChecksum</span><span class="hljs-params">(<span class="hljs-type">int</span> xCheck, <span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : log) &#123;<br>        xCheck = xCheck * SEED + b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> xCheck;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，对所有日志求出校验和<code>CheckSum</code>，每条校验和再求和（❌）就能得到日志文件的校验和<code>XCheckSum</code>了。</p><blockquote><p>注意，文件里的<code>XCheckSum</code>和每条日志的<code>CheckSum</code>计算对象是不一样的：</p><ul><li><code>XCheckSum</code>是用后续所有日志（包括日志里的<code>size</code>、<code>checkSum</code>、<code>data</code>字段）计算得到的<ul><li><code>XCheckSum</code>是用来保证文件的完整性的，关心的是整个文件，故可以用一整条日志参与计算</li></ul></li><li>每条日志里的<code>CheckSum</code>只用到日志里的<code>data</code>字段计算得到<ul><li>这是因为每条日志里的<code>CheckSum</code>是用来确保当前日志<code>data</code>部分的完整性，故只用<code>data</code>部分计算</li><li>此外，每条日志里的<code>CheckSum</code>的计算也无法用到整条日志进行计算，这是因为整条日志里也包含自身，如果用整条日志计算<code>CheckSum</code>会用到<code>CheckSum</code>自身，这是有问题的</li></ul></li><li>因此<code>XCheckSum</code>  !&#x3D; <code>calChecksum( calChecksum( calChecksum(0, data1), data2), ... dataN)</code></li></ul></blockquote><h4 id="遍历日志文件中的每一条日志"><a href="#遍历日志文件中的每一条日志" class="headerlink" title="遍历日志文件中的每一条日志"></a>遍历日志文件中的每一条日志</h4><p>Logger 被实现成迭代器模式，通过 <code>next()</code> 方法，不断地从文件中<strong>读取下一条日志</strong>，并<strong>将其中的 <code>Data</code> 解析出来并返回</strong>，<code>next()</code> 方法的实现主要依靠 <code>internNext()</code>，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] internNext() &#123;<br>  <span class="hljs-comment">// 位置超出文件大小</span><br>    <span class="hljs-keyword">if</span>(position + OF_DATA &gt;= fileSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取size，读取后position指针向后移动4位，指向checkSum开头</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    fc.position(position);<br>    fc.read(tmp);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Parser.parseInt(tmp.array());<br>    <span class="hljs-keyword">if</span>(position + size + OF_DATA &gt; fileSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取checksum+data，log中包含size+checkSum+data</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(OF_DATA + size);<br>    fc.position(position);<br>    fc.read(buf);<br>    <span class="hljs-type">byte</span>[] log = buf.array();<br><br>    <span class="hljs-comment">// 校验 checksum，确保本条日志的完整性</span><br>  <span class="hljs-comment">// checkSum1:手动计算该条日志的校验和，从log的第8位到最后一位读取</span><br>  <span class="hljs-comment">// checkSum2:从日志数据log中读取该条日志的校验和，从log的4到8位读取</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">checkSum1</span> <span class="hljs-operator">=</span> calChecksum(<span class="hljs-number">0</span>, Arrays.copyOfRange(log, OF_DATA, log.length));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">checkSum2</span> <span class="hljs-operator">=</span> Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));<br>    <span class="hljs-keyword">if</span>(checkSum1 != checkSum2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  <span class="hljs-comment">// position指针位置指向下一条日志</span><br>    position += log.length;<br>  <span class="hljs-comment">// 返回这条日志</span><br>    <span class="hljs-keyword">return</span> log;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="校验日志文件"><a href="#校验日志文件" class="headerlink" title="校验日志文件"></a>校验日志文件</h4><p>在<strong>打开一个日志文件</strong>时，需要首先<strong>校验日志文件</strong>的 <code>XChecksum</code>，并移除文件尾部可能存在的 <code>BadTail</code>，由于 <code>BadTail</code> 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 <code>BadTail</code> 即可保证日志文件的一致性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndRemoveTail</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 设置position为4，也就是XCheckSum后面，第一条日志开头的位置</span><br>    rewind();<br><br>  <span class="hljs-comment">// 对每条日志的!!所有字段!!(区别于一条日志的校验和计算)计算校验和，校验和再求和得到总校验和xCheck</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">xCheck</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">byte</span>[] log = internNext();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        xCheck = calChecksum(xCheck, log);<br>    &#125;<br>  <br>  <span class="hljs-comment">// xCheckSum是从日志文件开头4个字节获得的</span><br>    <span class="hljs-keyword">if</span>(xCheck != xChecksum) &#123;<br>        Panic.panic(Error.BadLogFileException);<br>    &#125;<br><br>    <span class="hljs-comment">// 截断文件到正常日志的末尾</span><br>    truncate(position);<br>  <span class="hljs-comment">// position指针回到起点</span><br>    rewind();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rewind</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算总校验和是用不到它，因为它只返回了日志的数据部分</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] next() &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">byte</span>[] log = internNext();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(log, OF_DATA, log.length);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="写入日志"><a href="#写入日志" class="headerlink" title="写入日志"></a>写入日志</h4><p>向日志文件写入日志时，也是首先<strong>将数据包裹成日志格式</strong>，写入文件后，再<strong>更新文件的校验和</strong>，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>  <span class="hljs-comment">// 将数据包装成日志格式[Size][CheckSum][Data]</span><br>    <span class="hljs-type">byte</span>[] log = wrapLog(data);<br>  <span class="hljs-comment">// 将包装好的一条日志包装成ByteBuffer格式</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(log);<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 将日志写到文件通道中的末尾</span><br>        fc.position(fc.size());<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>  <span class="hljs-comment">// 更新总校验和xCheckSum（这里的log是[Size][CheckSum][Data]这样一整条日志的格式）</span><br>    updateXChecksum(log);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXChecksum</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-built_in">this</span>.xChecksum = calChecksum(<span class="hljs-built_in">this</span>.xChecksum, log);<br>  <span class="hljs-comment">// 将更新后的总校验和xCheckSum写到文件开头4个字节的位置</span><br>    fc.position(<span class="hljs-number">0</span>);<br>    fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));<br>    fc.force(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 在数据前面拼接上Size和CheckSum</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] wrapLog(<span class="hljs-type">byte</span>[] data) &#123;<br>    <span class="hljs-type">byte</span>[] checksum = Parser.int2Byte(calChecksum(<span class="hljs-number">0</span>, data));<br>    <span class="hljs-type">byte</span>[] size = Parser.int2Byte(data.length);<br>    <span class="hljs-keyword">return</span> Bytes.concat(size, checksum, data);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h3><p>DM 为上层模块，提供了两种操作，分别是<strong>插入新数据（I）<strong>和</strong>更新现有数据（U）</strong>。（不包含删除操作）DM 的日志策略很简单，一句话就是：</p><blockquote><p>在进行 I 和 U 操作之前，<strong>必须先进行对应的日志操作</strong>，在保证日志写入磁盘后，才进行数据操作。</p></blockquote><p>这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后<strong>没有来得及同步到磁盘</strong>，<strong>数据库就发生了崩溃</strong>，后续也可以<strong>通过磁盘上的日志恢复该数据</strong>。</p><p>对于两种数据操作，DM 记录的日志如下：</p><ul><li>(Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x</li><li>(Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx</li></ul><p>我们首先不考虑并发的情况，那么在某一时刻，只可能有一个事务在操作数据库。日志会看起来像下面那样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(Ti, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Ti, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), (Tj, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Tj, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), (Tk, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Tk, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>)<br></code></pre></td></tr></table></figure><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下<strong>利用日志恢复</strong>很简单，假设日志中<strong>最后一个事务是 Ti</strong>：</p><ol><li>对 <strong>Ti 之前所有的事务</strong>的日志，进行<strong>重做（redo）</strong></li><li>接着检查 <strong>Ti 的状态（XID 文件）</strong>，如果 Ti 的状态是<strong>已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo）</strong></li></ol><p>接着，是如何对事务 T 进行 <strong>redo</strong>：</p><ol><li><strong>正序扫描</strong>事务 T 的所有日志</li><li>如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置</li><li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx</li></ol><p><strong>undo</strong> 也很好理解：</p><ol><li><strong>倒序扫描</strong>事务 T 的所有日志</li><li>如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除</li><li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx</li></ol><p>注意，MYDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>考虑以下两种情况：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 情况1</span><br><br>T1 <span class="hljs-keyword">begin</span><br>T2 <span class="hljs-keyword">begin</span><br>T2 U(<span class="hljs-variable language_">x</span>)<br>T1 R(<span class="hljs-variable language_">x</span>)<br>...<br>T1 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure><p>在系统崩溃时，T2 仍然是<strong>活跃</strong>状态（active）。那么当数据库重新启动，执行恢复例程时，会<strong>撤销 T2</strong>，它对数据库的影响会被消除。但是<strong>由于 T1 读取了 T2 更新的值</strong>，既然 T2 被撤销，那么 <strong>T1 也应当被撤销</strong>。这种情况，就是<strong>级联回滚Cascading Rollback</strong>。但是，T1 已经 commit 了，所有 commit 的事务的影响，应当被持久化。这里就造成了矛盾。所以这里需要保证：</p><blockquote><p>规定1:正在进行的事务，不会读取其他未提交的事务产生的数据（读提交Read Committed）</p></blockquote><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 情况2，假设x的初值为0</span><br><br>T1 <span class="hljs-keyword">begin</span><br>T2 <span class="hljs-keyword">begin</span><br>T1 set <span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 产生的日志为(T1, U, A, 0, 1)</span><br>T2 set <span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 产生的日志为(T1, U, A, 1, 2)</span><br>T2 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure><p>在系统崩溃时，T1 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，<strong>会对 T1 进行撤销，对 T2 进行重做</strong>，但是，无论撤销和重做的先后顺序如何，x 最后的结果，要么是 0，要么是 2，这都是错误的。</p><blockquote><p>出现这种问题的原因, 归根结底是因为我们的<strong>日志太过简单</strong>, 仅仅记录了**”前相”和”后相”<strong>. 并单纯的</strong>依靠”前相”undo, 依靠”后相”redo.** 这种简单的日志方式和恢复方式, 并不能涵盖住所有数据库操作形成的语义</p></blockquote><p>解决方法有两种：</p><ol><li>增加日志种类</li><li>限制数据库操作</li></ol><p>MYDB 采用的是<strong>限制数据库操作</strong>，需要保证：</p><blockquote><p>规定2：正在进行的事务，<strong>不会修改其他任何未提交的事务修改或产生的数据</strong>。</p></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="两种日志的格式"><a href="#两种日志的格式" class="headerlink" title="两种日志的格式"></a><strong>两种日志的格式</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">LOG_TYPE_INSERT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">LOG_TYPE_UPDATE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// updateLog:</span><br><span class="hljs-comment">// [LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><br><span class="hljs-comment">// insertLog:</span><br><span class="hljs-comment">// [LogType] [XID] [Pgno] [Offset] [Raw]</span><br></code></pre></td></tr></table></figure><p>和原理中描述的类似，recover 例程主要也是两步：<strong>重做所有已完成事务，撤销所有未完成事务</strong></p><h5 id="重做所有已完成事务（committed、aborted）"><a href="#重做所有已完成事务（committed、aborted）" class="headerlink" title="重做所有已完成事务（committed、aborted）"></a><strong>重做所有已完成事务（committed、aborted）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重做所有已完成事务（committed、aborted）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">redoTranscations</span><span class="hljs-params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;<br>  <span class="hljs-comment">// 从第一个事务开始（重做redo要按顺序重做）</span><br>    lg.rewind();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-comment">// 一个一个事务遍历</span><br>        <span class="hljs-type">byte</span>[] log = lg.next();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>          <span class="hljs-comment">// 如果是插入事务</span><br>            <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> li.xid;<br>            <span class="hljs-keyword">if</span>(!tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 事务状态是committed或aborted，重做插入操作</span><br>                doInsertLog(pc, log, REDO);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果是更新事务</span><br>            <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xi.xid;<br>            <span class="hljs-keyword">if</span>(!tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 事务状态是committed或aborted，重做更新操作</span><br>                doUpdateLog(pc, log, REDO);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="撤销所有未完成事务（active）"><a href="#撤销所有未完成事务（active）" class="headerlink" title="撤销所有未完成事务（active）"></a><strong>撤销所有未完成事务（active）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 撤销所有未完成事务（active）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undoTranscations</span><span class="hljs-params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;<br>  <span class="hljs-comment">// 用于记录(要撤回事务的xid，事务xid要撤回的操作列表)，一个事务可能要撤回多个操作，所以要用列表记录</span><br>    Map&lt;Long, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt; logCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    lg.rewind();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">byte</span>[] log = lg.next();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>          <span class="hljs-comment">// 如果是插入事务</span><br>            <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> li.xid;<br>          <span class="hljs-comment">// 事务状态是active</span><br>            <span class="hljs-keyword">if</span>(tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 把事务xid及其要撤回的操作加入到logCache中</span><br>                <span class="hljs-keyword">if</span>(!logCache.containsKey(xid)) &#123;<br>                    logCache.put(xid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                logCache.get(xid).add(log);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果是更新事务</span><br>            <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xi.xid;<br>          <span class="hljs-comment">// 事务状态是active</span><br>            <span class="hljs-keyword">if</span>(tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 把事务xid及其要撤回的操作加入到logCache中</span><br>                <span class="hljs-keyword">if</span>(!logCache.containsKey(xid)) &#123;<br>                    logCache.put(xid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                logCache.get(xid).add(log);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对所有active log进行倒序undo</span><br>    <span class="hljs-keyword">for</span>(Entry&lt;Long, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt; entry : logCache.entrySet()) &#123;<br>        List&lt;<span class="hljs-type">byte</span>[]&gt; logs = entry.getValue();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> logs.size()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-type">byte</span>[] log = logs.get(i);<br>            <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>                doInsertLog(pc, log, UNDO);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                doUpdateLog(pc, log, UNDO);<br>            &#125;<br>        &#125;<br>        tm.abort(entry.getKey());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判读是否是插入事务，否则是更新事务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInsertLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-keyword">return</span> log[<span class="hljs-number">0</span>] == LOG_TYPE_INSERT;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="解析插入事务与更新事务"><a href="#解析插入事务与更新事务" class="headerlink" title="解析插入事务与更新事务"></a><strong>解析插入事务与更新事务</strong></h5><ul><li><strong>解析插入事务日志</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解析插入事务日志 [LogType] [XID] [Pgno] [Offset] [Raw]</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// LogType位置：0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XID</span> <span class="hljs-operator">=</span> OF_TYPE+<span class="hljs-number">1</span>;<span class="hljs-comment">// XID位置：1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_PGNO</span> <span class="hljs-operator">=</span> OF_XID+<span class="hljs-number">8</span>;<span class="hljs-comment">// 插入事务发生的页号位置：9</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_OFFSET</span> <span class="hljs-operator">=</span> OF_INSERT_PGNO+<span class="hljs-number">4</span>;<span class="hljs-comment">// 插入事务发生在页中的位置：13</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_RAW</span> <span class="hljs-operator">=</span> OF_INSERT_OFFSET+<span class="hljs-number">2</span>;<span class="hljs-comment">// 插入数据位置：15</span><br><br><span class="hljs-comment">// 插入事务日志信息</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertLogInfo</span> &#123;<br>    <span class="hljs-type">long</span> xid;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] raw;<br>&#125;<br><br><span class="hljs-comment">// 解析插入事务日志</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InsertLogInfo <span class="hljs-title function_">parseInsertLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsertLogInfo</span>();<br>    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_INSERT_PGNO));<br>    li.pgno = Parser.parseInt(Arrays.copyOfRange(log, OF_INSERT_PGNO, OF_INSERT_OFFSET));<br>    li.offset = Parser.parseShort(Arrays.copyOfRange(log, OF_INSERT_OFFSET, OF_INSERT_RAW));<br>    li.raw = Arrays.copyOfRange(log, OF_INSERT_RAW, log.length);<br>    <span class="hljs-keyword">return</span> li;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析更新事务日志</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解析更新事务日志 [LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_UPDATE_UID</span> <span class="hljs-operator">=</span> OF_XID+<span class="hljs-number">8</span>;<span class="hljs-comment">// UID位置：9</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_UPDATE_RAW</span> <span class="hljs-operator">=</span> OF_UPDATE_UID+<span class="hljs-number">8</span>;<span class="hljs-comment">// 更新数据位置：17</span><br><br><span class="hljs-comment">// 更新事务日志信息</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateLogInfo</span> &#123;<br>    <span class="hljs-type">long</span> xid;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] oldRaw;<br>    <span class="hljs-type">byte</span>[] newRaw;<br>&#125;<br><br><span class="hljs-comment">// 解析更新事务日志</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UpdateLogInfo <span class="hljs-title function_">parseUpdateLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateLogInfo</span>();<br>    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_UPDATE_UID));<br>    <span class="hljs-type">long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> Parser.parseLong(Arrays.copyOfRange(log, OF_UPDATE_UID, OF_UPDATE_RAW));<br>    li.offset = (<span class="hljs-type">short</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">16</span>) - <span class="hljs-number">1</span>));<br>    uid &gt;&gt;&gt;= <span class="hljs-number">32</span>;<br>    li.pgno = (<span class="hljs-type">int</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (log.length - OF_UPDATE_RAW) / <span class="hljs-number">2</span>;<br>    li.oldRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW, OF_UPDATE_RAW+length);<br>    li.newRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW+length, OF_UPDATE_RAW+length*<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> li;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="updateLog-和-insertLog-的重做和撤销处理"><a href="#updateLog-和-insertLog-的重做和撤销处理" class="headerlink" title="updateLog 和 insertLog 的重做和撤销处理"></a><strong>updateLog 和 insertLog 的重做和撤销处理</strong></h5><p>updateLog 和 insertLog 的重做和撤销处理，分别合并为一个方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// updateLog的重做和撤销处理</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doUpdateLog</span><span class="hljs-params">(PageCache pc, <span class="hljs-type">byte</span>[] log, <span class="hljs-type">int</span> flag)</span> &#123;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] raw;<br>    <span class="hljs-keyword">if</span>(flag == REDO) &#123;<br>      <span class="hljs-comment">// 重做</span><br>        <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>        pgno = xi.pgno;<br>        offset = xi.offset;<br>        raw = xi.newRaw;<span class="hljs-comment">// 重做要设置数据到最新</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 撤销</span><br>        <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>        pgno = xi.pgno;<br>        offset = xi.offset;<br>        raw = xi.oldRaw;<span class="hljs-comment">// 撤销要设置数据到久版本</span><br>    &#125;<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(pgno);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 见普通页部分</span><br>        PageX.recoverUpdate(pg, raw, offset);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        pg.release();<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// insertLog的重做和撤销操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInsertLog</span><span class="hljs-params">(PageCache pc, <span class="hljs-type">byte</span>[] log, <span class="hljs-type">int</span> flag)</span> &#123;<br>    <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(li.pgno);<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(flag == UNDO) &#123;<br>          <span class="hljs-comment">// 撤销插入，逻辑删除，大致的作用，就是将该条 DataItem 的有效位设置为无效，来进行逻辑删除。</span><br>            DataItem.setDataItemRawInvalid(li.raw);<br>        &#125;<br>      <span class="hljs-comment">// 见普通页部分</span><br>        PageX.recoverInsert(pg, li.raw, li.offset);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        pg.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="页面索引与DM的实现"><a href="#页面索引与DM的实现" class="headerlink" title="页面索引与DM的实现"></a>页面索引与DM的实现</h2><blockquote><p>本节将为 DM 层做收尾，介绍一个实现简单的页面索引。并且实现了 DM 层对于上层的抽象：DataItem。</p></blockquote><h3 id="页面索引"><a href="#页面索引" class="headerlink" title="页面索引"></a>页面索引</h3><p>页面索引，<strong>缓存了每一页的空闲空间</strong>。用于在上层模块进行插入操作时，能够快速找到一个合适空间的页面，而<strong>无需从磁盘或者缓存中检查每一个页面的信息</strong>。</p><p>MYDB 用一个比较粗略的算法实现了页面索引，将一页的空间划分成了 <strong>40 个区间</strong>。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这 40 个区间中。insert 在请求一个页时，会首先将所需的空间<strong>向上取整</strong>，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。</p><p><code>PageIndex</code> 的实现也很简单，一个 List 类型的数组。</p><blockquote><p><code>lists</code>的作用是将页面信息根据页面的剩余空间分组存储，<code>THRESHOLD</code> &#x3D; 8192 &#x2F; 40 &#x3D; 204.8，这意味着，页面的剩余空间将被按大约 <strong>204.8 字节</strong>划分成多个区间，每个页面的剩余空间将根据这个阈值来计算自己属于哪个区间，并将自己的页面信息PageInfo放到对应的<code>list</code>下。打个比方：</p><ul><li>如果页面的<strong>剩余空间是 500 字节</strong>，那么它将**被划分到 500 &#x2F; 204.8 ≈ 2 的区间中（即 lists[2]）。**此时如果有一个数据，大小在 <code>[1 * 204.8, 2 * 204.8] </code>之间，那么他就会先到lists[2]中找到这个页面，并将数据保存在这个页面。</li><li>如果剩余空间是 1500 字节，那么它将被划分到 1500 &#x2F; 204.8 ≈ 7 的区间中（即 lists[7]）。</li><li>如果有多个页面，它们的<strong>剩余空间都在同一个区间内</strong>，那就会<strong>放在同一个<code>list</code>中</strong>，要取的时候，从列表头取起。</li><li>通过这个操作，要保存数据的时候就不用到磁盘中去一个个找哪个页面能够容纳这个数据，直接在<code>PageIndex</code>中就能够知道哪一页是能容纳该数据的。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageIndex</span> &#123;<br>    <span class="hljs-comment">// 将一页划成40个区间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERVALS_NO</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br>  <span class="hljs-comment">// 一个区间的大小，8192 / 40 = 204.8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> PageCache.PAGE_SIZE / INTERVALS_NO;<br><br>    <span class="hljs-keyword">private</span> Lock lock;<br>  <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">private</span> List&lt;PageInfo&gt;[] lists;<br>  <br>  <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PageIndex</span><span class="hljs-params">()</span> &#123;<br>        lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[INTERVALS_NO+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; INTERVALS_NO+<span class="hljs-number">1</span>; i ++) &#123;<br>            lists[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageInfo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> freeSpace;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PageInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno, <span class="hljs-type">int</span> freeSpace)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pgno = pgno;<br>        <span class="hljs-built_in">this</span>.freeSpace = freeSpace;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当来了一个大小为<code>spaceSize</code>的数据要保存到页面时，使用<code>select()</code>方法，直接算出区间号，直接取即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> PageInfo <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> spaceSize)</span> &#123;<br>  <span class="hljs-comment">// 计算哪个区间内的页面能容纳该数据（大于number的list中包含能容纳该数据的页面）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> spaceSize / THRESHOLD;<br>    <span class="hljs-keyword">if</span>(number &lt; INTERVALS_NO) number ++;<br>    <span class="hljs-keyword">while</span>(number &lt;= INTERVALS_NO) &#123;<br>      <span class="hljs-comment">// lists[number]中没有页面，那就往下找</span><br>        <span class="hljs-keyword">if</span>(lists[number].size() == <span class="hljs-number">0</span>) &#123;<br>            number ++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>      <span class="hljs-comment">// 找到一个符合的页面，返回页面信息PageInfo，并将该页从list中移除</span><br>        <span class="hljs-keyword">return</span> lists[number].remove(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以注意到，被选择的页，会<strong>直接从 <code>PageIndex</code> 中移除</strong>，这意味着，<strong>同一个页面是不允许并发写的</strong>。在上层模块使用完这个页面后，需要将其重新插入 <code>PageIndex</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno, <span class="hljs-type">int</span> freeSpace)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> freeSpace / THRESHOLD;<br>    lists[number].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>(pgno, freeSpace));<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>DataManager</code> 被创建时，需要获取所有页面并填充 <code>PageIndex</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化pageIndex</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">fillPageIndex</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageNumber</span> <span class="hljs-operator">=</span> pc.getPageNumber();<br>  <span class="hljs-comment">// 第一页用于启动检查，页面从1开始，故int i = 2</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= pageNumber; i ++) &#123;<br>        <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// getPage调用了AbstractCache中get方法，调用这个方法会先到缓存（HashMap cache）中找对应页号i的页面，若没有再到数据源（文件系统）找</span><br>            pg = pc.getPage(i);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>      <span class="hljs-comment">// 将对应的页面信息添加到PageIndex中</span><br>        pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));<br>      <span class="hljs-comment">// 注意在使用完 Page 后需要及时 release，否则可能会撑爆缓存</span><br>        pg.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DataItem"><a href="#DataItem" class="headerlink" title="DataItem"></a>DataItem</h3><p><code>DataItem</code>是 DM 层<strong>向上层提供的数据抽象</strong>。上层模块通过地址，向 DM 请求到对应的 <code>DataItem</code>，再获取到其中的数据。<code>DataItem</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dataItem 结构如下：</span><br><span class="hljs-comment"> * [ValidFlag] [DataSize] [Data]</span><br><span class="hljs-comment"> * ValidFlag 1字节，0为合法，1为非法</span><br><span class="hljs-comment"> * DataSize  2字节，标识Data的长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataItemImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataItem</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_VALID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">private</span> SubArray raw;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] oldRaw;<br>    <span class="hljs-keyword">private</span> Lock rLock;<br>    <span class="hljs-keyword">private</span> Lock wLock;<br>    <span class="hljs-keyword">private</span> DataManagerImpl dm;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> uid;<br>    <span class="hljs-keyword">private</span> Page pg;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] raw;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> start;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SubArray</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-built_in">this</span>.raw = raw;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>DataItem</code>中<code>SubArray raw</code>的大概意思：</p><ul><li>因为数据都是放在页面里的，取数据的时候也是按页为单位取的，故**<code>raw.raw</code>一般表示的是数据所在页那一整页的数据**</li><li>所以**<code>raw.start</code>表示的是<code>DataItem</code>所表示的数据在这一页中的起始位置**（偏移<code>offset</code>）</li></ul></blockquote><p>DataItem 中保存的数据，结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[ValidFlag]</span> <span class="hljs-selector-attr">[DataSize]</span> <span class="hljs-selector-attr">[Data]</span><br></code></pre></td></tr></table></figure><p>其中 <code>ValidFlag</code> 占用 1 字节，<strong>标识了该 <code>DataItem</code> 是否有效</strong>。<strong>删除一个 <code>DataItem</code>，只需要简单地将其有效位设置为 1</strong>。<code>DataSize</code> 占用 2 字节，标识了后面 <code>Data</code> 的长度。</p><blockquote><p>根据上面<code>DataItem</code>的结构，我们有：</p><ul><li><code>offset = raw.start</code></li><li><code>ValidFlag = raw.raw[offset + OF_VALID]</code></li><li><code>DataSize = Parser.parseShort(Arrays.copyOfRange(raw, offset+DataItemImpl.OF_SIZE, offset+DataItemImpl.OF_DATA))</code></li></ul></blockquote><p>上层模块在获取到 <code>DataItem</code> 后，可以通过 <code>data()</code> 方法，该方法返回的数组是数据共享的，而不是拷贝实现的，所以使用了 <code>SubArray</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SubArray <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(raw.raw, raw.start+OF_DATA, raw.end);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上层模块试图对 <code>DataItem</code> 进行修改时，需要遵循一定的流程：在<strong>修改之前</strong>需要调用 <code>before()</code> 方法，想要<strong>撤销修改</strong>时，调用 <code>unBefore()</code> 方法，在<strong>修改完成</strong>后，调用 <code>after()</code> 方法。整个流程，<strong>主要是为了保存前相数据，并及时落日志</strong>。DM 会保证对 <code>DataItem</code> 的修改是原子性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>    wLock.lock();<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    System.arraycopy(raw.raw, raw.start, oldRaw, <span class="hljs-number">0</span>, oldRaw.length);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unBefore</span><span class="hljs-params">()</span> &#123;<br>    System.arraycopy(oldRaw, <span class="hljs-number">0</span>, raw.raw, raw.start, oldRaw.length);<br>    wLock.unlock();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>  <span class="hljs-comment">// 调用 dm 中的一个方法，对修改操作落日志</span><br>    dm.logDataItem(xid, <span class="hljs-built_in">this</span>);<br>    wLock.unlock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> raw.raw[raw.start+OF_VALID] == (<span class="hljs-type">byte</span>)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用完 <code>DataItem</code> 后，也应当及时调用 <code>release()</code>方法，释放掉 <code>DataItem</code> 的缓存（由 DM 缓存 <code>DataItem</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    dm.releaseDataItem(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DM的实现"><a href="#DM的实现" class="headerlink" title="DM的实现"></a>DM的实现</h3><h4 id="DM读取、释放数据DataItem"><a href="#DM读取、释放数据DataItem" class="headerlink" title="DM读取、释放数据DataItem"></a>DM读取、释放数据DataItem</h4><p><code>DataManager</code> 是 DM 层直接对外提供方法的类，同时，也实现成 <code>DataItem</code> 对象的<strong>缓存</strong>，继承<code>AbstractCache</code>。<code>DataItem</code> 存储的 <strong>key</strong>，是<strong>由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4 字节</strong>。</p><p>DataItem 缓存，<code>getForCache()</code>，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> DataItem <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">16</span>) - <span class="hljs-number">1</span>));<br>    uid &gt;&gt;&gt;= <span class="hljs-number">32</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>));<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> pc.getPage(pgno);<br>    <span class="hljs-keyword">return</span> DataItem.parseDataItem(pg, offset, <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 从页面的offset处解析处DataItem</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataItem <span class="hljs-title function_">parseDataItem</span><span class="hljs-params">(Page pg, <span class="hljs-type">short</span> offset, DataManagerImpl dm)</span> &#123;<br>  <span class="hljs-comment">// 获取这个页面的所有数据</span><br>    <span class="hljs-type">byte</span>[] raw = pg.getData();<br>  <span class="hljs-comment">// 获取这个DataItem的Data字段的长度</span><br>    <span class="hljs-type">short</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Parser.parseShort(Arrays.copyOfRange(raw, offset+DataItemImpl.OF_SIZE, offset+DataItemImpl.OF_DATA));<br>  <span class="hljs-comment">// 获取这个DataItem总长度，则这个DataItem在这个页面中的范围是[offset， offset + length]</span><br>    <span class="hljs-type">short</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(size + DataItemImpl.OF_DATA);<br>  <span class="hljs-comment">// 获取这个DataItem的uid</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> Types.addressToUid(pg.getPageNumber(), offset);<br>  <span class="hljs-comment">// 拼装成一个DataItem返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataItemImpl</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(raw, offset, offset+length), <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length], pg, uid, dm);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DataItem</code> 缓存释放，需要将 <code>DataItem</code> 写回数据源，由于对文件的读写是以页为单位进行的，只需要<strong>将 <code>DataItem</code> 所在的页 release</strong> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(DataItem di)</span> &#123;<br>    di.page().release();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DM的创建与打开"><a href="#DM的创建与打开" class="headerlink" title="DM的创建与打开"></a>DM的创建与打开</h4><p>从<strong>已有文件</strong>创建 <code>DataManager</code> 和从<strong>空文件</strong>创建 <code>DataManager</code> 的流程稍有不同，除了 PageCache 和 Logger 的创建方式有所不同以外，从<strong>空文件创建首先需要对第一页进行初始化</strong>，而<strong>从已有文件创建，则是需要对第一页进行校验</strong>，来判断是否需要执行恢复流程。并重新对第一页生成随机字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataManager <span class="hljs-title function_">create</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem, TransactionManager tm)</span> &#123;<br>    <span class="hljs-type">PageCache</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> PageCache.create(path, mem);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> Logger.create(path);<br>    <span class="hljs-type">DataManagerImpl</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataManagerImpl</span>(pc, lg, tm);<br>    dm.initPageOne();<br>    <span class="hljs-keyword">return</span> dm;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataManager <span class="hljs-title function_">open</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem, TransactionManager tm)</span> &#123;<br>    <span class="hljs-type">PageCache</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> PageCache.open(path, mem);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> Logger.open(path);<br>    <span class="hljs-type">DataManagerImpl</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataManagerImpl</span>(pc, lg, tm);<br>    <span class="hljs-keyword">if</span>(!dm.loadCheckPageOne()) &#123;<br>        Recover.recover(tm, lg, pc);<br>    &#125;<br>    dm.fillPageIndex();<br>    PageOne.setVcOpen(dm.pageOne);<br>    dm.pc.flushPage(dm.pageOne);<br>    <span class="hljs-keyword">return</span> dm;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，初始化第一页，和校验第一页，基本都是调用 PageOne 类中的方法实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在创建文件时初始化PageOne</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">initPageOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pc.newPage(PageOne.InitRaw());<br>    <span class="hljs-keyword">assert</span> pgno == <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pageOne = pc.getPage(pgno);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    pc.flushPage(pageOne);<br>&#125;<br><br><span class="hljs-comment">// 在打开已有文件时时读入PageOne，并验证正确性</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">loadCheckPageOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pageOne = pc.getPage(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> PageOne.checkVc(pageOne);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DM读、插入数据"><a href="#DM读、插入数据" class="headerlink" title="DM读、插入数据"></a>DM读、插入数据</h4><p>DM 层提供了三个功能<strong>供上层使用</strong>，分别是读、插入和修改。修改是通过读出的 <code>DataItem</code> 实现的，于是 <code>DataManager</code> 只需要提供 <code>read()</code> 和 <code>insert()</code> 方法。</p><ul><li><code>read()</code> 根据 UID 从缓存中获取 DataItem，并校验有效位：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> DataItem <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DataItemImpl</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> (DataItemImpl)<span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">if</span>(!di.isValid()) &#123;<br>        di.release();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> di;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>insert()</code> 方法，在 <code>pageIndex</code> 中获取一个<strong>足以存储插入内容的页面的页号</strong>，获取页面后，<strong>首先需要写入插入日志</strong>，接着才可以<strong>通过 pageX 插入数据</strong>，并返回插入位置的偏移。最后需要<strong>将页面信息重新插入 pageIndex</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] wrapDataItemRaw(<span class="hljs-type">byte</span>[] raw) &#123;<br>    <span class="hljs-type">byte</span>[] valid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span>];<span class="hljs-comment">// 起始默认值为0，表示合法</span><br>    <span class="hljs-type">byte</span>[] size = Parser.short2Byte((<span class="hljs-type">short</span>)raw.length);<br>    <span class="hljs-keyword">return</span> Bytes.concat(valid, size, raw);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// 包装成DataItem</span><br>    <span class="hljs-type">byte</span>[] raw = DataItem.wrapDataItemRaw(data);<br>    <span class="hljs-keyword">if</span>(raw.length &gt; PageX.MAX_FREE_SPACE) &#123;<br>        <span class="hljs-keyword">throw</span> Error.DataTooLargeException;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试获取可用页</span><br>    <span class="hljs-type">PageInfo</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) &#123;<br>        pi = pIndex.select(raw.length);<br>        <span class="hljs-keyword">if</span> (pi != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newPgno</span> <span class="hljs-operator">=</span> pc.newPage(PageX.initRaw());<br>            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pi == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> Error.DatabaseBusyException;<br>    &#125;<br><br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">freeSpace</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(pi.pgno);<br>        <span class="hljs-comment">// 首先做日志</span><br>        <span class="hljs-type">byte</span>[] log = Recover.insertLog(xid, pg, raw);<br>        logger.log(log);<br>        <span class="hljs-comment">// 再执行插入操作</span><br>        <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageX.insert(pg, raw);<br><br>        pg.release();<br>        <span class="hljs-keyword">return</span> Types.addressToUid(pi.pgno, offset);<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 将取出的pg重新插入pIndex</span><br>        <span class="hljs-keyword">if</span>(pg != <span class="hljs-literal">null</span>) &#123;<br>            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pIndex.add(pi.pgno, freeSpace);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DM的关闭"><a href="#DM的关闭" class="headerlink" title="DM的关闭"></a>DM的关闭</h4><p><code>DataManager</code> 正常关闭时，需要执行缓存和日志的关闭流程，不要忘了设置<strong>第一页的字节校验</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// DataManager缓存关闭</span><br>    <span class="hljs-built_in">super</span>.close();<br>  <span class="hljs-comment">// 日志关闭</span><br>    logger.close();<br><br>  <br>  <span class="hljs-comment">// 第一页的字节校验</span><br>    PageOne.setVcClose(pageOne);<br>    pageOne.release();<br>  <span class="hljs-comment">// 页面缓存关闭</span><br>    pc.close();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-Version-Manager"><a href="#4-Version-Manager" class="headerlink" title="4. Version Manager"></a>4. Version Manager</h1><blockquote><p>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。类似于 Data Manager 是 MYDB 的数据管理核心，Version Manager 是 MYDB 的<strong>事务和数据版本的管理核心</strong>。</p></blockquote><h2 id="2PL与MVCC"><a href="#2PL与MVCC" class="headerlink" title="2PL与MVCC"></a>2PL与MVCC</h2><h3 id="冲突与2PL"><a href="#冲突与2PL" class="headerlink" title="冲突与2PL"></a>冲突与2PL</h3><p>首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这<strong>两个操作相互冲突</strong>：</p><ol><li>这两个操作是由不同的事务执行的</li><li>这两个操作操作的是同一个数据项</li><li>这两个操作至少有一个是更新操作</li></ol><p>那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：</p><ol><li>两个不同事务的 U 操作冲突</li><li>两个不同事务的 U、R 操作冲突</li></ol><p>那么冲突或者不冲突，意义何在？作用在于，<strong>交换两个互不冲突的操作的顺序，不会对最终的结果造成影响</strong>，而交换两个冲突操作的顺序，则是会有影响的。 </p><p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。<strong>MYDB 采用两段锁协议（2PL）来实现。<strong>当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作</strong>相互冲突</strong>的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的<strong>读或者写操作都会被阻塞</strong>，T2 必须等待 T1 释放掉对 x 的锁。</p><p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了<strong>事务间的相互阻塞</strong>，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>在介绍 MVCC 之前，首先明确记录和版本的概念。</p><p>DM 层向上层提供了数据项（<code>DataItem</code>）的概念，VM 通过管理所有的数据项，向上层提供了记录（<code>Entry</code>）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（<code>Version</code>）。每当上层模块对某个记录进行修改时，VM 就会为这个记录<strong>创建一个新的版本</strong>。</p><p>MYDB 通过 MVCC，<strong>降低了事务的阻塞概率</strong>。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是<strong>创建了一个新的 X 的版本，假设为 x3</strong>。假设 T1 <strong>还没有释放</strong> X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会<strong>返回一个较老版本的 X，例如 x2</strong>。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X <strong>没有一个更老的版本</strong>，那<strong>只能等待 T1 释放锁</strong>了。所以只是<strong>降低了概率</strong>。</p><h2 id="记录的实现"><a href="#记录的实现" class="headerlink" title="记录的实现"></a>记录的实现</h2><p>对于一条记录来说，MYDB 使用 <code>Entry</code> 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 <code>Update</code> 操作，对于字段的<strong>更新操作由后面的表和字段管理（TBM）实现</strong>。所以在 VM 的实现中，一条记录只有一个版本。</p><p>一条记录存储在一条 <code>DataItem</code> 中，所以 <code>Entry</code> 中保存一个 <code>DataItem</code> 的引用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM向上层抽象出entry</span><br><span class="hljs-comment"> * entry结构：</span><br><span class="hljs-comment"> * [XMIN] [XMAX] [data]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XMIN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// entry XMIN的起始位置：0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XMAX</span> <span class="hljs-operator">=</span> OF_XMIN+<span class="hljs-number">8</span>;<span class="hljs-comment">// entry XMAX的起始位置：8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> OF_XMAX+<span class="hljs-number">8</span>;<span class="hljs-comment">// 注意⚠️，这里的OF_DATA=16要和DataItemImpl中的OF_DATA=3区分开来</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> uid;<br>    <span class="hljs-keyword">private</span> DataItem dataItem;<br>    <span class="hljs-keyword">private</span> VersionManager vm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title function_">loadEntry</span><span class="hljs-params">(VersionManager vm, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DataItem</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);<br>        <span class="hljs-keyword">return</span> newEntry(vm, di, uid);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        dataItem.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们规定，一条 <code>Entry</code> 中存储的数据格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">// XMIN和XMAX都是一个<span class="hljs-number">8</span>字节的byte<span class="hljs-selector-attr">[]</span><br><span class="hljs-selector-attr">[XMIN]</span> <span class="hljs-selector-attr">[XMAX]</span> <span class="hljs-selector-attr">[DATA]</span><br></code></pre></td></tr></table></figure><p><code>XMIN</code> 是<strong>创建该条记录（版本）的事务编号</strong>，而 <code>XMAX</code> 则是<strong>删除该条记录（版本）的事务编号</strong>。它们的作用将在下一节中说明。<code>DATA</code> 就是<strong>这条记录持有的数据</strong>。根据这个结构，在<strong>创建记录</strong>时调用的 <code>wrapEntryRaw()</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] wrapEntryRaw(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data) &#123;<br>    <span class="hljs-type">byte</span>[] xmin = Parser.long2Byte(xid);<br>    <span class="hljs-type">byte</span>[] xmax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">return</span> Bytes.concat(xmin, xmax, data);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，如果要<strong>获取记录中持有的数据</strong>，也就需要按照这个结构来解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以拷贝的形式返回内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] data() &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 从DataItem中取出数据部分：也就是除去VaildFlag和DataSize后面的数据部分，也是一个SubArray</span><br>        <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> dataItem.data();<br>      <span class="hljs-comment">// 取出来的数据sa也被分为[XMIN] [XMAX] [DATA]的结构，这里的OF_DATA=16</span><br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[sa.end - sa.start - OF_DATA];<br>        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="hljs-number">0</span>, data.length);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里以拷贝的形式返回数据，如果需要修改的话，需要对 <code>DataItem</code> 执行 <code>before()</code> 方法，这个在设置 <code>XMAX</code> 的值中体现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setXmax</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    dataItem.before();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> dataItem.data();<br>      <span class="hljs-comment">// 将sa的XMAX部分修改为当前的xid</span><br>        System.arraycopy(Parser.long2Byte(xid), <span class="hljs-number">0</span>, sa.raw, sa.start+OF_XMAX, <span class="hljs-number">8</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.after(xid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="读提交（Read-Committed-RC）"><a href="#读提交（Read-Committed-RC）" class="headerlink" title="读提交（Read Committed, RC）"></a>读提交（Read Committed, RC）</h3><p>上面提到，如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，MYDB 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是<strong>版本可见性</strong>的概念就诞生了。</p><p>版本的可见性与事务的隔离度是相关的。MYDB 支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。</p><p>MYDB 实现读提交，为每个版本维护了两个变量，就是上面提到的 <code>XMIN</code>和 <code>XMAX</code>：</p><ul><li><code>XMIN</code>：创建该版本的事务编号</li><li><code>XMAX</code>：删除该版本的事务编号</li></ul><p><strong><code>XMIN</code> 应当在版本创建时填写，而 <code>XMAX</code> 则在版本被删除，或者有新版本出现时填写。</strong></p><p><code>XMAX</code> 这个变量，也就解释了为什么 DM 层不提供删除操作，<strong>当想删除一个版本时，只需要设置其 <code>XMAX</code></strong>，这样，<strong>这个版本对每一个 <code>XMAX</code> 之后的事务都是不可见的</strong>，也就等价于删除了。</p><p>如此，在读提交下，版本对事务的可见性逻辑如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 对于当前事务Ti，当如下逻辑判断为true时，该版本对当前事务Ti可见</span><br><br>(XMIN == Ti <span class="hljs-keyword">and</span>                             <span class="hljs-comment">// 由Ti创建且</span><br>    XMAX == NULL                            <span class="hljs-comment">// 还未被删除</span><br>)<br><span class="hljs-symbol">or</span>                                          <span class="hljs-comment">// 或</span><br>(XMIN is commited <span class="hljs-keyword">and</span>                       <span class="hljs-comment">// 由一个已提交的事务创建且</span><br>    (XMAX == NULL or                        <span class="hljs-comment">// 尚未删除或</span><br>    (XMAX != Ti <span class="hljs-keyword">and</span> XMAX is not commited)   <span class="hljs-comment">// 由一个未提交的事务删除</span><br>    )<br>)<br></code></pre></td></tr></table></figure><p>若条件为 true，则版本对 Ti 可见。那么获取 Ti 适合的版本，只需要<strong>从最新版本开始，依次向前检查可见性</strong>，如果为 true，就可以直接返回。以下方法判断某个记录对事务 t 是否可见：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readCommitted</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>  <span class="hljs-comment">// 当前事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> t.xid;<br>  <span class="hljs-comment">// 该条记录的XMIN，即创建该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmin</span> <span class="hljs-operator">=</span> e.getXmin();<br>  <span class="hljs-comment">// 该条记录的XMAX，即删除该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  <br>  <span class="hljs-comment">// 该记录由当前事务创建，且还未被删除，则对当前事务可见</span><br>    <span class="hljs-keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 该记录由一条已提交事务创建</span><br>    <span class="hljs-keyword">if</span>(tm.isCommitted(xmin)) &#123;<br>      <span class="hljs-comment">// 该记录还未被删除，则对当前事务可见</span><br>        <span class="hljs-keyword">if</span>(xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 该记录已被删除，但不是当前事务删除的，且删除这条记录的事务还没提交，则对当前事务可见</span><br>        <span class="hljs-keyword">if</span>(xmax != xid) &#123;<br>            <span class="hljs-keyword">if</span>(!tm.isCommitted(xmax)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">// 对当前事务不可见</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可重复读（Repeatable-Read-RR）"><a href="#可重复读（Repeatable-Read-RR）" class="headerlink" title="可重复读（Repeatable Read, RR）"></a>可重复读（Repeatable Read, RR）</h3><p>读提交会导致的问题大家也都很清楚，八股也背了不少。那就是不可重复读和幻读。这里我们来解决<strong>不可重复读</strong>的问题。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">T1 begin<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1 读得 0</span><br>T2 begin<br><span class="hljs-function"><span class="hljs-title">U2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// 将 X 修改为 1</span><br>T2 commit<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1 读的 1</span><br></code></pre></td></tr></table></figure><p>T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定：</p><blockquote><p>事务只能读取<strong>它开始时, 就已经结束的那些事务产生的数据版本</strong></p></blockquote><p>这条规定，相当于，事务需要<strong>忽略</strong>：</p><ol><li>在<strong>本事务后开始的事务的数据</strong>;</li><li><strong>本事务开始时还是 active 状态的事务的数据</strong></li></ol><p>对于第一条，只需要<strong>比较事务 ID，即可确定，因为事务ID是自增的</strong>。而对于第二条，则需要在<strong>事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)</strong>，如果记录的某个版本，XMIN 在 SP(Ti) 中，说明<strong>创建这个版本记录的事务，在当前事务开始时处于active状态</strong>，也应当对 Ti 不可见。于是，可重复读的判断逻辑如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 对于当前事务Ti，当如下逻辑判断为true时，该版本对当前事务Ti可见</span><br><br>(XMIN == Ti <span class="hljs-keyword">and</span>                 <span class="hljs-comment">// 由Ti创建且</span><br> (XMAX == NULL)                 <span class="hljs-comment">// 尚未被删除</span><br>)<br><span class="hljs-symbol">or</span>                              <span class="hljs-comment">// 或</span><br>(XMIN is commited <span class="hljs-keyword">and</span>           <span class="hljs-comment">// 由一个已提交的事务创建且</span><br> XMIN &lt; XID <span class="hljs-keyword">and</span>                 <span class="hljs-comment">// 这个事务小于Ti且</span><br> XMIN is not in <span class="hljs-built_in">SP</span>(Ti) <span class="hljs-keyword">and</span>      <span class="hljs-comment">// 这个事务在Ti开始前提交且</span><br> (XMAX == NULL or               <span class="hljs-comment">// 尚未被删除或</span><br>  (XMAX != Ti <span class="hljs-keyword">and</span>               <span class="hljs-comment">// 由其他事务删除但是</span><br>   (XMAX is not commited or     <span class="hljs-comment">// 这个事务尚未提交或</span><br><span class="hljs-symbol">XMAX</span> &gt; Ti or                    <span class="hljs-comment">// 这个事务在Ti开始之后才开始或</span><br><span class="hljs-symbol">XMAX</span> is in <span class="hljs-built_in">SP</span>(Ti)               <span class="hljs-comment">// 这个事务在Ti开始前还未提交</span><br>))))<br></code></pre></td></tr></table></figure><p>于是，需要提供一个结构，来抽象一个事务，以保存<strong>快照数据</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> xid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> level;<br>  <span class="hljs-comment">// snapshot用来保存活跃事务id</span><br>    <span class="hljs-keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;<br>    <span class="hljs-keyword">public</span> Exception err;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> autoAborted;<br><br>  <span class="hljs-comment">// 构造方法，active保存着当前所有状态为active的事务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Transaction <span class="hljs-title function_">newTransaction</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;<br>        <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transaction</span>();<br>        t.xid = xid;<br>        t.level = level;<br>      <span class="hljs-comment">// 如果是可重复读隔离级别，会将当前处于active的事务id保存到snapshot中</span><br>        <span class="hljs-keyword">if</span>(level != <span class="hljs-number">0</span>) &#123;<br>            t.snapshot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(Long x : active.keySet()) &#123;<br>                t.snapshot.put(x, <span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInSnapshot</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>        <span class="hljs-keyword">if</span>(xid == TransactionManagerImpl.SUPER_XID) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> snapshot.containsKey(xid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是，可重复读的隔离级别下，一个版本是否对事务可见的判断如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatableRead</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>  <span class="hljs-comment">// 当前事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> t.xid;<br>  <span class="hljs-comment">// 创建该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmin</span> <span class="hljs-operator">=</span> e.getXmin();<br>  <span class="hljs-comment">// 删除该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  <span class="hljs-comment">// 当前事务创建了该记录 且 该记录还没被删除</span><br>    <span class="hljs-keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 创建该记录的事务已提交 且 创建该记录的事务比当前事务早 且 当前事务创建时，创建该记录的事务不处于active状态</span><br>    <span class="hljs-keyword">if</span>(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;<br>      <span class="hljs-comment">// 该记录还未被删除</span><br>        <span class="hljs-keyword">if</span>(xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 该记录被删除，但不是当前事务删除的</span><br>        <span class="hljs-keyword">if</span>(xmax != xid) &#123;<br>          <span class="hljs-comment">// 删除该记录的事务未提交 或 删除该记录的事务比当前事务晚 或 当前事务创建时，删除该记录的事务处于active状态</span><br>            <span class="hljs-keyword">if</span>(!tm.isCommitted(xmax) || xmax &gt; xid || t.isInSnapshot(xmax)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="版本跳跃问题"><a href="#版本跳跃问题" class="headerlink" title="版本跳跃问题"></a>版本跳跃问题</h2><p>版本跳跃问题，考虑如下的情况，假设 X 最初只有 x0 版本，T1 和 T2 都是可重复读的隔离级别：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">T1 begin<br>T2 begin<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1读取x0</span><br><span class="hljs-function"><span class="hljs-title">R2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T2读取x0</span><br><span class="hljs-function"><span class="hljs-title">U1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1将X更新到x1</span><br>T1 commit<br><span class="hljs-function"><span class="hljs-title">U2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T2将X更新到x2</span><br>T2 commit<br></code></pre></td></tr></table></figure><p>这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 <strong>T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本</strong>。</p><p>**读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。**解决版本跳跃的思路也很简单：<strong>如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚</strong>。</p><p>上一节中就总结了，<strong>Ti 不可见的 Tj</strong>，有两种情况：</p><ol><li>XID(Tj) &gt; XID(Ti)</li><li>Tj in SP(Ti)</li></ol><p>于是版本跳跃的检查也就很简单了，取出要修改的数据 X 的最新提交版本，并<strong>检查该最新版本的创建者对当前事务是否可见</strong>：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502221957403.jpg" alt="IMG_3883 2" style="zoom:10%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检查版本跳跃 -&gt; 检查当前事务要修改的数据最新版本的创建者是否对当前事务可见</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVersionSkip</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  <span class="hljs-comment">// level = 0是读提交，可以接受版本跳跃</span><br>    <span class="hljs-keyword">if</span>(t.level == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 创建该数据的最新版本的事务已提交 且 （这个事务比当前事务创建晚 或 这个事务在当前事务创建时处于active状态），而我们当前事务想要更改这个数据，就会发生版本跳跃</span><br>        <span class="hljs-keyword">return</span> tm.isCommitted(xmax) &amp;&amp; <br>          (xmax &gt; t.xid || t.isInSnapshot(xmax));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj –&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要<strong>查看这个图中是否有环即可</strong>。</p><p>MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="hljs-comment">// 某个XID已经获得的资源的UID列表</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="hljs-comment">// UID被某个XID持有</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="hljs-comment">// 正在等待UID的XID列表</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="hljs-comment">// 正在等待资源的XID的锁</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="hljs-comment">// XID正在等待的UID</span><br>    <span class="hljs-keyword">private</span> Lock lock;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在<strong>每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测</strong>。如果<strong>检测到死锁，就撤销这条边，不允许添加，并撤销该事务</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// xid事务想要获得uid资源</span><br><span class="hljs-comment">// 不需要等待则返回null，否则返回锁对象</span><br><span class="hljs-comment">// 会造成死锁则抛出异常</span><br><span class="hljs-keyword">public</span> Lock <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// xid事务已获得uid资源</span><br>        <span class="hljs-keyword">if</span>(isInList(x2u, xid, uid)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      <span class="hljs-comment">// 没有事务持有uid资源，则xid事务可以获取</span><br>        <span class="hljs-keyword">if</span>(!u2x.containsKey(uid)) &#123;<br>            u2x.put(uid, xid);<br>            putIntoList(x2u, xid, uid);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      <span class="hljs-comment">// xid事务正在等待uid资源</span><br>        waitU.put(xid, uid);<br>      <span class="hljs-comment">// 将xid事务加入到等待uid资源的事务列表里</span><br>        putIntoList(wait, xid, uid);<br>      <span class="hljs-comment">// 发生死锁，抛出异常</span><br>        <span class="hljs-keyword">if</span>(hasDeadLock()) &#123;<br>            waitU.remove(xid);<br>            removeFromList(wait, uid, xid);<br>            <span class="hljs-keyword">throw</span> Error.DeadlockException;<br>        &#125;<br>      <span class="hljs-comment">// 没发生死锁，则将一个上了锁的Lock对象加入到xid事务的锁map里，返回这个锁</span><br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        l.lock();<br>        waitLock.put(xid, l);<br>        <span class="hljs-keyword">return</span> l;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 add，如果<strong>需要等待的话，会返回一个上了锁的 Lock 对象</strong>。调用方在<strong>获取到该对象时，需要尝试获取该对象的锁，由此实现阻塞线程的目的</strong>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ⚠️</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> lt.add(xid, uid);<br><span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>    l.lock();   <span class="hljs-comment">// 阻塞在这一步？ l是一个可重入锁，同一个线程再执行加锁不会阻塞吧？</span><br>    l.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>查找<strong>图中是否有环</strong>的算法也非常简单，就是一个深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasDeadLock</span><span class="hljs-params">()</span> &#123;<br>    xidStamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    stamp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> xid : x2u.keySet()) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> xidStamp.get(xid);<br>        <span class="hljs-keyword">if</span>(s != <span class="hljs-literal">null</span> &amp;&amp; s &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        stamp ++;<br>        <span class="hljs-keyword">if</span>(dfs(xid)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">stp</span> <span class="hljs-operator">=</span> xidStamp.get(xid);<br>    <span class="hljs-keyword">if</span>(stp != <span class="hljs-literal">null</span> &amp;&amp; stp == stamp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(stp != <span class="hljs-literal">null</span> &amp;&amp; stp &lt; stamp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    xidStamp.put(xid, stamp);<br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> waitU.get(xid);<br>    <span class="hljs-keyword">if</span>(uid == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> u2x.get(uid);<br>    <span class="hljs-keyword">assert</span> x != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> dfs(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>在一个事务 commit 或者 abort 时，就可以释放<strong>所有</strong>它持有的锁，并将自身从等待图中删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        List&lt;Long&gt; l = x2u.get(xid);<br>        <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 把所有资源都释放</span><br>            <span class="hljs-keyword">while</span>(l.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> l.remove(<span class="hljs-number">0</span>);<br>              <span class="hljs-comment">// 被释放的资源，从它的等待队列中选一个xid事务来占用该uid资源</span><br>                selectNewXID(uid);<br>            &#125;<br>        &#125;<br>      <br>      <span class="hljs-comment">// abort时可能还在等别的资源，abort后就不用等了，故移除waitU中的东西</span><br>        waitU.remove(xid);<br>      <span class="hljs-comment">// xid事务已释放所有资源，将xid从获得资源map中移除</span><br>        x2u.remove(xid);<br>      <span class="hljs-comment">// 因为abort时可能还在等资源，故waitLock中还有东西，要移除</span><br>        waitLock.remove(xid);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从等待队列中选择一个xid来占用uid</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectNewXID</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> &#123;<br>  <span class="hljs-comment">// 当前uid已不被占有</span><br>    u2x.remove(uid);<br>  <span class="hljs-comment">// 去uid资源的等待列表中找一个xid事务来占用</span><br>    List&lt;Long&gt; l = wait.get(uid);<br>  <span class="hljs-comment">// 没有xid想要uid</span><br>    <span class="hljs-keyword">if</span>(l == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">assert</span> l.size() &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l.size() &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 选取等待列表中最前面的xid，并将其从wait中移除</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> l.remove(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">// 若xid没有等待资源锁，说明xid已获得过了资源，跳过这个xid</span><br>      <span class="hljs-comment">// 至于为什么获得过了还会在wait中，因为在remove那里xid释放所有资源时并没有将wait的(uid, xid)记录删除，故导致wait中xid还在等uid，但是实际上xid已经获取并释放过uid了；但是如下方所示，获取资源后会将xid从waitLock中删除，故用waitLock来判断这个xid是否还需要资源。</span><br>        <span class="hljs-keyword">if</span>(!waitLock.containsKey(xid)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// xid占有uid</span><br>            u2x.put(uid, xid);<br>          <span class="hljs-comment">// xid的资源列表要加上uid</span><br>          <span class="hljs-comment">// putIntoList(x2u, xid, uid);</span><br>          <br>          <span class="hljs-comment">// xid的等待资源锁要移除</span><br>            <span class="hljs-type">Lock</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> waitLock.remove(xid);<br>          <span class="hljs-comment">// 将(xid,uid)从waitU中移除</span><br>            waitU.remove(xid);<br>          <span class="hljs-comment">// xid的等待资源锁解锁，才能进行获得资源后的操作</span><br>            lo.unlock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">// uid资源分配出去后，发现没有事务在等它了，将它从wait中移除</span><br>    <span class="hljs-keyword">if</span>(l.size() == <span class="hljs-number">0</span>) wait.remove(uid);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="VM的实现"><a href="#VM的实现" class="headerlink" title="VM的实现"></a>VM的实现</h2><p>VM 层通过 <code>VersionManager</code> 接口，向上层提供功能，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VersionManager</span> &#123;<br>    <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，VM 的实现类还**被设计为 <code>Entry</code> 的缓存，需要继承 <code>AbstractCache&lt;Entry&gt;</code>。**需要实现的获取到缓存和从缓存释放的方法很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Entry <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> Entry.loadEntry(<span class="hljs-built_in">this</span>, uid);<br>    <span class="hljs-keyword">if</span>(entry == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> Error.NullEntryException;<br>    &#125;<br>    <span class="hljs-keyword">return</span> entry;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Entry entry)</span> &#123;<br>    entry.remove();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title function_">loadEntry</span><span class="hljs-params">(VersionManager vm, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DataItem</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);<br>    <span class="hljs-keyword">return</span> newEntry(vm, di, uid);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    dataItem.release();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>begin()</code> 开启一个事务，并<strong>初始化事务的结构</strong>，将其<strong>存放在 <code>activeTransaction</code> 中</strong>，用于检查和快照使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 创建一个新事务，事务id自增并返回</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> tm.begin();<br>      <span class="hljs-comment">// 创建事务时传入activeTransaction是为了创造快照</span><br>        <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Transaction.newTransaction(xid, level, activeTransaction);<br>      <span class="hljs-comment">// 创建完将这个事务也加入active事务组中</span><br>        activeTransaction.put(xid, t);<br>        <span class="hljs-keyword">return</span> xid;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>commit()</code> 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(NullPointerException n) &#123;<br>        System.out.println(xid);<br>        System.out.println(activeTransaction.keySet());<br>        Panic.panic(n);<br>    &#125;<br>    lock.lock();<br>  <span class="hljs-comment">// 将xid事务从active事务中中移除</span><br>    activeTransaction.remove(xid);<br>    lock.unlock();<br>  <span class="hljs-comment">// 释放xid事务所拥有的所有资源</span><br>    lt.remove(xid);<br>  <span class="hljs-comment">// 提交xid事务</span><br>    tm.commit(xid);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>abort</code> 事务的方法则有两种，<strong>手动和自动</strong>。手动指的是调用 <code>abort()</code> 方法；而<strong>自动</strong>，则是在事务被检测出出现<strong>死锁</strong>时，会自动撤销回滚事务；或者出现<strong>版本跳跃</strong>时，也会自动回滚：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internAbort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">boolean</span> autoAborted)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    <span class="hljs-keyword">if</span>(!autoAborted) &#123;<br>        activeTransaction.remove(xid);<br>    &#125;<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.autoAborted) <span class="hljs-keyword">return</span>;<br>    lt.remove(xid);<br>    tm.abort(xid);<br>&#125;<br><br><span class="hljs-comment">// 手动abort</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    internAbort(xid, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">// 自动abort，t.autoAborted默认值为false</span><br>internAbort(xid, <span class="hljs-literal">true</span>); 然后-&gt; t.autoAborted = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><code>read()</code> 方法读取一个 <code>entry</code>，注意判断下可见性即可：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502221935459.png" alt="image-20250222193536630" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid) <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 想要读取的资源是对于当前事务是可见的</span><br>        <span class="hljs-keyword">if</span>(Visibility.isVisible(tm, t, entry)) &#123;<br>            <span class="hljs-keyword">return</span> entry.data();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        entry.release();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVisible</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t.level == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 读提交隔离级别下查看是否可见</span><br>        <span class="hljs-keyword">return</span> readCommitted(tm, t, e);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 可重复读隔离级别下查看是否可见</span><br>        <span class="hljs-keyword">return</span> repeatableRead(tm, t, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>insert()</code> 则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>  <span class="hljs-comment">// 将数据包裹成Entry格式：[XMIN] [XMAX] [data]，然后交给DM层</span><br>    <span class="hljs-type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data);<br>  <span class="hljs-comment">// 插入时DM会再将entry包裹成DataItem格式：[ValidFlag] [DataSize] [Data]</span><br>  <span class="hljs-comment">// Entry就是这里的Data</span><br>    <span class="hljs-keyword">return</span> dm.insert(xid, raw);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>delete()</code> 方法看起来略为复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br><br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 要删除的资源对这个事务不可见，无法删除</span><br>        <span class="hljs-keyword">if</span>(!Visibility.isVisible(tm, t, entry)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 可见，就让xid去获取uid</span><br>            l = lt.add(xid, uid);<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            t.err = Error.ConcurrentUpdateException;<br>            internAbort(xid, <span class="hljs-literal">true</span>);<br>            t.autoAborted = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>      <span class="hljs-comment">// 获取非空，是一把锁</span><br>        <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// ⚠️由于l是一把可重入锁，当获取到一把已上锁的锁时，再在这里上锁也能上锁成功，不会发生阻塞。。。</span><br>          <span class="hljs-comment">// 而我们这段代码的思路就是要让程序阻塞在这里。。。</span><br>            l.lock();<br>            l.unlock();<br>        &#125;<br>      <span class="hljs-comment">// 本事务已经删除过了（同一个事务，前面删除过了，这次再删当然删不了）</span><br>        <span class="hljs-keyword">if</span>(entry.getXmax() == xid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      <span class="hljs-comment">// 发生版本跳跃，抛出异常</span><br>        <span class="hljs-keyword">if</span>(Visibility.isVersionSkip(tm, t, entry)) &#123;<br>            t.err = Error.ConcurrentUpdateException;<br>            internAbort(xid, <span class="hljs-literal">true</span>);<br>            t.autoAborted = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>      <span class="hljs-comment">// 设置XMAX为本事务的xid，表明事务xid已删除这条数据</span><br>        entry.setXmax(xid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        entry.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上主要是前置的三件事：<strong>一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置 <code>XMAX</code>。</strong></p><h1 id="5-Index-Manager"><a href="#5-Index-Manager" class="headerlink" title="5. Index Manager"></a>5. Index Manager</h1><blockquote><p>IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的聚簇索引。目前 <strong>MYDB 只支持基于索引查找数据</strong>，不支持全表扫描。</p></blockquote><h2 id="二叉树索引"><a href="#二叉树索引" class="headerlink" title="二叉树索引"></a>二叉树索引</h2><p>二叉树由一个个 <code>Node</code> 组成，每个 <code>Node</code> 都存储在一条 <code>DataItem</code> 中。结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[LeafFlag]</span><span class="hljs-selector-attr">[KeyNumber]</span><span class="hljs-selector-attr">[SiblingUid]</span><br><span class="hljs-selector-attr">[Son0]</span><span class="hljs-selector-attr">[Key0]</span><span class="hljs-selector-attr">[Son1]</span><span class="hljs-selector-attr">[Key1]</span>...<span class="hljs-selector-attr">[SonN]</span><span class="hljs-selector-attr">[KeyN]</span><br></code></pre></td></tr></table></figure><p>其中 <code>LeafFlag</code> 标记了该节点是否是个叶子节点；<code>KeyNumber</code> 为该节点中 key 的个数；<code>SiblingUid</code> 是其兄弟节点存储在 DM 中的 UID。后续是穿插的子节点（<code>SonN</code>）和 <code>KeyN</code>。最后的一个 <code>KeyN</code> 始终为 <code>MAX_VALUE</code>，以此方便查找。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502231400050.jpg" alt="IMG_3885"></p><p><code>Node</code> 类持有了其 B+ 树结构的引用，<code>DataItem</code> 的引用和 <code>SubArray</code> 的引用，用于方便快速修改数据和释放数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>  <br>  <span class="hljs-comment">// LeafFlag起始位置：0</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">IS_LEAF_OFFSET</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// KeyNumber起始位置：1</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NO_KEYS_OFFSET</span> <span class="hljs-operator">=</span> IS_LEAF_OFFSET+<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// SiblingUid起始位置：3</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIBLING_OFFSET</span> <span class="hljs-operator">=</span> NO_KEYS_OFFSET+<span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// Node头文件大小：[LeafFlag][KeyNumber][SiblingUid]</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NODE_HEADER_SIZE</span> <span class="hljs-operator">=</span> SIBLING_OFFSET+<span class="hljs-number">8</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BALANCE_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NODE_SIZE</span> <span class="hljs-operator">=</span> NODE_HEADER_SIZE + (<span class="hljs-number">2</span>*<span class="hljs-number">8</span>)*(BALANCE_NUMBER*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>);<br>  <br>    BPlusTree tree;<br>    DataItem dataItem;<br>    SubArray raw;<br>    <span class="hljs-type">long</span> uid;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>于是<strong>生成一个根节点</strong>的数据可以写成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该根节点的初始两个子节点为 left 和 right, 初始键值为 key。</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] newRootRaw(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right, <span class="hljs-type">long</span> key)  &#123;<br>    <span class="hljs-type">SubArray</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[NODE_SIZE], <span class="hljs-number">0</span>, NODE_SIZE);<br>  <span class="hljs-comment">// 根结点为非叶节点，LeafFlag = 0</span><br>    setRawIsLeaf(raw, <span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">// 有left、right两个子节点，KeyNumber = 2</span><br>    setRawNoKeys(raw, <span class="hljs-number">2</span>);<br>  <span class="hljs-comment">// 根结点没有兄弟节点，SiblingUid = 0</span><br>    setRawSibling(raw, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// left子节点为第一个子节点</span><br>    setRawKthSon(raw, left, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 给left子节点设置初始键值：key</span><br>    setRawKthKey(raw, key, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// right子节点为第二个子节点</span><br>    setRawKthSon(raw, right, <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 给right子节点设置键值MAX_VALUE</span><br>    setRawKthKey(raw, Long.MAX_VALUE, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> raw.raw;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的，生成一个<strong>空的根节点</strong>数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] newNilRootRaw()  &#123;<br>    <span class="hljs-type">SubArray</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[NODE_SIZE], <span class="hljs-number">0</span>, NODE_SIZE);<br>    setRawIsLeaf(raw, <span class="hljs-literal">true</span>);<br>    setRawNoKeys(raw, <span class="hljs-number">0</span>);<br>    setRawSibling(raw, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> raw.raw;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Node</code> 类有两个方法，用于辅助 B+ 树做插入和搜索操作，分别是 <code>searchNext</code> 方法和 <code>leafSearchRange</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SearchNextRes</span> &#123;<br>    <span class="hljs-type">long</span> uid;<br>    <span class="hljs-type">long</span> siblingUid;<br>&#125;<br><br><span class="hljs-comment">// searchNext 寻找对应 key 的 UID, 如果找不到, 则返回兄弟节点的 UID。</span><br><span class="hljs-keyword">public</span> SearchNextRes <span class="hljs-title function_">searchNext</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SearchNextRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchNextRes</span>();<br>      <span class="hljs-comment">// 根据raw数据，获取当前Node节点的key数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">noKeys</span> <span class="hljs-operator">=</span> getRawNoKeys(raw);<br>      <span class="hljs-comment">// 遍历所有key</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">kth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; kth &lt; noKeys; kth ++) &#123;<br>          <span class="hljs-comment">// 获取第kth个key</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>            <span class="hljs-keyword">if</span>(key &lt; ik) &#123;<br>                res.uid = getRawKthSon(raw, kth);<br>                res.siblingUid = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        res.uid = <span class="hljs-number">0</span>;<br>        res.siblingUid = getRawSibling(raw);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>leafSearchRange</code> 方法在<strong>当前节点进行范围查找</strong>，范围是 <code>[leftKey, rightKey]</code>，这里约定如果 <code>rightKey</code> 大于等于该节点的最大的 key, 则还<strong>同时返回兄弟节点的 UID</strong>，方便继续搜索下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> LeafSearchRangeRes <span class="hljs-title function_">leafSearchRange</span><span class="hljs-params">(<span class="hljs-type">long</span> leftKey, <span class="hljs-type">long</span> rightKey)</span> &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">noKeys</span> <span class="hljs-operator">=</span> getRawNoKeys(raw);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">kth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(kth &lt; noKeys) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>          <span class="hljs-comment">// 从leftKey开始找起</span><br>            <span class="hljs-keyword">if</span>(ik &gt;= leftKey) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            kth ++;<br>        &#125;<br>        List&lt;Long&gt; uids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-comment">// 在不超出key数量的前提下</span><br>        <span class="hljs-keyword">while</span>(kth &lt; noKeys) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>          <span class="hljs-comment">// 若key在[leftKey, rightKey]范围内</span><br>            <span class="hljs-keyword">if</span>(ik &lt;= rightKey) &#123;<br>              <span class="hljs-comment">// 将符合条件的节点的uid加入</span><br>                uids.add(getRawKthSon(raw, kth));<br>                kth ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 在key数量范围内找完了 [leftKey, rightKey]范围的节点</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">siblingUid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 发现rightKey大于等于该节点的最大的 key</span><br>        <span class="hljs-keyword">if</span>(kth == noKeys) &#123;<br>          <span class="hljs-comment">// 返回兄弟节点的uid</span><br>            siblingUid = getRawSibling(raw);<br>        &#125;<br>        <span class="hljs-type">LeafSearchRangeRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeafSearchRangeRes</span>();<br>        res.uids = uids;<br>        res.siblingUid = siblingUid;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 B+ 树在插入删除时，会动态调整，<strong>根节点不是固定节点</strong>，于是设置一个 <code>bootDataItem</code>，该 <code>DataItem</code> 中存储了根节点的 UID。可以注意到，IM 在操作 DM 时，使用的事务都是 <strong>SUPER_XID</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BPlusTree</span> &#123;<br>    DataItem bootDataItem;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">rootUid</span><span class="hljs-params">()</span> &#123;<br>        bootLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> bootDataItem.data();<br>            <span class="hljs-keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+<span class="hljs-number">8</span>));<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bootLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateRootUid</span><span class="hljs-params">(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right, <span class="hljs-type">long</span> rightKey)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        bootLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] rootRaw = Node.newRootRaw(left, right, rightKey);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">newRootUid</span> <span class="hljs-operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);<br>            bootDataItem.before();<br>            <span class="hljs-type">SubArray</span> <span class="hljs-variable">diRaw</span> <span class="hljs-operator">=</span> bootDataItem.data();<br>            System.arraycopy(Parser.long2Byte(newRootUid), <span class="hljs-number">0</span>, diRaw.raw, diRaw.start, <span class="hljs-number">8</span>);<br>            bootDataItem.after(TransactionManagerImpl.SUPER_XID);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bootLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可能会有疑问，IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 <code>Entry</code>，实际的操作是设置其 <code>XMAX</code>。如果不去删除对应索引的话，当后续再次尝试读取该 <code>Entry</code> 时，是可以通过索引寻找到的，但是由于设置了 <code>XMAX</code>，寻找不到合适的版本而返回一个找不到内容的错误。</p><h1 id="6-Table-Manager"><a href="#6-Table-Manager" class="headerlink" title="6. Table Manager"></a>6. Table Manager</h1><blockquote><p>本章概述 TBM，即表管理器的实现。TBM 实现了对字段结构和表结构的管理。同时简要介绍 MYDB 使用的类 SQL 语句的解析。</p></blockquote><h2 id="SQL解析器"><a href="#SQL解析器" class="headerlink" title="SQL解析器"></a>SQL解析器</h2><p>Parser 实现了对类 SQL 语句的结构化解析，将<strong>语句中包含的信息封装为对应语句的类</strong>，这些类可见 top.guoziyang.mydb.backend.parser.statement 包。</p><p>MYDB 实现的 SQL 语句语法如下：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 开启事务，isolation level设置事务隔离级别，默认为RC<br><span class="hljs-variable">&lt;begin statement&gt;</span><br>    begin [isolation level (read committedrepeatable read)]<br>        begin isolation level read committed<br><br>// 提交事务<br><span class="hljs-variable">&lt;commit statement&gt;</span><br>    commit<br><br>// 撤销事务<br><span class="hljs-variable">&lt;abort statement&gt;</span><br>    abort<br><br>// 建表语句<br><span class="hljs-variable">&lt;create statement&gt;</span><br>    create <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;table name&gt;</span><br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    ...<br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    [(index <span class="hljs-variable">&lt;field name list&gt;</span>)]<br>        create <span class="hljs-built_in">table</span> students<br>        id int32,<br>        name string,<br>        age int32,<br>        (index id name)<br><br>// 删表语句<br><span class="hljs-variable">&lt;drop statement&gt;</span><br>    <span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;table name&gt;</span><br>        <span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> students<br><br>// 查询语句<br><span class="hljs-variable">&lt;select statement&gt;</span><br>    select (*<span class="hljs-variable">&lt;field name list&gt;</span>) <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;table name&gt;</span> [<span class="hljs-variable">&lt;where statement&gt;</span>]<br>        select * <span class="hljs-keyword">from</span> student where id = <span class="hljs-number">1</span><br>        select name <span class="hljs-keyword">from</span> student where id &gt; <span class="hljs-number">1</span> and id <span class="hljs-variable">&lt; 4</span><br><span class="hljs-variable">        select name, age, id from student where id = 12</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">// 插入语句</span><br><span class="hljs-variable">&lt;insert statement&gt;</span><br>    insert into <span class="hljs-variable">&lt;table name&gt;</span> values <span class="hljs-variable">&lt;value list&gt;</span><br>        insert into student values <span class="hljs-number">5</span> <span class="hljs-string">&quot;Zhang Yuanjia&quot;</span> <span class="hljs-number">22</span><br><br>// 删除语句<br><span class="hljs-variable">&lt;delete statement&gt;</span><br>    delete <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;table name&gt;</span> <span class="hljs-variable">&lt;where statement&gt;</span><br>        delete <span class="hljs-keyword">from</span> student where name = <span class="hljs-string">&quot;Zhang Yuanjia&quot;</span><br><br>// 更新语句<br><span class="hljs-variable">&lt;update statement&gt;</span><br>    update <span class="hljs-variable">&lt;table name&gt;</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">&lt;field name&gt;</span>=<span class="hljs-variable">&lt;value&gt;</span> [<span class="hljs-variable">&lt;where statement&gt;</span>]<br>        update student <span class="hljs-built_in">set</span> name = <span class="hljs-string">&quot;ZYJ&quot;</span> where id = <span class="hljs-number">5</span><br><br>// where查询<br><span class="hljs-variable">&lt;where statement&gt;</span><br>    where <span class="hljs-variable">&lt;field name&gt;</span> (&gt;<span class="hljs-variable">&lt;=) &lt;value&gt;</span> [(andor) <span class="hljs-variable">&lt;field name&gt;</span> (&gt;<span class="hljs-variable">&lt;=) &lt;value&gt;</span>]<br>        where age &gt; <span class="hljs-number">10</span> or age <span class="hljs-variable">&lt; 3</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">// 字段名命名规则</span><br><span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;table name&gt;</span><br>    [a-zA-Z][a-zA-Z0-<span class="hljs-number">9</span>_]*<br><br>// 字段类型只有下面三种<br><span class="hljs-variable">&lt;field type&gt;</span><br>    int32 int64 string<br><br><span class="hljs-variable">&lt;value&gt;</span><br>    .*<br></code></pre></td></tr></table></figure><p>parser 包的 <code>Tokenizer</code> 类，对语句进行逐字节解析，根据空白符或者上述词法规则，<strong>将语句切割成多个 token</strong>。对外提供了 <code>peek()</code>、<code>pop()</code> 方法方便取出 <code>Token</code> 进行解析。</p><p><code>Parser</code> 类则直接对外提供了 <code>Parse(byte[] statement)</code> 方法，核心就是一个调用 <code>Tokenizer</code> 类分割 <code>Token</code>，并根据词法规则包装成具体的 <code>Statement</code> 类并返回。解析过程很简单，仅仅是<strong>根据第一个 <code>Token</code> 来区分语句类型</strong>，并分别处理，不再赘述。</p><h2 id="字段和表管理"><a href="#字段和表管理" class="headerlink" title="字段和表管理"></a>字段和表管理</h2><p>由于 TBM 基于 VM，单个字段信息和表信息都是直接保存在 Entry 中。字段的二进制表示如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[FieldName]</span><span class="hljs-selector-attr">[TypeName]</span><span class="hljs-selector-attr">[IndexUid]</span><br></code></pre></td></tr></table></figure><p>这里 <code>FieldName</code> 和 <code>TypeName</code>，以及后面的表名，存储的都是字节形式的字符串。这里规定一个字符串的存储方式，以明确其存储边界。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[StringLength]</span><span class="hljs-selector-attr">[StringData]</span><br></code></pre></td></tr></table></figure><p>TypeName 为字段的类型，<strong>限定为 int32、int64 和 string 类型</strong>。<strong>如果这个字段有索引，那个 IndexUID 指向了索引二叉树的根</strong>，否则该字段为 0。</p><p>根据这个结构，通过一个 UID 从 VM 中读取并解析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取字段信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Field <span class="hljs-title function_">loadField</span><span class="hljs-params">(Table tb, <span class="hljs-type">long</span> uid)</span> &#123;<br>    <span class="hljs-type">byte</span>[] raw = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        raw = ((TableManagerImpl)tb.tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">assert</span> raw != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Field</span>(uid, tb).parseSelf(raw);<br>&#125;<br><br><span class="hljs-comment">// 解析字段信息</span><br><span class="hljs-keyword">private</span> Field <span class="hljs-title function_">parseSelf</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 第一个res，包含FieldName的[StringLength][StringData]</span><br>  <span class="hljs-comment">// 返回的res.str 是 FieldName，res.next 是 [StringLength][StringData]的长度</span><br>    <span class="hljs-type">ParseStringRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Parser.parseString(raw);<br>    fieldName = res.str;<br>    position += res.next;<br>  <br>  <span class="hljs-comment">// 第二个res，包含TypeName的[StringLength][StringData]</span><br>  <span class="hljs-comment">// 返回的res.str 是 TypeName，res.next 是 [StringLength][StringData]的长度</span><br>    res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));<br>    fieldType = res.str;<br>    position += res.next;<br>  <br>  <span class="hljs-comment">// 若有index，则继续解析index</span><br>    <span class="hljs-built_in">this</span>.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position+<span class="hljs-number">8</span>));<br>    <span class="hljs-keyword">if</span>(index != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm);<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个字段的方法类似，将相关的信息通过 VM 持久化即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">persistSelf</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">byte</span>[] nameRaw = Parser.string2Byte(fieldName);<br>    <span class="hljs-type">byte</span>[] typeRaw = Parser.string2Byte(fieldType);<br>    <span class="hljs-type">byte</span>[] indexRaw = Parser.long2Byte(index);<br>    <span class="hljs-built_in">this</span>.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));<br>&#125;<br><br><span class="hljs-comment">// [StringLength] + [StringData]</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] string2Byte(String str) &#123;<br>    <span class="hljs-type">byte</span>[] l = int2Byte(str.length());<br>    <span class="hljs-keyword">return</span> Bytes.concat(l, str.getBytes());<br>&#125;<br></code></pre></td></tr></table></figure><p>一个数据库中存在多张表，TBM 使用链表的形式将其组织起来，每一张表都保存一个指向下一张表的 UID。表的二进制结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[TableName]</span><span class="hljs-selector-attr">[NextTable]</span><br><span class="hljs-selector-attr">[Field1Uid]</span><span class="hljs-selector-attr">[Field2Uid]</span>...<span class="hljs-selector-attr">[FieldNUid]</span><br></code></pre></td></tr></table></figure><p>这里由于每个 Entry 中的数据，字节数是确定的，于是<strong>无需保存字段的个数</strong>。根据 UID 从 Entry 中读取表数据的过程和读取字段的过程类似。</p><p>对表和字段的操作，有一个很重要的步骤，就是计算 Where 条件的范围，目前 MYDB 的 Where <strong>只支持两个条件的与和或</strong>。MYDB 只支持<strong>已索引字段</strong>作为 Where 的条件。。计算 Where 的范围，具体可以查看 <code>Table</code> 的 <code>parseWhere()</code> 和 <code>calWhere()</code> 方法，以及 Field 类的 <code>calExp()</code> 方法。</p><ul><li><code>parseWhere()</code>：解析Where语句，返回一个<code>Where</code>，<code>Where.singleExp1</code>表示第一个条件，<code>Where.logicOp</code>表示两个条件之间是and还是or，<code>Where.singleExp2</code>表示第二个条件<ul><li>其中条件<code>singleExp</code>所属类<code>SingleExpression</code>包含属性：字段<code>field</code>、条件比较符号<code>compareOp</code>、和字段比较的数值<code>value</code></li></ul></li><li><code>calWhere()</code>：处理逻辑连接词and和or</li><li><code>calExp()</code>：根据Where的条件，返回一个区间：<ul><li>如果<code>compareOp</code>是<code>&lt;</code>，表示字段<code> &lt; value</code>的一个区间。区间left &#x3D; 0，区间right &#x3D; 条件的<code>value</code> - 1；</li><li>如果<code>compareOp</code>是<code>&gt;</code>，表示字段<code>&gt; value</code>的一个区间。区间left &#x3D; <code>value</code>，区间right &#x3D; <code>Long.MAX_VALUE</code>；</li><li>如果如果<code>compareOp</code>是<code>=</code>，表示字段<code>= value</code>的一个区间。区间left &#x3D; right &#x3D; <code>value</code></li></ul></li></ul><p>由于 TBM 的表管理，使用的是链表串起的 Table 结构，所以就必须<strong>保存一个链表的头节点</strong>，即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。</p><p>MYDB 使用 Booter 类和 bt 文件，来管理 MYDB 的启动信息，虽然现在所需的启动信息，只有一个：头表的 UID。<strong>Booter 类对外提供了两个方法：load 和 update，并保证了其原子性。<strong>update 在修改 bt 文件内容时，没有直接对 bt 文件进行修改，而是首先将内容写入一个 bt_tmp 文件中，随后将这个文件重命名为 bt 文件。以期</strong>通过操作系统重命名文件的原子性，来保证操作的原子性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path + BOOTER_TMP_SUFFIX);<br>    <span class="hljs-keyword">try</span> &#123;<br>        tmp.createNewFile();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!tmp.canRead() || !tmp.canWrite()) &#123;<br>        Panic.panic(Error.FileCannotRWException);<br>    &#125;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(tmp)) &#123;<br>        out.write(data);<br>        out.flush();<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Files.move(tmp.toPath(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+BOOTER_SUFFIX);<br>    <span class="hljs-keyword">if</span>(!file.canRead() || !file.canWrite()) &#123;<br>        Panic.panic(Error.FileCannotRWException);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TableManager"><a href="#TableManager" class="headerlink" title="TableManager"></a>TableManager</h2><p>TBM 层对外提供服务的是 TableManager 接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableManager</span> &#123;<br>    BeginRes <span class="hljs-title function_">begin</span><span class="hljs-params">(Begin begin)</span>;<br>    <span class="hljs-type">byte</span>[] commit(<span class="hljs-type">long</span> xid) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] abort(<span class="hljs-type">long</span> xid);<br><br>    <span class="hljs-type">byte</span>[] show(<span class="hljs-type">long</span> xid);<br>    <span class="hljs-type">byte</span>[] create(<span class="hljs-type">long</span> xid, Create create) <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-type">byte</span>[] insert(<span class="hljs-type">long</span> xid, Insert insert) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, Select select) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] update(<span class="hljs-type">long</span> xid, Update update) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] delete(<span class="hljs-type">long</span> xid, Delete delete) <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 TableManager 已经是直接被最外层 Server 调用（MYDB 是 <strong>C&#x2F;S</strong> 结构），这些方<strong>法直接返回执行的结果</strong>，例如<strong>错误信息</strong>或者<strong>结果信息的字节数组</strong>（可读）。</p><h1 id="7-服务端客户端的实现及其通信规则"><a href="#7-服务端客户端的实现及其通信规则" class="headerlink" title="7. 服务端客户端的实现及其通信规则"></a>7. 服务端客户端的实现及其通信规则</h1><blockquote><p>MYDB 被设计为 C&#x2F;S 结构，类似于 MySQL。支持启动一个服务器，并有多个客户端去连接，通过 socket 通信，执行 SQL 返回结果。</p></blockquote><h2 id="C-S通信"><a href="#C-S通信" class="headerlink" title="C&#x2F;S通信"></a>C&#x2F;S通信</h2><p>MYDB 使用了一种特殊的二进制格式，用于客户端和服务端通信。传输的最基本结构，是 <code>Package</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Package</span> &#123;<br>    <span class="hljs-type">byte</span>[] data;<br>    Exception err;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 <code>Package</code> 在发送前，由 <code>Encoder</code> <strong>编码</strong>为字节数组，在对方收到后同样会由 <code>Encoder</code> 解<strong>码</strong>成 <code>Package</code> 对象。编码和解码的规则如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Flag]</span><span class="hljs-selector-attr">[data]</span><br></code></pre></td></tr></table></figure><p><strong>若 flag 为 0，表示发送的是数据</strong>，那么 data 即为这份数据本身；<strong>如果 flag 为 1，表示发送的是错误</strong>，data 是 Exception.getMessage() 的错误提示信息。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Encoder</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] encode(Package pkg) &#123;<br>        <span class="hljs-keyword">if</span>(pkg.getErr() != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 发送错误信息</span><br>            <span class="hljs-type">Exception</span> <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> pkg.getErr();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Intern server error!&quot;</span>;<br>            <span class="hljs-keyword">if</span>(err.getMessage() != <span class="hljs-literal">null</span>) &#123;<br>                msg = err.getMessage();<br>            &#125;<br>            <span class="hljs-keyword">return</span> Bytes.concat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>&#125;, msg.getBytes());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 发送数据信息</span><br>            <span class="hljs-keyword">return</span> Bytes.concat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0</span>&#125;, pkg.getData());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Package <span class="hljs-title function_">decode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span>(data.length &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> Error.InvalidPkgDataException;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(data[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// 接受数据</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(Arrays.copyOfRange(data, <span class="hljs-number">1</span>, data.length), <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-comment">// 接受错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Arrays.copyOfRange(data, <span class="hljs-number">1</span>, data.length))));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> Error.InvalidPkgDataException;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码之后的信息会通过 <code>Transporter</code> 类，写入输出流发送出去。为了避免特殊字符造成问题，这里会<strong>将数据转成十六进制字符串</strong>（Hex String），并为<strong>信息末尾加上换行符</strong>。这样在发送和接收数据时，就可以很简单地使用 <code>BufferedReader</code> 和 <code>Writer</code> 来直接按行读写了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transporter</span> &#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> BufferedReader reader;<br>    <span class="hljs-keyword">private</span> BufferedWriter writer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Transporter</span><span class="hljs-params">(Socket socket)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>        <span class="hljs-built_in">this</span>.reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>        <span class="hljs-built_in">this</span>.writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> hexEncode(data);<br>        writer.write(raw);<br>        writer.flush();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] receive() <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-comment">// 按行读取</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> reader.readLine();<br>        <span class="hljs-keyword">if</span>(line == <span class="hljs-literal">null</span>) &#123;<br>            close();<br>        &#125;<br>        <span class="hljs-keyword">return</span> hexDecode(line);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        writer.close();<br>        reader.close();<br>        socket.close();<br>    &#125;<br><br>  <span class="hljs-comment">// 编码后的数据转成：16进制字符串+换行符</span><br>  <span class="hljs-comment">// 换行符方便接收方收到数据后直接按行读取，一行就是一条数据</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">hexEncode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buf)</span> &#123;<br>        <span class="hljs-keyword">return</span> Hex.encodeHexString(buf, <span class="hljs-literal">true</span>)+<span class="hljs-string">&quot;n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] hexDecode(String buf) <span class="hljs-keyword">throws</span> DecoderException &#123;<br>        <span class="hljs-keyword">return</span> Hex.decodeHex(buf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Packager</code> 则是 <code>Encoder</code> 和 <code>Transporter</code> 的结合体，直接对外提供 <code>send</code> 和 <code>receive</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Packager</span> &#123;<br>    <span class="hljs-keyword">private</span> Transporter transpoter;<br>    <span class="hljs-keyword">private</span> Encoder encoder;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Packager</span><span class="hljs-params">(Transporter transpoter, Encoder encoder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.transpoter = transpoter;<br>        <span class="hljs-built_in">this</span>.encoder = encoder;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(Package pkg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] data = encoder.encode(pkg);<br>        transpoter.send(data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Package <span class="hljs-title function_">receive</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] data = transpoter.receive();<br>        <span class="hljs-keyword">return</span> encoder.decode(data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        transpoter.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Server和Client的实现"><a href="#Server和Client的实现" class="headerlink" title="Server和Client的实现"></a>Server和Client的实现</h2><p><code>Server</code> 和 <code>Client</code>，偷懒直接使用了 Java 的 socket。</p><p><code>Server</code> 启动一个 <code>ServerSocket</code> 监听端口，当有请求到来时直接<strong>把请求丢给一个新线程处理</strong>。</p><p><code>HandleSocket</code> 类实现了 <code>Runnable</code> 接口，在建立连接后初始化 <code>Packager</code>，随后就循环接收来自客户端的数据并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleSocket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> TableManager tbm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HandleSocket</span><span class="hljs-params">(Socket socket, TableManager tbm)</span> &#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>        <span class="hljs-built_in">this</span>.tbm = tbm;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> (InetSocketAddress)socket.getRemoteSocketAddress();<br>        System.out.println(<span class="hljs-string">&quot;Establish connection: &quot;</span> + address.getAddress().getHostAddress()+<span class="hljs-string">&quot;:&quot;</span>+address.getPort());<br>        <span class="hljs-type">Packager</span> <span class="hljs-variable">packager</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Transporter</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transporter</span>(socket);<br>            <span class="hljs-type">Encoder</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Encoder</span>();<br>            packager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Packager</span>(t, e);<br>        &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>                e1.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">exe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Executor</span>(tbm);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Package</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 收数据</span><br>                pkg = packager.receive();<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-type">byte</span>[] sql = pkg.getData();<br>            <span class="hljs-type">byte</span>[] result = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Exception</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                result = exe.execute(sql);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>                e = e1;<br>                e.printStackTrace();<br>            &#125;<br>            pkg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(result, e);<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 发回去</span><br>                packager.send(pkg);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>                e1.printStackTrace();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        exe.close();<br>        <span class="hljs-keyword">try</span> &#123;<br>            packager.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;    <br></code></pre></td></tr></table></figure><p>处理的核心是 <code>Executor</code> 类，<code>Executor</code> 调用 <code>Parser</code> <strong>获取到对应语句的结构化信息对象</strong>，并<strong>根据对象的类型，调用 TBM 的不同方法进行处理</strong>。</p><p>top.guoziyang.mydb.backend.Launcher 类，则是<strong>服务器的启动入口</strong>。这个类<strong>解析了命令行参数</strong>。很重要的参数就是 -open 或者 -create。<code>Launcher</code> 根据两个参数，来决定是<strong>创建数据库</strong>文件，还是<strong>启动一个已有的数据库</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createDB</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-type">TransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> TransactionManager.create(path);<br>    <span class="hljs-type">DataManager</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> DataManager.create(path, DEFALUT_MEM, tm);<br>    <span class="hljs-type">VersionManager</span> <span class="hljs-variable">vm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VersionManagerImpl</span>(tm, dm);<br>    TableManager.create(path, vm, dm);<br>    tm.close();<br>    dm.close();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openDB</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem)</span> &#123;<br>    <span class="hljs-type">TransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> TransactionManager.open(path);<br>    <span class="hljs-type">DataManager</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> DataManager.open(path, mem, tm);<br>    <span class="hljs-type">VersionManager</span> <span class="hljs-variable">vm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VersionManagerImpl</span>(tm, dm);<br>    <span class="hljs-type">TableManager</span> <span class="hljs-variable">tbm</span> <span class="hljs-operator">=</span> TableManager.open(path, vm, dm);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(port, tbm).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端有一个简单的 Shell，实际上只是<strong>读入用户的输入</strong>，并调用 Client.execute()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] execute(<span class="hljs-type">byte</span>[] stat) <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Package</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(stat, <span class="hljs-literal">null</span>);<br>    <span class="hljs-type">Package</span> <span class="hljs-variable">resPkg</span> <span class="hljs-operator">=</span> rt.roundTrip(pkg);<br>    <span class="hljs-keyword">if</span>(resPkg.getErr() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> resPkg.getErr();<br>    &#125;<br>    <span class="hljs-keyword">return</span> resPkg.getData();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RoundTripper</code> 类实际上实现了<strong>单次收发</strong>动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Package <span class="hljs-title function_">roundTrip</span><span class="hljs-params">(Package pkg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    packager.send(pkg);<br>    <span class="hljs-keyword">return</span> packager.receive();<br>&#125;<br></code></pre></td></tr></table></figure><p>最后附上<strong>客户端的启动入口</strong>，很简单，把 Shell run 起来即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Launcher</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnknownHostException, IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>        <span class="hljs-type">Encoder</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Encoder</span>();<br>        <span class="hljs-type">Transporter</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transporter</span>(socket);<br>        <span class="hljs-type">Packager</span> <span class="hljs-variable">packager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Packager</span>(t, e);<br><br>        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>(packager);<br>        <span class="hljs-type">Shell</span> <span class="hljs-variable">shell</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shell</span>(client);<br>        shell.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-项目总结"><a href="#8-项目总结" class="headerlink" title="8. 项目总结"></a>8. 项目总结</h1><p>为充分理解数据库知识，本项目参考MySQL数据库的设计原理，基于Java实现了简易的数据库MYDB，实现的功能如下：</p><ul><li>事务状态：active、committed、aborted</li><li>数据库日志管理，保证数据的可靠性和数据恢复</li><li>基本的缓存框架，用于缓存数据、日志等信息</li><li>2PL和MVCC</li><li>两种事务隔离级别（读提交和可重复读）和死锁处理</li><li>基于B+树的聚簇索引，支持基于索引查找数据</li><li>简单的表管理器和SQL解析器，支持SQL语句操作表</li><li>基于socket的Server和Client</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>MySQL</category>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC</title>
    <link href="/2025/02/17/RPC/"/>
    <url>/2025/02/17/RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC（Remote-Procedure-Call）"><a href="#RPC（Remote-Procedure-Call）" class="headerlink" title="RPC（Remote Procedure Call）"></a><strong>RPC（Remote Procedure Call）</strong></h1><blockquote><p>本文参考：</p><p>​JavaGuide星球RPC文档</p><p>​<a href="https://javaguide.cn/distributed-system/rpc/http_rpc.html#http-%E5%92%8C-rpc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">https://javaguide.cn/distributed-system/rpc/http_rpc.html#http-%E5%92%8C-rpc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB</a></p></blockquote><h1 id="1-什么是RPC？RPC原理是什么？"><a href="#1-什么是RPC？RPC原理是什么？" class="headerlink" title="1. 什么是RPC？RPC原理是什么？"></a><strong>1. 什么是RPC？RPC原理是什么？</strong></h1><h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h2><p><strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p><p><strong>为什么要 RPC ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。</p><p><strong>RPC 能帮助我们做什么呢？</strong>  简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p><p>一言蔽之：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p><h2 id="RPC原理是什么？"><a href="#RPC原理是什么？" class="headerlink" title="RPC原理是什么？"></a>RPC原理是什么？</h2><p>可以将整个 RPC 的 核心功能看作是下面 5 个部分实现的：</p><ol><li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li><li><strong>客户端 Stub（桩）</strong> ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li><li><strong>网络传输</strong> ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。</li><li><strong>服务端 Stub（桩）</strong> ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li><li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li></ol><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154285.jpg" alt="1594701419183-13976b20-36c8-44fa-a797-5f16ce27c495"></p><ol><li>服务消费端（client）以本地调用的方式调用远程服务；</li><li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li><li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: <code>RpcRequest</code>；</li><li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li><li>客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:<code>RpcResponse</code> ，这样也就得到了最终结果。over!</li></ol><h1 id="2-有了HTTP协议，为什么还要有RPC？"><a href="#2-有了HTTP协议，为什么还要有RPC？" class="headerlink" title="2. 有了HTTP协议，为什么还要有RPC？"></a><strong>2. 有了HTTP协议，为什么还要有RPC？</strong></h1><h2 id="从TCP聊起"><a href="#从TCP聊起" class="headerlink" title="从TCP聊起"></a><strong>从TCP聊起</strong></h2><p>假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。这时候，我们可选项一般也就<strong>TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。</strong></p><p>类似下面这样。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">fd</span> = socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>其中<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP 协议</strong>。</p><p>在定义了 socket 之后，我们就可以愉快的对这个 socket 进行操作，比如用<code>bind()</code>绑定 IP 端口，用<code>connect()</code>发起建连。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154286.png" alt="f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>在连接建立之后，我们就可以使用<code>send()</code>发送数据，<code>recv()</code>接收数据。光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？不行，这么用会有问题。</p><h2 id="使用纯裸TCP会有什么问题"><a href="#使用纯裸TCP会有什么问题" class="headerlink" title="使用纯裸TCP会有什么问题"></a><strong>使用纯裸TCP会有什么问题</strong></h2><p>TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 <strong>01 串</strong> 。纯裸 TCP 收发的这些 01 串之间是 <strong>没有任何边界</strong> 的，你根本不知道到哪个地方才算一条完整消息。正因为这个没有任何边界的特点，所以当我们选择使用 TCP 发送 <strong>“夏洛”和”特烦恼”</strong> 的时候，接收端收到的就是 <strong>“夏洛特烦恼”</strong> ，这时候接收端没发区分你是想要表达 <strong>“夏洛”+”特烦恼”</strong> 还是 <strong>“夏洛特”+”烦恼”</strong> ，这就是所谓的<strong>粘包问题</strong>。</p><p>因此，纯裸TCP是不能直接拿来用的，你需要在这个基础上加入一些 <strong>自定义的规则</strong> ，用于区分 <strong>消息边界</strong> 。于是我们会把每条要发送的数据都包装一下，比如加入 <strong>消息头</strong> ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的 <strong>消息体</strong> 。</p><p>而这里头提到的 <strong>消息头</strong> ，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的 **协议。**每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能 <strong>有区别，但原理都类似</strong>。</p><p><strong>于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p><h2 id="HTTP和RPC"><a href="#HTTP和RPC" class="headerlink" title="HTTP和RPC"></a><strong>HTTP和RPC</strong></h2><h3 id="RPC其实是一直调用方式"><a href="#RPC其实是一直调用方式" class="headerlink" title="RPC其实是一直调用方式"></a><strong>RPC其实是一直调用方式</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154287.png" alt="04b603b5bd2443209233deea87816161~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p><strong>TCP 是传输层的协议</strong> ，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的 <strong>应用层协议</strong> 而已。</p><p><strong>HTTP</strong>（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol）协议又叫做 <strong>超文本传输协议</strong> 。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154288.png" alt="8f07a5d1c72a4c4fa811c6c3b5aadd3d~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>而 <strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all）又叫做 <strong>远程过程调用</strong>，它本身并不是一个具体的协议，而是一种 <strong>调用方式</strong> 。举个例子，我们平时调用一个 <strong>本地方法</strong> 就像下面这样。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">res</span> <span class="hljs-operator">=</span> localFunc(req)<br></code></pre></td></tr></table></figure><p>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法<code>remoteFunc</code>，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">res</span> <span class="hljs-operator">=</span> remoteFunc(req)<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154289.png" alt="761da6c30af244e19b1c44075d8b4254~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>基于这个思路，大佬们造出了非常多款式的 RPC 协议，比如比较有名的<code>gRPC</code>，<code>thrift</code>。</p><p>值得注意的是，虽然大部分 RPC 协议底层使用 TCP，但实际上 <strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p><h3 id="那既然有-RPC-了，为什么还要有-HTTP-呢？"><a href="#那既然有-RPC-了，为什么还要有-HTTP-呢？" class="headerlink" title="那既然有 RPC 了，为什么还要有 HTTP 呢？"></a><strong>那既然有 RPC 了，为什么还要有 HTTP 呢？</strong></h3><p>其实，TCP 是 <strong>70 年</strong> 代出来的协议，而 HTTP 是 <strong>90 年代</strong> 才开始流行的。而直接使用裸 TCP 会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有 <strong>80 年代</strong> 出来的<code>RPC</code>。</p><p>所以我们该问的不是 <strong>既然有 HTTP 协议为什么要有 RPC</strong> ，而是 <strong>为什么有 RPC 还要有 HTTP 协议?</strong></p><p>现在电脑上装的各种联网软件，比如 xx 管家，xx 卫士，它们都作为客户端（Client） 需要跟服务端（Server） 建立连接收发消息，此时都会用到应用层协议，在这种 Client&#x2F;Server (C&#x2F;S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。</p><p>但有个软件不同，浏览器（Browser） ，不管是 Chrome 还是 IE，它们不仅要能访问自家公司的<strong>服务器（Server）</strong> ，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 <strong>Browser&#x2F;Server (B&#x2F;S)</strong> 的协议。</p><p>也就是说在多年以前，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。</strong> 很多软件同时支持多端，比如某度云盘，既要支持<strong>网页版</strong>，还要支持<strong>手机端和 PC 端</strong>，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p><p>那这么说的话，<strong>都用 HTTP 得了，还用什么 RPC？</strong></p><h3 id="HTTP和RPC有什么区别"><a href="#HTTP和RPC有什么区别" class="headerlink" title="HTTP和RPC有什么区别"></a><strong>HTTP和RPC有什么区别</strong></h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a><strong>服务发现</strong></h4><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 <strong>IP 地址和端口</strong> 。这个找到服务对应的 IP 端口的过程，其实就是 <strong>服务发现</strong>。</p><p>在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong> 去解析得到它背后的 IP 地址，默认 <strong>80 端口</strong>。</p><p>而 <strong>RPC</strong> 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 <strong>Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 <strong>CoreDNS</strong>。</p><p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p><h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a><strong>底层连接形式</strong></h4><p>以主流的 <strong>HTTP1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p><p>而 <strong>RPC</strong> 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 <strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154290.png" alt="72fcad064c9e4103a11f1a2d579f79b2~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。</p><h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a><strong>传输的内容</strong></h4><p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p><p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p><p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p><p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154291.png" alt="d501dfc6f764430188ce61fda0f3e5d9~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154292.png" alt="HTTP报文"></p><p>可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 <code>Content-Type</code>，就不需要每次都真的把 <code>Content-Type</code> 这个字段都传过来，类似的情况其实在 Body 的 JSON 结构里也特别明显。</p><p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154293.png" alt="HTTP原理"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154294.png" alt="RPC原理"></p><p>当然上面说的 HTTP，其实 <strong>特指的是现在主流使用的 HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以 <strong>性能可能比很多 RPC 协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p><h3 id="为什么既然有了HTTP2，还要有RPC"><a href="#为什么既然有了HTTP2，还要有RPC" class="headerlink" title="为什么既然有了HTTP2，还要有RPC"></a><strong>为什么既然有了HTTP2，还要有RPC</strong></h3><p>这个是由于 HTTP2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 <strong>消息边界</strong> 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li><li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li><li>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。</strong> 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li><li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li><li><strong>HTTP2.0</strong> 在 <strong>HTTP1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li></ul><h1 id="3-如何自己实现一个RPC框架"><a href="#3-如何自己实现一个RPC框架" class="headerlink" title="3.如何自己实现一个RPC框架"></a><strong>3.如何自己实现一个RPC框架</strong></h1><p>一般情况下， RPC 框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这样的 RPC 框架才算真正合格的。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410865.png" alt="e13cfb04-a05c-4882-92c9-ea0861e5cc10"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410866.png" alt="06f58c75-1637-456b-bea9-a83060a62c01"></p><p>从上图我们可以看出：服务提供端 Server 向注册中心注册服务，服务消费者 Client 通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端 Server。</p><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a><strong>注册中心</strong></h2><p><strong>注册中心负责服务地址的注册与查找，相当于目录服务。</strong> 服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。结合Dubbo到架构图：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410867.png" alt="d0ba7446-455a-40e8-bba2-58f03634860d"></p><p>上述节点简单说明：</p><ul><li><strong>Provider：</strong> 暴露服务的服务提供方</li><li><strong>Consumer：</strong> 调用远程服务的服务消费方</li><li><strong>Registry：</strong> 服务注册与发现的注册中心</li><li><strong>Monitor：</strong> 统计服务的调用次数和调用时间的监控中心</li><li><strong>Container：</strong> 服务运行容器</li></ul><p>调用关系说明：</p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于<strong>长连接推送</strong>变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于<strong>软负载均衡算法</strong>，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a><strong>网络传输</strong></h2><p><strong>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。</strong></p><p>网络传输具体实现你可以使用 <strong>Socket</strong> （ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。</p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a><strong>序列化与反序列化</strong></h2><p>要在网络传输数据就要涉及到<strong>序列化</strong>。<strong>为什么需要序列化和反序列化呢？</strong><br>因为网络传输的数据必须是二进制的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够让 Java 对象在网络中传输我们需要将其<strong>序列化</strong>为二进制的数据。我们最终需要的还是目标 Java 对象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次<strong>反序列化</strong>。</p><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可，不过这种方式不推荐，因为不支持跨语言调用并且性能比较差。现在比较常用序列化的有 <strong>hessian</strong>、<strong>kryo</strong>、<strong>protostuff</strong> ……</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a><strong>动态代理</strong></h2><p>我们知道代理模式就是： 我们给某一个对象提供一个代理对象，并由代理对象来代替真实对象做一些事情。你可以把代理对象理解为一个幕后的工具人。 举个例子：我们真实对象调用方法的时候，我们可以通过代理对象去做一些事情比如安全校验、日志打印等等。但是，这个过程是完全对真实对象屏蔽的。</p><p>讲完了代理模式，再来说动态代理在 RPC 框架中的作用。</p><ul><li>前面第一节的时候，我们就已经提到 ：<strong>RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输</strong>。</li></ul><p><strong>怎样才能屏蔽远程方法调用的底层细节呢？</strong></p><ul><li>答案就是<strong>动态代理</strong>。简单来说，当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法。</li><li>因为消费端没有服务的实现类，无法获得一个实例进行方法调用，所以只能通过动态代理获得一个代理对象。然后通过<strong>代理对象替我们调用方法</strong>。</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h2><p>我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a><strong>传输协议</strong></h2><p>我们还需要设计一个私有的 RPC 协议，这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。</p><p>简单来说：**通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二进制数据之后，就可以正确的解析出我们需要的数据。**这有一点像密文传输的感觉。</p><p>通常一些标准的 RPC 协议包含下面这些内容：</p><ul><li><strong>魔数</strong> ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。 </li><li><strong>序列化器编号</strong> ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kryo 等序列化方式。 </li><li><strong>消息体长度</strong> ： 运行时计算出来。</li></ul><h1 id="4-序列化介绍以及序列化协议选择"><a href="#4-序列化介绍以及序列化协议选择" class="headerlink" title="4. 序列化介绍以及序列化协议选择"></a><strong>4. 序列化介绍以及序列化协议选择</strong></h1><h2 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h2><ul><li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><h2 id="序列化协议对应于TCP-IP-4层模型中的哪一层？"><a href="#序列化协议对应于TCP-IP-4层模型中的哪一层？" class="headerlink" title="序列化协议对应于TCP&#x2F;IP 4层模型中的哪一层？"></a><strong>序列化协议对应于TCP&#x2F;IP 4层模型中的哪一层？</strong></h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410868.png" alt="64adec3d-78ee-488f-92ad-ad3013006985"></p><p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p><p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以<strong>序列化协议属于 TCP&#x2F;IP 协议应用层的一部分</strong>。</p><h2 id="常见的序列化协议有哪些？"><a href="#常见的序列化协议有哪些？" class="headerlink" title="常见的序列化协议有哪些？"></a><strong>常见的序列化协议有哪些？</strong></h2><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p><h3 id="JDK自带的序列化方式"><a href="#JDK自带的序列化方式" class="headerlink" title="JDK自带的序列化方式"></a><strong>JDK自带的序列化方式</strong></h3><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1905122041950251207L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-keyword">private</span> Object[] parameters;<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] paramTypes;<br>    <span class="hljs-keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="serialVersionUID有什么作用？"><a href="#serialVersionUID有什么作用？" class="headerlink" title="serialVersionUID有什么作用？"></a><strong>serialVersionUID有什么作用？</strong></h4><ul><li>序列化号 <code>serialVersionUID</code> 属于<strong>版本控制</strong>的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。</li></ul><h4 id="serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？"><a href="#serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？" class="headerlink" title="serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？"></a><strong>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</strong></h4><ul><li><p><code>static</code> 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。但是，<code>serialVersionUID</code> 的序列化做了特殊处理，在序列化时，会将 <code>serialVersionUID</code> 序列化到二进制字节流中；在反序列化时，也会解析它并做一致性判断。</p></li><li><blockquote><p>A serializable class can declare its own serialVersionUID explicitly by declaring a field named <code>&quot;serialVersionUID&quot;</code> that must be <code>static</code>, <code>final</code>, and of type <code>long</code>;</p><p>如果想显式指定 <code>serialVersionUID</code> ，则需要在类中使用 <code>static</code> 和 <code>final</code> 关键字来修饰一个 <code>long</code> 类型的变量，变量名字必须为 <code>&quot;serialVersionUID&quot;</code> 。</p></blockquote></li><li><p>也就是说，<code>serialVersionUID</code> 只是用来被 JVM 识别，实际并没有被序列化。</p></li></ul><h4 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a><strong>如果有些字段不想进行序列化怎么办？</strong></h4><p>对于不想进行序列化的变量，可以使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：<strong>阻止实例中那些用此关键字修饰的的变量序列化</strong>；当对象被反序列化时，被 <code>transient</code> 修饰的变量值<strong>不会被持久化和恢复</strong>。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成<strong>类型的默认值</strong>。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h4 id="为什么不推荐使用-JDK-自带的序列化？"><a href="#为什么不推荐使用-JDK-自带的序列化？" class="headerlink" title="为什么不推荐使用 JDK 自带的序列化？"></a><strong>为什么不推荐使用 JDK 自带的序列化？</strong></h4><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong> ：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li></ul><h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a><strong>Kryo</strong></h3><p>Kryo 是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月13日 19:29:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KryoSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializer</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;<br>        <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>        kryo.register(RpcResponse.class);<br>        kryo.register(RpcRequest.class);<br>        <span class="hljs-keyword">return</span> kryo;<br>    &#125;);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] serialize(Object obj) &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>             <span class="hljs-type">Output</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Output</span>(byteArrayOutputStream)) &#123;<br>            <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoThreadLocal.get();<br>            <span class="hljs-comment">// Object-&gt;byte:将对象序列化为byte数组</span><br>            kryo.writeObject(output, obj);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> output.toBytes();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializeException</span>(<span class="hljs-string">&quot;Serialization failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">byteArrayInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>             <span class="hljs-type">Input</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Input</span>(byteArrayInputStream)) &#123;<br>            <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoThreadLocal.get();<br>            <span class="hljs-comment">// byte-&gt;Object:从byte数组中反序列化出对象</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> kryo.readObject(input, clazz);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> clazz.cast(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializeException</span>(<span class="hljs-string">&quot;Deserialization failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Socket网络通信"><a href="#5-Socket网络通信" class="headerlink" title="5. Socket网络通信"></a><strong>5. Socket网络通信</strong></h1><h2 id="什么是Socket（套接字）"><a href="#什么是Socket（套接字）" class="headerlink" title="什么是Socket（套接字）"></a><strong>什么是Socket（套接字）</strong></h2><p>Socket 是一个抽象概念，应用程序可以通过它发送或接收数据。在使用 Socket 进行网络通信的时候，通过 Socket 就可以让我们的数据在网络中传输。操作套接字的时候，和我们读写文件很像。套接字是 IP 地址与端口的组合，套接字 Socket&#x3D;（IP 地址：端口号）。</p><p>要通过互联网进行通信，至少需要一对套接字：</p><ol><li>运行于服务器端的 Server Socket。</li><li>运行于客户机端的 Client Socket</li></ol><p>在 Java 开发中使用 Socket 时会常用到两个类，都在 <code>java.net</code> 包中：</p><ol><li><code>Socket</code>: 一般用于客户端</li><li><code>ServerSocket</code> :用于服务端</li></ol><h2 id="Socket网络通信过程"><a href="#Socket网络通信过程" class="headerlink" title="Socket网络通信过程"></a><strong>Socket网络通信过程</strong></h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171451051.png" alt="aacf635e-4ed6-4ba5-9346-d45500b48098"></p><p><strong>Socket 网络通信过程简单来说分为下面 4 步：</strong></p><ol><li>建立服务端并且监听客户端请求</li><li>客户端请求，服务端和客户端建立连接</li><li>两端之间可以传递数据</li><li>关闭资源</li></ol><p>对应到服务端和客户端的话，是下面这样的。</p><p><strong>服务器端：</strong></p><ol><li>创建 <code>ServerSocket</code> 对象并且绑定地址（ip）和端口号(port)：<code>server.bind(new InetSocketAddress(host, port))</code></li><li>通过 <code>accept()</code>方法监听客户端请求</li><li>连接建立后，通过输入流读取客户端发送的请求信息</li><li>通过输出流向客户端发送响应信息</li><li>关闭相关资源</li></ol><p><strong>客户端：</strong></p><ol><li>创建<code>Socket</code> 对象并且连接指定的服务器的地址（ip）和端口号(port)：<code>socket.connect(inetSocketAddress)</code></li><li>连接建立后，通过输出流向服务器端发送请求信息</li><li>通过输入流获取服务器响应的信息</li><li>关闭相关资源</li></ol><h2 id="Socket网络通信实战"><a href="#Socket网络通信实战" class="headerlink" title="Socket网络通信实战"></a><strong>Socket网络通信实战</strong></h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloServer.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-comment">//1.创建 ServerSocket 对象并且绑定一个端口</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);) &#123;<br>            Socket socket;<br>            <span class="hljs-comment">//2.通过 accept()方法监听客户端请求</span><br>            <span class="hljs-keyword">while</span> ((socket = server.accept()) != <span class="hljs-literal">null</span>) &#123;<br>                logger.info(<span class="hljs-string">&quot;client connected&quot;</span>);<br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());<br>                     <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream())) &#123;<br>                   <span class="hljs-comment">//3.通过输入流读取客户端发送的请求信息</span><br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (Message) objectInputStream.readObject();<br>                    logger.info(<span class="hljs-string">&quot;server receive message:&quot;</span> + message.getContent());<br>                    message.setContent(<span class="hljs-string">&quot;new content&quot;</span>);<br>                    <span class="hljs-comment">//4.通过输出流向客户端发送响应信息</span><br>                    objectOutputStream.writeObject(message);<br>                    objectOutputStream.flush();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                    logger.error(<span class="hljs-string">&quot;occur exception:&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur IOException:&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HelloServer</span> <span class="hljs-variable">helloServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloServer</span>();<br>        helloServer.start(<span class="hljs-number">6666</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ServerSocket</code> 的 <code>accept（）</code> 方法是<strong>阻塞方法</strong>，也就是说 <code>ServerSocket</code> 在调用 <code>accept（)</code>等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p><p>很明显，上面演示的代码片段有一个很严重的问题：**只能同时处理一个客户端的连接，如果需要管理多个客户端的话，就需要为我们请求的客户端单独创建一个线程。**对应的 Java 代码可能是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>   <span class="hljs-comment">// 创建 socket 连接</span><br>&#125;).start();<br></code></pre></td></tr></table></figure><p>但是，这样会导致一个很严重的问题：<strong>资源浪费</strong>。</p><p>我们知道线程是很宝贵的资源，如果我们为每一次连接都用一个线程处理的话，就会导致<strong>线程越来越多</strong>，最后达到了极限之后，就无法再创建线程处理请求了。处理的不好的话，甚至可能直接就宕机掉了。很多人就会问了：那有没有改进的方法呢？</p><p>当然有！ 比较简单并且实际的改进方法就是使用<strong>线程池</strong>。线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。<strong>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的 BIO 模型的事实，因此无法从根本上解决问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> Executors.defaultThreadFactory();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, TimeUnit.MINUTES, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>), threadFactory);<br>threadPool.execute(() -&gt; &#123;<br>     <span class="hljs-comment">// 创建 socket 连接</span><br> &#125;);<br></code></pre></td></tr></table></figure><blockquote><p>bio的话，线程池最多防止资源耗费过多，因为你读完数据，下一轮还是会阻塞到read方法，并不会结束这个线程的任务，所以线程还不回线程池。</p></blockquote><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloClient.class);<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">send</span><span class="hljs-params">(Message message, String host, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-comment">//1. 创建Socket对象并且指定服务器的地址和端口号</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(host, port)) &#123;<br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream());<br>            <span class="hljs-comment">//2.通过输出流向服务器端发送请求信息</span><br>            objectOutputStream.writeObject(message);<br>            <span class="hljs-comment">//3.通过输入流获取服务器响应的信息</span><br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());<br>            <span class="hljs-keyword">return</span> objectInputStream.readObject();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur exception:&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HelloClient</span> <span class="hljs-variable">helloClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloClient</span>();<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (Message) helloClient.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;content from client&quot;</span>), <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br>        System.out.println(<span class="hljs-string">&quot;client receive message:&quot;</span> + message.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先运行服务端，然后再运行客户端，控制台输出如下：</p><p>服务端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[main] INFO github.javaguide.socket.HelloServer - client connected<br>[main] INFO github.javaguide.socket.HelloServer - server receive message:content from client<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">client receive message:<span class="hljs-keyword">new</span> <span class="hljs-title class_">content</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>点评项目</title>
    <link href="/2025/02/15/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/02/15/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="点评项目"><a href="#点评项目" class="headerlink" title="点评项目"></a>点评项目</h1><h2 id="短信登录功能"><a href="#短信登录功能" class="headerlink" title="短信登录功能"></a>短信登录功能</h2><h3 id="基于Session实现登录"><a href="#基于Session实现登录" class="headerlink" title="基于Session实现登录"></a>基于Session实现登录</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151751207.png" alt="image-20250211151403643"></p><h4 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a><strong>Session原理</strong></h4><ul><li>Session会为每一次会话分配一个Session对象</li><li>同一个浏览器发起的多次请求，同属于一次会话（Session）</li><li>首次使用到Session时，服务器会自动创建Session，并创建<strong>Cookie</strong>存储SessionId发送回客户端</li></ul><h4 id="Session在项目中的使用"><a href="#Session在项目中的使用" class="headerlink" title="Session在项目中的使用"></a><strong>Session在项目中的使用</strong></h4><ul><li><strong>保存验证码到session</strong>：session.setAttribute(“code”, code)</li><li><strong>校验验证码</strong>：session.getAttribute(“code”)获取前面生成的验证码，与提交表单中的验证码进行比较，相同则说明输入正确</li><li><strong>保存用户到session</strong>：session.setAttribute(“user”,BeanUtil.copyProperties(user,UserDTO.class))<ul><li>其中这里保存的并非User对象，而是UserDTO对象</li><li>这是因为user对象中包含密码等敏感信息，若直接将User对象保存到session不安全，故将UserDTO对象保存到session中，用于后面的登录校验</li></ul></li></ul><h4 id="登录校验功能"><a href="#登录校验功能" class="headerlink" title="登录校验功能"></a><strong>登录校验功能</strong></h4><p>登录校验功能用于检验用户的登录状态，因为某些功能需要用户登录才能实现，比如：用户主页、用户私信。但是每次执行这些功能，都需要在对应功能的service实现类中实现从session中获取用户的操作，这样会很麻烦。</p><p>于是，我们选择在前面加一层拦截器，用于实现session中获取用户的操作，具体实现如下：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151751652.png" alt="image-20250211154537472"></p><h4 id="拦截器的实现"><a href="#拦截器的实现" class="headerlink" title="拦截器的实现"></a><strong>拦截器的实现</strong></h4><p>我们用于实现登录状态校验的拦截器<strong>LoginInterceptor</strong>，需要实现<strong>HandlerInterceptor</strong>，拦截器的执行流程分为三个主要阶段：<em><strong>preHandle</strong></em>、<em><strong>postHandle</strong></em>和<em><strong>afterCompletion</strong></em>。</p><ul><li>在请求处理的前期，<em>preHandle</em>方法会被调用，如果返回<em>true</em>，则继续执行后续的拦截器和请求处理器；如果返回<em>false</em>，则中断执行流程。</li><li>在请求处理完毕后，<em>postHandle</em>方法会被调用，用于进行后处理操作。</li><li>最后，在请求完成后，<em>afterCompletion</em>方法会被调用，用于进行资源清理等操作。</li></ul><h4 id="拦截器的注册"><a href="#拦截器的注册" class="headerlink" title="拦截器的注册"></a><strong>拦截器的注册</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 登录拦截器,order(1)表示顺序</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<br>                        <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/voucher/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/login&quot;</span><br>                ).order(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 获取用户token并刷新token</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshTokenInterceptor</span>(stringRedisTemplate))<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="保存用户到ThreadLocal"><a href="#保存用户到ThreadLocal" class="headerlink" title="保存用户到ThreadLocal"></a><strong>保存用户到ThreadLocal</strong></h4><p>ThreadLocal的三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.set(T value); <span class="hljs-comment">//设置值</span><br>ThreadLocal.get(); <span class="hljs-comment">//获取值</span><br>ThreadLocal.remove(); <span class="hljs-comment">//移除值</span><br></code></pre></td></tr></table></figure><p>所以我们可以借助这个ThreadLocal来存储登录用户的信息，在一个请求中，所有调用的方法都在同一个线程中去处理，这样就实现了在任何地方都可以获取到用户信息了，从而摆脱了HttpServletRequest的束缚。</p><h4 id="基于MybatisPlus实现的增删改查操作"><a href="#基于MybatisPlus实现的增删改查操作" class="headerlink" title="基于MybatisPlus实现的增删改查操作"></a><strong>基于MybatisPlus实现的增删改查操作</strong></h4><p>项目中使用MybatisPlus，简化了对数据库的增删改查操作，这是由service实现类通过继承MybatisPlus的<strong>ServiceImpl</strong>&lt;UserMapper, User&gt;实现的</p><ul><li><p><strong>根据手机号查询用户</strong>：User user &#x3D; query().eq(“phone”, phone).one()</p></li><li><p><strong>根据手机号生成新用户</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建用户</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>user.setPhone(phone);<br>user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="hljs-number">10</span>));<br><span class="hljs-comment">// 2.保存用户</span><br>save(user);<br></code></pre></td></tr></table></figure></li></ul><h4 id="集群的Session共享问题"><a href="#集群的Session共享问题" class="headerlink" title="集群的Session共享问题"></a><strong>集群的Session共享问题</strong></h4><p>当使用<strong>Tomcat集群</strong>时，多台Tomcat并不共享session的存储空间，当请求切换到不同tomcat服务时会导致数据丢失问题。如：用户登录时，使用Tomcat1，其对应的用户登录信息存储在Tomcat1的session中，当用户访问其他功能时，系统负载均衡分配了Tomcat2，这时的Tomcat2中不存在该用户存在session中的信息，于是会导致用户即使刚刚才登录，此时又需要再登录一遍。</p><p>session的替代方案应满足如下需求：</p><ul><li>数据共享</li><li>内存存储：session是基于内存存储的，它的读写效率高。而登录校验的访问频率非常高</li><li>key、value结构</li></ul><p><strong>——Redis</strong></p><h3 id="基于Redis实现共享session登录"><a href="#基于Redis实现共享session登录" class="headerlink" title="基于Redis实现共享session登录"></a><strong>基于Redis实现共享session登录</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752686.png" alt="image-20250211160014180"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752612.png" alt="image-20250211161336341"></p><h4 id="redis在项目中的使用"><a href="#redis在项目中的使用" class="headerlink" title="redis在项目中的使用"></a><strong>redis在项目中的使用</strong></h4><ul><li><p><strong>保存验证码到redis</strong>：stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES)，key设置为如上格式，能够清晰读懂redis各条键值对的功能，同时设置验证码的过期时间</p></li><li><p><strong>校验验证码</strong>：stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone)</p></li><li><p><strong>保存用户到redis</strong>：以随机token为key存储用户数据，用户对象使用Hash类型存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 7.保存用户信息到redis中</span><br><span class="hljs-comment">// 7.1随机生成token作为登陆令牌</span><br><span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 7.2 将User对象转换为HashMap存储</span><br><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO);<br>userMap.replace(<span class="hljs-string">&quot;id&quot;</span>, userDTO.getId().toString());<br><span class="hljs-comment">// 7.3存储</span><br><span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);<br><span class="hljs-comment">// 7.4设置有效期</span><br>stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure></li><li><p><strong>刷新过期时间</strong>：在拦截器中更新用户的过期时间</p></li></ul><p>通过上述改动，我们完成了使用redis实现共享session登录</p><h4 id="刷新过期时间问题"><a href="#刷新过期时间问题" class="headerlink" title="刷新过期时间问题"></a><strong>刷新过期时间问题</strong></h4><p>因为刷新过期时间是在拦截器中实现的，因此只有请求通过拦截器才会刷新过期时间，即使用户一直浏览主界面也不会刷新过期时间。为了解决这个问题，我们又添加了一个拦截器在前面</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752570.png" alt="image-20250211162311047"></p><ul><li>第一个拦截器RefreshTokenInterceptor的核心工作是得到用户、保存起来并刷新过期时间</li><li>第二个拦截器LoginInterceptor的核心工作是对不存在的用户进行拦截</li></ul><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a><strong>添加商户缓存</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752594.png" alt="image-20250211201328475"></p><p>使用redis中的<strong>string类型</strong>存储商铺缓存：</p><ul><li>若redis中存在要查询的商户，利用redis查到的json字符串结合hutool中的JSONUtil工具实现：Shop shop &#x3D; JSONUtil.toBean(shopJson, Shop.class)</li><li>若redis中不存在要查询的商户，到数据库中去查找，将找到的Shop对象通过hutool中的JSONUtil工具转换为json字符串：JSONUtil.toJsonStr(shop)</li></ul><h3 id="添加商户类型缓存"><a href="#添加商户类型缓存" class="headerlink" title="添加商户类型缓存"></a><strong>添加商户类型缓存</strong></h3><p>查询商户类型返回的是多个商户类型，即List<ShopType>，因此将商户类型存储在redis中时，我们选择使用<strong>redis中的list类型</strong>进行存储：</p><ul><li><p>先在缓存中查询：<strong>List<String></strong> shopTypeJsonList &#x3D; stringRedisTemplate.opsForList().range(CACHE_SHOPTYPE_LIST, 0, -1)，0、-1表示从头查到尾&#x3D;&#x3D;（注意，list类型查询返回只能得到一个List<String>类型的集合，因此我们每一个对象都要先转为json字符串再存储）&#x3D;&#x3D;</p></li><li><p>若redis中存在，即shopTypeJsonList非空，则将这个json字符串集合一个个转换为ShopType对象后，返回一个ShopTypeList集合</p></li><li><p>若redis中不存在，则需要到数据库中查找，注意，我们需要按照“sort”字段排序查找</p></li><li><p>查找到之后，将这些ShopType对象的集合一个个push到redis中去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(ShopType shopType : shopTypeList) &#123;<br>  stringRedisTemplate.opsForList().rightPush(CACHE_SHOPTYPE_LIST, JSONUtil.toJsonStr(shopType));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后返回一个ShopTypeList集合</p></li></ul><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752321.png" alt="image-20250211202918433"></p><ul><li>低一致性需求：使用内存淘汰机制。如商户类型查询的缓存。</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案。如店铺详情查询的缓存。</li></ul><h4 id="操作缓存和数据库需要考虑的问题"><a href="#操作缓存和数据库需要考虑的问题" class="headerlink" title="操作缓存和数据库需要考虑的问题"></a><strong>操作缓存和数据库需要考虑的问题</strong></h4><ul><li>删除缓存还是更新缓存？<ul><li>更新缓存：每次更新数据库都更新缓存，无效的写操作较多。</li><li>&#x3D;&#x3D;删除缓存&#x3D;&#x3D;：更新数据库时让缓存失效，查询时再更新缓存。</li></ul></li><li>如何保证缓存和数据库的操作<strong>同时成功或失败</strong>？<ul><li>单体系统：将缓存和数据库的操作放在同一个事务内。如放在同一个方法内，并用**@Transactional**修饰这个方法。</li><li>分布式系统：利用TCC等分布式事务。</li></ul></li><li><strong>先操作缓存还是先操作数据库？</strong><ul><li><strong>先删除缓存再操作数据库</strong></li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752308.png" alt="image-20250211203731172" style="zoom: 33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752090.png" alt="image-20250211203755582" style="zoom: 33%;" /></li><li>&#x3D;&#x3D;<strong>先操作数据库再删除缓存</strong>&#x3D;&#x3D;</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752210.png" alt="image-20250211203939763" style="zoom:33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752102.png" alt="image-20250211203955306" style="zoom:33%;" /></li><li>左边为正常情况，右边为异常情况</li><li>相比之下，前者出现异常情况的概率较大，而后者出现异常情况的概率较小，<strong>这是因为更新数据库的耗时相对而言较长导致的</strong>，因此可以选择后者。</li></ul></li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752365.png" alt="image-20250211204527433" style="zoom: 25%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752605.png" alt="image-20250211205011369" style="zoom:33%;" /></p><p>缓存穿透是指客户端请求的数据<strong>在缓存和数据库中都不存在</strong>，这样<strong>缓存永远不会生效</strong>，这些请求都会打到数据库。常见的解决方案有两种：</p><ul><li><p><strong>缓存空对象</strong>：将这种数据在redis中使用一个空对象如 “” 缓存起来，并设置一个<strong>较短的TTL</strong>，当下次再有这样的请求过来时就不会打到数据库了。</p><ul><li>优点：实现简单，维护方便</li><li>缺点：额外的内存消耗、可能造成短期的不一致</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752212.png" alt="image-20250211205343702" style="zoom:33%;" /></li></ul></li><li><p><strong>布隆过滤</strong></p><ul><li>布隆过滤算法是一种数据统计算法，用于检索一个元素是否在集合中。但是布隆过滤无需存储元素到集合，而是把元素映射到一个很长的二进制数位上。利用布隆过滤算法，在请求进入redis之前先判断是否存在，如果不存在则直接拒绝请求</li><li>优点：内存占用较少，没有多余的key</li><li>缺点：实现复杂、存在误判可能</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752022.png" alt="image-20250212135951528" style="zoom:33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752918.png" alt="image-20250212140747872" style="zoom:33%;" /></li></ul></li><li><p><strong>其他</strong></p><ul><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul></li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753143.png" alt="image-20250211205458168" style="zoom: 33%;" /><p>缓存雪崩是指在<strong>同一时段大量的缓存key同时失效</strong>或者redis服务宕机，导致大量请求打到数据库，带来巨大压力。解决方案：</p><ul><li>给不同的key的TTL添加随机值</li><li>利用redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753170.png" alt="image-20250211205931115" style="zoom: 33%;" /><p>缓存击穿问题也叫<strong>热点key问题</strong>，就是一个被高并发访问并且缓存重建业务比较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大冲击。常见的解决方案有两种：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753133.png" alt="image-20250211210042375" style="zoom:50%;" /><ul><li>互斥锁：给<strong>第一个未命中缓存的线程加锁</strong>、查询数据库并写入缓存后再释放锁，<strong>其他线程在此期间需要等待</strong>。<ul><li>优点：1. 没有额外的内存消耗    2. 保证一致性    3. 实现简单</li><li>缺点：1. 线程需要等待，性能受影响     2. 可能有死锁风险</li></ul></li><li>逻辑过期：不设置TTL，而是设置一个逻辑过期时间，首个发现逻辑时间过期的线程会<strong>开启一个新的线程用于更新数据</strong>，其本身以及在此期间查询的其他线程则会<strong>返回当下的过期数据</strong>。<ul><li>优点：线程无需等待，性能良好</li><li>缺点：1. 不保证一致性    2. 有额外内存消耗    3. 实现复杂</li></ul></li></ul><h4 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a><strong>利用互斥锁解决缓存击穿问题</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753969.png" alt="image-20250212113031052" style="zoom:50%;" /><ul><li>利用redis中的&#x3D;&#x3D;<strong>setnx（SET if Not eXists）命令</strong>&#x3D;&#x3D;实现互斥锁。</li><li>setnx基本语法：SETNX KEY_NAME VALUE在指定的 key 不存在时，为 key 设置指定的值，返回设置的值；若指定的key存在时，返回0。</li><li>Java中如何使用setnx方法实现<strong>获取互斥锁</strong>？stringRedisTemplate.opsForValue().<strong>setIfAbsent</strong>，这个方法返回一个Boolean值，在需要获取互斥锁时，在redis中设置<strong>setnx lockKey 1（TTL &#x3D; 20s）</strong>，如果设置成功，则返回true；而<strong>其他想要获取互斥锁的线程都会在setnx lockKey 1这一步中被堵住</strong>，故只有一个最早的线程能够到达后面的数据库，并进行缓存重建。</li><li>Java中如何使用setnx方法实现<strong>释放互斥锁</strong>？只需要进行缓存重建的线程在重建完毕后，将lockKey删除即可，这样后面想要获取互斥锁的线程就能够得到互斥锁了。注意，为了避免互斥锁无法释放，一般将释放锁操作放在finally代码块中执行。</li><li>由于缓存重建的过程需要先查找数据库，再写入redis，<strong>这一过程需要花费一定时间</strong>，在这段时间中，因为缓存未命中而想要重建缓存的线程都会被互斥锁挡住，直到缓存重建完毕，因此<strong>不会存在不一致的情况</strong>，即这段时间内所有的线程返回的值都是缓存重建完后的值。</li></ul><h4 id="利用逻辑过期解决缓存击穿问题"><a href="#利用逻辑过期解决缓存击穿问题" class="headerlink" title="利用逻辑过期解决缓存击穿问题"></a><strong>利用逻辑过期解决缓存击穿问题</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753395.png" alt="image-20250212113214513" style="zoom:33%;" /><ul><li>因为要处理的数据一般为热点数据，所以会提前写入缓存中预热，且只有逻辑过期时间、没有TTL，永不过期。因此，如果发现缓存未命中，说明不存在这样的数据，则直接返回空。</li><li>由于存到redis中的数据还需要包含一个逻辑过期的时间，因此创建一个新的对象redisData将商铺对象、逻辑过期时间包含起来。</li><li>将取得的逻辑过期时间与当前时间对比，若未过期，说明当前的商铺信息仍在有效期内，故直接返回。</li><li>若已过期，则先获取一个lockKey的互斥锁，获取方法同上。然后<strong>开启一个独立的线程</strong>，进行缓存重建，重建完释放互斥锁。而当前线程则直接返回获取到的过期数据。</li><li>在缓存重建期间，其他线程到达想要获取互斥锁，获取失败后也直接返回过期数据。</li><li>因为该方法存在返回过期数据的情况，因此这个方法会有不一致的情况出现。</li><li>注意⚠️：由于本项目中选择的缓存更新策略是——更新数据库时让缓存失效，查询时再更新缓存。但是在本方法中，<strong>删除缓存之后会导致其他线程无法命中缓存就直接返回空值</strong>，因此逻辑过期不适用于当前方法。可以采用更新缓存的策略——每次更新数据库都更新缓存。</li></ul><h3 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a><strong>缓存工具封装</strong></h3><p><strong>&#x3D;&#x3D;泛型&#x3D;&#x3D;</strong></p><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a><strong>优惠券秒杀</strong></h2><h3 id="全局唯一ID生成策略"><a href="#全局唯一ID生成策略" class="headerlink" title="全局唯一ID生成策略"></a><strong>全局唯一ID生成策略</strong></h3><p>当用户购买商品时，就会生成订单并保存到订单表中，而如果订单表采用数据库自增ID就会出现一些问题：</p><ul><li>ID的规律性太过明显，不安全</li><li>受单表数据量的限制，因为订单是会不断累积的，而单表所能容纳的数据量是有限的，后期会需要用到分库分表。而如果此时还使用数据库的自增ID，就会出现多个订单有相同的订单ID。</li></ul><p>故我们需要选择一种方法实现全局ID的生成，这种方法需要满足：唯一性、高可用、高性能、递增性、安全性的特点——<strong>redis</strong>。</p><ul><li>递增性：INCR key。当执行 INCR 命令时，如果键不存在，Redis 会先创建一个新的键，并将其初始值设置为0，然后再进行自增操作。</li><li>安全性：INCR 命令是原子操作，这意味着当多个客户端同时对同一个键执行 INCR 命令时，Redis 会确保操作的原子性。这意味着在多线程或并发环境下，不会出现竞态条件或数据不一致的情况。为了增加ID的安全性，我们可以不直接使用redis自增的数值，而是拼接一些其他的信息，如：时间戳（31位）+计数位（32位）</li></ul><h3 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a><strong>添加优惠券</strong></h3><p>本项目中的优惠券分为普通优惠券与秒杀优惠券，普通优惠券不限量且没有购买时间要求，而秒杀优惠券有库存，且需要在指定时间范围内才能购买。两者的数据表如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> `tb_voucher`  (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键&#x27;</span>,<br>  `shop_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商铺id&#x27;</span>,<br>  `title` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">CHARACTER SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;代金券标题&#x27;</span>,<br>  `sub_title` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">CHARACTER SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;副标题&#x27;</span>,<br>  `rules` <span class="hljs-type">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">CHARACTER SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;使用规则&#x27;</span>,<br>  `pay_value` <span class="hljs-type">bigint</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;支付金额，单位是分。例如200代表2元&#x27;</span>,<br>  `actual_value` <span class="hljs-type">bigint</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;抵扣金额，单位是分。例如200代表2元&#x27;</span>,<br>  `type` tinyint(<span class="hljs-number">1</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;0,普通券；1,秒杀券&#x27;</span>,<br>  `status` tinyint(<span class="hljs-number">1</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;1,上架; 2,下架; 3,过期&#x27;</span>,<br>  `create_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `update_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">CHARACTER SET</span> <span class="hljs-operator">=</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> `tb_seckill_voucher`  (<br>  `voucher_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;关联的优惠券的id&#x27;</span>,<br>  `stock` <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;库存&#x27;</span>,<br>  `create_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `begin_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;生效时间&#x27;</span>,<br>  `end_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;失效时间&#x27;</span>,<br>  `update_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`voucher_id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-keyword">CHARACTER SET</span> <span class="hljs-operator">=</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8mb4_general_ci COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;秒杀优惠券表，与优惠券是一对一关系&#x27;</span> ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br></code></pre></td></tr></table></figure><p>两张表是关联的，添加秒杀优惠券只需先保存到优惠券表中，然后再将部分字段保存到秒杀优惠券表中即可。</p><h3 id="实现秒杀优惠券下单"><a href="#实现秒杀优惠券下单" class="headerlink" title="实现秒杀优惠券下单"></a><strong>实现秒杀优惠券下单</strong></h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753985.png" alt="image-20250212164645234" style="zoom:33%;" /><p>扣减库存选择直接使用MybatisPlus中的update操作：seckillVoucherService.update().setSql(“stock &#x3D; stock - 1”).eq(“voucher_id”, voucherId).update()。</p><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a><strong>超卖问题</strong></h4><p>但是这样的做法会导致<strong>超卖现象</strong>的产生：即在线程1扣减库存之前，<strong>其他线程查到了未扣减之前的库存</strong>，导致最终<strong>库存变为了负数</strong>。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753604.png" alt="image-20250212165754627" style="zoom:33%;" /><p>超卖问题是典型的多线程安全问题，常见的解决方案就是加锁。而锁又可分为**&#x3D;&#x3D;悲观锁和乐观锁&#x3D;&#x3D;**：</p><ul><li><strong>悲观锁</strong>：<strong>认为线程安全问题一定会发生</strong>，因此在操作数据之前先获取锁，确保<strong>线程串行执行</strong>。Synchronized、Lock都属于悲观锁。优点：简单；缺点：性能一般。</li><li><strong>乐观锁</strong>：<strong>认为线程安全问题不一定会发生</strong>，因此&#x3D;&#x3D;不加锁&#x3D;&#x3D;，而是在更新数据的时候去<strong>判断有没有其他线程对数据进行修改</strong>。优点：性能好；缺点：存在成功率低的问题。<ul><li>如果没有修改，则认为是安全的，更新数据。</li><li>如果发现数据被修改了，说明发生了线程安全问题，此时可以重试或报异常。</li><li>乐观锁的常见实现方式有两种：<strong>版本号法、CAS（Compare and Swap）</strong><ul><li>版本号法：在原有数据基础上，为每个数据添加一个版本号version，数据每进行一次修改就使版本号增加。当要修改数据时，比较之前查询该数据得到的版本号与当前的版本号是否一致，若不一致则说明数据出现了修改。</li><li>CAS：在版本号的基础上，直接拿数据中要进行修改的字段进行比较，若前后不一致则说明发生了修改。</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754527.png" alt="image-20250212170606199" style="zoom: 33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754859.png" alt="image-20250212170924768" style="zoom: 33%;" /></li></ul></li></ul></li></ul><h4 id="CAS解决超卖问题时出现的问题"><a href="#CAS解决超卖问题时出现的问题" class="headerlink" title="CAS解决超卖问题时出现的问题"></a><strong>CAS解决超卖问题时出现的问题</strong></h4><p>我们选择使用上方的CAS方法解决超卖问题，在jMeter压力测试中，选择使用200个线程同时对100张秒杀优惠券进行抢购，这一次优惠券的库存没有变为负数，但是优惠券只卖出了20张，秒杀成功率大大减少了。</p><p>这是因为当有<strong>多个线程同时查到了同样的库存</strong>时，<strong>只有一个线程能够抢到优惠券</strong>，其他线程会因为当前剩余库存与前面查询到的库存不一致导致秒杀失败。</p><p>解决方案：将sql语句中的：stock &#x3D; 前面查询到的stock更改为<strong>stock &gt; 0</strong> 即可。</p><h4 id="实现一人一单功能"><a href="#实现一人一单功能" class="headerlink" title="实现一人一单功能"></a><strong>实现一人一单功能</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754411.png" alt="image-20250212175948943" style="zoom: 33%;" /><p>相较于上面主要的改动就是在扣减库存之前多了一道判断订单是否存在的步骤：判断数据库中<strong>是否已存在相同user_id和相同voucher_id的订单</strong>，如果这样的订单数量大于0，说明该用户已经买过这张优惠券，返回异常值。</p><p>1️⃣但是这样的操作会导致&#x3D;&#x3D;<strong>线程安全问题</strong>&#x3D;&#x3D;：一个用户在<strong>多个线程中同时进行了订单是否存在的判断</strong>，而此时还没创建订单，因此判断的结果都说明数据库中不存在这样的订单，则这多个线程会同时对库存进行扣减，还是没达到一人一单的效果。为了解决这个线程安全问题，我们可以加锁。由于<strong>乐观锁是在数据发生修改时才生效的</strong>，因此无法用于本问题里，于是我们选择<strong>悲观锁——synchronized</strong>用于解决线程安全问题。</p><p>由于前面的判断环节不会产生线程安全问题，为了方便synchronized关键字的使用，我们选择将查询订单到返回订单id这一段代码独立出来成为一个方法createVoucherOrder，该方法带有**@Transactional注释**。<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151756013.png" alt="image-20250212190212401" style="zoom:33%;" /></p><p>2️⃣现在就有一个问题，&#x3D;&#x3D;<strong>synchronized关键字的位置应该放在什么位置呢</strong>&#x3D;&#x3D;？是用于修饰方法createVoucherOrder呢？还是修饰方法内的一段代码块呢？解决这个问题的关键在于我们引入锁的初衷——实现一人一单功能。</p><ul><li>如果我们将synchronized用于修饰方法，那么当一个用户执行这个方法时，其他用户无法执行这个方法，只能等待，这显然大大削减了性能。而我们的目的仅仅只是让一个用户的多个线程无法同时进行方法的执行。</li><li>因此我们选择将synchronized用于修饰代码块，同时将**&#x3D;&#x3D;userId作为对象传入synchronized实现对单个用户加锁&#x3D;&#x3D;**。</li><li>为了实现对单个用户加锁，不同的用户不会被锁定，那么同一个用户传入synchronized的Long userId对象就需要是同一个：<ul><li>如果仅仅只传userId，多个线程下查到的userId地址不同，是不同的userId对象❌</li><li>如果传入userId.toString()，多个线程下查到的字符串地址不同，是不同的字符串对象❌</li><li>因此需要传入的是<strong>userId.toString().intern()</strong>，String.intern()是一个Native方法，它的作用是：如果字符常量池中已经包含一个等于此String对象的字符串，则返回常量池中字符串的引用。总之就是源于<strong>String对象的字符串是存储在&#x3D;&#x3D;常量池&#x3D;&#x3D;中的</strong>，如果多个String对象的字符串长得一样，那么他们在常量池中都<strong>指向同一个字符串</strong>，这就保证了传入synchronized关键字的是同一个对象。<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151756025.png" alt="image-20250212191841136" style="zoom:33%;" />✅</li></ul></li></ul><p>3️⃣但是，这样也会产生新的问题。由于方法是被@Transactional注释所修饰的，因此如果synchronized修饰<strong>方法内的一段代码块</strong>，就会出现**&#x3D;&#x3D;先释放锁，再提交事务&#x3D;&#x3D;<strong>的现象。如果一个线程释放锁但还没提交事务，这时有一个新的线程获取了锁，由于事务尚未提交，如果这时这个新的线程去查询订单，<strong>查询到的可能就是前一个线程未修改前的数据</strong>，这就产生了线程安全问题。这说明</strong>&#x3D;&#x3D;锁的范围小了，应该在事务提交之后再释放锁&#x3D;&#x3D;**，于是synchronized应该修饰函数调用所在的代码块，即：<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754132.png" alt="image-20250212193326069" style="zoom: 50%;" /></p><p>4️⃣经过上述操作，确保了线程安全，但是随之而来又有事务方面的问题。注意到，我们是对当前的createVoucherOrder方法进行了@Transactional的注释，而没有给外面的函数seckillVoucher加事务，而外面的函数seckillVoucher在执行上面这段代码时，等价于是这样执行的：<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754889.png" alt="image-20250212194040961" style="zoom:33%;" />这里的**&#x3D;&#x3D;this&#x3D;&#x3D;代表的是当前VoucherOrderServiceImpl这个类的对象，而不是它的代理对象**。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754096.png" alt="image-20250212194513920" style="zoom: 33%;" /><p>而事务要想生效，是因为<strong>spring对VoucherOrderServiceImpl这个类进行了动态代理，拿到了它的&#x3D;&#x3D;代理对象&#x3D;&#x3D;</strong>，用这个代理对象来去做事务处理；而<strong>现在这个this指的是非代理对象，是不具有事务功能的</strong>。因此我们需要拿到这个代理对象，获取方法如下：<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754106.png" alt="image-20250212194939735" style="zoom:33%;" />当然，上面的解决代理对象问题还需要如下两个步骤：</p><ul><li>pom文件中引入aspectjweaver依赖。</li><li>启动类添加@EnableAspectJAutoProxy(exposeProxy &#x3D; true)注解，用于暴露代理对象。</li></ul><p>这样就解决了事务问题。</p><h4 id="集群下一人一单的并发安全问题"><a href="#集群下一人一单的并发安全问题" class="headerlink" title="集群下一人一单的并发安全问题"></a><strong>集群下一人一单的并发安全问题</strong></h4><p>上面的处理方式，在单体部署的情况下是没有问题的，因为此时只有一台Tomcat1，即只有一台JVM1，线程获取的锁都是这台JVM1中的同一把锁（锁的UUID保存在常量池中），故<strong>多个线程竞争这一把锁</strong>，保证了线程安全。</p><p>但是如果在集群部署的情况下，就说明有<strong>多台Tomcat提供服务，即有多台JVM</strong>，故Tomcat1中的线程竞争的是JVM1中的锁，而Tomcat2中的线程竞争的是JVM2中的锁，<strong>此时有多把锁</strong>。故此时如果一个用户在两台Tomcat中都实现了下单操作，则<strong>两边都能获取到锁</strong>，故生成了两个订单，违背了一人一单的规定，这就导致了集群下一人一单问题的并发安全问题。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754699.png" alt="image-20250212203633633" style="zoom:33%;" /><h4 id="Redis的分布式锁实现"><a href="#Redis的分布式锁实现" class="headerlink" title="Redis的分布式锁实现"></a><strong>Redis的分布式锁实现</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754441.png" alt="image-20250213114816370" style="zoom:33%;" /><p>为了解决上述的并发安全，我们就需要实现<strong>多台JVM下的线程竞争同一把锁</strong>，<strong>即分布式锁</strong>——满足分布式系统或集群模式下多进程可见并且互斥的锁，本项目中我们选择使用redis的<strong>setnx</strong>关键字来解决分布式锁的实现。</p><p>而为了实现redis分布式锁只对同一个用户产生作用，设置的<strong>key值就需要区分不同用户</strong>，以此来实现对同一个用户的不同进程加锁，而不同用户获取的锁不同。对于下单功能，本项目设置的key值为：<strong>“lock:order:”+userId</strong>。</p><p>1️⃣而使用redis实现分布式锁就会出现一个问题：当一个进程占有锁时，若此时redis宕机了，就会导致锁无法被释放，造成<strong>死锁现象</strong>的产生。解决这个问题也很简单，我们只需要给这个锁设置一个<strong>过期时间</strong>，超时自动释放锁，就不会出现由于redis宕机导致的死锁现象。</p><p>2️⃣但是，正是由于给锁设置了过期时间，新的问题产生了——<strong>锁的误删问题</strong>。如下图所示，当线程1获取锁但是业务阻塞导致<strong>超时释放锁</strong>，在线程1业务完成之前，<strong>线程2趁虚而入拿到了锁并开始执行业务</strong>，这时候线程1完成了业务并按部就班去释放锁，但是这时候占用锁的是线程2，也就是说<strong>线程1把线程2的锁给释放了</strong>，这时候如果又有一个线程3来获取锁是能够获取成功的，这就导致了线程2、线程3同时执行业务，产生了并发安全问题。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754037.png" alt="image-20250213130001479" style="zoom:33%;" /><p>解决锁的误删问题可以采用如下方法：在给锁设置<strong>value值</strong>时，使用<strong>线程ID作为锁的value值</strong>，这样就能知道当前的锁是不是本线程所设置的，当线程业务执行完毕想要释放锁时，先执行一个判断，<strong>判断当前锁的value值与自身线程ID是否相同</strong>，如果相同说明是同一把锁可以释放，否则说明是别的线程的锁，不做操作，这样就避免了锁的误删问题。</p><p>当然，仅仅只使用线程ID作为value值是不够的，因为在不同的进程之间可能存在相同的线程ID，有小概率出现混淆的情况，我们可以选择在<strong>线程ID之前拼接一个UUID确保唯一性</strong>，将拼接的结果作为锁的value值。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754613.png" alt="image-20250213131120388" style="zoom:33%;" /><p>3️⃣但是，还会有一个问题：当线程1获取锁之后，未执行业务就发生了阻塞，此时如果锁释放了，线程2来获取锁是能够获取得到的，这就会造成线程1、2同时执行业务的情况出现，还是会发生一个用户下了多个订单的情况。如上图中<strong>线程1、2执行业务有重叠的部分</strong>。</p><p>4️⃣此外，由于<strong>判断锁标识是否一致与释放锁不是一个原子操作</strong>，如果<strong>判断完后想要释放锁时发生了阻塞</strong>，会触发锁的超时释放，此时线程2来获取了锁，线程1阻塞结束后会使用之前的判断结果去把线程2的锁释放，这就又导致的并发安全问题，如下图所示：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754097.png" alt="image-20250213131921945" style="zoom:33%;" /><p>为了解决原子性的问题，我们可以选择使用redis提供的lua脚本功能，在一个脚本中编写多条redis命令，确保多条命令执行的原子性。</p><h3 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a><strong>Redisson分布式锁</strong></h3><h4 id="基于SETNX实现的分布式锁存在的问题"><a href="#基于SETNX实现的分布式锁存在的问题" class="headerlink" title="基于SETNX实现的分布式锁存在的问题"></a><strong>基于SETNX实现的分布式锁存在的问题</strong></h4><ol><li>重入问题<ul><li>重入问题是指<strong>获取锁的线程，可以再次进入到相同的锁的代码块中</strong>，可重入锁的意义在于防止死锁，例如在HashTable这样的代码中，它的方法都是使用synchronized修饰的，加入它在一个方法内调用另一个方法，如果此时是不可重入的，那就死锁了。所以<strong>可重入锁的主要意义是防止死锁</strong>，我们的synchronized和Lock锁都是可重入的</li></ul></li><li>不可重试<ul><li>我们编写的分布式锁只能尝试一次，失败了就返回false，没有重试机制。但合理的情况应该是：当线程获取锁失败后，他应该能再次尝试获取锁</li></ul></li><li>超时释放<ul><li>我们在加锁的时候增加了TTL，这样我们可以防止死锁，但是如果卡顿(阻塞)时间太长，也会导致锁的释放。虽然我们采用Lua脚本来防止删锁的时候，误删别人的锁，但现在的新问题是没锁住，也有安全隐患，也就是上面的问题3️⃣</li></ul></li><li>主从一致性<ul><li>如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题</li></ul></li></ol><h4 id="Redisson可重入锁原理"><a href="#Redisson可重入锁原理" class="headerlink" title="Redisson可重入锁原理"></a><strong>Redisson可重入锁原理</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754395.png" alt="image-20250213160502630" style="zoom:33%;" /><ul><li><p>method1在方法内部调用method2，method1和method2出于<strong>同一个线程</strong>，那么method1已经拿到一把锁了，想进入method2中拿另外一把锁，必然是拿不到的，于是就出现了死锁</p></li><li><p>所以我们需要额外判断，<strong>method1和method2是否处于同一线程</strong>，如果是<strong>同一个线程，则可以拿到锁，但是state会<code>+1</code></strong>，之后执行method2中的方法，释放锁，<strong>释放锁的时候也只是将state进行<code>-1</code>，只有减至0，才会真正释放锁</strong></p></li><li><p>由于我们需要额外存储一个state，所以用字符串型<code>SET NX EX</code>是不行的，需要用到**<code>Hash</code>结构**，但是<code>Hash</code>结构又没有<code>NX</code>这种方法，所以我们需要将原有的逻辑拆开，进行手动判断，如上图所示</p></li><li><p>为了保证原子性，所以流程图中的业务逻辑也是需要我们用Lua来实现的</p></li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754005.png" alt="image-20250213160531577" style="zoom:33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754783.png" alt="image-20250213160607090" style="zoom:33%;" /></p><h4 id="Redisson锁重试和WatchDog机制"><a href="#Redisson锁重试和WatchDog机制" class="headerlink" title="Redisson锁重试和WatchDog机制"></a><strong>Redisson锁重试和WatchDog机制</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754136.png" alt="image-20250213161206038" style="zoom:33%;" /><ul><li><strong>锁重试</strong>：利用信号量、发布消息publish、订阅消息subscribe功能，实现获取锁失败后的一段时间（ttl）内重新尝试获取锁。而重新尝试获取锁<strong>并不是立刻重新尝试</strong>，而是通过<strong>订阅</strong>释放锁的消息，接收到锁释放的消息后去重试，<strong>减轻了cpu的负担</strong>，因此在线程释放锁后需要向外<strong>发布</strong>释放锁的消息。</li><li><strong>WatchDog机制</strong>：给锁添加过期时间，虽然能够解决死锁的问题，但是如果事务发生了阻塞导致超时释放锁，还是会出现多个线程同时执行业务的情况，失去了锁的作用，造成了一人多单的情况。因此，关键点就是**&#x3D;&#x3D;不要让事务阻塞导致超时释放锁，超时释放只应该在redis服务宕机、或持有锁的线程挂掉时起作用&#x3D;&#x3D;**，于是就引出了WatchDog机制。<ul><li>WatchDog就是持有锁的线程给锁加了一条看门狗，<strong>只要这个线程存在，狗就会不断给锁续期不让它过期</strong>，<strong>&#x3D;&#x3D;直到线程执行完事务并亲自释放锁&#x3D;&#x3D;</strong>。</li><li>既然WatchDog会给锁不断续期，那么锁设置过期时间还有意义吗？答案是有的。因为这个<strong>过期时间主要是为了防止线程挂掉、redis宕机导致的死锁，过期时间只应在这些情况下释放锁</strong>，如果过期时间是因为线程事务发生阻塞超时释放锁，就会产生上面的并发问题，而WatchDog就是引进来不让这种情况发生的。</li></ul></li></ul><h4 id="Redisson锁的MutiLock原理"><a href="#Redisson锁的MutiLock原理" class="headerlink" title="Redisson锁的MutiLock原理"></a><strong>Redisson锁的MutiLock原理</strong></h4><ul><li>为了提高Redis的可用性，我们会搭建集群或者主从，现在以主从为例</li><li>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设<strong>主机还没来得及把数据写入到从机去的时候，主机宕机了</strong></li><li>哨兵会发现主机宕机了，于是选举一个slave(从机)变成master(主机)，而此时<strong>新的master(主机)上并没有锁的信息</strong>，那么其他线程就可以获取锁，又会引发安全问题</li><li>为了解决这个问题。Redisson提出来了MutiLock锁，使用这把锁的话，那我们就不用主从了，每个节点的地位都是一样的，都可以当做是主机，那我们就**&#x3D;&#x3D;需要将加锁的逻辑写入到每一个主从节点上，只有所有的服务器都写入成功，此时才是加锁成功&#x3D;&#x3D;**，假设现在某个节点挂了，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性</li></ul><h4 id="Redisson小结"><a href="#Redisson小结" class="headerlink" title="Redisson小结"></a><strong>Redisson小结</strong></h4><ol><li>不可重入Redis分布式锁<ul><li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入Redis分布式锁<ul><li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：Redis宕机引起锁失效问题</li></ul></li><li>Redisson的multiLock<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li><li>缺陷：运维成本高、实现复杂</li></ul></li></ol><h3 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a><strong>秒杀优化</strong></h3><h4 id="异步秒杀思路"><a href="#异步秒杀思路" class="headerlink" title="异步秒杀思路"></a><strong>异步秒杀思路</strong></h4><p>我们先来回顾一下下单流程，当用户发起请求，此时会先请求Nginx，Nginx反向代理到Tomcat，而Tomcat中的程序，会进行串行操作，分为如下几个步骤：</p><ol><li>查询优惠券</li><li>判断秒杀库存是否足够</li><li>查询订单</li><li>校验是否一人一单</li><li>扣减库存</li><li>创建订单</li></ol><p>在这六个步骤中，有很多操作都是要去操作数据库的，而且还是一个线程串行执行，这样就会导致我们的程序执行很慢，所以我们需要异步程序执行，那么如何加速呢？</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754941.png" alt="image-20250213200222171" style="zoom:33%;" /><ul><li>优化方案：我们<strong>将耗时较短的逻辑判断放到Redis</strong>中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。</li><li>我们现在来看整体思路：当用户下单之后，判断库存是否充足，只需要取Redis中根据key找对应的value是否大于0即可，如果不充足，则直接结束。如果充足，则在Redis中判断用户是否可以下单，如果set集合中没有该用户的下单数据，则可以下单，并将<strong>userId和优惠券存入到Redis</strong>中，并且返回0，整个过程需要保证是原子性的，所以我们要用Lua来操作</li><li>我们只需要判断Lua脚本的返回值是否为0，如果是0，则表示可以下单，将信息保存到queue中去，然后返回，开一个线程来异步下单</li></ul><h4 id="异步秒杀小结"><a href="#异步秒杀小结" class="headerlink" title="异步秒杀小结"></a><strong>异步秒杀小结</strong></h4><ul><li>秒杀业务的优化思路是什么？<ol><li>先利用Redis完成库存容量、一人一单的判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li></ol></li><li>基于阻塞队列的异步秒杀存在哪些问题？<ol><li>内存限制问题：<ul><li>我们现在使用的是JDK里的阻塞队列，它使用的是JVM的内存，如果在高并发的条件下，无数的订单都会放在阻塞队列里，可能就会造成内存溢出，所以我们在创建阻塞队列时，设置了一个长度，但是如果真的存满了，再有新的订单来往里塞，那就塞不进去了，存在内存限制问题</li></ul></li><li>数据安全问题：<ul><li>经典服务器宕机了，用户明明下单了，但是数据库里没看到</li></ul></li></ol></li></ul><h3 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a><strong>Redis消息队列</strong></h3><h4 id="认识消息队列"><a href="#认识消息队列" class="headerlink" title="认识消息队列"></a><strong>认识消息队列</strong></h4><ul><li>什么是消息队列？字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色<ol><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ol></li><li>使用队列的好处在于<code>解耦</code>：举个例子，快递员(生产者)把快递放到驿站&#x2F;快递柜里去(Message Queue)去，我们(消费者)从快递柜&#x2F;驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的</li></ul><h4 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a><strong>基于List实现消息队列</strong></h4><ul><li>基于List结构模拟消息队列</li><li>消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果</li><li>队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。</li><li>不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用<strong>BRPOP或者BLPOP来实现阻塞效果</strong></li><li>基于List的消息队列有哪些优缺点？<ul><li>优点<ol><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保障</li><li>可以满足消息有序性</li></ol></li><li>缺点<ol><li>无法避免消息丢失(经典服务器宕机)</li><li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)</li></ol></li></ul></li></ul><h4 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a><strong>基于PubSub的消息队列</strong></h4><ul><li>PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</li><li><code>SUBSCRIBE channel [channel]</code>：订阅一个或多个频道</li><li><code>PUBLISH channel msg</code>：向一个频道发送消息</li><li><code>PSUBSCRIBE pattern [pattern]</code>：订阅与pattern格式匹配的所有频道</li><li>基于PubSub的消息队列有哪些优缺点<ul><li>优点：<ol><li>采用发布订阅模型，支持多生产，多消费</li></ol></li><li>缺点：<ol><li>不支持数据持久化</li><li>无法避免消息丢失（如果向频道发送了消息，却<strong>没有人订阅该频道</strong>，那发送的这条消息就丢失了）</li><li>消息堆积有上限，超出时数据丢失（<strong>消费者拿到数据的时候处理的太慢，而发送消息发的太快</strong>）</li></ol></li></ul></li></ul><h4 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a><strong>基于Stream的消息队列</strong></h4><ul><li>发送消息的命令</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">XADD key <span class="hljs-comment">[NOMKSTREAM]</span> <span class="hljs-comment">[MAXLEN|MINID <span class="hljs-comment">[=!~]</span> threshold <span class="hljs-comment">[LIMIT count]</span>]</span> *|ID field value <span class="hljs-comment">[field value ...]</span><br><br>NOMKSTREAM<br>如果队列不存在，是否自动创建队列，默认是自动创建<br><span class="hljs-comment">[MAXLEN|MINID <span class="hljs-comment">[=!~]</span> threshold <span class="hljs-comment">[LIMIT count]</span>]</span><br>设置消息队列的最大消息数量，不设置则无上限<br>*|ID<br>消息的唯一id，*代表由Redis自动生成。格式是”时间戳-递增数字”，例如”114514114514-0”<br>field value <span class="hljs-comment">[field value …]</span><br>发送到队列中的消息，称为Entry。格式就是多个key-value键值对<br><br>举例：创建名为users的队列，并向其中发送一个消息，内容是&#123;name=jack, age=21&#125;，并且使用Redis自动生成ID<br>XADD users * name jack age 21<br></code></pre></td></tr></table></figure><ul><li>读取消息的命令</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">XREAD <span class="hljs-comment">[COUNT count]</span> <span class="hljs-comment">[BLOCK milliseconds]</span> STREAMS key <span class="hljs-comment">[key ...]</span> ID <span class="hljs-comment">[ID ...]</span><br><br><span class="hljs-comment">[COUNT count]</span><br>每次读取消息的最大数量<br><span class="hljs-comment">[BLOCK milliseconds]</span><br>当没有消息时，是否阻塞，阻塞时长<br>STREAMS key <span class="hljs-comment">[key …]</span><br>要从哪个队列读取消息，key就是队列名<br>ID <span class="hljs-comment">[ID …]</span><br>起始ID，只返回大于该ID的消息<br>0：表示从第一个消息开始<br>$：表示从最新的消息开始<br>注意：当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现漏读消息的问题<br></code></pre></td></tr></table></figure><ul><li>STREAM类型消息队列的XREAD命令特点<ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有漏读消息的风险</li></ol></li></ul><h4 id="基于Stream的消息队列—消费者组"><a href="#基于Stream的消息队列—消费者组" class="headerlink" title="基于Stream的消息队列—消费者组"></a><strong>基于Stream的消息队列—消费者组</strong></h4><ul><li><p>消费者组(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列，具备以下特点</p><ol><li>消息分流<ul><li>队列中的消息会分留给组内的不同消费者，而不是重复消费者，从而<strong>加快消息处理的速度</strong></li></ul></li><li>消息标识<ul><li>消费者会维护一个标识，<strong>记录最后一个被处理的消息</strong>，哪怕消费者宕机重启，还会从标识之后读取消息，<strong>确保每一个消息都会被消费</strong></li></ul></li><li>消息确认<ul><li>消费者获取消息后，消息处于pending状态，并存入一个<strong>pending-list</strong>，当处理完成后，<strong>需要通过XACK来确认消息</strong>，标记消息为已处理，才会从pending-list中移除</li></ul></li></ol></li><li><p>创建消费者组</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gauss">XGROUP <span class="hljs-keyword">CREATE</span> <span class="hljs-built_in">key</span> groupName ID [MKSTREAM]<br><br><span class="hljs-built_in">key</span><br>队列名称<br>groupName<br>消费者组名称<br>ID<br>起始ID标识，$代表队列中的最后一个消息，<span class="hljs-number">0</span>代表队列中的第一个消息<br>MKSTREAM<br>队列不存在时自动创建队列<br></code></pre></td></tr></table></figure></li><li><p>从消费者组中读取消息</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs q">XREADGROUP GROUP <span class="hljs-built_in">group</span> consumer [COUNT <span class="hljs-built_in">count</span>] [BLOCK milliseconds] [NOACK] STREAMS <span class="hljs-built_in">key</span> [<span class="hljs-built_in">keys</span> ...] ID [ID ...]<br><br><span class="hljs-built_in">group</span><br>消费者组名称<br>consumer<br>消费者名，如果消费者不存在，会自动创建一个消费者<br><span class="hljs-built_in">count</span><br>本次查询的最大数量<br>BLOCK milliseconds<br>当前没有消息时的最大等待时间<br>NOACK<br>无需手动ACK，获取到消息后自动确认（一般不用，我们都是手动确认）<br>STREAMS <span class="hljs-built_in">key</span><br>指定队列名称<br>ID<br>获取消息的起始ID<br>&gt;：从下一个未消费的消息开始(pending-list中)<br>其他：根据指定id从pending-list中获取已消费但未确认的消息，例如<span class="hljs-number">0</span>，是从pending-list中的第一个消息开始<br></code></pre></td></tr></table></figure></li><li><p>STREAM类型消息队列的XREADGROUP命令的特点</p><ol><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ol></li></ul><h4 id="三种方式实现消息队列对比"><a href="#三种方式实现消息队列对比" class="headerlink" title="三种方式实现消息队列对比"></a><strong>三种方式实现消息队列对比</strong></h4><table><thead><tr><th align="center"></th><th align="center">List</th><th align="center">PubSub</th><th align="center">Stream</th></tr></thead><tbody><tr><td align="center">消息持久化</td><td align="center">支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">阻塞读取</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">消息堆积处理</td><td align="center">受限于内存空间， 可以利用多消费者加快处理</td><td align="center">受限于消费者缓冲区</td><td align="center">受限于队列长度， 可以利用消费者组提高消费速度，减少堆积</td></tr><tr><td align="center">消息确认机制</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">消息回溯</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr></tbody></table><h4 id="Redis消息队列实现异步秒杀"><a href="#Redis消息队列实现异步秒杀" class="headerlink" title="Redis消息队列实现异步秒杀"></a><strong>Redis消息队列实现异步秒杀</strong></h4><ul><li><p>需求：</p><ol><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li></ol></li><li><p>业务实现伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// 尝试监听队列，使用阻塞模式，最大等待时长为2000ms</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;&quot;</span>)<br>    <span class="hljs-keyword">if</span>(msg == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">// 没监听到消息，重试</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//处理消息，完成后要手动确认ACK</span><br>        handleMessage(msg);<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0&quot;</span>);<br>            <span class="hljs-keyword">if</span>(msg == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//null表示没有异常消息，所有消息均已确认，结束循环</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//说明有异常消息，再次处理</span><br>                handleMessage(msg);<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                <span class="hljs-comment">//再次出现异常，记录日志，继续循环</span><br>                log.error(<span class="hljs-string">&quot;..&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="使用RabbitMQ实现异步秒杀"><a href="#使用RabbitMQ实现异步秒杀" class="headerlink" title="使用RabbitMQ实现异步秒杀"></a><strong>使用RabbitMQ实现异步秒杀</strong></h4><p>具体实现：</p><ol><li>首先还是先使用lua脚本，在redis中实现耗时较短的逻辑判断：判断库存是否充足、判断用户是否下单、扣减redis中的库存、将用户加入下单名单里</li><li>如果上面判断出用户还未下过单，则能够进行下一步扣减数据库中的库存</li><li>数据库的扣减就交给消息队列去实现，实现了如下几个程序：<ul><li>MQSender：将信息封装成一个优惠券订单对象后，转换为JSON字符串，使用这个MQSender发送出去</li><li>MQReceiver：rabbitmq在接收到这个消息后，将接收到的json字符串解析为订单对象，在数据库中判断一人一单、基于CAS实现库存扣减，然后扣减库存。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 创建订单</span><br><span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>voucherOrder.setUserId(userId);<br>voucherOrder.setId(orderId);<br>voucherOrder.setVoucherId(voucherId);<br><span class="hljs-comment">// 将信息放入MQ中</span><br>mqSender.sendSeckillMessage(JSON.toJSONString(voucherOrder));<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MQSender</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTINGKEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;seckill.message&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送秒杀信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendSeckillMessage</span><span class="hljs-params">(String msg)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;发送消息&quot;</span>+msg);<br>        rabbitTemplate.convertAndSend(RabbitMQTopicConfig.EXCHANGE,ROUTINGKEY,msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MQReceiver</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    IVoucherOrderService voucherOrderService;<br><br>    <span class="hljs-meta">@Resource</span><br>    ISeckillVoucherService seckillVoucherService;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收秒杀信息并下单</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@RabbitListener(queues = RabbitMQTopicConfig.QUEUE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveSeckillMessage</span><span class="hljs-params">(String msg)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;接收到消息: &quot;</span>+msg);<br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> JSON.parseObject(msg, VoucherOrder.class);<br><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">voucherId</span> <span class="hljs-operator">=</span> voucherOrder.getVoucherId();<br>        <span class="hljs-comment">//5.一人一单</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>        <span class="hljs-comment">//5.1查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> voucherOrderService.query().eq(<span class="hljs-string">&quot;user_id&quot;</span>,userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">//5.2判断是否存在</span><br>        <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//用户已经购买过了</span><br>            log.error(<span class="hljs-string">&quot;该用户已购买过&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;扣减库存&quot;</span>);<br>        <span class="hljs-comment">//6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService<br>                .update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock-1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>,<span class="hljs-number">0</span>)<span class="hljs-comment">//cas乐观锁</span><br>                .update();<br>        <span class="hljs-keyword">if</span>(!success)&#123;<br>            log.error(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//直接保存订单</span><br>        voucherOrderService.save(voucherOrder);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Blog点赞功能"><a href="#Blog点赞功能" class="headerlink" title="Blog点赞功能"></a><strong>Blog点赞功能</strong></h2><h3 id="一人一赞"><a href="#一人一赞" class="headerlink" title="一人一赞"></a><strong>一人一赞</strong></h3><p>当前的业务下，点赞功能直接在controller层中，update数据库中blog的点赞数，这会导致一个用户可以给一篇blog无限点赞，这是不合理的。我们的需求是：</p><ul><li>同一个用户只能对同一篇笔记点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则<strong>点赞按钮高亮显示</strong>（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现的方法如下：</p><ul><li>修改点赞功能，利用<strong>redis中的set集合</strong>的sismember方法来判断是否点赞过，未点赞则点赞数+1，已点赞则点赞数-1</li><li>修改根据id查询blog的业务，判断当前用户是否点赞过，赋值给blog对象的isLike字段</li><li>修改分页查询blog业务，判断当前用户是否点赞过，赋值给blog对象的isLike字段</li></ul><h3 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a><strong>点赞排行榜</strong></h3><p>当我们点击探店笔记详情页面时，应该按点赞顺序展示点赞用户，比如显示最早点赞的TOP5，形成点赞排行榜。之前的点赞是放到Set集合中，但是Set集合又不能排序，所以这个时候，我们就可以改用<strong>SortedSet(Zset)</strong>，将<strong>时间戳作为zset对应用户id的得分</strong>，根据得分排序即可实现显示最早点赞的top5。</p><ul><li><p>而Zset没有ismember的方法，我们可以选择score方法，该方法查询对应用户ID的score，如果没有这个用户，就返回空值。</p></li><li><pre><code class="language-java">// 查询点赞排行榜@Overridepublic Result queryBlogLikes(Integer id) &#123;    String key = BLOG_LIKED_KEY + id;    //zrange key 0 4  查询zset中前5个元素    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);    //如果是空的(可能没人点赞)，直接返回一个空集合    if (top5 == null || top5.isEmpty()) &#123;        return Result.ok(Collections.emptyList());    &#125;    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());    //将ids使用`,`拼接，SQL语句查询出来的结果并不是按照我们期望的方式进行排    //所以我们需要用order by field来指定排序方式，期望的排序方式就是按照查询出来的id进行排序    String idsStr = StrUtil.join(&quot;,&quot;, ids);    //select * from tb_user where id in (ids[0], ids[1] ...) order by field(id, ids[0], ids[1] ...)    List&lt;UserDTO&gt; userDTOS = userService.query().in(&quot;id&quot;, ids)            .last(&quot;order by field(id,&quot; + idsStr + &quot;)&quot;)            .list().stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    return Result.ok(userDTOS);&#125;</code></pre></li></ul><h2 id="好友关注功能"><a href="#好友关注功能" class="headerlink" title="好友关注功能"></a><strong>好友关注功能</strong></h2><h3 id="关注与取关"><a href="#关注与取关" class="headerlink" title="关注与取关"></a><strong>关注与取关</strong></h3><p>关注与取关会传入一个isFollow参数，true表示关注，false表示取关</p><ul><li>关注只需要创建一个Follow对象，将关注者（当前用户）id与被关注者id赋给这个Follow对象，然后直接保存到数据库中即可</li><li>同理，取关只需要把数据库中<code>user_id = userId</code>且<code>follow_user_id = followUserId</code>的记录删除即可。</li></ul><h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a><strong>共同关注</strong></h3><p>共同关注可以利用redis中<strong>set</strong>数据类型，对<strong>两个key的set取交集来实现</strong></p><ul><li>key用于区分用户，模式为<code>follow:userId</code></li><li>value则是对应用户的关注对象的set集合</li><li>因此，需要在关注时，同步将关注信息传入redis中；同理取关时也要将被关注者从当前用户的set集合中删除</li><li>使用set数据结构的intersect功能来实现取交集</li><li>取得共同关注id集合（String集合）后，要将id集合解析（String转化为Long），然后查询各id对应的用户信息user并<strong>封装到userDTO</strong>中确保安全，然后返回。</li></ul><h3 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a><strong>关注推送</strong></h3><ul><li>需求：<ol><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须使用Redis的数据结构实现</li><li>查询收件箱数据时，实现分页查询</li></ol></li><li>实现：<ol><li><strong>基于redis实现收件箱</strong>：在redis为每个用户设置一个收件箱，key模式为<code>FEED_KEY + userId</code>，每当一个用户发布一条blog时，在tb_follow表中查询他的粉丝，并<strong>将blog id推送到每个粉丝的收件箱</strong></li><li>由于要按照时间戳排序，我们选择redis数据结构为<strong>zset，score使用时间戳来表示</strong></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/15/hello-world/"/>
    <url>/2025/02/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
