<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis渐进式rehash</title>
    <link href="/2026/02/04/Redis%E6%B8%90%E8%BF%9B%E5%BC%8Frehash/"/>
    <url>/2026/02/04/Redis%E6%B8%90%E8%BF%9B%E5%BC%8Frehash/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis渐进式rehash"><a href="#Redis渐进式rehash" class="headerlink" title="Redis渐进式rehash"></a>Redis渐进式rehash</h1><blockquote><p><b>渐进式 rehash</b> 是 Redis 为了避免在扩容或收缩<b>哈希表（Dict）</b>时导致服务器“卡死”而设计的一种高明策略。</p><p>如果 Redis 像传统方式那样一次性完成百万级键值的搬迁，会导致主线程长时间阻塞，对于追求高并发、低延迟的 Redis 来说，这显然是不可接受的。</p></blockquote><h2 id="1-核心数据结构"><a href="#1-核心数据结构" class="headerlink" title="1. 核心数据结构"></a>1. 核心数据结构</h2><p>在 Redis 的字典结构中，实际上维护了两个哈希表：</p><ul><li><b>ht[0]</b>：平时使用的哈希表。</li><li><b>ht[1]</b>：只在 rehash 期间使用的哈希表（通常大小是 ht[0] 的两倍）。</li></ul><h2 id="2-搬迁过程：化整为零"><a href="#2-搬迁过程：化整为零" class="headerlink" title="2. 搬迁过程：化整为零"></a>2. 搬迁过程：化整为零</h2><blockquote><p><b>核心思想</b>：将巨大的计算成本，<mark>平摊到了每一次请求和后台空闲时间</mark>中。这避免了集中式处理带来的长耗时，保证了 Redis 的 响应时间 始终保持在极低水平。</p></blockquote><p>Redis 不会一次性把 <code>ht[0]</code> 的所有数据搬到 <code>ht[1]</code>，而是采取了“分而治之”的办法：</p><h3 id="触发式搬迁"><a href="#触发式搬迁" class="headerlink" title="触发式搬迁"></a>触发式搬迁</h3><p>每当客户端对该字典执行 <b>添加、删除、查找或更新</b> 操作时，Redis 除了执行指定操作外，还会顺带将 <code>ht[0]</code> 在 <code>rehashidx</code> 索引上的所有键值对搬迁到 <code>ht[1]</code>。</p><h3 id="定时同步"><a href="#定时同步" class="headerlink" title="定时同步"></a>定时同步</h3><p>即便没有客户端访问，Redis 也会利用 <b>定时任务</b>，在系统空闲时主动搬迁一部分数据，确保 rehash 最终能完成。</p><h2 id="3-rehash的触发条件"><a href="#3-rehash的触发条件" class="headerlink" title="3. rehash的触发条件"></a>3. rehash的触发条件</h2><p>在 Redis 中，rehash 的触发主要取决于<strong>负载因子（Load Factor）</strong>。负载因子的计算公式非常简单：</p><p>$$\text{Load Factor} &#x3D; \frac{\text{ht[0].used}}{\text{ht[0].size}}$$</p><p>即：<mark>已保存节点的数量与哈希表大小的比值</mark></p><h3 id="3-1-扩容（Expand）的触发条件"><a href="#3-1-扩容（Expand）的触发条件" class="headerlink" title="3.1 扩容（Expand）的触发条件"></a>3.1 扩容（Expand）的触发条件</h3><p>Redis 会根据当前是否在执行后台指令，采取不同的扩容阈值：</p><ul><li><b>常规状态</b>：当负载因子 <strong>$\ge 1$</strong> 时，Redis <b>可能</b>会触发扩容</li><li><b>强制状态</b>：当负载因子 <strong>$&gt; 5$</strong> 时，无论是否有后台进程，Redis 都会立即开始扩容<mark>（因为出现hash冲突时使用拉链法解决，所以实际保存的节点数可能会超过哈希表大小）</mark></li></ul><h3 id="3-2-为什么有两个标准？"><a href="#3-2-为什么有两个标准？" class="headerlink" title="3.2 为什么有两个标准？"></a>3.2 为什么有两个标准？</h3><p>这涉及到 Redis 的 <strong>Copy-On-Write (COW)</strong> 机制。当 Redis 正在执行 <code>BGSAVE</code>（生成 RDB 快照）或 <code>BGREWRITEAOF</code>（AOF 重写）时，会创建子进程。</p><ul><li>为了尽可能减少父子进程间的内存页写入，Redis 会提高扩容门槛（从 1 提升到 5）。</li><li>这样可以避免在子进程工作期间发生大规模的内存地址变动，从而节省系统内存并提高效率。</li></ul><h3 id="3-3-收缩（Shrink）的触发条件"><a href="#3-3-收缩（Shrink）的触发条件" class="headerlink" title="3.3 收缩（Shrink）的触发条件"></a>3.3 收缩（Shrink）的触发条件</h3><p>当数据库中的键值对大量减少时，为了不浪费内存，Redis 会对哈希表进行收缩。</p><ul><li><b>触发条件</b>：当负载因子 <strong>$&lt; 0.1$</strong> 时（即已用空间不足 10%），Redis 会自动开始收缩操作。</li></ul><h3 id="3-4-rehash-的空间分配规则"><a href="#3-4-rehash-的空间分配规则" class="headerlink" title="3.4 rehash 的空间分配规则"></a>3.4 rehash 的空间分配规则</h3><p>无论是扩容还是收缩，新哈希表 <code>ht[1]</code> 的大小都是有讲究的：</p><ul><li><b>如果是扩容</b>：<code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used * 2</code> 的 $2^n$。<ul><li>例如：当前用了 100 个空间，扩容大小就是 $2^8 &#x3D; 256$</li></ul></li><li><b>如果是收缩</b>：<code>ht[1]</code> 的大小为第一个大于等于 <code>ht[0].used</code> 的 $2^n$。<ul><li>例如：当前只剩 10 个键，收缩大小就是 $2^4 &#x3D; 16$</li></ul></li></ul><h2 id="4-rehash-的详细步骤"><a href="#4-rehash-的详细步骤" class="headerlink" title="4. rehash 的详细步骤"></a>4. rehash 的详细步骤</h2><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202602041625600.png" alt="img" style="zoom: 50%;" /><p>⚠️：图中<code>ht[1]</code>大小应为16，即首个大于2 * 6 &#x3D; 12 的2次幂</p><ol><li><b>分配空间</b>：为 <code>ht[1]</code> 分配空间：<ul><li>如果是<b>扩容</b>，大小通常是第一个大于等于 <code>ht[0].used * 2</code> 的 $2^n$<mark>（首个大于已使用空间两倍的2次幂）</mark>；</li><li>如果是<b>收缩</b>，则是第一个大于等于 <code>ht[0].used</code> 的 $2^n$<mark>（首个大于已使用空间的2次幂）</mark></li></ul></li><li><b>设置索引</b>：将变量 <code>rehashidx</code> 设置为 <b>0</b>，代表 rehash 正式开始。</li><li><b>分步搬迁</b>：<ul><li>每次操作字典，将 <code>ht[0]</code> 中 <code>rehashidx</code> 索引位置上的桶（Bucket）移动到 <code>ht[1]</code>。</li><li>搬迁完成后，<code>rehashidx</code> <strong>自增 1</strong>。</li></ul></li><li><b>完成收尾</b>：当 <code>ht[0]</code> 的所有数据都迁移到 <code>ht[1]</code> 后，将 <code>rehashidx</code> 设为 <b>-1</b>。释放 <code>ht[0]</code>，将 <code>ht[1]</code> 设置为新的 <code>ht[0]</code>，并创建一个空的 <code>ht[1]</code> 为下次做准备。</li></ol><h2 id="5-rehash-期间的特殊行为"><a href="#5-rehash-期间的特殊行为" class="headerlink" title="5. rehash 期间的特殊行为"></a>5. rehash 期间的特殊行为</h2><p>在搬迁过程中，字典处于一个“过渡状态”，其行为如下：</p><ul><li><b>查找操作</b>：程序会先在 <code>ht[0]</code> 找，如果没找到，再去 <code>ht[1]</code> 找。</li><li><b>添加操作</b>：所有新键值对一律直接插入 <code>ht[1]</code>。这样可以保证 <code>ht[0]</code> 的数据只减不增，直到变空。</li><li><b>删除&#x2F;更新</b>：同样会在两个表上进行，确保数据一致性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis性能排查调优</title>
    <link href="/2026/02/04/Redis%E6%80%A7%E8%83%BD%E6%8E%92%E6%9F%A5%E8%B0%83%E4%BC%98/"/>
    <url>/2026/02/04/Redis%E6%80%A7%E8%83%BD%E6%8E%92%E6%9F%A5%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis性能排查调优"><a href="#Redis性能排查调优" class="headerlink" title="Redis性能排查调优"></a>Redis性能排查调优</h1><blockquote><p>Redis执行命令变慢的原因</p></blockquote><h2 id="1-网络问题"><a href="#1-网络问题" class="headerlink" title="1. 网络问题"></a>1. 网络问题</h2><h2 id="2-业务问题"><a href="#2-业务问题" class="headerlink" title="2. 业务问题"></a>2. 业务问题</h2><blockquote><p>设置慢日志阈值，开启慢日志slowLog</p></blockquote><h3 id="2-1-命令复杂度过高"><a href="#2-1-命令复杂度过高" class="headerlink" title="2.1 命令复杂度过高"></a>2.1 命令复杂度过高</h3><ol><li>经常使用 <code>O(N)</code> 以上复杂度的命令，例如 <code>SORT</code>、<code>SUNION</code>、<code>ZUNIONSTORE</code> 聚合类命令</li><li>使用 <code>O(N</code>) 复杂度的命令，但 <code>N</code> 的值非常大</li></ol><p>解决方法：</p><ol><li>尽量不使用 <code>O(N)</code> 以上复杂度过高的命令，对于数据的聚合操作，放在客户端做</li><li>执行 <code>O(N)</code> 命令，保证 <code>N</code> 尽量的小（推荐 <code>N &lt;= 300</code>），每次获取尽量少的数据，让 Redis 可以及时处理返回</li></ol><h3 id="2-2-bigkey"><a href="#2-2-bigkey" class="headerlink" title="2.2 bigkey"></a>2.2 bigkey</h3><ol><li>避免写入bigkey</li><li>bigkey分为多个小key</li></ol><h3 id="2-3-集中过期"><a href="#2-3-集中过期" class="headerlink" title="2.3 集中过期"></a>2.3 集中过期</h3><p>大量key同时过期，过期删除策略定期删除过期的key，如果有很多key同时过期，就会一直处于删除状态，该操作在执行命令之前执行，因此慢日志也看不出来（redis4.0之后的版本可以开启 lazy-free，将过期删除操作放到后台线程去执行）</p><h3 id="2-4-内存淘汰"><a href="#2-4-内存淘汰" class="headerlink" title="2.4 内存淘汰"></a>2.4 内存淘汰</h3><p>内存不够用了，写入新数据之前需要淘汰老数据，这就和内存淘汰策略的耗时有关了，其中随机淘汰效率最高</p><h2 id="3-运维问题"><a href="#3-运维问题" class="headerlink" title="3. 运维问题"></a>3. 运维问题</h2><h3 id="3-1-RDB、AOF日志"><a href="#3-1-RDB、AOF日志" class="headerlink" title="3.1 RDB、AOF日志"></a>3.1 RDB、AOF日志</h3><p>rdb、aof持久化时都需要主进程fork一个子进程去执行，这个fork的过程中主进程需要拷贝自己的内存页表给子进程,如果实例很大,拷贝的过程也会很长时间耗时</p><h3 id="3-2-使用Swap虚拟内存"><a href="#3-2-使用Swap虚拟内存" class="headerlink" title="3.2 使用Swap虚拟内存"></a>3.2 使用Swap虚拟内存</h3><p>Redis遵循 key-value模型。同时key和value通常都存储在内存中。然而有时这并不是一个最好的选择，所以在设计过程中我们要求key必须存储在内存中（为了保证快速查找），而value在很少使用时，可以从内存被交换出至磁盘上。 实际应用中，如果内存中有一个10万条记录的key值数据集，而只有10%被经常使用，那么开启虚拟内存的Redis将把与较少使用的key相对应的value转移至磁盘上。当客户端请求获取这些value时，他们被将从swap 文件中读回，并载入到内存中。从磁盘中读取速度肯定会慢很多。</p><p>预留更多的空间,避免使用 swap</p><h3 id="3-3-内存碎片"><a href="#3-3-内存碎片" class="headerlink" title="3.3 内存碎片"></a>3.3 内存碎片</h3><p>Redis 的数据都存储在内存中，当我们的应用程序频繁修改 Redis 中的数据时，就有可能会导致 Redis 产生内存碎片（比如当一个key过期后，其占用的内存空间会被释放，如果这份释放的空间无法被新数据填满，就会出现内存碎片）。</p><p>碎片化的内存空间无法得到有效利用，即使总的剩余内存充足，但由于碎片的存在，可能导致新数据无法找到足够大的连续空闲空间进行分配，从而引发“内存不足”的假象，迫使 Redis 进行不必要的数据淘汰或触发 swap。</p><p>Redis4.0之后可以开启内存碎片自动整理，但是由于碎片整理工作也是在主线程中执行的，所以碎片整理也可能会导致redis性能下降</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Caffeine常见面试题</title>
    <link href="/2026/01/27/Caffeine%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2026/01/27/Caffeine%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Caffeine常见面试题"><a href="#Caffeine常见面试题" class="headerlink" title="Caffeine常见面试题"></a>Caffeine常见面试题</h1><h2 id="一、Caffeine-基础相关"><a href="#一、Caffeine-基础相关" class="headerlink" title="一、Caffeine 基础相关"></a>一、Caffeine 基础相关</h2><h3 id="Caffeine-的原理、特性是什么？"><a href="#Caffeine-的原理、特性是什么？" class="headerlink" title="Caffeine 的原理、特性是什么？"></a>Caffeine 的原理、特性是什么？</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>采用 W-TinyLFU 淘汰算法，底层通过分段锁减少并发竞争，结合惰性删除、异步加载等机制实现高性能</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>性能高：基于 W-TinyLFU 淘汰算法，命中率 &#x2F; 吞吐量比传统的 LRU、LFU 算法要好</p><p>缓存策略比较丰富：支持基于大小、时间、引用类型的过期 &#x2F; 淘汰策略；</p><p>加载比较灵活：支持手动加载、自动加载、异步加载</p><p>高并发性能：无锁设计，分段锁机制</p><p>事件监听：支持缓存淘汰、过期、移除的事件监听，便于问题排查</p><p>兼容性：API 几乎和 Guava Cache 一致，迁移成本低</p><h3 id="Caffeine-缓存主要存储什么数据？"><a href="#Caffeine-缓存主要存储什么数据？" class="headerlink" title="Caffeine 缓存主要存储什么数据？"></a>Caffeine 缓存主要存储什么数据？</h3><p>热点数据（秒杀商品库存）、高频访问 + 低变更数据（商品基础信息）</p><h3 id="Caffeine-缓存的数据具体是怎么添加的？"><a href="#Caffeine-缓存的数据具体是怎么添加的？" class="headerlink" title="Caffeine 缓存的数据具体是怎么添加的？"></a>Caffeine 缓存的数据具体是怎么添加的？</h3><p>手动添加（cache.put，直接添加缓存项）， 同步加载（cache.get，通过加载器自动加载，未命中时执行加载逻辑），异步加载（也可以根据自己的实际业务作出回答）</p><h2 id="二、Caffeine-与其他组件的区别"><a href="#二、Caffeine-与其他组件的区别" class="headerlink" title="二、Caffeine 与其他组件的区别"></a>二、Caffeine 与其他组件的区别</h2><h3 id="Caffeine-与-HashMap-的区别？"><a href="#Caffeine-与-HashMap-的区别？" class="headerlink" title="Caffeine 与 HashMap 的区别？"></a>Caffeine 与 HashMap 的区别？</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202601271428366.png" alt="img"></p><h3 id="Caffeine-与-Guava-Cache-的区别？"><a href="#Caffeine-与-Guava-Cache-的区别？" class="headerlink" title="Caffeine 与 Guava Cache 的区别？"></a>Caffeine 与 Guava Cache 的区别？</h3><p>区别性能：Caffeine 命中率高，吞吐量大；</p><p>并发：Caffeine 支持异步加载，Guava 仅同步加载；（ Caffeine 并不像 Guava Cache 那样在读写操作时立即加锁，而是使用 RingBuffer（类似 RingBuffer 的环形队列）将写操作、淘汰、更新等操作记录下来，然后异步、批量地执行。）</p><p>算法：Caffeine 用 W-TinyLFU，Guava 用 LRU；</p><p>功能：Caffeine 支持异步刷新，Guava 同步刷新易阻塞。</p><p>兼容性好：API 兼容 Guava，迁移成本低解决的问题</p><h3 id="Caffeine-解决了-Guava-的哪些问题？"><a href="#Caffeine-解决了-Guava-的哪些问题？" class="headerlink" title="Caffeine 解决了 Guava 的哪些问题？"></a>Caffeine 解决了 Guava 的哪些问题？</h3><p>Guava 的 LRU 易被偶发冷数据冲掉热点，W-TinyLFU 兼顾热点保留与冷数据淘汰；</p><p>Guava 同步加载导致高并发下线程阻塞，Caffeine 异步加载避免此问题；</p><p>Guava 无原生异步加载，需手动封装，Caffeine 内置</p><h3 id="Caffeine-与-Redis-缓存的区别？"><a href="#Caffeine-与-Redis-缓存的区别？" class="headerlink" title="Caffeine 与 Redis 缓存的区别？"></a>Caffeine 与 Redis 缓存的区别？</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202601271428368.png" alt="img"></p><h2 id="三、Caffeine-核心机制"><a href="#三、Caffeine-核心机制" class="headerlink" title="三、Caffeine 核心机制"></a>三、Caffeine 核心机制</h2><h3 id="Caffeine-为什么比-Guava-快？"><a href="#Caffeine-为什么比-Guava-快？" class="headerlink" title="Caffeine 为什么比 Guava 快？"></a>Caffeine 为什么比 Guava 快？</h3><p>算法：W-TinyLFU 算法时间复杂度更低，命中率更高</p><p>并发：Guava通过类似ConcurrentHashMap的分段锁减少竞争；而Caffeine读操作几乎无锁，写入、删除操作交给独立的线程池异步执行</p><p>异步支持：内置异步加载，避免同步阻塞</p><p>惰性操作：过期数据惰性清理，避免后台线程开销</p><h3 id="Caffeine-本地缓存的失效（淘汰）算法是什么？"><a href="#Caffeine-本地缓存的失效（淘汰）算法是什么？" class="headerlink" title="Caffeine 本地缓存的失效（淘汰）算法是什么？"></a>Caffeine 本地缓存的失效（淘汰）算法是什么？</h3><p>W-TinyLFU解决传统 LRU&#x2F;LFU 缺陷</p><p>LRU：缓存 “突发流量的临时数据”，挤占常用数据</p><p>LFU：缓存 “历史高频但当前无用” 的数据；</p><ul><li>对新数据不友好计数最小草图（Count-Min Sketch）用 “近似统计” 替代 “精确统计”解决 LFU 的 “频率统计内存开销大” 问题；</li><li>频率衰减解决 LFU “历史高频数据占坑” 问题</li><li>单独开辟一个 “窗口缓存”，专门接纳新数据，给新数据一个 “观察期”，避免刚进来就被淘汰，解决 LFU 的 “新数据歧视” 问题</li></ul><h3 id="多线程请求数据时，Caffeine-缓存未命中的内部处理逻辑是什么？（例：多线程同时请求同一数据）"><a href="#多线程请求数据时，Caffeine-缓存未命中的内部处理逻辑是什么？（例：多线程同时请求同一数据）" class="headerlink" title="多线程请求数据时，Caffeine 缓存未命中的内部处理逻辑是什么？（例：多线程同时请求同一数据）"></a>多线程请求数据时，Caffeine 缓存未命中的内部处理逻辑是什么？（例：多线程同时请求同一数据）</h3><p>核心是 请求合并（避免缓存击穿）第一个线程请求未命中时，标记 key 为 “加载中”，执行加载逻辑；</p><p>后续线程请求同一 key 时，不重复加载，等待第一个线程完成；</p><p>加载完成后，结果放入缓存，所有等待线程获取结果；</p><p>加载异常时，所有线程抛出异常，缓存不存储异常结果。</p><h3 id="给-Caffeine-预留固定内存（如-128M），并发量高导致数据存不下时如何处理？"><a href="#给-Caffeine-预留固定内存（如-128M），并发量高导致数据存不下时如何处理？" class="headerlink" title="给 Caffeine 预留固定内存（如 128M），并发量高导致数据存不下时如何处理？"></a>给 Caffeine 预留固定内存（如 128M），并发量高导致数据存不下时如何处理？</h3><p>临时调整缓存配置（缩短过期时间+提高淘汰优先级+临时扩容）通过配置中心关闭非核心场景的 Caffeine 缓存，非核心热点 key 直接走 Redis若 JVM 堆内存剩余较多，临时提高 Caffeine 内存上限（比如，128 ——&gt; 256）</p><h2 id="四、Caffeine-的优缺点与选型"><a href="#四、Caffeine-的优缺点与选型" class="headerlink" title="四、Caffeine 的优缺点与选型"></a>四、Caffeine 的优缺点与选型</h2><h3 id="用-Caffeine-缓存有什么缺点？"><a href="#用-Caffeine-缓存有什么缺点？" class="headerlink" title="用 Caffeine 缓存有什么缺点？"></a>用 Caffeine 缓存有什么缺点？</h3><p>仅支持本地缓存，无法解决分布式场景下的数据共享问题</p><p>JVM 重启丢失，可能引发数据库瞬时压力仅能存热点数据，无法存储大规模数据一致性难保证，更新需手动失效，易遗漏</p><h2 id="五、缓存一致性问题"><a href="#五、缓存一致性问题" class="headerlink" title="五、缓存一致性问题"></a>五、缓存一致性问题</h2><h3 id="Redis-和-Caffeine-的缓存一致性如何保证？"><a href="#Redis-和-Caffeine-的缓存一致性如何保证？" class="headerlink" title="Redis 和 Caffeine 的缓存一致性如何保证？"></a>Redis 和 Caffeine 的缓存一致性如何保证？</h3><p>最终一致性写流程：更新数据库 → 更新 Redis → 删 Caffeine；</p><p>读流程：查 Caffeine → 查 Redis → 查数据库（查库后更新 Redis 和 Caffeine）；</p><p>兜底：Redis 设置短过期（30 分钟），Canal 监听 binlog 异步刷新缓存，MQ 广播缓存失效事件（集群场景）</p><h3 id="本地缓存的一致性如何保证？"><a href="#本地缓存的一致性如何保证？" class="headerlink" title="本地缓存的一致性如何保证？"></a>本地缓存的一致性如何保证？</h3><p>采用双写策略：先更新数据库，再更新 Redis 和 Caffeine</p><p>通过消息队列或发布-订阅机制同步更新设置较短的过期时间，保证数据最终一致性</p><h3 id="本地缓存失败了怎么办？"><a href="#本地缓存失败了怎么办？" class="headerlink" title="本地缓存失败了怎么办？"></a>本地缓存失败了怎么办？</h3><p>降级策略：本地缓存失败时直接读Redis</p><p>监控告警：缓存命中率低于阈值时告警</p><h2 id="六、多级缓存架构"><a href="#六、多级缓存架构" class="headerlink" title="六、多级缓存架构"></a>六、多级缓存架构</h2><h3 id="Redis-缓存和本地缓存（Caffeine-Guava）如何取舍？"><a href="#Redis-缓存和本地缓存（Caffeine-Guava）如何取舍？" class="headerlink" title="Redis 缓存和本地缓存（Caffeine&#x2F;Guava）如何取舍？"></a>Redis 缓存和本地缓存（Caffeine&#x2F;Guava）如何取舍？</h3><p>选 Caffeine：访问频率高、数据量小、单节点使用的热点数据；</p><p>选 Redis：数据需共享、容量大、需持久化 &#x2F; 分布式支持的场景</p><h3 id="采用-Redis-Caffeine-两级缓存是出于什么考虑？"><a href="#采用-Redis-Caffeine-两级缓存是出于什么考虑？" class="headerlink" title="采用 Redis+Caffeine 两级缓存是出于什么考虑？"></a>采用 Redis+Caffeine 两级缓存是出于什么考虑？</h3><p>性能：本地缓存减少网络延迟稳定性：即使 Redis 故障，Caffeine 仍可提供服务</p><p>数据库保护：大幅减少数据库查询压力</p><p>缓存压力：分流热点请求，降低 Redis 负载</p><h3 id="多级缓存主要解决了什么问题？"><a href="#多级缓存主要解决了什么问题？" class="headerlink" title="多级缓存主要解决了什么问题？"></a>多级缓存主要解决了什么问题？</h3><ul><li>性能瓶颈：应对突发流量，保护下游存储</li><li>数据库的读压力过大</li><li>网络延迟导致的响应时间长</li><li>单级故障不影响全局</li></ul><h2 id="七、缓存命中率问题"><a href="#七、缓存命中率问题" class="headerlink" title="七、缓存命中率问题"></a>七、缓存命中率问题</h2><h3 id="若-Caffeine-本地缓存命中率不高，会产生什么问题？"><a href="#若-Caffeine-本地缓存命中率不高，会产生什么问题？" class="headerlink" title="若 Caffeine 本地缓存命中率不高，会产生什么问题？"></a>若 Caffeine 本地缓存命中率不高，会产生什么问题？</h3><h4 id="如何解决？"><a href="#如何解决？" class="headerlink" title="如何解决？"></a>如何解决？</h4><p>问题性能下降：请求穿透到 Redis &#x2F; 数据库，接口响应变慢资源浪费：占用 JVM 内存但无缓存效果</p><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ul><li>优化配置：调整过期时间，增加缓存大小</li><li>缓存预热：系统启动时加载热点数据到缓存</li><li>监控与告警：实时监控缓存命中率，设置告警阈值</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis本身有事务为什么还要用Lua脚本?</title>
    <link href="/2026/01/21/Redis%E6%9C%AC%E8%BA%AB%E6%9C%89%E4%BA%8B%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8Lua%E8%84%9A%E6%9C%AC/"/>
    <url>/2026/01/21/Redis%E6%9C%AC%E8%BA%AB%E6%9C%89%E4%BA%8B%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8Lua%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis本身有事务为什么还要用Lua脚本"><a href="#Redis本身有事务为什么还要用Lua脚本" class="headerlink" title="Redis本身有事务为什么还要用Lua脚本?"></a>Redis本身有事务为什么还要用Lua脚本?</h1><p>Redis有事务（MULTI&#x2F;EXEC），但更青睐Lua脚本，主要因为Lua提供<b>更强大的逻辑灵活性</b>（可依赖前一步结果）、<b>更好的性能</b>（减少网络往返）和更适合实现<b>复杂原子操作</b>，如分布式锁、限流等，而Redis事务在复杂场景下难以处理依赖关系且有执行错误不回滚的限制，因此Lua脚本成为处理复杂业务逻辑的优选方案。 </p><h2 id="Redis事务（MULTI-EXEC）的局限"><a href="#Redis事务（MULTI-EXEC）的局限" class="headerlink" title="Redis事务（MULTI&#x2F;EXEC）的局限"></a>Redis事务（MULTI&#x2F;EXEC）的局限</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202601211533698.png" alt="Redis事务(MULTI&#x2F;EXEC)执行流程"></p><ul><li><b>不支持依赖</b>： 事务中的命令排队执行，但<b>无法在事务内获取前一个命令的结果</b>，对后续命令的依赖处理很弱。</li><li><b>不回滚</b>： 执行过程中命令出错（如类型错误）不会回滚，会继续执行其他命令，与传统数据库事务不同。</li><li><b>网络开销</b>： 每个命令都需要一次网络往返，累积起来开销较大。</li></ul><h2 id="Lua脚本的优势"><a href="#Lua脚本的优势" class="headerlink" title="Lua脚本的优势"></a>Lua脚本的优势</h2><ul><li><b>原子性与隔离性</b>： Redis将Lua脚本视为一个整体，在服务器端<b>一次性、原子性地执行</b>，期间不会被其他命令打断，保证了执行过程中的数据一致性。</li><li><b>强大的逻辑处理</b>： 可以在脚本内编写条件判断、循环，<b>支持命令结果的链式调用</b>，实现复杂业务逻辑（如分布式锁、计数器）。</li><li><b>性能更优</b>： 脚本将多个命令打包成<b>一次远程调用</b>，大幅减少网络延迟和通信开销。</li><li><b>功能互补</b>： Lua脚本能做事务能做的，还能做事务做不到的，是事务功能的<b>强大补充</b>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>事务适用于简单的命令批处理，而 Lua脚本则用于处理需要<b>复杂逻辑、依赖和高性能的场景</b>，如分布式锁、限流、队列操作等，它们共同构成了Redis的原子性操作方案，满足不同业务需求。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL-MVCC</title>
    <link href="/2026/01/21/MySQL-MVCC/"/>
    <url>/2026/01/21/MySQL-MVCC/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL-MVCC"><a href="#MySQL-MVCC" class="headerlink" title="MySQL-MVCC"></a>MySQL-MVCC</h1><blockquote><p>MySQL通过ReadView和undo log实现了MVCC</p></blockquote><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><table><thead><tr><th>创建该ReadView的事务id（creator_trx_id）</th><th>创建该ReadView时，当前<mark>活跃且未提交</mark>事务id列表（m_ids）</th><th>创建该ReadView时，<mark>最小活跃未提交</mark>事务id（min_trx_id）</th><th>创建该ReadView时，下一个事务id（max_trx_id）</th></tr></thead></table><p>记录的隐藏列（只存在聚簇索引，非聚簇索引内不存在隐藏列）：</p><table><thead><tr><th>创建该记录的事务id（trx_id）</th><th>roll_pointer指向前一个版本记录</th></tr></thead></table><ol><li>若<code>trx_id &lt; min_trx_id</code>，说明创建该ReadView时，修改该版本记录的事务已提交，则该版本记录对事务<code>creator_trx_id</code>可见</li><li>若<code>trx_id &gt;= max_trx_id</code>，说明这个版本记录的事务是在ReadView创建后才启动的，则该版本记录对事务<code>creator_trx_id</code>不可见</li><li>否则：<code>min_trx_id &lt; trx_id &lt; max_trx_id</code>，若：<ul><li><code>trx_id in m_ids</code>，说明在该ReadView创建时，修改这个版本记录的事务尚未提交，则不可见</li><li><code>trx_id not in m_ids</code>，说明在该ReadView创建时，修改这个版本记录的事务已提交，则可见</li><li>例：启动1 2 3 4四个事务，3执行非常快，已结束了；若此时启动事务5，则此时ReadView中<code>m_ids</code>为1 2 4，事务3的改动对事务5可见</li></ul></li></ol><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><ul><li>可重复读Repeatable Read：启动事务时创建一个ReadView，<mark>整个事务期间都用这个ReadView</mark></li><li>读提交Read Comitted：<mark>每次读数据时都会生成一个新的ReadView</mark></li></ul><p>通过MVCC，RR很大程度上避免了幻读，但不能完全避免：事务2插入一条新记录并提交，然后<mark>事务1虽然读不到这条新纪录，但是能够修改这条数据，修改完再读就能读到了</mark>。这是因为修改后，这条记录的<code>trx_id</code>变成事务1，对于事务1的ReadView而言是可见的。</p><p>所以要彻底解决幻读还是需要使用锁。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL深分页问题</title>
    <link href="/2026/01/20/MySQL%E6%B7%B1%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/"/>
    <url>/2026/01/20/MySQL%E6%B7%B1%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL深分页问题"><a href="#MySQL深分页问题" class="headerlink" title="MySQL深分页问题"></a>MySQL深分页问题</h1><h2 id="1-什么是深分页问题"><a href="#1-什么是深分页问题" class="headerlink" title="1. 什么是深分页问题"></a>1. 什么是深分页问题</h2><p>深分页的性能瓶颈源于MySQL处理LIMIT的机制。当执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">tabLe</span> LIMIT <span class="hljs-number">1000000</span>, <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>MySQL需要先定位到第1000000条记录，然后再取出接下来的20条记录。这个过程需要跳过前面的100万条记录，即使有索引，这种跳跃操作的成本也是非常高的。随着偏移量的增加，查询时间会线性增长，这就是深分页问题的根本原因。</p><h2 id="2-深分页问题解决方案"><a href="#2-深分页问题解决方案" class="headerlink" title="2. 深分页问题解决方案"></a>2. 深分页问题解决方案</h2><h3 id="2-1-游标分页"><a href="#2-1-游标分页" class="headerlink" title="2.1 游标分页"></a>2.1 游标分页</h3><p>游标分页是解决深分页问题最有效的方案。其核心思想是<mark>使用上一页的最后一条记录作为下一页查询的起点，避免了大偏移量的跳跃操作</mark>。</p><p>例如，如果上一页的最后一条记录ID是12345，下一页查询就变成：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">12345</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> id LIMIT <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>这种方式的查询时间复杂度是常数级的，不会随着页数增加而性能衰减。但游标分页也有局限性：<mark>无法随机跳转到任意页面，只能顺序翻页</mark>。</p><h3 id="2-2-延迟关联优化"><a href="#2-2-延迟关联优化" class="headerlink" title="2.2 延迟关联优化"></a>2.2 延迟关联优化</h3><p>延迟关联优化适用于需要<mark>返回大量字段但只按主键排序</mark>的场景。其思路是<mark>先通过索引查询出符合条件的主键ID，然后再通过主键关联获取完整数据</mark>。比如原始查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> created_at LIMIT <span class="hljs-number">100000</span>, <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>可以优化为:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> t.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> t<br><span class="hljs-keyword">JOIN</span> (<br><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> created_at LIMIT <span class="hljs-number">100000</span>, <span class="hljs-number">20</span><br>) tmp<br><span class="hljs-keyword">ON</span> t.id <span class="hljs-operator">=</span> tmp.id<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引优化手段</title>
    <link href="/2026/01/20/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/"/>
    <url>/2026/01/20/MySQL%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引优化手段"><a href="#MySQL索引优化手段" class="headerlink" title="MySQL索引优化手段"></a>MySQL索引优化手段</h1><p>假设有一张表 <code>user</code>，三个字段 <code>id</code> (主键索引) 、 <code>age</code>(非唯一索引)、<code>name</code>(联合索引<code>idx_name_age</code>)、<code>gender</code>、<code>empid</code>（联合索引<code>idx_gender_empid</code>）。 表中现有数据：</p><ul><li><code>id: 10, age: 10_v1, name: aaa，gender: M，empid: 10</code></li><li><code>id: 11, age: 10_v2, name: bbb，gender: F，empid: 11</code></li><li><code>id: 20, age: 20, name: aac，gender: M，empid: 20</code></li><li><code>id: 30, age: 30, name: ddd，gender: F，empid: 30</code></li></ul><h2 id="1-索引覆盖"><a href="#1-索引覆盖" class="headerlink" title="1. 索引覆盖"></a>1. 索引覆盖</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>id, age<br><span class="hljs-keyword">FROM</span><br><span class="hljs-keyword">user</span><br><span class="hljs-keyword">WHERE</span><br>age <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p><code>age</code>索引的<code>B+</code>树里就包含了<code>id</code>和<code>age</code>，不需要回表</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="2-索引下推"><a href="#2-索引下推" class="headerlink" title="2. 索引下推"></a>2. 索引下推</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span><br><span class="hljs-keyword">user</span><br><span class="hljs-keyword">WHERE</span><br>name <span class="hljs-keyword">like</span> &quot;aa%&quot;<br><span class="hljs-keyword">and</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>在MySQL5.6之前，由于最左前缀索引原则，这里的<code>idx_name_age</code>索引只能用到<code>name</code>，于是需要拿到<code>id = 10、20</code>的两条记录去回表查询，回表的时候再根据<code>age</code>去过滤</p><p>MySQL5.6之后引入了索引下推，在<code>idx_name_age</code>索引中拿到两条记录后，不着急回表，先根据<code>age</code>的查询条件去过滤一遍，最终回表的时候只拿着<code>id = 10</code>这一条记录去回表</p><h2 id="3-索引跳跃扫描"><a href="#3-索引跳跃扫描" class="headerlink" title="3. 索引跳跃扫描"></a>3. 索引跳跃扫描</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br><span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span><br><span class="hljs-keyword">user</span><br><span class="hljs-keyword">WHERE</span><br>empid <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>正常来说，根据最左前缀原则，由于<code>empid</code>查询条件前面没有<code>gender</code>查询条件，不满足最左前缀原则，应该用不到索引<code>idx_gender_empid</code>；但是MySQL8.0之后引入了索引跳跃扫描，<mark>由于<code>gender</code>字段区分度小</mark>，优化器会将SQL进行如下优化：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> gender <span class="hljs-operator">=</span> &quot;M&quot; <span class="hljs-keyword">AND</span> empid <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br><span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> gender <span class="hljs-operator">=</span> &quot;F&quot; <span class="hljs-keyword">AND</span> empid <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h2 id="4-索引合并"><a href="#4-索引合并" class="headerlink" title="4. 索引合并"></a>4. 索引合并</h2><p>查询优化器同时使用<b>多个互相独立的索引</b>来处理一个查询，<mark>将不同索引扫描结果（主键集）通过交集、并集或排序并集方式合并，以减少回表次数，提高复杂查询效率</mark>。下面例子中<code>key1</code>和<code>key2</code>分别为两个独立的索引</p><h3 id="4-1-交集合并"><a href="#4-1-交集合并" class="headerlink" title="4.1 交集合并"></a>4.1 交集合并</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-operator">=</span> xxx <span class="hljs-keyword">AND</span> key2 <span class="hljs-operator">=</span> yyy<br></code></pre></td></tr></table></figure><p>对<code>key1 = xxx</code>和<code>key2 = yyy</code>得到的两个主键集合做交集，再去回表</p><h3 id="4-2-并集合并"><a href="#4-2-并集合并" class="headerlink" title="4.2 并集合并"></a>4.2 并集合并</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> key1 <span class="hljs-operator">=</span> xxx <span class="hljs-keyword">OR</span> key2 <span class="hljs-operator">=</span> yyy<br></code></pre></td></tr></table></figure><p>对<code>key1 = xxx</code>和<code>key2 = yyy</code>得到的两个主键集合做并集，再去回表</p><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>对于<b>复合索引</b>的情况：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202601201524953.png" alt="image-20260120152429879"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202601201525706.png" alt="image-20260120152529076"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LongAdder相比AtomicLong的优势</title>
    <link href="/2026/01/19/LongAdder%E7%9B%B8%E6%AF%94AtomicLong%E7%9A%84%E4%BC%98%E5%8A%BF/"/>
    <url>/2026/01/19/LongAdder%E7%9B%B8%E6%AF%94AtomicLong%E7%9A%84%E4%BC%98%E5%8A%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="LongAdder相比AtomicLong的优势"><a href="#LongAdder相比AtomicLong的优势" class="headerlink" title="LongAdder相比AtomicLong的优势"></a>LongAdder相比AtomicLong的优势</h1><p>LongAdder相比AtomicLong最核心的优势在于<mark>大幅降低了高并发场景下的CAS竞争开销</mark>。当多个线程频繁对AtomicLong进行递增操作时，所有线程都会竞争同一个内存位置，导致<b>大量CAS失败重试，性能急剧下降</b>。这就像几十个人同时去抢一把锁，成功率极低，大家都在空转浪费CPU。</p><p>LongAdder采用<b>分段累加</b>策略巧妙地解决了这个问题。它的核心思想其实很朴素，就是”分而治之”—既然大家抢一个资源会冲突，那就准备多个资源让大家分开抢。LongAdder内部维护<b>一个Cell数组和一个base值</b>，当发生竞争时会动态扩容Cell数组。每个线程通过ThreadLocalRandom计算出一个probe值，映射到不同的Cell槽位进行累加操作，这样就把竞争分散到多个内存位置上。<mark>读取总值时会遍历所有Cell求和再加上base值</mark>。</p><p>具体工作机制是：初始状态所有操作都在base上进行，一旦检测到CAS竞争失败，就会初始化Cell数组并重新哈希线程到不同槽位。如果某个Cell仍然竞争激烈，会继续扩容数组直到达到CPU核心数。这种设计让写操作几乎无锁化，但读操作相对较重，因此<mark>LongAdder特别适合写多读少的计数场景</mark>，比如监控系统的QPS统计、缓存命中率计算等。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么HashMap的键值可以为null，而ConcurrentHashMap不行？</title>
    <link href="/2026/01/19/%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E7%9A%84%E9%94%AE%E5%80%BC%E5%8F%AF%E4%BB%A5%E4%B8%BAnull%EF%BC%8C%E8%80%8CConcurrentHashMap%E4%B8%8D%E8%A1%8C%EF%BC%9F/"/>
    <url>/2026/01/19/%E4%B8%BA%E4%BB%80%E4%B9%88HashMap%E7%9A%84%E9%94%AE%E5%80%BC%E5%8F%AF%E4%BB%A5%E4%B8%BAnull%EF%BC%8C%E8%80%8CConcurrentHashMap%E4%B8%8D%E8%A1%8C%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么HashMap的键值可以为null，而ConcurrentHashMap不行？"><a href="#为什么HashMap的键值可以为null，而ConcurrentHashMap不行？" class="headerlink" title="为什么HashMap的键值可以为null，而ConcurrentHashMap不行？"></a>为什么HashMap的键值可以为null，而ConcurrentHashMap不行？</h1><p><mark>根本原因：二义性问题，无法判断get(key)返回的Null值到底是因为不存在这个key，还是因为这个key对应的value就是Null</mark></p><h2 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h2><p>HashMap允许一个Null key和多个Null value，为什么HashMap没有二义性问题？</p><p>因为HashMap是为单线程设计的，在单线程的情况下，即便get(key)返回了Null，也可以通过containsKey(key)来判断是否存在这个key，从而破除了二义性问题。</p><h2 id="2-ConcurrentHashMap"><a href="#2-ConcurrentHashMap" class="headerlink" title="2. ConcurrentHashMap"></a>2. ConcurrentHashMap</h2><p>ConcurrentHashMap不允许Null key和Null value</p><p>ConcurrentHashMap使用的场景是多线程，假设ConcurrentHashMap可以存入Null值，有这样一个场景，现在有一个线程A先调用concurrentHashMap.get(key)，由于key不存在，返回了Null值；这时候再去调concurrentHashMap.containsKey(key)，在返回结果之前，线程B又调用了concurrentHashMap.put(key,Null)存入了Null值，那么线程A最终返回的结果就是true，按照这个结果，线程A就会做出判断：前面调用get(key)方法返回Null值的原因是因为key所对应的value就是Null，这显然是不对的，因为线程A调用get(key)方法时，Null值还没被存入</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>多线程手撕</title>
    <link href="/2026/01/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%8B%E6%92%95/"/>
    <url>/2026/01/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%8B%E6%92%95/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程手撕"><a href="#多线程手撕" class="headerlink" title="多线程手撕"></a>多线程手撕</h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>    <br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(singleton == <span class="hljs-literal">null</span>)&#123;<br>      <span class="hljs-keyword">synchronized</span>(Singleton.class)&#123;<br>        <span class="hljs-keyword">if</span>(singleton == <span class="hljs-literal">null</span>)&#123;<br>          singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singleton;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-三个线程交替打印ABC"><a href="#2-三个线程交替打印ABC" class="headerlink" title="2. 三个线程交替打印ABC"></a>2. 三个线程交替打印ABC</h2><h3 id="无限打印"><a href="#无限打印" class="headerlink" title="无限打印"></a>无限打印</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABCPrinter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintTask</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>), <span class="hljs-string">&quot;Thread-A&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintTask</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">1</span>), <span class="hljs-string">&quot;Thread-B&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintTask</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">2</span>), <span class="hljs-string">&quot;Thread-C&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> targetChar;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> targetState;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintTask</span><span class="hljs-params">(<span class="hljs-type">char</span> targetChar, <span class="hljs-type">int</span> targetState)</span> &#123;<br>            <span class="hljs-built_in">this</span>.targetChar = targetChar;<br>            <span class="hljs-built_in">this</span>.targetState = targetState;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                        <span class="hljs-keyword">while</span> (state != targetState) &#123;<br>                            lock.wait();<br>                        &#125;<br>                        System.out.println(targetChar);<br>                        state = (state + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>;<br>                        lock.notifyAll();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="限制只打印前100个"><a href="#限制只打印前100个" class="headerlink" title="限制只打印前100个"></a>限制只打印前100个</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ABCPrinter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintTask</span>(<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-number">0</span>), <span class="hljs-string">&quot;Thread-A&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintTask</span>(<span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-number">1</span>), <span class="hljs-string">&quot;Thread-B&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintTask</span>(<span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-number">2</span>), <span class="hljs-string">&quot;Thread-C&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> targetChar;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> targetState;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintTask</span><span class="hljs-params">(<span class="hljs-type">char</span> targetChar, <span class="hljs-type">int</span> targetState)</span> &#123;<br>            <span class="hljs-built_in">this</span>.targetChar = targetChar;<br>            <span class="hljs-built_in">this</span>.targetState = targetState;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (state &lt; <span class="hljs-number">100</span>) &#123;<br>                        <span class="hljs-keyword">while</span> ((state % <span class="hljs-number">3</span>) != targetState &amp;&amp; state &lt; <span class="hljs-number">100</span>) &#123;<br>                            lock.wait();<br>                        &#125;<br>                        <span class="hljs-keyword">if</span>(state &lt; <span class="hljs-number">100</span>)&#123;<br>                            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; - &quot;</span> + state + <span class="hljs-string">&quot; : &quot;</span> + targetChar);<br>                            state++;<br>                            lock.notifyAll();<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-交替打印0-100-内的奇偶数"><a href="#3-交替打印0-100-内的奇偶数" class="headerlink" title="3. 交替打印0 - 100 内的奇偶数"></a>3. 交替打印0 - 100 内的奇偶数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OddEvenPrinter</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">monitor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (monitor)&#123;<br>                <span class="hljs-keyword">while</span>(count &lt;= <span class="hljs-number">100</span>)&#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + count++);<br>                    monitor.notify();<br>                    <span class="hljs-keyword">if</span>(count &lt;= <span class="hljs-number">100</span>)&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            monitor.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Printer</span>(), <span class="hljs-string">&quot;odd&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Printer</span>(), <span class="hljs-string">&quot;even&quot;</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-生产者-消费者"><a href="#4-生产者-消费者" class="headerlink" title="4. 生产者-消费者"></a>4. 生产者-消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingDeque;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProduceConsumer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_QUEUE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedBlockingDeque&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(MAX_QUEUE_SIZE);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(), <span class="hljs-string">&quot;Producer-&quot;</span> + i).start();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(), <span class="hljs-string">&quot;Consumer-&quot;</span> + i).start();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> random.nextInt(<span class="hljs-number">100</span>);<br>                    queue.put(i);<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; produced: &quot;</span> + i);<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> queue.take();<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; consumed: &quot;</span> + i);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5. 死锁"></a>5. 死锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.management.ManagementFactory;<br><span class="hljs-keyword">import</span> java.lang.management.ThreadInfo;<br><span class="hljs-keyword">import</span> java.lang.management.ThreadMXBean;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadLockDemo</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; got resource1&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; waiting resource2&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; got resource2&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;Thread-1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (resource2) &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; got resource2&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000L</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; waiting resource1&quot;</span>);<br>                <span class="hljs-keyword">synchronized</span> (resource1) &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; got resource1&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;Thread-2&quot;</span>).start();<br><br>        <span class="hljs-type">ThreadMXBean</span> <span class="hljs-variable">threadMXBean</span> <span class="hljs-operator">=</span> ManagementFactory.getThreadMXBean();<br>        <span class="hljs-type">long</span>[] allThreadIds = threadMXBean.getAllThreadIds();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> threadId : allThreadIds) &#123;<br>            <span class="hljs-type">ThreadInfo</span> <span class="hljs-variable">threadInfo</span> <span class="hljs-operator">=</span> threadMXBean.getThreadInfo(threadId);<br>            <span class="hljs-keyword">if</span> (!threadInfo.getThreadName().equals(<span class="hljs-string">&quot;Thread-1&quot;</span>) &amp;&amp; !threadInfo.getThreadName().equals(<span class="hljs-string">&quot;Thread-2&quot;</span>)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;线程名称：&quot;</span> + threadInfo.getThreadName());<br>            System.out.println(<span class="hljs-string">&quot;线程状态：&quot;</span> + threadInfo.getThreadState());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>知识获取分享平台</title>
    <link href="/2026/01/05/%E7%9F%A5%E8%AF%86%E8%8E%B7%E5%8F%96%E5%88%86%E4%BA%AB%E5%B9%B3%E5%8F%B0/"/>
    <url>/2026/01/05/%E7%9F%A5%E8%AF%86%E8%8E%B7%E5%8F%96%E5%88%86%E4%BA%AB%E5%B9%B3%E5%8F%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="知识获取与分享平台"><a href="#知识获取与分享平台" class="headerlink" title="知识获取与分享平台"></a>知识获取与分享平台</h1><blockquote><p>知识社区App，支持发布知识、点赞&#x2F;收藏、关注取关、首页Feed展示、AI生成摘要等等。项目各模块进行了充分详细的设计以满足高并发和高可用需求</p></blockquote><h2 id="一、认证系统"><a href="#一、认证系统" class="headerlink" title="一、认证系统"></a>一、认证系统</h2><blockquote><p>开发JWT双令牌认证系统，采用RS256签名 + Redis刷新令牌白名单，实现15分钟访问令牌 + 7天刷新令牌的安全会话管理，支持即时令牌撤销，兼顾高安全和高性能。</p></blockquote><h3 id="1-1-有状态身份验证和无状态身份验证"><a href="#1-1-有状态身份验证和无状态身份验证" class="headerlink" title="1.1 有状态身份验证和无状态身份验证"></a>1.1 有状态身份验证和无状态身份验证</h3><ul><li>有状态身份验证：服务器端保存用户的会话状态信息，当用户访问时会携带上会话标识（如sessionid），服务器查找是否有这个会话来判断是否放行</li><li>无状态身份验证：服务器端不保存用户的会话状态信息，用户登录时，服务器使用私钥加密生成一个token返回给客户端，用户访问时带上这个token，若能用私钥解密，则允许访问。</li></ul><h3 id="1-2-什么是双令牌机制"><a href="#1-2-什么是双令牌机制" class="headerlink" title="1.2 什么是双令牌机制"></a>1.2 什么是双令牌机制</h3><p>服务器返回两个token给客户端，一个access token（AT）用于访问，一个refresh token（RT）用于刷新access token。</p><table><thead><tr><th></th><th><strong>Access Token</strong></th><th><strong>Refresh Token</strong></th></tr></thead><tbody><tr><td>持续时间</td><td>短，15min</td><td>长，7d</td></tr><tr><td>用途</td><td>用于客户端访问</td><td>用于刷新AT</td></tr><tr><td>是否无状态</td><td>是</td><td>否，需要将RT存储在Redis中，通过查询Redis中是否有对应RT来判断RT是否过期，这样的好处是能够方便强制踢人下线，保障了安全管控能力</td></tr></tbody></table><p>所以本项目实现的是一个<mark>半无状态的</mark>双token机制，兼顾高安全与高性能。</p><h3 id="1-3-token保存在什么地方"><a href="#1-3-token保存在什么地方" class="headerlink" title="1.3 token保存在什么地方"></a>1.3 token保存在什么地方</h3><p>JWT Token 存放在 HTTP 请求头的<code>Authorization</code> 字段中，格式为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">Authorization<span class="hljs-punctuation">:</span> Bearer Header.Payload.Signature<br></code></pre></td></tr></table></figure><p>客户端在登录成功后，会将服务端返回的 token 保存在：</p><ul><li><p>localStorage &#x2F; sessionStorage （本项目中使用此种保存方法）</p><blockquote><p><strong>localStorage</strong> 是一种浏览器提供的客户端存储机制，允许开发者在用户的浏览器中以键值对的形式存储数据。与 sessionStorage 不同，<mark>localStorage 中的数据可以长期保留，直到手动删除。</mark></p></blockquote></li><li><p>Cookie （如果使用 HttpOnly Cookie）</p></li><li><p>内存变量 （如 Redux&#x2F;Vuex 状态）</p></li></ul><p>每次发送请求时，客户端需要手动在请求头中加上这个 token。流程如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 用户在前端输入账号密码<br>   ↓<br><span class="hljs-bullet">2.</span> 前端发送给后端 (Spring Boot)<br>   ↓<br><span class="hljs-bullet">3.</span> 后端验证成功，生成 JWT Token，返回给前端<br>   ↓<br><span class="hljs-bullet">4.</span> 前端把 Token 存到 localStorage<br>   ↓<br><span class="hljs-bullet">5.</span> 以后每次请求，前端从 localStorage 读取 Token<br>   ↓<br><span class="hljs-bullet">6.</span> 把 Token 放在 HTTP Header 中发给后端<br>   ↓<br><span class="hljs-bullet">7.</span> 后端用 @AuthenticationPrincipal 自动解析 Token<br></code></pre></td></tr></table></figure><h3 id="1-4-token过期验证流程"><a href="#1-4-token过期验证流程" class="headerlink" title="1.4 token过期验证流程"></a>1.4 token过期验证流程</h3><h4 id="场景1：token正常"><a href="#场景1：token正常" class="headerlink" title="场景1：token正常"></a>场景1：token正常</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">前端：<br>  └─ ⚠️ 每 <span class="hljs-number">60</span> 秒检查：<span class="hljs-built_in">Date</span>.<span class="hljs-built_in">now</span>() &lt; expiresAt - <span class="hljs-number">5000</span> → 是 → 不刷新<br>  └─ 发送请求，携带 token<br>      ↓<br>后端：<br>  └─ JwtDecoder 验证：<span class="hljs-built_in">exp</span> &gt; 当前时间 → 通过 ✓<br>  └─ Controller 正常处理<br></code></pre></td></tr></table></figure><h4 id="场景2：token快过期（还有几秒）"><a href="#场景2：token快过期（还有几秒）" class="headerlink" title="场景2：token快过期（还有几秒）"></a>场景2：token快过期（还有几秒）</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gauss">前端：<br>  └─ ⚠️ 检查：Date.now() &gt;= expiresAt - <span class="hljs-number">5000</span> → 快过期了！<br>  └─ 自动调用 /api/v1/auth/<span class="hljs-built_in">token</span>/refresh<br>      ↓<br>后端：<br>  └─ 验证 refresh <span class="hljs-built_in">token</span>（<span class="hljs-number">7</span>天有效期）<br>  └─ 生成新的 access <span class="hljs-built_in">token</span>（新的<span class="hljs-number">15</span>分钟）<br>  └─ 返回给前端<br>      ↓<br>前端：<br>  └─ 保存新 <span class="hljs-built_in">token</span> 到 localStorage<br>  └─ 后续请求使用新 <span class="hljs-built_in">token</span><br></code></pre></td></tr></table></figure><h4 id="场景3：token已过期（前端没刷新成功）"><a href="#场景3：token已过期（前端没刷新成功）" class="headerlink" title="场景3：token已过期（前端没刷新成功）"></a>场景3：token已过期（前端没刷新成功）</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gauss">前端：<br>  └─ 发送请求，携带过期 <span class="hljs-built_in">token</span><br>      ↓<br>后端：<br>  └─ JwtDecoder 验证：<span class="hljs-built_in">exp</span> &lt; 当前时间 → 过期！<br>  └─ 抛出 JwtException<br>  └─ Spring Security 返回 <span class="hljs-number">401</span> Unauthorized<br>      ↓<br>前端：<br>  └─ 收到 <span class="hljs-number">401</span> 错误<br>  └─ 可以尝试刷新 <span class="hljs-built_in">token</span>，或跳转到登录页<br></code></pre></td></tr></table></figure><h3 id="1-5-token使用什么加密算法？token里包含什么信息？"><a href="#1-5-token使用什么加密算法？token里包含什么信息？" class="headerlink" title="1.5 token使用什么加密算法？token里包含什么信息？"></a>1.5 token使用什么加密算法？token里包含什么信息？</h3><p>本项目中的Jwt采用<code>RSA-256</code>非对称加密算法，原理如下：</p><table><thead><tr><th align="left">密钥类型</th><th align="left">作用</th><th align="left">谁持有</th></tr></thead><tbody><tr><td align="left">私钥 (private.pem)</td><td align="left">签名 Token（加密）<br />生成：header.payload.signature</td><td align="left">只有后端服务器持有</td></tr><tr><td align="left">公钥 (public.pem)</td><td align="left">验证 Token（解密）<br />检查：signature 是否匹配 header + payload</td><td align="left">可以公开，任何人都能验证</td></tr></tbody></table><p>一个完整的Jwt长这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Header]</span>.<span class="hljs-selector-attr">[Payload]</span>.<span class="hljs-selector-attr">[Signature]</span><br>这三部分用 . 分隔：<br></code></pre></td></tr></table></figure><h4 id="Header（头部）-算法信息"><a href="#Header（头部）-算法信息" class="headerlink" title="Header（头部） - 算法信息"></a>Header（头部） - 算法信息</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;RS256&quot;</span><span class="hljs-punctuation">,</span>      <span class="hljs-comment">// 使用 RSA-256 算法</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-comment">// 类型是 JWT</span><br>  <span class="hljs-attr">&quot;kid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx-key&quot;</span> <span class="hljs-comment">// 密钥 ID（用于密钥轮换）</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="Payload（负载）-实际数据"><a href="#Payload（负载）-实际数据" class="headerlink" title="Payload（负载） - 实际数据"></a>Payload（负载） - 实际数据</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;iss&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><span class="hljs-punctuation">,</span>           <span class="hljs-comment">// 签发者（issuer）</span><br>  <span class="hljs-attr">&quot;iat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1706169600</span><span class="hljs-punctuation">,</span>           <span class="hljs-comment">// 签发时间（issued at）</span><br>  <span class="hljs-attr">&quot;exp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1706170500</span><span class="hljs-punctuation">,</span>           <span class="hljs-comment">// 过期时间（expires at）</span><br>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123&quot;</span><span class="hljs-punctuation">,</span>                <span class="hljs-comment">// 主题（subject，通常是用户ID）</span><br>  <span class="hljs-attr">&quot;jti&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;uuid-1234&quot;</span><span class="hljs-punctuation">,</span>          <span class="hljs-comment">// JWT ID（唯一标识）</span><br>  <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;access&quot;</span><span class="hljs-punctuation">,</span>      <span class="hljs-comment">// Token 类型（access 或 refresh）</span><br>  <span class="hljs-attr">&quot;uid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123</span><span class="hljs-punctuation">,</span>                  <span class="hljs-comment">// 用户 ID（自定义声明）</span><br>  <span class="hljs-attr">&quot;nickname&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;张三&quot;</span>           <span class="hljs-comment">// 用户昵称（自定义声明）</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="Signature（签名）-防篡改"><a href="#Signature（签名）-防篡改" class="headerlink" title="Signature（签名） - 防篡改"></a>Signature（签名） - 防篡改</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">签名 = RSA_SIGN(<br>  Base64Url(header) + <span class="hljs-string">&quot;.&quot;</span> + Base64Url(payload)<span class="hljs-punctuation">,</span><br>  private.pem  <span class="hljs-comment">// 私钥</span><br>)<br></code></pre></td></tr></table></figure><h3 id="1-6-Jwt验证完整流程"><a href="#1-6-Jwt验证完整流程" class="headerlink" title="1.6 Jwt验证完整流程"></a>1.6 Jwt验证完整流程</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-number">1.</span> 接收 Token<br>   前端发送：Authorization<span class="hljs-punctuation">:</span> Bearer eyJhbGc...<br>   <br><span class="hljs-number">2.</span> 分解 Token<br>   header.payload.signature<br>   <br><span class="hljs-number">3.</span> ⚠️ 用公钥验证签名【关键步骤】<br>   ┌─────────────────────────────┐<br>   │ 用 public.pem 解密 signature │<br>   │ 得到：hash1                  │<br>   └─────────────────────────────┘<br>   <br>   ┌─────────────────────────────┐<br>   │ 重新计算 header + payload    │<br>   │ 的哈希值：hash2              │<br>   └─────────────────────────────┘<br>   <br>   ┌─────────────────────────────┐<br>   │ 对比：hash1 == hash2 ?       │<br>   │ - 相等 → 签名有效，未被篡改    │<br>   │ - 不等 → 签名无效，拒绝！      │<br>   └─────────────────────────────┘<br><br><span class="hljs-number">4.</span> 验证声明（Claims）<br>   ✅ exp（过期时间）&gt; 当前时间？<br>   ✅ iss（签发者）== <span class="hljs-string">&quot;xxx&quot;</span>？<br>   ✅ Token 格式正确？<br><br><span class="hljs-number">5.</span> 提取用户信息<br>   从 payload 中取出 uid、nickname 等<br>   <br><span class="hljs-number">6.</span> 传递给 Controller<br>   @AuthenticationPrincipal Jwt jwt<br></code></pre></td></tr></table></figure><h2 id="二、计数系统"><a href="#二、计数系统" class="headerlink" title="二、计数系统"></a>二、计数系统</h2><blockquote><p>计数系统：笔记维度(点赞收藏)与用户维度(关注取关) 以 Redis 作为底层存储系统，采用<mark>定制化 Redis SDS 二进制</mark>紧凑计数，使用 Lua 脚本进行原子更新，并实现了采样一致性校验与自愈重建。</p></blockquote><h3 id="2-1-为什么要单独把计数模块抽出来，有什么好处？"><a href="#2-1-为什么要单独把计数模块抽出来，有什么好处？" class="headerlink" title="2.1 为什么要单独把计数模块抽出来，有什么好处？"></a>2.1 为什么要单独把计数模块抽出来，有什么好处？</h3><p>计数类数据（浏览量、点赞数、收藏数、关注数、粉丝数等）有几个典型特征：</p><ul><li><b>读写极高频</b>：一个热门用户&#x2F;热门作品，计数每秒都在变。</li><li><b>更新粒度小且随机</b>：每次只改一个数，还可能集中打在少数热点 Key 上。</li><li><b>对“绝对强一致”要求没那么死</b>：10001 和 9999 对用户来说差别不大，比起“页面加载很慢&#x2F;操作失败”，用户更在乎“流畅”。</li></ul><p>如果计数都落在 MySQL：</p><ul><li>热点行会频繁 UPDATE，行锁、redo log 压力巨大，很容易撑爆。</li><li>想做分库分表，计数又和业务数据纠缠在一起，拆分困难。</li><li>任意一个计数维度新增或变更，都要改表结构，DDL 成本很高。</li></ul><p>所以：把计数抽出成一个独立的“计数服务 + Redis 存储”，是更合理的架构拆分。</p><h3 id="2-2-选择Redis作为底层存储系统可靠吗？"><a href="#2-2-选择Redis作为底层存储系统可靠吗？" class="headerlink" title="2.2 选择Redis作为底层存储系统可靠吗？"></a>2.2 选择Redis作为底层存储系统可靠吗？</h3><ol><li>可以使用 <mark>RDB + AOF</mark> 混合持久化的方式，将数据持久化到本地；AOF开启策略everysec，理论上最多丢失1s的数据</li><li>如果担心redis宕机，可以使用 <mark>多副本 + 主从</mark> 的模式，确保一台redis服务器宕机了，另一台能立马顶上</li><li>对于 RDB + AOF 可能丢失的1s的数据，也可能与数据库事实表出现不一致，可以通过执行<mark>定时对账任务</mark>，和事实表进行对账来修正（本项目的：采样一致性校验与自愈重建）</li><li>在极端情况下，比如硬盘损坏，也可以通过和事实表定期对账，来找回丢失的数据 &#x2F; 修正错误的数据</li></ol><h3 id="2-3-为什么采用自定义的二进制Redis-SDS来计数，讲一下存储计数的实现细节"><a href="#2-3-为什么采用自定义的二进制Redis-SDS来计数，讲一下存储计数的实现细节" class="headerlink" title="2.3 为什么采用自定义的二进制Redis SDS来计数，讲一下存储计数的实现细节"></a>2.3 为什么采用自定义的二进制Redis SDS来计数，讲一下存储计数的实现细节</h3><p>对于作品维度，有点赞数、收藏数；对于用户维度，有关注数、粉丝数、作品数、获赞数、获收藏数，乍一看来，好像是使用Hash来存储更加合适：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">key:</span> 作品id<span class="hljs-params">field:</span> like<span class="hljs-symbol">/fav</span><span class="hljs-params">value:</span> likeNum<span class="hljs-symbol">/favNum</span><br><br><span class="hljs-params">key:</span> userId<br><span class="hljs-params">field:</span> followCount, fanCount, workCount, likeCount, favCount<br><span class="hljs-params">value:</span> <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>但是随着业务规模上涨，用户数、作品数增加，如果每个用户&#x2F;作品都在Redis里维护一个这样的Hash结构，先不谈数据多少，<mark>元数据的字段名就占了很多重复的空间，浪费内存</mark></p><p>我们设计的紧凑计数：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">key:</span> userId<br><span class="hljs-params">value:</span> 一个连续的二进制块<br>[<span class="hljs-params">offset0:</span> followCount][<span class="hljs-params">offset1:</span> fanCount][<span class="hljs-params">offset2:</span> workCount][<span class="hljs-params">offset3:</span> likeCount][<span class="hljs-params">offset4:</span> favCount]<br></code></pre></td></tr></table></figure><p><mark>没有字段名，只存值，节省空间；寻找对应的数据只需：“起始地址 + 类型偏移”即可</mark>。我们为每一个key分配了20字节的value，每个value分成5段，每段4字节存储对应数值。</p><h3 id="2-4-采样一致性校验和自愈重建是怎么做的？"><a href="#2-4-采样一致性校验和自愈重建是怎么做的？" class="headerlink" title="2.4 采样一致性校验和自愈重建是怎么做的？"></a>2.4 采样一致性校验和自愈重建是怎么做的？</h3><p>每隔300s，在查询Redis SDS中数量的时候，去对比和数据库中事实表的实际值，如果不一致，就触发重建<mark>（用户关系每隔300s检查是否一致；而点赞系统每次获取数量都判断最终计数结构是否完整，只有结构不完整才会重建）</mark>。</p><p><mark>采样 &#x3D; 不是每次请求都校验，而是按一定频率抽样检查</mark>：</p><ol><li>限流机制：使用 <mark>setIfAbsent (相当于 SETNX) 实现分布式锁</mark>，过期时间300s，保证300s内只有一个线程能够校验并重建<ol><li>如果 300 秒内第一次访问：key 不存在，设置成功 → doCheck &#x3D; true，执行校验</li><li>如果 300 秒内已校验过：key 已存在 → doCheck &#x3D; false，跳过校验</li></ol></li><li>校验内容：对比 Redis SDS 中的关注&#x2F;粉丝数与数据库实际值</li><li>修复机制：发现不一致时，触发 rebuildAllCounters() 全量重建</li></ol><p>为什么需要采样校验？</p><ul><li><p>性能考虑：每次查询都去数据库校验会严重影响性能</p></li><li><p>最终一致性：通过定期采样保证缓存与数据库的<strong>最终一致性</strong></p></li><li><p>自动修复：自动检测并修复可能出现的数据不一致问题</p></li></ul><h2 id="三、用户关系系统"><a href="#三、用户关系系统" class="headerlink" title="三、用户关系系统"></a>三、用户关系系统</h2><blockquote><p>实现关注功能，采用<b>一主多从+事件驱动</b>模型。粉丝表，计数系统，列表缓存都作为关注表的伪从。关注事件发生时，在同一事务中插入关注表和 Outbox 表，使用 Canal 订阅 Outbox 表的 binlog，并将变更事件发布到 Kafka 异步更新其他数据源。</p></blockquote><h3 id="3-1-用户关系系统是怎么实现的？什么是“一主多从-事件驱动”？"><a href="#3-1-用户关系系统是怎么实现的？什么是“一主多从-事件驱动”？" class="headerlink" title="3.1 用户关系系统是怎么实现的？什么是“一主多从+事件驱动”？"></a>3.1 用户关系系统是怎么实现的？什么是“一主多从+事件驱动”？</h3><p>当用户A关注用户B时，以下多张表会发生更新：</p><ol><li>关注表（MySQL）需要新增：A -&gt; B</li><li>粉丝表（MySQL）需要新增：B -&gt; A</li><li>A关注数 + 1，B粉丝数 + 1（Redis）</li><li>A关注列表缓存、B粉丝列表缓存更新（Redis）</li></ol><p>这么多操作，如果有一个发生错误，就会导致<mark>数据不一致</mark>的情况。为了解决一致性的问题，可能会想到，使用<mark>分布式事务</mark>，将这多个任务都放在一个事务里，就能解决多张表之间的一致性问题。</p><p>但是，随之而来的新问题，<mark>多个任务放在同一个事务里，会导致性能变差，特别是对于热点用户</mark>，后续如果有新的任务需要添加，性能只会越来越差。而且，多个任务放在同一个事务里，如果有一个组件挂了，整体就会一起挂，<mark>耦合性</mark>变得非常高。</p><p>而在我们的用户关系系统里，当用户A关注了用户B后，用户B的粉丝表、用户A的关注数、用户B的粉丝数等这些都不需要非常强的一致性，只需要保证最终一致即可。<mark>于是我们将关注表作为主表，其他作为从表，我们只关注主表是否成功，主表成功就算业务成功，下游任务可以容忍慢一点，甚至短暂挂掉，后续只要通过重建措施来保证最终一致性即可</mark>。</p><table><thead><tr><th>表</th><th>性质</th><th>是否必须一致</th></tr></thead><tbody><tr><td>following（关注表）</td><td>唯一真相</td><td>必须准确</td></tr><tr><td>follower（粉丝表）</td><td>粉丝投影表</td><td>可延时，但必须可修正</td></tr><tr><td>计数（Redis SDS）</td><td>聚合投影</td><td>可延时，可修正</td></tr><tr><td>列表缓存（ZSet &#x2F; Caffeine）</td><td>性能投影</td><td>可延时，可修正</td></tr></tbody></table><p>我们通过一个新的表：outbox表，来记录following主表的事件，一个事务里只需要完成following表 + outbox表的更新即可。然后通过Canal去订阅outbox表的binlog，再通过Kafka去异步消费outbox表中的事件以更新下游的follower表、Redis计数、缓存<mark>（kafka带上userId作为key，保证一个用户的所有事件都进入同一个分区，确保顺序消费）</mark>。这就是“一主多从 + 事件驱动”。</p><h3 id="3-2-这种模式有什么好处？"><a href="#3-2-这种模式有什么好处？" class="headerlink" title="3.2 这种模式有什么好处？"></a>3.2 这种模式有什么好处？</h3><ol><li>高可扩展性：在没有使用outbox表之前，如果想在下游添加新的任务，需要放在一个事务里，拖垮性能。使用outbox表之后，新来的任务只需要新增一个消费者去订阅Kafka事件，就能够无限扩展下游服务。</li><li>高可用性：在没有outbox表时，如果不把所有任务放在一个事务里，那么follower表只要有一次失败，那就永远不一致；Redis计数也是同理。添加outbox + canal + kafka之后：<ul><li><mark>kafka具有重试机制，同时消息会持久化到本地，保证了不会丢消息</mark></li><li>下游任务可以通过outbox表，进行重建</li><li>由于我们保证了following是强一致的，即使下游Redis计数任务有不一致，也可以通过<mark>每日自动比对following聚合值与Redis计数是否一致，并自动修复</mark>，来保证计数任务的一致性</li></ul></li></ol><h3 id="3-3-讲一下Canal的原理"><a href="#3-3-讲一下Canal的原理" class="headerlink" title="3.3 讲一下Canal的原理"></a>3.3 讲一下Canal的原理</h3><p>canal的工作原理就是把自己<b>伪装成MySQL slave，模拟MySQL slave的交互协议向MySQL Mater发送 dump协议</b>，MySQL mater收到canal发送过来的dump请求，开始推送bin log给canal，然后canal解析bin log，再发送到存储目的地，比如MySQL，Kafka，Elastic Search等等。</p><h3 id="3-4-讲一下Outbox设计模式"><a href="#3-4-讲一下Outbox设计模式" class="headerlink" title="3.4 讲一下Outbox设计模式"></a>3.4 讲一下Outbox设计模式</h3><p>Outbox模式主要用于解决在微服务架构中，数据库更新与消息发送之间可能出现的不一致性问题。其基本思想是：</p><ol><li><strong>创建Outbox表</strong>：在数据库中增加一个专用的Outbox表，用于存储待发送的事件或消息。</li><li><strong>原子性操作</strong>：在同一个数据库事务中，先更新业务相关的数据库表（如订单表），然后将事件记录插入到Outbox表中。这样可以确保这两个操作要么同时成功，要么同时失败，保证数据的一致性。</li><li><strong>异步发送</strong>：一个独立的进程（如消息中继或调度器）定期查询Outbox表（本项目中的Canal），将待发送的消息发布到外部消息代理（如Kafka、RabbitMQ等）。在消息成功发送后，更新Outbox表中对应消息的状态</li></ol><h3 id="3-5-用户关系系统中如何保障消息的幂等性？"><a href="#3-5-用户关系系统中如何保障消息的幂等性？" class="headerlink" title="3.5 用户关系系统中如何保障消息的幂等性？"></a>3.5 用户关系系统中如何保障消息的幂等性？</h3><ol><li>Canal每次拉取outbox表中一批未确认的消息，只有消息解析成功并被成功发送到Kafka，才会ack这一批消息，保证了Canal中的幂等</li><li>Kafka也采用手动提交offset的方式，只有消息都被成功消费了，才会提交</li><li>而对于消费者中每一个用户关注事件，通过<mark>Redis分布式锁（10min的setnx）</mark>，来实现一个用户关注事件只被消费一次，保证了幂等性</li></ol><h3 id="3-6-用户关系系统如何实现重建？"><a href="#3-6-用户关系系统如何实现重建？" class="headerlink" title="3.6 用户关系系统如何实现重建？"></a>3.6 用户关系系统如何实现重建？</h3><p>采样校验：查询关注数&#x2F;粉丝数等Redis计数时，使用 Redis 锁限流，每用户<b> 300s 触发一次</b>，去和数据库中的事实表做比较，不一致则重建。</p><h3 id="3-7-Outbox表的结构？Outbox表binlog中哪些信息可以被Canal监控并发送消息？"><a href="#3-7-Outbox表的结构？Outbox表binlog中哪些信息可以被Canal监控并发送消息？" class="headerlink" title="3.7 Outbox表的结构？Outbox表binlog中哪些信息可以被Canal监控并发送消息？"></a>3.7 Outbox表的结构？Outbox表binlog中哪些信息可以被Canal监控并发送消息？</h3><p>Outbox表结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> outbox (<br>    id <span class="hljs-type">BIGINT</span> UNSIGNED <span class="hljs-keyword">NOT NULL</span>,<br>    aggregate_type <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT NULL</span>,<br>    aggregate_id <span class="hljs-type">BIGINT</span> UNSIGNED <span class="hljs-keyword">NULL</span>,<br>    type <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT NULL</span>,<br>    payload JSON <span class="hljs-keyword">NOT NULL</span>,<br>    created_at <span class="hljs-type">TIMESTAMP</span>(<span class="hljs-number">3</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>(<span class="hljs-number">3</span>),<br>    <span class="hljs-keyword">PRIMARY KEY</span> (id),<br>    KEY ix_outbox_agg (aggregate_type, aggregate_id),<br>    KEY ix_outbox_ct (created_at)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_unicode_ci;<br></code></pre></td></tr></table></figure><p>其中<code>payload</code>字段为如下Json：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造关系事件。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> type       事件类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> fromUserId 触发方用户ID</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> toUserId   目标方用户ID</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> id         关系记录ID，可为空</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">RelationEvent</span><span class="hljs-params">(</span><br><span class="hljs-params">        String type,</span><br><span class="hljs-params">        Long fromUserId,</span><br><span class="hljs-params">        Long toUserId,</span><br><span class="hljs-params">        Long id)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>Canal通过监控outbox表中，事件类型为<code>INSERT</code>或<code>UPDATE</code>的数据行，并将<code>payload</code>字段发送给kafka，这个字段包含了完整的业务信息。最终发送到kafka的消息结构：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;table&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;outbox&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;INSERT/UPDATE&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;payload&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;type: FollowCreated, fromUserId: 123, toUserId: 456&#125;&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="四、点赞系统"><a href="#四、点赞系统" class="headerlink" title="四、点赞系统"></a>四、点赞系统</h2><blockquote><p>采用<b>异步写+写聚合</b>的形式应对高并发写场景。采用<b>分片位图</b>的结构高效实现幂等和判重。读取遇到异常或缺失时，基于位图做按需重建，保证最终一致。</p></blockquote><h3 id="4-1-点赞系统是怎么设计的？"><a href="#4-1-点赞系统是怎么设计的？" class="headerlink" title="4.1 点赞系统是怎么设计的？"></a>4.1 点赞系统是怎么设计的？</h3><p>点赞系统存在如下“矛盾”：</p><ul><li>一方面，用户操作后需要<mark>“即时生效”的交互反馈（如点击点赞后立即显示“已点赞”状态）</mark>，这要求用户维度的状态具备强一致性；</li><li>另一方面，实体的<mark>总计数（如点赞数）对实时性要求较低</mark>，允许秒级最终一致。</li></ul><p>于是，点赞系统也效仿用户关系系统，采用“一主多从 + 事件驱动”的设计。记录用户是否点赞&#x2F;收藏的位图bitmap（key为作品id）作为主表，需要强一致性；而作品点赞数、收藏数等这些不需要非常精确的计数作为从表，通过消费事件来同步<b>（异步写）</b>，保证最终一致性。只要确保主表bitmap正确，即使计数有不一致，也可以通过正确的bitmap进行重建。</p><h3 id="4-2-什么是“写聚合”"><a href="#4-2-什么是“写聚合”" class="headerlink" title="4.2 什么是“写聚合”"></a>4.2 什么是“写聚合”</h3><p>如果每发生一次点赞操作，更新位图bitmap的同时，直接去更新最终计数存储（Redis SDS），会导致形成高频次、细粒度的写请求，特别是对于热点帖子，它们的计数键会成为热点行，集中占用存储节点的资源。单条行为的计数更新数据量极小，但高频请求会占用大量网络带宽；同时，存储层需要处理海量零散写请求，硬件资源利用率低，导致成本浪费。</p><p>所以需要一个中间层，去将 <mark>同一实体（同一帖子）、同一指标（点赞&#x2F;收藏）在同一时间窗口内的多次增量更新聚合为一次批量更新</mark>，减少最终存储层的写次数，这就是<b>“写聚合”</b>。具体通过Redis的一个Hash结构实现，架构图如下：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202601061722309.png" alt="点赞操作流程"></p><ol><li><p>用户发起点赞操作，去更新位图（这一步需要强一致），然后即时返回点赞结果</p></li><li><p>位图更新成功后，产出事件供kafka去消费（更新点赞数、触发点赞数缓存失效）,<mark>以作品id为key，保证同一个作品的所有事件都进入同一个分区，保证顺序消费</mark></p></li><li><p>kafka消费事件时，并不是直接写入最终存储层的自定义SDS，而是先写入一个Redis Hash聚合桶里，聚合桶结构如下：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">key:</span> 作品id + 指标（点赞 <span class="hljs-keyword">or</span> 收藏） + 时间窗口<br><span class="hljs-symbol">field:</span> 点赞、收藏<br><span class="hljs-symbol">value:</span> 这段时间窗口累积的点赞数、这段时间窗口累积的收藏数<br></code></pre></td></tr></table></figure><p>这样就实现了：大量更新操作不会直接达到最终的计数存储SDS处，而是<mark>在中间的Hash聚合桶累计一段时间，再批量直接写入最终存储，将多次写入变为一次写入</mark>；同时，时间窗口的划分，也能够<mark>保证对一个作品的大量点赞操作不会打到同一个聚合桶的key上</mark></p></li><li><p>最后，再设计一个定时任务，每隔1s去读取聚合桶里累积的点赞数&#x2F;收藏数，批量写入最终计数，写入成功后再删除已刷写的聚合字段，防止重复计算</p></li></ol><h3 id="4-3-什么是分片位图？为什么需要分片？"><a href="#4-3-什么是分片位图？为什么需要分片？" class="headerlink" title="4.3 什么是分片位图？为什么需要分片？"></a>4.3 什么是分片位图？为什么需要分片？</h3><p>当前用户量少的情况下，一个作品的所有点赞用户通过一个位图bitmap来记录是可以的；但是随着用户量的增加，如果还用一个位图bitmap来记录，那么这个key就会非常大，对这个key的操作也会变得非常重，所以需要将一个作品的key分成多个，本项目中设计每个分片位数为32K位（即可以记录32K &#x3D; 32768个用户的点赞数据），即每个分片4KB；<mark>通过<code>usedId / 32768</code>得到该用户的点赞数据在哪个分片，再通过<code>userId % 32768</code>得到该用户的点赞数据在该分片的哪一位</mark>。</p><p>分片的好处：</p><ul><li>避免bigkey</li><li>统计总点赞数时，可以对多个分片<mark>并行</mark>执行 <code>BITCOUNT</code> 再汇总</li><li>某些分片冷了，可以整体迁移到冷实例&#x2F;冷存储</li><li>用户量级上去，只需要增加分片数或调整映射规则，无需推倒重来</li></ul><h3 id="4-4-点赞系统是如何实现重建的？"><a href="#4-4-点赞系统是如何实现重建的？" class="headerlink" title="4.4 点赞系统是如何实现重建的？"></a>4.4 点赞系统是如何实现重建的？</h3><p>对需要重建点赞&#x2F;收藏数的内容，列出该内容的所有分片位图键，对每个位图bitmap执行<code>BITCOUNT</code>统计1的数量，求和即为真实点赞&#x2F;收藏数量，再写回对应的最终计数存储。（注意：重建过程需要加锁，重建结束删除对应的过时聚合字段）</p><h3 id="4-5-点赞系统是如何保障幂等性的？"><a href="#4-5-点赞系统是如何保障幂等性的？" class="headerlink" title="4.5 点赞系统是如何保障幂等性的？"></a>4.5 点赞系统是如何保障幂等性的？</h3><ol><li><p><strong>位图层面、事件生产的幂等</strong></p><p>使用Lua脚本，只有位图对应位发生改变时，才会产生事件；否则不产生任何事件，也就不会多算点赞&#x2F;收藏数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 位图状态切换：仅在状态变化时返回成功，并产出增量事件。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> etype 实体类型</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> eid 实体 ID</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> uid 用户 ID</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> metric 指标名称（like/fav）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> idx 指标索引（用于 SDS 固定结构定位）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> add 是否置位（true=添加，false=移除）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">toggle</span><span class="hljs-params">(String etype, String eid, <span class="hljs-type">long</span> uid, String metric, <span class="hljs-type">int</span> idx, <span class="hljs-type">boolean</span> add)</span> &#123;<br>    <span class="hljs-comment">// 固定分片定位：按用户ID映射到 chunk 与分片内 bit 偏移，避免单键膨胀与热点</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">chunk</span> <span class="hljs-operator">=</span> BitmapShard.chunkOf(uid);<br>    <span class="hljs-comment">// 分片内位偏移</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">bit</span> <span class="hljs-operator">=</span> BitmapShard.bitOf(uid);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">bmKey</span> <span class="hljs-operator">=</span> CounterKeys.bitmapKey(metric, etype, eid, chunk);<br>    List&lt;String&gt; keys = List.of(bmKey);<br>    List&lt;String&gt; args = List.of(String.valueOf(bit), add ? <span class="hljs-string">&quot;add&quot;</span> : <span class="hljs-string">&quot;remove&quot;</span>);<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">changed</span> <span class="hljs-operator">=</span> redis.execute(toggleScript, keys, args.toArray());<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> changed == <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">if</span> (ok) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">delta</span> <span class="hljs-operator">=</span> add ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 产出计数事件（异步聚合），分区按实体维度保证同实体事件顺序</span><br>        eventProducer.publish(CounterEvent.of(etype, eid, metric, idx, uid, delta));<br>        <span class="hljs-comment">// 本地事件：触发缓存失效/旁路更新等快速路径</span><br>        eventPublisher.publishEvent(CounterEvent.of(etype, eid, metric, idx, uid, delta));<br>    &#125;<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>聚合刷写的幂等</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">redis.execute(incrScript, List.of(cntKey),<br>        String.valueOf(CounterSchema.SCHEMA_LEN),<br>        String.valueOf(CounterSchema.FIELD_SIZE),<br>        String.valueOf(idx),<br>        String.valueOf(delta));<br><span class="hljs-comment">// 成功后删除该字段，避免重复加算</span><br>redis.opsForHash().delete(aggKey, field);<br></code></pre></td></tr></table></figure><ul><li><p>事件先写入聚合桶（Hash）</p></li><li><p>定时任务（每1秒）将增量折叠到SDS</p></li><li><p>刷写成功后立即删除聚合字段</p></li><li><p>即使定时任务多次执行，每个增量只会被刷写一次</p></li></ul></li><li><p><strong>重建场景的幂等</strong></p><ul><li>使用<strong>Redisson分布式锁</strong>保证只有一个线程重建，这个过程中其他获取锁失败的线程降级返回0（启用Redisson的看门狗机制去自动给锁续期，防止<code>BITCOUNT</code>统计没统计完就释放锁，因为这个执行多个分片的<code>BITCOUNT</code>可能是很耗时的操作）</li><li>重建完成后删除对应的聚合字段，<mark>避免 位图重建值 + 聚合增量 被重复计算</mark></li></ul></li></ol><h3 id="4-6-使用位图判断点赞与否不会存在内存浪费的问题吗？"><a href="#4-6-使用位图判断点赞与否不会存在内存浪费的问题吗？" class="headerlink" title="4.6 使用位图判断点赞与否不会存在内存浪费的问题吗？"></a>4.6 使用位图判断点赞与否不会存在内存浪费的问题吗？</h3><p>用户量很小时不会产生稀疏问题，后续可更换为稀疏位图，比如 roaring bitmap</p><h3 id="4-7-一次点赞会访问三次Redis（bitmap-hash-sds），这是不是冗余的？为什么不直接存储在sds里？"><a href="#4-7-一次点赞会访问三次Redis（bitmap-hash-sds），这是不是冗余的？为什么不直接存储在sds里？" class="headerlink" title="4.7 一次点赞会访问三次Redis（bitmap+hash+sds），这是不是冗余的？为什么不直接存储在sds里？"></a>4.7 一次点赞会访问三次Redis（bitmap+hash+sds），这是不是冗余的？为什么不直接存储在sds里？</h3><p>并不冗余。</p><ul><li>第一次访问Redis的bitmap，用于记录该用户是否点赞了该作品，用于实时展示“已点赞”的状态；然后生成一个kafka消息，用于后续点赞数更新</li><li>第二次访问Redis的hash，用于记录当前时间窗口内，该作品点赞数的增量（防止某个作品的总点赞数sds被不停访问更新，特别是对于热门作品，导致redis负载不均衡）</li><li>第三次访问Redis的sds，用于将hash中的增量点赞数刷写到总点赞数中去</li></ul><h3 id="4-8-对于点赞业务，如果消息还没被消费，那么如果在前端页面上刷新一下页面，这个点赞会消失吗？"><a href="#4-8-对于点赞业务，如果消息还没被消费，那么如果在前端页面上刷新一下页面，这个点赞会消失吗？" class="headerlink" title="4.8 对于点赞业务，如果消息还没被消费，那么如果在前端页面上刷新一下页面，这个点赞会消失吗？"></a>4.8 对于点赞业务，如果消息还没被消费，那么如果在前端页面上刷新一下页面，这个点赞会消失吗？</h3><p>不会消失，因为当用户点赞之后，触发作品对应的bitmap更新，将该用户对应的bitmap位设置为1，表示用户“已点赞”，之后才发出消息去更新点赞数，所以即使刷新页面，用户已点赞的状态不会消失</p><p>但是如果此时消息还没被消费，那么点赞数的更新可能会有延迟，但这是在能够接受的范围内的</p><h2 id="五、Feed信息流"><a href="#五、Feed信息流" class="headerlink" title="五、Feed信息流"></a>五、Feed信息流</h2><blockquote><p>采用<b>三级缓存</b>架构且设计了缓存一致性策略，本地 Caffeine + Redis 页面缓存 + Redis 片段缓存。<b>自定义 hotkey 探测机制</b>，基于热点检测按层级延长缓存时长，叠加随机抖动抗雪崩。并设置<b>单飞锁(single-flight)</b>避免同一页并发回源风暴</p></blockquote><h3 id="5-1-介绍一下项目中用到的三级缓存"><a href="#5-1-介绍一下项目中用到的三级缓存" class="headerlink" title="5.1 介绍一下项目中用到的三级缓存"></a>5.1 介绍一下项目中用到的三级缓存</h3><p>三级缓存用来存放一个页面里的所有推文数据：</p><ul><li>L2 本地Caffeine缓存：存放完整页面数据，命中成本最低，适合最热的公共页</li><li>L1 Redis页面缓存：存放页面“骨架”，即当前页面文章的id列表，命中后用它来快速拼装页面</li><li>L0 Redis片段缓存：存放每篇文章的小碎片（作者、封面、标题、计数等），用来按id拼装完整条目</li></ul><p>获取页面数据的流程是：</p><ul><li>优先读 L2：本地命中则直接返回完整页面，延迟最小。</li><li>L2 未命中则读 L1：拿到页面骨架（ID 列表），随后按 <mark>ID 批量读取 L0 的条目碎片与计数碎片</mark>；缺片则进行最小化补全。</li><li>L1 未命中则回源数据库：用单次查询拉取页面数据，同时并行批量获取计数；把结果写回 L0&#x2F;L1，并把完整响应写入 L2，最后返回给用户。</li></ul><h3 id="5-2-为什么Redis要分成页面缓存和碎片缓存？不能像Caffeine一样存储完整页面数据吗？"><a href="#5-2-为什么Redis要分成页面缓存和碎片缓存？不能像Caffeine一样存储完整页面数据吗？" class="headerlink" title="5.2 为什么Redis要分成页面缓存和碎片缓存？不能像Caffeine一样存储完整页面数据吗？"></a>5.2 为什么Redis要分成页面缓存和碎片缓存？不能像Caffeine一样存储完整页面数据吗？</h3><p>如果Redis存储完整页面数据，虽然一次读取就能够返回所有数据，但是一个key包含整个页面的所有数据，容易产生<mark>bigkey问题</mark>；此外，页面内<mark>任何一篇文章更新（点赞数更新、内容更新），都会导致整个页面的缓存失效</mark>；而且，倘若当前页面和其他页面有<mark>同一篇文章，这篇文章的内容也没法复用</mark>。</p><p>相比之下，将Redis缓存分成页面缓存、片段缓存，当文章内容发生更新时，只需要<mark>使文章对应的那份片段缓存失效即可</mark>，无需将整页缓存失效，在最小范围内进行改动；若多个页面都包含同一篇文章，那么它们都能够<mark>复用同一篇文章的片段缓存，提高了空间利用率</mark>。</p><h3 id="5-3-如何保证Caffeine、Redis、MySQL的一致性？"><a href="#5-3-如何保证Caffeine、Redis、MySQL的一致性？" class="headerlink" title="5.3 如何保证Caffeine、Redis、MySQL的一致性？"></a>5.3 如何保证Caffeine、Redis、MySQL的一致性？</h3><p>采用缓存双删策略：</p><ul><li>更新前先删除 Redis 和 Caffeine 缓存</li><li>执行 MySQL 更新</li><li>延迟后（默认200ms）再次删除，清除更新 MySQL 期间可能写入的旧数据</li></ul><h3 id="5-4-项目中的hotkey探测是怎么设计的？"><a href="#5-4-项目中的hotkey探测是怎么设计的？" class="headerlink" title="5.4 项目中的hotkey探测是怎么设计的？"></a>5.4 项目中的hotkey探测是怎么设计的？</h3><p>本项目中的hotkey探测以<mark>滑动窗口</mark>为核心，为每个 Redis key 维护一个<mark>整型计数数组</mark>，数组的每个元素对应滑动窗口内的一个 “时间切片”，<mark>用于存储该时间段内的页面访问次数</mark>。</p><h4 id="滑动窗口核心参数"><a href="#滑动窗口核心参数" class="headerlink" title="滑动窗口核心参数"></a>滑动窗口核心参数</h4><ul><li>滑动窗口总时长 <code>window-seconds</code> ：统计热度的时间范围（如 60 秒，即仅统计最近 60 秒的访问量）；</li><li>分段粒度 <code>segment-seconds</code> ：每个时间切片的时长（如 10 秒，即把 60 秒窗口划分为 6 个连续切片）；</li><li>分段数量 <code>segments</code> ：滑动窗口包含的时间切片总数，由公式 <code>segments = window-seconds / segment-seconds</code> 计算得出（示例中 60s&#x2F;10s&#x3D;6，即数组长度为 6）。</li></ul><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>调参建议</th></tr></thead><tbody><tr><td>window-seconds</td><td>滑动窗口总时长</td><td>60 秒</td><td>流量波动大的场景可缩短至 30 秒（快速响应热点变化）；流量稳定的场景可延长至 120 秒（更准确统计热度）</td></tr><tr><td>segment-seconds</td><td>分段粒度（轮转频率）</td><td>10 秒</td><td>确保 segments 在 6-12 之间：若 window-seconds&#x3D;60 秒，segment-seconds 可在 5-10 秒之间调整；若 window-seconds&#x3D;120 秒，segment-seconds 可在 10-20 秒之间调整</td></tr></tbody></table><h4 id="热度统计与轮转机制"><a href="#热度统计与轮转机制" class="headerlink" title="热度统计与轮转机制"></a>热度统计与轮转机制</h4><ul><li>全局指针管理：通过一个原子类型 <code>AtomInteger</code> 的变量 <code>current</code>，记录当前处于哪个时间窗口</li><li>窗口轮转机制：启用一个定时任务，每隔10s（分段粒度决定）去执行 <code>current++</code>，超出 <code>segments</code> 则归零，并将该索引对应的数组元素清空（该机制天然实现了<mark>热度自动降级</mark>）</li><li>热度计算：对数组求和，结果即为当前时间窗口内，该 Redis key 的热度</li><li>计数逻辑：每访问一个key，找到该key对应的数组 <code>arr</code>，执行 <code>arr[current]++</code></li></ul><h4 id="热度分级与TTL动态扩展"><a href="#热度分级与TTL动态扩展" class="headerlink" title="热度分级与TTL动态扩展"></a>热度分级与TTL动态扩展</h4><p>根据每个 Redis key 的热度，划分为三个等级：</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>调参建议</th></tr></thead><tbody><tr><td>level-low</td><td>低 &#x2F; 中热度分界阈值</td><td>50</td><td>参考日常 QPS：若平均单页 QPS 为 10，可设为 30；若平均单页 QPS 为 50，可设为 100</td></tr><tr><td>level-medium</td><td>中 &#x2F; 高热分界阈值</td><td>200</td><td>高热阈值建议为低热阈值的 3-5 倍，避免等级分布过于集中</td></tr><tr><td>level-high</td><td>高热上限阈值（可选）</td><td>500</td><td>用于告警（如高热页面占比超 30% 需关注），不影响分级逻辑</td></tr></tbody></table><p>每次访问某个key时，都需要reset该key的TTL，如果该key的热度较高，则需在baseTTL的基础上，再加上对应的扩展TTL，同时再加上随机抖动时间防止缓存雪崩。</p><table><thead><tr><th>参数名称</th><th>含义</th><th>默认值</th><th>调参建议</th></tr></thead><tbody><tr><td>extend-medium-seconds</td><td>中热度扩展 TTL</td><td>60 秒</td><td>初始可设为基础 TTL 的 1-2 倍，观察命中率变化；若命中率提升不明显，可适当增大</td></tr><tr><td>extend-high-seconds</td><td>高热扩展 TTL</td><td>120 秒</td><td>不超过 window-seconds 的 2 倍，避免缓存过度停留导致数据陈旧</td></tr><tr><td>jitter-percent</td><td>随机抖动比例</td><td>±5%</td><td>流量峰值高的场景可增大至 ±10%，进一步分散失效时间</td></tr></tbody></table><h3 id="5-5-项目中的single-flight有什么作用？"><a href="#5-5-项目中的single-flight有什么作用？" class="headerlink" title="5.5 项目中的single-flight有什么作用？"></a>5.5 项目中的single-flight有什么作用？</h3><p>当本地缓存Caffeine、Redis缓存都失效时，需要到MySQL数据库查询，如果大量请求直接打到MySQL性能会非常差，这就是所谓的<b>缓存击穿</b>。<mark>single-flight主要思想就是只允许一个线程获取锁，到MySQL中去取数据并回源到Caffeine和Redis，这个过程中的其他线程都需要等待</mark>；直到完成了回源重建工作，其他线程才能获取锁，这时候缓存中已有数据，无需查询MySQL就可返回。</p><h3 id="5-6-项目有对缓存雪崩、缓存击穿、缓存穿透做预防和处理吗？"><a href="#5-6-项目有对缓存雪崩、缓存击穿、缓存穿透做预防和处理吗？" class="headerlink" title="5.6 项目有对缓存雪崩、缓存击穿、缓存穿透做预防和处理吗？"></a>5.6 项目有对缓存雪崩、缓存击穿、缓存穿透做预防和处理吗？</h3><ul><li>缓存穿透：缓存空值，对“不存在内容”的查询直接写入一个短 TTL 的 NULL 值，下次请求命中后不再打数据库</li><li>缓存雪崩：设置缓存过期时间时，加上一个随机抖动值，防止大量key同时过期；同时还采用自定义的hotkey探测，动态延长热点key的TTL</li><li>缓存击穿：采用single-flight锁，热点key过期时只允许一个线程操作数据库查询数据并执行重建工作</li></ul><h3 id="5-7-为什么选用Caffeine？Caffeine解决了guava的哪些痛点？"><a href="#5-7-为什么选用Caffeine？Caffeine解决了guava的哪些痛点？" class="headerlink" title="5.7 为什么选用Caffeine？Caffeine解决了guava的哪些痛点？"></a>5.7 为什么选用Caffeine？Caffeine解决了guava的哪些痛点？</h3><h4 id="核心算法：从-LRU-到-W-TinyLFU"><a href="#核心算法：从-LRU-到-W-TinyLFU" class="headerlink" title="核心算法：从 LRU 到 W-TinyLFU"></a>核心算法：从 LRU 到 W-TinyLFU</h4><ul><li><b>Guava 的痛点（LRU）</b>： Guava 使用的是经典的 <b>LRU (Least Recently Used) </b>算法。LRU 在应对突发流量（稀疏流量）时表现很差。例如，如果有一波冷数据瞬间被大量访问，LRU 会把真正的热数据挤出缓存，导致缓存命中率骤降。</li><li><b>Caffeine 的解决（W-TinyLFU）</b>： Caffeine 使用了 <b>W-TinyLFU </b>算法。它结合了 LFU（频率）和 LRU（新鲜度）的优点：<ul><li>它用极小的内存空间（类似布隆过滤器的 Count-Min Sketch）记录数据的访问频率。</li><li>当新数据进来时，它会对比新数据和待淘汰数据的“频率”，如果新数据访问频率更高才准入。</li><li><a href="https://gemini.google.com/share/a06b9019c3ee">W-TinyLFU算法原理</a></li></ul></li></ul><h4 id="并发性能：由“段”到“条”"><a href="#并发性能：由“段”到“条”" class="headerlink" title="并发性能：由“段”到“条”"></a>并发性能：由“段”到“条”</h4><ul><li><b>Guava 的痛点（Segment）</b>： Guava 的设计思路类似于 <code>ConcurrentHashMap</code>（Java 7 之前），通过<b>分段锁 (Segment) </b>来减少竞争。但在高并发下，对同一个段的访问依然会有锁竞争。此外，Guava 在读取数据时也会执行一些清理维护操作，这进一步加剧了竞争。</li><li><b>Caffeine 的解决（无锁化&#x2F;异步）</b>： Caffeine 借鉴了数据库写前日志（WAL）的思想。<ul><li><b>读取操作</b>： 几乎是无锁的，它将读取记录放入一个环形缓冲区（Ring Buffer）中。</li><li><b>维护操作</b>： 将缓存的清理、写入、统计等繁重任务交给<b>独立的线程池（ForkJoinPool）</b>异步执行。</li></ul></li></ul><h2 id="六、AI问答系统"><a href="#六、AI问答系统" class="headerlink" title="六、AI问答系统"></a>六、AI问答系统</h2><blockquote><p>开发 RAG 知识问答系统，实现用户调用接口→索引检查→向量检索→Prompt 构造→大模型流式生成的全流程，通过合理分块、幂等删除保持单一版本、预索引减少首次提问等待时间等，显著提升用户围绕单篇知文的智能问答效率与准确性。</p></blockquote><h3 id="6-1-向量检索用的是哪个数据库？为什么选择它？索引维度是多少？召回率是多少？"><a href="#6-1-向量检索用的是哪个数据库？为什么选择它？索引维度是多少？召回率是多少？" class="headerlink" title="6.1 向量检索用的是哪个数据库？为什么选择它？索引维度是多少？召回率是多少？"></a>6.1 向量检索用的是哪个数据库？为什么选择它？索引维度是多少？召回率是多少？</h3><p>Elasticsearch</p><ul><li><p>Elasticsearch 是成熟的分布式搜索引擎，支持向量检索的同时也支持传统的全文检索</p></li><li><p>Spring AI 原生支持：Spring AI 框架提供了开箱即用的 Elasticsearch Vector Store 集成</p></li></ul><p>索引维度是1536 维，embedding使用的是阿里云 DashScope 的 text-embedding-v4 模型；回答采用deepseek模型</p><p>采用了<mark>宽召回策略</mark>来提高召回率：</p><ul><li><p>采用 <code>fetchK = max(topK × 3, 20)</code> 的宽召回策略，即召回 3 倍目标数量的候选，再进行后过滤</p></li><li><p>通过 metadata.postId 进行服务端过滤，避免跨帖子污染</p></li></ul><h3 id="6-2-“合理分块”的策略是什么？-块大小如何确定？块之间有重叠吗？如何处理跨块的语义信息？"><a href="#6-2-“合理分块”的策略是什么？-块大小如何确定？块之间有重叠吗？如何处理跨块的语义信息？" class="headerlink" title="6.2 “合理分块”的策略是什么？ 块大小如何确定？块之间有重叠吗？如何处理跨块的语义信息？"></a>6.2 “合理分块”的策略是什么？ 块大小如何确定？块之间有重叠吗？如何处理跨块的语义信息？</h3><p>先按 <b>Markdown 标题（以 # 开头的行）进行段落划分</b>，保持逻辑结构的完整性；再对每个段落进行进一步切分，<b>每个chunk &lt;&#x3D; 800字符</b>，避免单个 chunk 过长，同时块之间保留<b>100个字符的重叠</b>，确保跨块的关键信息不会被切断。</p><h3 id="6-3-“幂等删除保持单一版本”具体怎么实现？如果用户编辑了知文，旧版本的向量如何清理？如何避免检索到过期内容？"><a href="#6-3-“幂等删除保持单一版本”具体怎么实现？如果用户编辑了知文，旧版本的向量如何清理？如何避免检索到过期内容？" class="headerlink" title="6.3 “幂等删除保持单一版本”具体怎么实现？如果用户编辑了知文，旧版本的向量如何清理？如何避免检索到过期内容？"></a>6.3 “幂等删除保持单一版本”具体怎么实现？如果用户编辑了知文，旧版本的向量如何清理？如何避免检索到过期内容？</h3><p>项目采用指纹检测 + 先删后写的策略来保持单一版本：</p><ul><li>先检测文章的指纹，如果未发生变化则跳过重建</li><li>否则先删除所有旧版本向量</li><li>再重新写入新版本向量，并携带新的指纹信息</li></ul><h3 id="6-4-“预索引”是在什么时候实现的？"><a href="#6-4-“预索引”是在什么时候实现的？" class="headerlink" title="6.4 “预索引”是在什么时候实现的？"></a>6.4 “预索引”是在什么时候实现的？</h3><ul><li>发布文章成功后触发一次预索引</li><li>回答时检查文章是否发生变化，若发生变化则生成新索引</li></ul><h3 id="6-5-检索的原理是什么？"><a href="#6-5-检索的原理是什么？" class="headerlink" title="6.5 检索的原理是什么？"></a>6.5 检索的原理是什么？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 语义检索上下文：</span><br><span class="hljs-comment"> * - 先进行宽召回（fetchK ≥ 3×topK，至少 20）提高召回率</span><br><span class="hljs-comment"> * - 再按 metadata.postId 做服务端过滤，避免跨帖子污染</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> List&lt;String&gt; <span class="hljs-title function_">searchContexts</span><span class="hljs-params">(String postId, String query, <span class="hljs-type">int</span> topK)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">fetchK</span> <span class="hljs-operator">=</span> Math.max(topK * <span class="hljs-number">3</span>, <span class="hljs-number">20</span>); <span class="hljs-comment">// 宽召回：扩大初始检索集合</span><br>    List&lt;Document&gt; docs = vectorStore.similaritySearch(<br>            SearchRequest.builder().query(query).topK(fetchK).build() <span class="hljs-comment">// 语义相似检索</span><br>    );<br>    List&lt;String&gt; out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(topK);<br>    <span class="hljs-keyword">for</span> (Document d : docs) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> d.getMetadata().get(<span class="hljs-string">&quot;postId&quot;</span>);<br>        <span class="hljs-keyword">if</span> (pid != <span class="hljs-literal">null</span> &amp;&amp; postId.equals(String.valueOf(pid))) &#123; <span class="hljs-comment">// 仅保留当前帖子对应的切片</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">txt</span> <span class="hljs-operator">=</span> d.getText();<br>            <span class="hljs-keyword">if</span> (txt != <span class="hljs-literal">null</span> &amp;&amp; !txt.isEmpty()) &#123;<br>                out.add(txt);<br>                <span class="hljs-keyword">if</span> (out.size() &gt;= topK) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 只取前 topK 个上下文</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基于向量距离的-kNN-ANN-搜索"><a href="#基于向量距离的-kNN-ANN-搜索" class="headerlink" title="基于向量距离的 kNN&#x2F;ANN 搜索"></a>基于向量距离的 kNN&#x2F;ANN 搜索</h4><ol><li><b>Embedding（向量化）</b>: 系统首先会调用 Embedding Model，将输入的自然语言 <code>query</code> 转换成一个1536维向量。</li><li><b>Distance Calculation（距离计算）</b>: 拿着这个查询向量，到 <code>vectorStore</code>（向量数据库）中去计算它与库中存储的 Document 向量之间的距离（通常使用<mark>余弦相似度 Cosine 或 欧氏距离 L2</mark>）。</li><li><b>Ranking（排序）</b>: 找出距离最近（相似度最高）的 <code>fetchK</code> 个文档返回。</li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis为什么这么快</title>
    <link href="/2025/12/14/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/"/>
    <url>/2025/12/14/Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis为什么这么快？"><a href="#Redis为什么这么快？" class="headerlink" title="Redis为什么这么快？"></a>Redis为什么这么快？</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol><li>Redis基于内存的数据存储，内存的读写速度远高于硬盘</li><li>Redis提供了高效的数据结构</li><li>Redis使用了<strong>单线程模型</strong>处理命令执行，避免了多线程上下文切换开销、以及资源同步开销</li><li>Redis采用了高效的<strong>IO多路复用</strong>模型</li><li>Redis 客户端和服务端之间使用 <strong>RESP (Redis Serialization Protocol)</strong> 协议通信</li></ol><h2 id="为什么要用单线程？多线程难道不会更快吗？"><a href="#为什么要用单线程？多线程难道不会更快吗？" class="headerlink" title="为什么要用单线程？多线程难道不会更快吗？"></a>为什么要用单线程？多线程难道不会更快吗？</h2><ol><li>在Redis这个数据库相关的场景下，CPU不是瓶颈，内存和IO才是（后续为了解决网络数据IO的性能瓶颈，在网络IO操作使用了多线程），单线程已经足够胜任。redis相关的IO操作：<ul><li>磁盘IO：如持久化机制，使用后台子进程解决</li><li>网络IO：redis6.0后使用多线程处理</li></ul></li><li>单线程能够避免多线程场景下的锁机制、线程切换的开销</li><li>单线程能够简化问题</li></ol><h2 id="Redis6-0引入了多线程"><a href="#Redis6-0引入了多线程" class="headerlink" title="Redis6.0引入了多线程"></a>Redis6.0引入了多线程</h2><p>Redis 6.0 引入了<strong>多线程 I&#x2F;O</strong>。这并不是说 Redis 变成了多线程数据库，而是指：</p><ul><li><strong>命令执行</strong>（读写内存数据）依然是 <strong>单线程</strong> 的（保证原子性，无需锁）。</li><li><strong>网络数据读写</strong>（Socket Read&#x2F;Write）变成了 <strong>多线程</strong> 处理。</li><li><strong>原因：</strong> 随着网卡速度越来越快，解析网络请求包成了瓶颈。多线程 I&#x2F;O 旨在解决网络带宽处理能力的瓶颈，进一步提升吞吐量。</li></ul><h2 id="IO多路复用和多线程IO"><a href="#IO多路复用和多线程IO" class="headerlink" title="IO多路复用和多线程IO"></a>IO多路复用和多线程IO</h2><blockquote><ul><li><strong>IO 多路复用</strong> 解决的是 <strong>“同时监听大量连接”</strong> 的问题（解决连接数并发）。</li><li><strong>多线程 IO</strong> 解决的是 <strong>“快速读写网络数据” </strong>的问题（解决数据吞吐量）。</li></ul></blockquote><h3 id="它们的关系：如何协作？"><a href="#它们的关系：如何协作？" class="headerlink" title="它们的关系：如何协作？"></a>它们的关系：如何协作？</h3><p>在 Redis 6.0 之前，Redis 是“单线程”的，意味着<strong>监听连接</strong>和<strong>读写网络数据</strong>都是同一个人（主线程）。 在 Redis 6.0 之后，Redis 引入了多线程 IO，它们开始分工合作。</p><ol><li><strong>监听 (IO 多路复用)</strong>: 主线程通过 <code>epoll</code> 监听所有连接。发现连接 A 有数据发过来了！</li><li><strong>读取 (多线程 IO):</strong> 主线程把连接 A 分配给<strong>IO 线程组</strong>。IO 线程并行地把数据从 Socket 读出来，并解析好命令。<ul><li><em>(注：此时主线程会等待 IO 线程组全部干完活)</em></li></ul></li><li><strong>执行 (主线程 - 依然单线程):</strong> 数据都读好、解析好了。<strong>主线程</strong>拿过来，执行 <code>SET key value</code>。<ul><li><em>(注：执行命令依然是排队单线程执行，不需要加锁，保证原子性)</em></li></ul></li><li><strong>发送 (多线程 IO):</strong> 执行完了，要返回 “OK”。主线程把结果打包好，再次分配给<strong>IO 线程组</strong>，让它们并行地把数据写回 Socket 发送给客户端。</li></ol><table><thead><tr><th><strong>组件</strong></th><th><strong>线程归属</strong></th><th><strong>职责</strong></th></tr></thead><tbody><tr><td><strong>IO 多路复用 (epoll_wait)</strong></td><td><strong>主线程</strong></td><td>负责“站岗放哨”。它监听所有连接，一旦发现有数据来了（可读）或者可以发数据了（可写），就通知下一步。</td></tr><tr><td><strong>IO 线程 (Worker Threads)</strong></td><td><strong>辅助线程组</strong></td><td>负责“搬运重活”。它们只负责从 Socket <strong>读取&#x2F;解析</strong>数据，或者把响应数据 <strong>写回</strong> Socket。它们<strong>不</strong>负责监听。</td></tr><tr><td><strong>命令执行 (Command Exec)</strong></td><td><strong>主线程</strong></td><td>负责“核心业务”。执行 <code>GET</code>, <code>SET</code> 等逻辑，修改内存数据。</td></tr></tbody></table><h3 id="为什么要有这种变化？"><a href="#为什么要有这种变化？" class="headerlink" title="为什么要有这种变化？"></a>为什么要有这种变化？</h3><p>您可能会问：<em>“以前没有多线程 IO，Redis 不也很快吗？”</em></p><p>是的，但瓶颈变了。</p><ul><li><strong>早期</strong>： 瓶颈是<strong>内存</strong>和<strong>CPU</strong>。单线程足以应付网络流量，因为以前是千兆网卡。</li><li><strong>现在</strong>： 瓶颈变成了<strong>网络带宽</strong>。现在的服务器动辄万兆网卡，每秒钟能进来的数据包太多了。<ul><li>如果还是单线程，主线程光是把这么巨大的数据从 Socket 读到内存里，CPU 就已经累趴下了，根本没时间去执行命令。</li><li>所以，引入<strong>多线程 IO</strong> 就是为了把“读写数据”这个消耗 CPU 的体力活分摊出去，让主线程专注于“执行命令”这个核心脑力活。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVCC导致索引覆盖失效场景</title>
    <link href="/2025/12/12/MVCC%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/"/>
    <url>/2025/12/12/MVCC%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="MVCC导致索引覆盖失效场景"><a href="#MVCC导致索引覆盖失效场景" class="headerlink" title="MVCC导致索引覆盖失效场景"></a>MVCC导致索引覆盖失效场景</h1><p><strong>MVCC（多版本并发控制）确实会导致索引覆盖失效，从而触发回表。</strong></p><p>很多开发者认为只要 SQL 的字段都在联合索引里，就一定能走“索引覆盖（Using index）”，但在高并发写场景下，这并不绝对。</p><p>其根本原因在于 MySQL InnoDB 存储引擎的<strong>二级索引（Secondary Index）结构设计</strong>。</p><hr><h2 id="核心原因：二级索引“不完整”"><a href="#核心原因：二级索引“不完整”" class="headerlink" title="核心原因：二级索引“不完整”"></a>核心原因：二级索引“不完整”</h2><p>在 InnoDB 中，MVCC 的实现依赖于数据行中隐藏的两个字段：</p><ol><li><strong><code>DB_TRX_ID</code></strong>：最近修改该行数据的事务 ID。</li><li><strong><code>DB_ROLL_PTR</code></strong>：回滚指针，指向 Undo Log。</li></ol><p>关键点来了：</p><p><mark>这两列隐藏字段只存在于聚簇索引（主键索引）的叶子节点中。普通的二级索引（非主键索引）是不存储 DB_TRX_ID 的</mark></p><p>这意味着：<strong>当你扫描二级索引时，MySQL 无法仅凭二级索引中的数据判断这条记录“对于当前事务是否可见”。</strong></p><hr><h2 id="失效的具体过程"><a href="#失效的具体过程" class="headerlink" title="失效的具体过程"></a>失效的具体过程</h2><p>假设你有一个表 users，索引是 idx_name (name)。</p><p>SQL：SELECT name FROM users WHERE name &#x3D; ‘Alice’;（理论上应该走索引覆盖）</p><h3 id="1-正常情况（无并发修改）"><a href="#1-正常情况（无并发修改）" class="headerlink" title="1. 正常情况（无并发修改）"></a>1. 正常情况（无并发修改）</h3><p>InnoDB 在二级索引页（Page）头部维护了一个 <code>PAGE_MAX_TRX_ID</code> 属性，记录了修改过该页面的最大事务 ID。</p><ul><li>如果 <strong><code>PAGE_MAX_TRX_ID</code> &lt; 当前事务的 Read View 最小活跃事务 ID <code>min_trx_id</code></strong>。</li><li>说明该页面的所有数据都是“旧”的，肯定对当前事务可见。</li><li><strong>结果：</strong> 放心使用索引覆盖，<strong>不需要回表</strong>。</li></ul><h3 id="2-并发修改情况（MVCC-导致失效）"><a href="#2-并发修改情况（MVCC-导致失效）" class="headerlink" title="2. 并发修改情况（MVCC 导致失效）"></a>2. 并发修改情况（MVCC 导致失效）</h3><p>如果在你查询的同时，有其他事务（哪怕是刚提交的）修改了 <code>name=&#39;Alice&#39;</code> 所在的二级索引页（比如插入了 ‘Bob’，但他俩在一个 Page 上）：</p><ul><li>该 Page 的 <code>PAGE_MAX_TRX_ID</code> 变大，变得“太新了”（大于当前事务 Read View）。</li><li>此时，MySQL 扫描到 ‘Alice’ 这条索引记录时，心里会发慌：“这页被新事务动过，虽然 ‘Alice’ 看着没变，但我没法确定这条索引记录是不是最新版本，或者是不是被删了。”</li><li><strong>结果：</strong> 哪怕你需要的数据 <code>name</code> 就在手边，InnoDB 也不敢直接返回。它必须拿着主键 ID，<strong>回表</strong>到聚簇索引中，找到包含 <code>DB_TRX_ID</code> 的完整行，做一次 MVCC 可见性判断。</li><li><strong>结论：索引覆盖失效。</strong></li></ul><hr><h2 id="这种失效的特点"><a href="#这种失效的特点" class="headerlink" title="这种失效的特点"></a>这种失效的特点</h2><ol><li><strong>隐蔽性强：</strong> <code>EXPLAIN</code> 有时可能还会显示 <code>Using index</code>（因为执行计划是预测的），但实际执行时产生了大量的随机 I&#x2F;O 回表。</li><li><strong>瞬时性：</strong> 一旦那些活跃的事务提交，且相关的数据页不再频繁变动，后续的查询又会恢复成正常的索引覆盖。</li><li><strong>性能抖动：</strong> 这解释了为什么在数据更新频繁的业务高峰期，某些原本极快的“纯读”查询（Top SQL）耗时会偶尔飙升。</li></ol><h2 id="对比：PostgreSQL-的解决方案"><a href="#对比：PostgreSQL-的解决方案" class="headerlink" title="对比：PostgreSQL 的解决方案"></a>对比：PostgreSQL 的解决方案</h2><p>为了解决这个问题，PostgreSQL 引入了 Visibility Map（可见性映射表）。</p><p>它用一个位图标记哪些 Page 是“全可见”的。如果位图显示该页所有元组都可见，就直接走 Index Only Scan；否则才回表查 MVCC 版本。MySQL 目前主要依赖 PAGE_MAX_TRX_ID 做类似的判断，但粒度较粗（Page 级）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>MVCC 机制决定了二级索引并不总是“可信”的。</strong> 当数据页处于“脏”或“由于并发写入导致版本过新”的状态时，为了保证数据一致性（Repeatable Read），MySQL 必须放弃索引覆盖，强制回表“验明正身”。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL日志</title>
    <link href="/2025/12/11/MySQL%E6%97%A5%E5%BF%97/"/>
    <url>/2025/12/11/MySQL%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL日志"><a href="#MySQL日志" class="headerlink" title="MySQL日志"></a>MySQL日志</h1><h2 id="1-undo-log"><a href="#1-undo-log" class="headerlink" title="1. undo log"></a>1. undo log</h2><h3 id="1-1-undo-log的实现"><a href="#1-1-undo-log的实现" class="headerlink" title="1.1 undo log的实现"></a>1.1 undo log的实现</h3><p>在事务提交之前，每当InnoDB引擎对一条记录进行增、删、改操作时，要把操作之前的信息记录到undo log中。如果事务还没提交就发生了崩溃，那么就可以通过undo log回滚到之前的数据。</p><p>一条记录的每一次更新操作产生的undo log格式都有一个<code>roll pointer指针</code>和<code>trx_id事务id</code>：</p><ul><li><p>通过<code>trx_id</code>可以知道是那个事务修改的</p></li><li><p>通过<code>roll pointer</code>可以将这些记录串成一条链，称为版本链：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202512111914764.png" alt="版本链"></p></li></ul><h3 id="1-2-undo-log的作用"><a href="#1-2-undo-log的作用" class="headerlink" title="1.2 undo log的作用"></a>1.2 undo log的作用</h3><ol><li>undo log可以和ReadView配合，实现MVCC，实现了<mark>事务的隔离性I</mark></li><li>实现事务的回滚，保障<mark>事务原子性A</mark></li></ol><h2 id="2-Buffer-Pool"><a href="#2-Buffer-Pool" class="headerlink" title="2. Buffer Pool"></a>2. Buffer Pool</h2><p>如果每次取数据、写数据都直接对硬盘进行操作，那么时间开销会很大。最好的方法当然是先写到一个缓存中，后面再由缓存慢慢写到磁盘中去，这个缓存就是Buffer Pool</p><p>Buffer Pool将数据划分为若干个 页 ，以页作为磁盘和内存的交互单位，一个页默认大小为16KB。当某一页中有数据发生了更改，那么这一页就会被标记为脏页，后续会将脏页回写到磁盘中。</p><p>由于undo log也要回写到磁盘中去，所以Buffer Pool中也有对应的Undo页，undo log发生修改时，先写到Buffer Pool中的Undo页中，后续再回写到磁盘中。</p><h2 id="3-redo-log"><a href="#3-redo-log" class="headerlink" title="3. redo log"></a>3. redo log</h2><p>Buffer Pool确实提升了读写效率，但是如果机器断电重启，此时内存中尚未写回磁盘中的脏页就丢失了，redo log就可以用来解决这个问题。</p><p>当有一条记录需要更新时，先更新BufferPool中对应的页，并标记为脏页，然后将本次对这个页的修改以redo log的形式保留下来，这时候更新就算是完成了。后续会在适当时候，由后台线程将缓存在BufferPool中的脏页刷新到磁盘去。这就是<strong>WAL（Write-Ahead Logging）技术</strong></p><p>也就是说，<mark>redo log记录的是：仍在BufferPool，尚未被刷入磁盘中的脏数据</mark>。（区别于undo log：记录事务提交前的数据）所以undo log对应的Undo页面也会记录到redo log中。</p><h3 id="3-1-redo-log要写入到磁盘，数据也要写入磁盘，为什么需要多此一举"><a href="#3-1-redo-log要写入到磁盘，数据也要写入磁盘，为什么需要多此一举" class="headerlink" title="3.1 redo log要写入到磁盘，数据也要写入磁盘，为什么需要多此一举"></a>3.1 redo log要写入到磁盘，数据也要写入磁盘，为什么需要多此一举</h3><p>因为redo log属于是<strong>顺序写</strong>，而数据写入磁盘是<strong>随机写</strong>，相比之下肯定是顺序写的效率更高。</p><p>所以redo log的作用：</p><ol><li>MySQL崩溃重启后已提交的记录不丢失（Buffer Pool中尚未刷入磁盘的脏页），实现<mark>事务持久性D</mark></li><li>将数据的随机写变为日志的顺序写，提升了效率</li></ol><p>redo log文件采用<mark>循环写</mark>的操作，分成两个文件ib_logfile0和ib_logfile1：</p><ul><li>write pos ~ checkpoint之间的部分：空闲的，用来记录新的更新操作</li><li>checkpoint ～ write pos之间的部分：待落盘的脏页数据</li></ul><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202512111914766.png" alt="img" style="zoom: 33%;" /><p>如果write pos追上了checkpoint，就意味redo log文件满了，此时MySQL不能再执行新的更新操作，会被阻塞。会停下来将脏页数据刷入磁盘直到redo log有空闲空间为止（对并发大的系统，redo log的大小很重要）</p><h2 id="4-bin-log"><a href="#4-bin-log" class="headerlink" title="4. bin log"></a>4. bin log</h2><p>相较于redo log记录的是脏页数据，bin log记录的则是全量数据（默认记录的是每一条修改数据的SQL）</p><p>binlog有3种格式类型，分别是STATEMENT（默认格式）、ROW、MIXED，区别如下：</p><ul><li>STATEMENT：<strong>每一条修改数据的SQL</strong>都会被记录到binlog中（相当于记录了逻辑操作，所以针对这种格式，binlog可以称为逻辑日志），主从复制中slave端再根据SQL语句重现。但STATEMENT有动态函数的问题，比如你用了uuid或者now这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li><li>ROW：记录行数据<strong>最终被修改成什么样</strong>了（这种格式的日志，就不能称为逻辑日志了），不会出现STATEMENT下动态函数的问题。但ROW的缺点是每行数据的变化结果都会被记录，比如执行批量update语句，更新多少行数据就会产生多少条记录，使binlog文件过大，而在STATEMENT格式下只会记录一个update语句而已；</li><li>MIXED：包含了STATEMENT和ROW模式，它会根据不同的情况自动使用ROW模式和STATEMENT模式；</li></ul><h3 id="4-1-bin-log和redo-log的区别"><a href="#4-1-bin-log和redo-log的区别" class="headerlink" title="4.1 bin log和redo log的区别"></a>4.1 bin log和redo log的区别</h3><ol><li>binlog属于Server层，redolog属于Innodb引擎</li><li>文件格式不同</li><li>写入方式：binlog属于追加写，redolog属于循环写</li><li>用途：binlog用于主从复制、数据库被删除时恢复，redolog用于故障恢复</li></ol><h3 id="4-2-bin-log主从复制"><a href="#4-2-bin-log主从复制" class="headerlink" title="4.2 bin log主从复制"></a>4.2 bin log主从复制</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202512111914767.png" alt="image-20251211190300250"></p><p>通过返回响应的区别，MySQL主从复制分为了如下三种模型：</p><ol><li>同步复制：主库要等所有从库成功响应</li><li>异步复制：主库不等</li><li>半同步复制：只要有一个从库成功响应就行</li></ol><h2 id="5-两阶段提交"><a href="#5-两阶段提交" class="headerlink" title="5. 两阶段提交"></a>5. 两阶段提交</h2><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成<mark>两份日志之间的逻辑不一致</mark>。</p><p>举个例子，假设 id &#x3D; 1 这行数据的字段 name 的值原本是 ‘jay’，然后执行 UPDATE t_user SET name &#x3D; ‘xiaolin’ WHERE id &#x3D; 1；如果在持久化 redo log 和 binlog 两个日志的过程中，出现了半成功状态，那么就有两种情况：</p><ul><li>如果在将 redo log 刷入到磁盘之后，MySQL 突然宕机了，而 binlog 还没有来得及写入。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id &#x3D; 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；</li><li>如果在将 binlog 刷入到磁盘之后，MySQL 突然宕机了，而 redo log 还没有来得及写入。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id &#x3D; 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；</li></ul><p>所以两阶段提交就是为了解决redo log和bin log不一致的问题。</p><h3 id="5-1-两阶段提交流程"><a href="#5-1-两阶段提交流程" class="headerlink" title="5.1 两阶段提交流程"></a>5.1 两阶段提交流程</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202512111914768.png" alt="两阶段提交"></p><p>从图中可看出，事务的提交过程有两个阶段，就是将redo log的写入拆成了两个步骤：prepare和commit，中间再穿插写入binlog，具体如下：</p><ul><li>prepare阶段：将XID（内部XA事务的ID）写入到redo log，同时将redo log对应的事务状态设置为prepare，然后将redo log持久化到磁盘（innodb_flush_log_at_trx_commit &#x3D; 1的作用）；</li><li>commit阶段：把XID写入到binlog，然后将binlog持久化到磁盘（sync_binlog &#x3D; 1的作用），接着调用引擎的提交事务接口，将redo log状态设置为commit，此时该状态（commit状态）并不需要持久化到磁盘，只需要write到文件系统的page cache中就够了，因为只要binlog写磁盘成功，就算redo log的状态还是prepare也没有关系，一样会被认为事务已经执行成功；</li></ul><h3 id="5-2-两阶段提交如何解决异常"><a href="#5-2-两阶段提交如何解决异常" class="headerlink" title="5.2 两阶段提交如何解决异常"></a>5.2 两阶段提交如何解决异常</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202512111914769.png" alt="时刻 A 与时刻 B"></p><p>不管是时刻 A（redo log 已经写入磁盘，binlog 还没写入磁盘），还是时刻 B（redo log 和 binlog 都已经写入磁盘，还没写入 commit 标识）崩溃，<mark>此时的 redo log 都处于 prepare 状态</mark>。</p><p>在 MySQL 重启后会按顺序扫描 redo log 文件，碰到处于 <strong>prepare</strong> 状态的 redo log，就拿着 redo log 中的 XID 去 binlog 查看是否存在此 XID：</p><ul><li>如果<mark> binlog 中没有当前内部 XA 事务的 XID，说明 redolog 完成刷盘，但是 binlog 还没有刷盘，则<strong>回滚</strong>事务</mark>。对应时刻 A 崩溃恢复的情况。</li><li>如果<mark> binlog 中有当前内部 XA 事务的 XID，说明 redolog 和 binlog 都已经完成了刷盘，则<strong>提交</strong>事务</mark>。对应时刻 B 崩溃恢复的情况。</li></ul><p>可以看到，对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID，如果有就提交事务，如果没有就回滚事务。这样就可以保证 redo log 和 binlog 这两份日志的一致性了。</p><p>所以说，两阶段提交是以 binlog 写成功为事务提交成功的标识，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL是怎么加行级锁的？</title>
    <link href="/2025/12/11/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%EF%BC%9F/"/>
    <url>/2025/12/11/MySQL%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL是怎么加行级锁的？"><a href="#MySQL是怎么加行级锁的？" class="headerlink" title="MySQL是怎么加行级锁的？"></a>MySQL是怎么加行级锁的？</h1><p>假设有一张表 <code>user</code>，只有三个字段 <code>id</code> (主键索引) 、 <code>age</code>(非唯一索引)和<code>name</code>(无索引)。 表中现有数据：</p><ul><li><code>id: 10, age: 10_v1, name: aaa</code></li><li><code>id: 11, age: 10_v2, name: bbb</code></li><li><code>id: 20, age: 20, name: ccc</code></li><li><code>id: 30, age: 30, name: ddd</code></li></ul><h2 id="1-唯一索引等值查询"><a href="#1-唯一索引等值查询" class="headerlink" title="1. 唯一索引等值查询"></a>1. 唯一索引等值查询</h2><h3 id="1-1-等值查询存在"><a href="#1-1-等值查询存在" class="headerlink" title="1.1 等值查询存在"></a>1.1 等值查询存在</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><p>先给<code>(-∞, 10]</code>加上next-key锁，然后退化成<code>id = 10</code>处的记录锁</p><h3 id="1-2-等值查询不存在"><a href="#1-2-等值查询不存在" class="headerlink" title="1.2 等值查询不存在"></a>1.2 等值查询不存在</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">15</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><p>先给<code>(11, 20]</code>加上next-key锁，然后退化成<code>(11, 20)</code>的间隙锁</p><h2 id="2-唯一索引范围查询"><a href="#2-唯一索引范围查询" class="headerlink" title="2. 唯一索引范围查询"></a>2. 唯一索引范围查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;=</span><span class="hljs-number">20</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">25</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><ul><li><code>id = 20</code>的记录锁：从<code>(11, 20]</code>的next-key锁退化而来</li><li><code>(20, 30)</code>的间隙锁：从<code>(20, 30]</code>的next-key锁退化而来</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">&gt;</span> <span class="hljs-number">15</span> <span class="hljs-keyword">and</span> id <span class="hljs-operator">&lt;=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><ul><li><code>(20, 30]</code>的next-key锁</li><li><code>(11, 20]</code>的next-key锁</li></ul><h2 id="3-非唯一索引等值查询"><a href="#3-非唯一索引等值查询" class="headerlink" title="3. 非唯一索引等值查询"></a>3. 非唯一索引等值查询</h2><h3 id="3-1-等值查询存在"><a href="#3-1-等值查询存在" class="headerlink" title="3.1 等值查询存在"></a>3.1 等值查询存在</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><ul><li><code>(-∞, 10_v1]</code>的next_key锁</li><li><code>(10_v1, 10_v2]</code>的next_key锁</li><li><code>(10_v2, 20)</code>的间隙锁</li><li><code>id = 10</code>和<code>id = 11</code>的记录锁</li></ul><blockquote><p>[!CAUTION]</p><p>由于这里是select *，所以会<mark>触发回表，去查找主键索引的B+树</mark>，也就会给<code>id = 10</code>和<code>id = 11</code>这两条记录加上记录锁</p><p>如果是select id且用的不是<code>for update</code>而是<code>lock in share mode</code>，会出现<mark>索引覆盖</mark>，不会触发回表，也就不会在主键上加锁</p></blockquote><h3 id="3-2-等值查询不存在"><a href="#3-2-等值查询不存在" class="headerlink" title="3.2 等值查询不存在"></a>3.2 等值查询不存在</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">=</span> <span class="hljs-number">15</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><ul><li><code>(10_v2, 20)</code>的间隙锁</li></ul><h2 id="4-非唯一索引范围查询"><a href="#4-非唯一索引范围查询" class="headerlink" title="4. 非唯一索引范围查询"></a>4. 非唯一索引范围查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><ul><li><p><code>(-∞, 10_v1]</code>的next-key锁</p><blockquote><p>[!CAUTION]</p><p>这里貌似很反常识：为什么比10要小的区间也要锁起来呢？这是因为age不是唯一索引，如果不锁这个区间，那么就很有可能<mark>出现一条：id &#x3D; 9(&lt; 10), age &#x3D; 10_v0的记录插进来</mark>，这时候再执行这条语句就会出现三条记录，导致<strong>幻读</strong></p></blockquote></li><li><p><code>(10_v1, 10_v2]</code>的next-key锁</p></li><li><p><code>(10_v2, 20]</code>的next-key锁</p></li><li><p><code>(20, 30]</code>的next-key锁</p></li><li><p><code>(30, +∞]</code>的next-key锁</p></li><li><p><code>id = 10, 11, 20, 30</code>的记录锁<mark>（虽然发生了索引覆盖，但是是for update，系统会认为你接下来要更新数据，因此会顺便给主键上满足条件的行加锁）</mark></p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;</span> <span class="hljs-number">15</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><ul><li><p><code>(-∞, 10_v1]</code>的next-key锁</p></li><li><p><code>(10_v1, 10_v2]</code>的next-key锁</p></li><li><p><code>(10_v2, 20]</code>的next-key锁</p></li><li><p><code>id = 10, 11</code>的记录锁</p><blockquote><p>[!CAUTION]</p><p>注意，这里并没有退化成<code>(10_v2, 20)</code>的间隙锁，而是依然是<code>(10_v2, 20]</code>的next-key锁；所以如果此时有另一个事务想要执行：<code>insert into user values (16, 16, eee)</code>也会被阻塞，这似乎也很反直觉……</p><h3 id="为什么不像等值查询那样退化？"><a href="#为什么不像等值查询那样退化？" class="headerlink" title="为什么不像等值查询那样退化？"></a>为什么不像等值查询那样退化？</h3><p>你可能会问：<em>“引擎明明已经判断出 20 &gt;&#x3D;15 了，为什么不把 20上的锁释放掉，只留间隙锁？”</em></p><p>这是因为 MySQL 在代码实现上，<strong>“等值查询”和“范围查询”</strong>走的是不同的加锁逻辑分支：</p><ol><li><strong>等值查询 (Equality Search)</strong>：<ul><li>MySQL 专门做了一个优化：如果查找的是 <code>age = 20</code>，当扫描到 <code>age = 30</code> 时，发现值不匹配，判定这是<strong>边界</strong>，且搜索类型是<strong>等值</strong>，于是将 Next-Key Lock 专门退化为 Gap Lock。</li></ul></li><li><strong>范围查询 (Range Search)</strong>：<ul><li>对于 <code>age &gt;= 10 AND age &lt; 15</code>，MySQL 将其视为一个范围扫描。</li><li>在非唯一索引上，MySQL 的设计原则是<strong>“宁可多锁，不可漏锁”</strong>。当扫描到 <code>age = 20</code> 时，虽然它不满足 <code>&lt; 15</code>，但它作为扫描停止的边界，InnoDB 并没有为“非唯一索引的范围查询”做类似于等值查询的那种“退化优化”。<ul><li>我的猜想：可能是因为在单边的范围查询如：上面的<code>age &gt;= 10</code>的情况下，锁全都是next-key锁，那么在这种双边的范围查询就不特殊处理了，和单边范围查询保持一致，也是全用next-key锁，处理起来更简便一些</li></ul></li></ul></li></ol></blockquote></li></ul><p>因此要记住：<mark>非唯一索引和主键索引的范围查询的加锁有所不同，不同之处在于非唯一索引范围查询，next-key lock 不会退化为间隙锁和记录锁。</mark></p><h2 id="5-没有加索引的查询"><a href="#5-没有加索引的查询" class="headerlink" title="5. 没有加索引的查询"></a>5. 没有加索引的查询</h2><p>如果<code>select for update</code>查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加上next-key锁（主键索引，因为扫描的是主键的B+树），这样就相当于锁住全表。</p><p>同理<code>delete, update</code>语句查询条件不加索引也会导致锁全表的情况。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单例模式的double check与volatile</title>
    <link href="/2025/12/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84double-check%E4%B8%8Evolatile/"/>
    <url>/2025/12/08/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84double-check%E4%B8%8Evolatile/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="为什么需要使用单例模式"><a href="#为什么需要使用单例模式" class="headerlink" title="为什么需要使用单例模式"></a>为什么需要使用单例模式</h2><p><strong>节省内存、节省计算。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton singleton;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;<br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单例模式为什么需要double-check"><a href="#单例模式为什么需要double-check" class="headerlink" title="单例模式为什么需要double check"></a>单例模式为什么需要double check</h2><p>我们先来看第二次的 check，这时你需要考虑这样一种情况，有两个线程同时调用 getInstance 方法，由于 singleton 是空的 ，因此两个线程都可以通过第一重的 if 判断；然后由于锁机制的存在，会有一个线程先进入同步语句，并进入第二重 if 判断 ，而另外的一个线程就会在外面等待。</p><p>不过，当第一个线程执行完 new Singleton() 语句后，就会退出 synchronized 保护的区域，这时如果没有第二重 if (singleton &#x3D;&#x3D; null) 判断的话，那么<strong>第二个线程也会创建一个实例，此时就破坏了单例</strong>，这肯定是不行的。</p><p>而对于第一个 check 而言，<strong>如果去掉它，那么所有线程都会串行执行，效率低下</strong>，所以两个 check 都是需要保留的。</p><h2 id="单例模式为什么需要volatile"><a href="#单例模式为什么需要volatile" class="headerlink" title="单例模式为什么需要volatile"></a>单例模式为什么需要volatile</h2><p>那**为什么要用 volatile 呢？**主要就在于 singleton &#x3D; new Singleton() ，它并非是一个原子操作，事实上，在 JVM 中上述语句至少做了以下这 3 件事：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202512081119677.png" alt="Cgq2xl6BpWCAMBaVAACFIdffjfM852"></p><p>这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。</p><p>如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，<strong>所以使用这个实例的时候</strong>会报错，详细流程如下图所示：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202512081120378.png" alt="Cgq2xl6BpWCAB6QQAAEKacFd0CE542"></p><p>于是，使用volatile的意义在于：<mark>防止指令重排序，避免别的线程拿到未完成初始化的对象，从而保证了线程安全</mark></p><h2 id="静态内部类实现单例模式"><a href="#静态内部类实现单例模式" class="headerlink" title="静态内部类实现单例模式"></a>静态内部类实现单例模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">final</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getInstance()</code> 调用的是 <code>SingletonHolder.INSTANCE</code> ，跟上面DCL方法不同的是， <code>getInstance()</code> 方法并没有多次去 new 对象，故不管多少个线程去调用 <code>getInstance()</code> ，取的都是同一个 <code>INSTANCE</code> 对象，而不用去重新创建</p><blockquote><p>1、 虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 在 多线程环境中被正确地加锁、同步 。<br>2、 <mark>如果多个线程同时去初始化一个类，那么，只会有一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> ，其他线程都需要阻塞等待</mark>。<br>3、 需要注意的是，<b>第一个活动线程</b> 执行 <code>&lt;clinit&gt;()</code> 后，其他线程被唤醒之后，不会再次进入 <code>&lt;clinit&gt;()</code> 。同一个类加载器下，一个类型只会初始化一次。在实际应用中，这种阻塞往往是很隐蔽的。</p></blockquote><p>因此，可以看出 <code>INSTANCE</code> 在创建过程中是线程安全的，所以说 <b>静态内部类</b> 形式的单例 可保证线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AQS</title>
    <link href="/2025/05/24/AQS/"/>
    <url>/2025/05/24/AQS/</url>
    
    <content type="html"><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><blockquote><p>引用：JavaGuide</p></blockquote><h2 id="1-什么是AQS？"><a href="#1-什么是AQS？" class="headerlink" title="1. 什么是AQS？"></a>1. 什么是AQS？</h2><p>AQS，全称AbstractQueuedSynchronizer，是Java中的一个抽象类，是Java并发包中提供的构建锁和同步器的基本框架。像<code>ReentrantLock</code>，<code>CountDownLatch</code>，<code>Semaphore</code>等类都使用到AQS完成线程间同步</p><h2 id="2-CLH锁"><a href="#2-CLH锁" class="headerlink" title="2. CLH锁"></a>2. CLH锁</h2><p>AQS是基于<strong>CLH锁</strong>进一步优化实现的，那什么是CLH锁呢？</p><p>CLH 锁对自旋锁进行了改进，是基于<strong>单链表</strong>的<strong>自旋锁</strong>。在多线程场景下，会将请求获取锁的线程组织成一个单向队列，每个等待的线程会<strong>通过自旋访问前一个线程节点的状态</strong>，前一个节点释放锁之后，当前节点才可以获取锁。CLH 锁的队列结构如下图所示。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505241523493.png" alt="CLH 锁的队列结构"></p><h2 id="3-AQS的核心思想"><a href="#3-AQS的核心思想" class="headerlink" title="3. AQS的核心思想"></a>3. AQS的核心思想</h2><p>首先是它有一个<code>volatile</code>修饰的int型变量<strong>state</strong>，在ReentrantLock里它表示锁被获取的次数，在Semaphore里它表示剩余的许可数量。一般我们通过cas操作来修改这个变量，cas成功表示获取锁成功，否则失败。</p><p>同时，AQS维护了一个基于CLH锁优化实现的FIFO等待队列，以下称之为<strong>CLH变体队列</strong>，CLH变体队列与原队列的区别如下：</p><ul><li>由 <strong>自旋</strong> 优化为 <strong>自旋 + 阻塞</strong> ：自旋操作的性能很高，但大量的自旋操作比较占用 CPU 资源，因此在 CLH 变体队列中会先通过自旋尝试获取锁，如果失败再进行阻塞等待</li><li>由 <strong>单向队列</strong> 优化为 <strong>双向队列</strong> ：在 CLH 变体队列中，会对等待的线程进行阻塞操作，当队列前边的线程释放锁之后，需要<strong>对后边的线程进行唤醒</strong>，因此增加了 <code>next</code> 指针，成为了双向队列</li></ul><p>AQS 将每条请求共享资源的线程封装成一个 CLH 变体队列的一个结点（Node）来实现锁的分配。当线程获取锁失败时，就会把线程引用包装成一个结点放到队列里去。当持有锁的线程释放资源时，会调用release方法，在释放锁之后会把队列里的第一个结点唤醒，被唤醒的线程会去尝试获取锁。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505241523494.png" alt="CLH 变体队列结构"></p><p>AQS 定义两种资源共享方式：<code>Exclusive</code>（<strong>独占</strong>，只有一个线程能获得锁，如<code>ReentrantLock</code>）和<code>Share</code>（<strong>共享</strong>，允许多个线程同时获得锁资源，如<code>Semaphore</code>&#x2F;<code>CountDownLatch</code>）。</p><h2 id="4-Node节点WaitStatus状态"><a href="#4-Node节点WaitStatus状态" class="headerlink" title="4. Node节点WaitStatus状态"></a>4. Node节点WaitStatus状态</h2><p>AQS 中的 <code>waitStatus</code> 状态类似于 <strong>状态机</strong> ，通过不同状态来表明 Node 节点的不同含义，并且根据不同操作，来控制状态之间的流转。</p><table><thead><tr><th>Node 节点状态</th><th>值</th><th>含义</th></tr></thead><tbody><tr><td><code>CANCELLED</code></td><td>1</td><td>表示线程已经取消获取锁。线程在等待获取资源时被中断、等待资源超时会更新为该状态。（排队时突然不需要锁了）</td></tr><tr><td><code>SIGNAL</code></td><td>-1</td><td>表示后继节点需要当前节点唤醒。在当前线程节点释放锁之后，需要<strong>对后继节点进行唤醒</strong>。</td></tr><tr><td><code>CONDITION</code></td><td>-2</td><td>表示节点在等待 Condition。当其他线程调用了 Condition 的 <code>signal()</code> 方法后，节点会从等待队列转移到同步队列中等待获取资源。</td></tr><tr><td><code>PROPAGATE</code></td><td>-3</td><td>用于共享模式。在共享模式下，可能会出现线程在队列中无法被唤醒的情况，因此引入了 <code>PROPAGATE</code> 状态来解决这个问题。</td></tr><tr><td></td><td>0</td><td>加入队列的新节点的初始状态。</td></tr></tbody></table><h2 id="4-以ReentrantLock为例图解AQS工作流程（资源独占）"><a href="#4-以ReentrantLock为例图解AQS工作流程（资源独占）" class="headerlink" title="4. 以ReentrantLock为例图解AQS工作流程（资源独占）"></a>4. 以ReentrantLock为例图解AQS工作流程（资源独占）</h2><p>假设总共有 3 个线程尝试获取锁，线程分别为 <code>T1</code> 、 <code>T2</code> 和 <code>T3</code> 。</p><p>此时，假设线程 <code>T1</code> 先获取到锁，线程 <code>T2</code> 排队等待获取锁。在线程 <code>T2</code> 进入队列之前，需要<mark>对 AQS 内部队列进行初始化</mark>。<code>head</code> 节点（虚拟头节点）在初始化后状态为 <code>0</code> 。AQS 内部初始化后的队列如下图：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505241523495.png" alt="img"></p><p>此时，线程 <code>T2</code> 尝试获取锁。由于线程 <code>T1</code> 持有锁，因此线程 <code>T2</code> 会进入队列中等待获取锁。同时会<mark>将前继节点（ <code>head</code> 节点）的状态由 <code>0</code> 更新为 <code>SIGNAL</code> ，表示需要对 <code>head</code> 节点的后继节点进行唤醒</mark>。此时，AQS 内部队列如下图所示：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505241523496.png" alt="img"></p><p>此时，线程 <code>T3</code> 尝试获取锁。由于线程 <code>T1</code> 持有锁，因此线程 <code>T3</code> 会进入队列中等待获取锁。同时会将前继节点（线程 <code>T2</code> 节点）的状态由 <code>0</code> 更新为 <code>SIGNAL</code> ，表示线程 <code>T2</code> 节点需要对后继节点进行唤醒。此时，AQS 内部队列如下图所示：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505241523497.png" alt="img"></p><p>此时，假设线程 <code>T1</code> 释放锁，会唤醒后继节点 <code>T2</code> 。线程 <code>T2</code> 被唤醒后获取到锁，并且会从等待队列中退出。</p><p>这里<mark>线程 <code>T2</code> 节点退出等待队列并不是直接从队列移除，而是令线程 <code>T2</code> 节点成为新的 <code>head</code> 节点，以此来退出资源获取的等待</mark>。此时 AQS 内部队列如下所示：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505241523498.png" alt="img"></p><p>此时，假设线程 <code>T2</code> 释放锁，会唤醒后继节点 <code>T3</code> 。线程 <code>T3</code> 获取到锁之后，同样也退出等待队列，即将线程 <code>T3</code> 节点变为 <code>head</code> 节点来退出资源获取的等待。此时 AQS 内部队列如下所示：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505241523499.png" alt="img"></p><h2 id="5-公平锁与非公平锁"><a href="#5-公平锁与非公平锁" class="headerlink" title="5. 公平锁与非公平锁"></a>5. 公平锁与非公平锁</h2><p>上面给出的就是一个公平锁的流程：一个新的线程来到想要竞争锁，</p><ul><li>如果此时锁不空闲，就到队列中去排队等待</li><li>如果此时有线程释放了锁，也得老老实实去队列中排队，等待前面的人用完了锁之后自己才能获得锁</li></ul><p>而非公平锁则有一些不同，当一个新线程来到想要竞争锁，</p><ul><li>如果此时锁不空闲，也得老老实实排队等待</li><li>如果此时有线程释放了锁，这个<strong>新线程是有机会通过CAS操作直接插队获取到这个锁</strong>的<ul><li>如果成功获得，那就不用排队了</li><li>否则，还是得排队</li></ul></li></ul><h2 id="6-为什么AQS要用双向链表"><a href="#6-为什么AQS要用双向链表" class="headerlink" title="6. 为什么AQS要用双向链表?"></a>6. 为什么AQS要用双向链表?</h2><ul><li>没有竞争到锁的线程会加入到队列中，线程阻塞等待的前提是：<mark>当前线程所在的节点的前置节点是正常状态（waitStatus &#x3D; SIGNAL）</mark>。这是为了避免队列中出现异常线程，导致无法唤醒后续线程的情况出现。所以线程阻塞等待之前需要判断它的前置节点状态是否正常，如果使用单向链表，那就只能从头遍历，效率很低</li><li>处于队列中<mark>阻塞等待的线程允许被外部线程通过<code>interrupt()</code>方法去触发唤醒的</mark>，这时节点的状态waitStatus需要修改为<strong>CANCELLED</strong>，标记为CANCELLED的线程就<mark>不需要参与锁的竞争了，但它仍会处于队列中，为了方便移除它，可以选用双向链表</mark></li><li>线程在加入到队列之后，会尝试通过CAS+自旋去获取锁，但我们知道，只有队列中的第一个线程能优先得到锁，后面的线程去尝试获取锁只会浪费资源，于是<mark>在线程尝试CAS+自旋获取锁之前，会判断这个线程的前置节点是不是队列的头节点</mark>，如果是，说明这个线程是队列中的第一个线程，则可以尝试CAS+自旋获取锁；否则直接阻塞等待即可。所以，这个判断前置节点是否是头节点的操作，使用双向链表效率会更高</li></ul><h2 id="7-AQS唤醒节点时，为什么是从队列后面往前去找的？"><a href="#7-AQS唤醒节点时，为什么是从队列后面往前去找的？" class="headerlink" title="7. AQS唤醒节点时，为什么是从队列后面往前去找的？"></a>7. AQS唤醒节点时，为什么是从队列后面往前去找的？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS：这里的入参 node 为队列的头节点（虚拟头节点）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-comment">// 1、将头节点的状态进行清除，为后续的唤醒做准备。</span><br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-comment">// 2、如果后继节点异常，则需要从 tail 向前遍历，找到正常状态的节点进行唤醒。</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 3、唤醒后继节点</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 <code>s == null</code> 或者 <code>s.waitStatus &gt; 0</code> ，表明后继节点异常，此时不能唤醒异常节点，而是要找到正常状态的节点进行唤醒。</p><p><mark>因此需要从 <code>tail</code> 指针向前遍历，来找到第一个状态正常（<code>waitStatus &lt;= 0</code>）的节点进行唤醒</mark>。</p><p><mark><code>node</code> 节点入队需要修改 <code>node.prev</code> 和 <code>pred.next</code> 两个指针，但是这两个操作并不是 <strong>原子操作</strong> ，先修改了 <code>node.prev</code> 指针，之后才修改 <code>pred.next</code> 指针。</mark></p><p>在极端情况下，可能会出现 <code>head</code> 节点的下一个节点状态为 <code>CANCELLED</code> ，此时新入队的节点仅更新了 <code>node.prev</code> 指针，还未更新 <code>pred.next</code> 指针，如下图：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505241523500.png" alt="img"></p><p>这样如果从 <code>head</code> 指针向后遍历，无法找到新入队的节点，因此需要从 <code>tail</code> 指针向前遍历找到新入队的节点。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2025/05/23/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2025/05/23/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><blockquote><p>引用：</p><ul><li>javaguide</li><li><a href="https://javabetter.cn/sidebar/sanfene/javathread.html">https://javabetter.cn/sidebar/sanfene/javathread.html</a></li></ul></blockquote><h2 id="1-线程池优点"><a href="#1-线程池优点" class="headerlink" title="1. 线程池优点"></a>1. 线程池优点</h2><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程<mark>降低线程创建和销毁造成的消耗</mark>。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以<mark>不需要等待线程创建就能立即执行</mark>。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><p>如何创建线程池？通过<code>ThreadPoolExecutor</code>构造函数来创建。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505231423531.jpeg" alt="通过构造方法实现"></p><h2 id="2-线程池的重要参数"><a href="#2-线程池的重要参数" class="headerlink" title="2. 线程池的重要参数"></a>2. 线程池的重要参数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                           )</span> &#123;<br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>  <br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  <br>    <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>    <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>    <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>    <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>    <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    <span class="hljs-built_in">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code> 3 个最重要的参数：</p><ul><li><code>corePoolSize</code> : 任务队列<strong>未达到队列容量</strong>时，最大可以同时运行的线程数量。</li><li><code>maximumPoolSize</code> : 任务队列中存放的<strong>任务达到队列容量</strong>的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><code>workQueue</code>: 新任务来的时候会先判断当前运行的线程数量<strong>是否达到核心线程数</strong>，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><code>keepAliveTime</code>:当线程池中的线程数量大于 <code>corePoolSize</code> ，即有非核心线程（线程池中核心线程以外的线程）时，这些非核心线程空闲后不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li><li><code>unit</code> : <code>keepAliveTime</code> 参数的时间单位。</li><li><code>threadFactory</code> :executor 创建新线程的时候会用到。</li><li><code>handler</code> :拒绝策略</li></ul><h2 id="3-线程池处理任务的流程"><a href="#3-线程池处理任务的流程" class="headerlink" title="3. 线程池处理任务的流程"></a>3. 线程池处理任务的流程</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505231423533.png" alt="图解线程池实现原理"></p><p><strong>线程池在提交任务前，可以提前创建线程吗？</strong></p><p>答案是可以的！<code>ThreadPoolExecutor</code> 提供了两个方法帮助我们在提交任务之前，完成核心线程的创建，从而实现<strong>线程池预热</strong>的效果：</p><ul><li><code>prestartCoreThread()</code>：启动一个线程，等待任务，如果已达到核心线程数，这个方法返回 false，否则返回 true；</li><li><code>prestartAllCoreThreads()</code>：启动所有的核心线程，并返回启动成功的核心线程数。</li></ul><h2 id="4-线程池的拒绝策略"><a href="#4-线程池的拒绝策略" class="headerlink" title="4. 线程池的拒绝策略"></a>4. 线程池的拒绝策略</h2><ul><li><code>AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理</li><li><code>DiscardPolicy</code>：不处理新任务，直接丢弃掉</li><li><code>DiscardOldestPolicy</code>：此策略将丢弃最早的未处理的任务请求</li><li><code>CallerRunsPolicy</code>：调用执行者自己的线程运行任务（比如说main线程调用了execute，但线程池内线程数量不够，就让main线程自己去执行任务，有可能会导致main线程阻塞，影响正常程序执行）</li></ul><h2 id="5-线程池有哪几种阻塞队列？"><a href="#5-线程池有哪几种阻塞队列？" class="headerlink" title="5. 线程池有哪几种阻塞队列？"></a>5. 线程池有哪几种阻塞队列？</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505231423534.png" alt="线程池常用阻塞队列"></p><h2 id="6-线程池提交execute-和submit-有什么区别？"><a href="#6-线程池提交execute-和submit-有什么区别？" class="headerlink" title="6. 线程池提交execute()和submit()有什么区别？"></a>6. 线程池提交execute()和submit()有什么区别？</h2><p><code>execute()</code> 方法<strong>没有返回值</strong>，适用于不关心结果和异常的简单任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">threadsPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;execute() 方法提交的任务&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>submit()</code> <strong>有返回值</strong>，适用于需要获取结果或处理异常的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);<br><span class="hljs-keyword">try</span> &#123; <span class="hljs-type">Object</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> future.get(); &#125; <br><span class="hljs-keyword">catch</span> (InterruptedException e | ExecutionException e) &#123;<br>    <span class="hljs-comment">// 处理无法执行任务异常</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 关闭线程池 executor.shutdown();</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-线程池怎么关闭？"><a href="#7-线程池怎么关闭？" class="headerlink" title="7. 线程池怎么关闭？"></a>7. 线程池怎么关闭？</h2><p>可以调用线程池的<code>shutdown</code>或<code>shutdownNow</code>方法来关闭线程池。</p><p><code>shutdown</code> 不会立即停止线程池，而是<mark>等待所有任务执行完毕后再关闭线程池</mark>。</p><p><code>shutdownNow</code> 会尝试通过一系列动作来停止线程池，包括停止接收外部提交的任务、忽略队列里等待的任务、尝试将正在跑的任务 interrupt 中断。</p><p>需要注意的是，<code>shutdownNow</code> 不会真正终止正在运行的任务，只是给任务线程发送 interrupt 信号，任务是否能真正终止取决于线程是否响应 <code>InterruptedException</code>。</p><h2 id="8-线程池有几种状态？"><a href="#8-线程池有几种状态？" class="headerlink" title="8. 线程池有几种状态？"></a>8. 线程池有几种状态？</h2><p>有 5 种状态，它们的转换遵循严格的状态流转规则，不同状态控制着线程池的任务调度和关闭行为。</p><p>状态由 RUNNING → SHUTDOWN → STOP → TIDYING → TERMINATED 依次流转。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505231423535.png" alt="线程池状态切换图"></p><ul><li><strong>RUNNING</strong> 状态的线程池可以接收新任务，并处理阻塞队列中的任务；</li><li><strong>SHUTDOWN</strong> 状态的线程池不会接收新任务，但会处理阻塞队列中的任务；</li><li><strong>STOP</strong> 状态的线程池不会接收新任务，也不会处理阻塞队列中的任务，并且会<strong>尝试中断</strong>正在执行的任务；</li><li><strong>TIDYING</strong> 状态表示所有任务已经终止；</li><li><strong>TERMINATED</strong> 状态表示线程池完全关闭，所有线程销毁。</li></ul><table><thead><tr><th>状态</th><th>状态码</th><th>是否接收新任务</th><th>是否执行队列中的任务</th><th>是否中断正在执行的任务</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>✅ 是</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>SHUTDOWN</td><td>000</td><td>❌ 否</td><td>✅ 是</td><td>❌ 否</td></tr><tr><td>STOP</td><td>001</td><td>❌ 否</td><td>❌ 否</td><td>✅ 是</td></tr><tr><td>TIDYING</td><td>010</td><td>❌ 否</td><td>❌ 否</td><td>❌ 否</td></tr><tr><td>TERMINATED</td><td>011</td><td>❌ 否</td><td>❌ 否</td><td>❌ 否</td></tr></tbody></table><p>状态码是线程池通过一个int类型变量来表示的，int类型变量4bit，32位，它的高3位用来表示线程池状态，而剩下的29位则用来表示线程数量，所以理论上一个线程池的最大线程数是：2^29 - 1</p><h2 id="9-线程池的线程数应该如何配置？"><a href="#9-线程池的线程数应该如何配置？" class="headerlink" title="9. 线程池的线程数应该如何配置？"></a>9. 线程池的线程数应该如何配置？</h2><ul><li><p>对于 <strong>CPU 密集型</strong>任务，我的目标是尽量减少线程上下文切换，以优化 CPU 使用率。一般来说，核心线程数设置为<strong>处理器的核心数 或 核心数 + 1</strong>是较理想的选择。</p><blockquote><p>+1 是为了以备不时之需，如果某线程因等待系统资源而阻塞时，可以有多余的线程顶上去，不至于影响整体性能</p></blockquote></li><li><p>对于 <strong>IO 密集型</strong>任务，由于线程经常处于等待状态，等待 IO 操作完成，所以可以设置更多的线程来提高并发，比如说 <strong>CPU 核心数的两倍</strong></p></li></ul><h2 id="10-手写一个线程池"><a href="#10-手写一个线程池" class="headerlink" title="10. 手写一个线程池"></a>10. 手写一个线程池</h2><h3 id="核心线程池类"><a href="#核心线程池类" class="headerlink" title="核心线程池类"></a>核心线程池类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyThreadPool;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.RejectedExecutionHandler;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> corePoolSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxPoolSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> keepAliveTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TimeUnit timeUnit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RejectedExecutionHandler handler;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> isShutdown;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> currentPoolSize;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                        <span class="hljs-type">int</span> maxPoolSize,</span><br><span class="hljs-params">                        <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                        TimeUnit timeUnit,</span><br><span class="hljs-params">                        BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                        RejectedExecutionHandler handler)</span> &#123;<br>        <span class="hljs-built_in">super</span>(corePoolSize, maxPoolSize, keepAliveTime, timeUnit, workQueue, handler); <br>        <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>        <span class="hljs-built_in">this</span>.maxPoolSize = maxPoolSize;<br>        <span class="hljs-built_in">this</span>.keepAliveTime = keepAliveTime;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>        <span class="hljs-built_in">this</span>.handler = handler;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-keyword">if</span>(isShutdown)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;ThreadPool is closed&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(currentPoolSize &lt; corePoolSize)&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task).start();<br>            currentPoolSize++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!workQueue.offer(task))&#123;<br>            <span class="hljs-keyword">if</span>(currentPoolSize &lt; maxPoolSize)&#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task).start();<br>                currentPoolSize++;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                handler.rejectedExecution(task, <span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>        isShutdown = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 工作线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span>&#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task.run();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> workQueue.poll(keepAliveTime, timeUnit);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyThreadPool;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.RejectedExecutionHandler;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRejectedExecutionHandler</span> &#123;<br>    <span class="hljs-comment">// AbortPolicy 抛出异常</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Task &quot;</span> + r.toString() + <span class="hljs-string">&quot; rejected from &quot;</span> + e.toString());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// DiscardPolicy 什么都不做</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscardPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            <span class="hljs-comment">// Do nothing</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// CallerRunsPolicy 让调用执行方法的线程去执行，这里是main线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor e)</span> &#123;<br>            <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>                r.run();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> MyThreadPool;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadPoolTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThreadPoolExecutor</span> <span class="hljs-variable">myThreadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThreadPoolExecutor</span>(<br>                <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRejectedExecutionHandler</span>.CallerRunsPolicy()<br>        );<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i;<br>            myThreadPool.execute(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Task &quot;</span> + index + <span class="hljs-string">&quot; is running&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;);<br>        &#125;<br><br>        myThreadPool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505231444982.png" alt="image-20250523144408614"></p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>synchronized3</title>
    <link href="/2025/05/23/synchronized3/"/>
    <url>/2025/05/23/synchronized3/</url>
    
    <content type="html"><![CDATA[<h1 id="synchronized3"><a href="#synchronized3" class="headerlink" title="synchronized3"></a>synchronized3</h1><blockquote><p>引用：</p><ul><li><a href="https://www.cnblogs.com/duanxz/p/4458342.html">https://www.cnblogs.com/duanxz/p/4458342.html</a></li><li><a href="https://www.cnblogs.com/vipstone/p/15121109.html">https://www.cnblogs.com/vipstone/p/15121109.html</a></li></ul></blockquote><h2 id="1-自旋锁"><a href="#1-自旋锁" class="headerlink" title="1. 自旋锁"></a>1. 自旋锁</h2><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。</p><p>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。<br>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。</p><h2 id="2-适应自旋锁"><a href="#2-适应自旋锁" class="headerlink" title="2. 适应自旋锁"></a>2. 适应自旋锁</h2><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着<strong>自旋的次数不再是固定</strong>的，它是<mark>由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</mark>。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。<br>有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h2 id="3-锁消除"><a href="#3-锁消除" class="headerlink" title="3. 锁消除"></a>3. 锁消除</h2><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到<strong>不可能存在共享数据竞争</strong>，这时JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。<br>如果不存在竞争，为什么还需要加锁呢？所以<strong>锁消除可以节省毫无意义的请求锁的时间</strong>。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样，我们虽然没有显式使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在<strong>隐形的加锁操作</strong>。比如StringBuffer的append()方法，Vector的add()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        sb.append(<span class="hljs-string">&quot;i:&quot;</span> + i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505231030451.png" alt="image.png"></p><p>在运行这段代码时，JVM可以明显检测到变量sb没有逃逸出方法method()之外，所以JVM可以大胆地将sb内部的加锁操作消除。从上述结果可以看出，之前我们写的线程安全的加锁的 StringBuffer 对象，在生成字节码之后就<strong>被替换成了不加锁不安全的 StringBuilder 对象</strong>了，原因是 StringBuffer 的变量属于一个局部变量，并且不会从该方法中逃逸出去，所以此时我们就可以使用锁消除（不加锁）来加速程序的运行。</p><h2 id="4-锁粗化"><a href="#4-锁粗化" class="headerlink" title="4. 锁粗化"></a>4. 锁粗化</h2><p><strong>锁粗化是指，将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁</strong>。</p><p>我只听说锁“细化”可以提高程序的执行效率，也就是将锁的范围尽可能缩小，这样在锁竞争时，等待获取锁的线程才能更早的获取锁，从而提高程序的运行效率，但锁粗化是如何提高性能的呢？</p><p>没错，锁细化的观点在大多数情况下都是成立了，但是一系列连续加锁和解锁的操作，也会导致不必要的性能开销，从而影响程序的执行效率，比如这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-comment">// 伪代码：加锁操作</span><br>        sb.append(<span class="hljs-string">&quot;i:&quot;</span> + i);<br>        <span class="hljs-comment">// 伪代码：解锁操作</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们不考虑编译器优化的情况，<strong>如果在 for 循环中定义锁，那么锁的范围很小，但每次 for 循环都需要进行加锁和释放锁的操作，性能是很低的；但如果我们直接在 for 循环的外层加一把锁，那么对于同一个对象操作这段代码的性能就会提高很多</strong>，如下伪代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-comment">// 伪代码：加锁操作</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        sb.append(<span class="hljs-string">&quot;i:&quot;</span> + i);<br>    &#125;<br>    <span class="hljs-comment">// 伪代码：解锁操作</span><br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>锁粗化的作用：如果检测到同一个对象执行了连续的加锁和解锁的操作，则会将这一系列操作合并成一个更大的锁，从而提升程序的执行效率</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>synchronized2</title>
    <link href="/2025/05/23/synchronized2/"/>
    <url>/2025/05/23/synchronized2/</url>
    
    <content type="html"><![CDATA[<h1 id="synchronized2"><a href="#synchronized2" class="headerlink" title="synchronized2"></a>synchronized2</h1><h2 id="1-Java的对象头"><a href="#1-Java的对象头" class="headerlink" title="1. Java的对象头"></a>1. Java的对象头</h2><p>在JVM中，对象是分成三部分存在的：对象头、实例数据、对齐填充</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505231033854.webp" alt="img"></p><p>对象头是我们需要关注的重点，它是<code>synchronized</code>实现锁的基础，因为<code>synchronized</code>申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由<code>Mark Word</code> 和 <code>Class Metadata Address</code>组成：</p><ul><li><code>Mark Word</code>：<strong>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</strong>，</li><li><code>Class Metadata Address</code>：<strong>是类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例</strong>。</li></ul><p>锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对<code>synchronized</code>进行了优化，新增了两种状态，总共就是四个状态：<strong>无锁状态、偏向锁、轻量级锁、重量级锁</strong>。锁的类型和状态在对象头<code>Mark Word</code>中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的<code>Mark Word</code>数据。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505231033855.png" alt="img"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202601191616846.png" alt="image-20260119161645901"></p><h2 id="2-锁升级过程"><a href="#2-锁升级过程" class="headerlink" title="2. 锁升级过程"></a>2. 锁升级过程</h2><h3 id="2-1-为什么需要锁升级？"><a href="#2-1-为什么需要锁升级？" class="headerlink" title="2.1 为什么需要锁升级？"></a>2.1 为什么需要锁升级？</h3><p>在JDK1.6之前，<code>synchronized</code>属于<strong>重量级锁</strong>，重量级锁在用户态发起系统调用，向<strong>内核申请<code>mutex</code>互斥量</strong>，这个过程需要发生上下文切换 以及 <strong>用户态内核态的切换</strong>，基于此实现线程的阻塞与唤醒。而<mark>大量的用户态内核态切换是很浪费时间和资源的</mark>。</p><p>既然线程的阻塞唤醒比较慢，那么在低并发、锁竞争比较少的情况下，就不需要阻塞，那么就不需要用户态内核态的切换，就能减少开销，提高性能；并发量高、锁竞争激烈的情况下，再去阻塞，于是在JDK1.6之后引进了锁升级。所以说，<strong>锁升级是为了提高低并发时的性能</strong>，毕竟低并发才是常态，高并发只有那么几个时间点会出现。</p><p>上面讲到锁有四种状态，并且会因实际情况进行升级，其升级方向是：<strong>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</strong>，并且升级方向不可逆</p><h3 id="2-2-无锁"><a href="#2-2-无锁" class="headerlink" title="2.2 无锁"></a>2.2 无锁</h3><p>无锁状态是对象初始化后的默认锁状态，表示对象当前未被任何线程锁定。在这种状态下，对象头的锁标志位通常为空或特定的无锁标识，表明对象不受任何同步控制，任何线程都能够无障碍地访问该对象。</p><h3 id="2-3-偏向锁"><a href="#2-3-偏向锁" class="headerlink" title="2.3 偏向锁"></a>2.3 偏向锁</h3><p>何谓“偏向”？就是<strong>锁对象会偏向于第一个获得它的线程</strong>。</p><p>当一个线程访问同步代码块并获取锁时，该锁会进入偏向模式，锁的拥有者被设置为当前线程。当该线程执行完同步代码块后，<strong>线程并不会主动释放偏向锁</strong>。当线程再次进入同步代码块时，会首先判断此时持有锁的线程与它是否为同一线程，如果是则正常往下执行，由于<strong>此前是没有释放锁的</strong>，所以这次就不会有任何的获取锁操作。</p><p><strong>偏向锁的锁释放</strong>是一个<strong>被动过程</strong>，线程不会主动释放偏向锁。如果有别的线程来竞争偏向锁时，通过CAS操作竞争，竞争成功则更改锁拥有者；否则说明有多线程竞争锁的情况，当到达<strong>全局安全点</strong>（所有线程会暂停），获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块</p><blockquote><p>偏向锁的撤销过程特别值得关注。当第二个线程尝试获取锁时，JVM需要检查偏向的线程是否还在执行同步代码。<mark>如果偏向线程已经退出同步块，JVM会直接将偏向锁撤销并升级；如果偏向线程还在同步块内，JVM需要等到安全点才能执行撤销操作。</mark></p></blockquote><p>所以，引入偏向锁的目的是<mark>认为当前环境下是不存在多线程竞争的场景，可以认为是单线程环境，同一个线程多次持有锁，减少单线程环境下获取锁带来的不必要</mark>。</p><h3 id="2-4-轻量级锁"><a href="#2-4-轻量级锁" class="headerlink" title="2.4 轻量级锁"></a>2.4 轻量级锁</h3><p>当一个线程持有偏向锁时且仍处于活动状态时，另外一个线程来竞争锁，这时偏向锁就会升级为轻量级锁。</p><p>轻量级锁的竞争方式是一种比较轻量级的竞争方式，<mark>当某个线程没有获取到锁，它并不是立刻被阻塞，而是采取CAS+自旋的方式来竞争锁资源</mark>。在竞争较少的情况下，轻量级锁通过<strong>减少线程阻塞和唤醒操作</strong>，可以提高性能。</p><p>轻量级锁的目的在于它<mark>认为系统当前的竞争环境不是很激烈，如果采取阻塞和唤醒线程的方式，则会过多地消耗系统资源</mark>。如果某个线程没有获取到轻量级锁，则采取<strong>自旋</strong>的方式来判断锁资源是否已被释放。这种方式减少了上下文的切换。</p><h3 id="2-5-重量级锁"><a href="#2-5-重量级锁" class="headerlink" title="2.5 重量级锁"></a>2.5 重量级锁</h3><p>短时间的自旋性能是不错的，但轻量级锁自旋是要有限度的，不能一直在那里空转，这样也是很消耗CPU资源的，所以如果锁竞争环境比较严重，当自旋次数达到某个阈值（默认 10 次，可自动调整）后 或者 等待轻量级锁的线程很多时，就停止自旋，此时锁升级为重量级锁。当其膨胀为重量级锁后，其他线程就不再是等待了，而是<strong>阻塞等待</strong>。重量级锁依赖对象内部的监视器（<code>monitor</code>）实现，而 <code>monitor</code> 依赖的是操作系统的 <code>mutex</code>原语。</p><h3 id="2-6-为什么JDK18中废止了偏向锁"><a href="#2-6-为什么JDK18中废止了偏向锁" class="headerlink" title="2.6 为什么JDK18中废止了偏向锁"></a>2.6 为什么JDK18中废止了偏向锁</h3><ul><li>性能收益不明显<ul><li>受益于偏向锁的应用程序通常使用了早期的 Java 集合 API，例如 HashTable、Vector，在这些集合类中通过 <code>synchronized</code> 来控制同步，这样在单线程频繁访问时，通过偏向锁会减少同步开销</li><li>随着 JDK 的发展，出现了 ConcurrentHashMap 高性能的集合类，在集合类内部进行了许多性能优化，此时偏向锁带来的性能收益就不明显了</li></ul></li><li>JVM内部维护代码成本太高</li></ul><h2 id="3-Monitor"><a href="#3-Monitor" class="headerlink" title="3. Monitor"></a>3. Monitor</h2><blockquote><p>重量级锁的实现</p></blockquote><p>每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由<strong>ObjectMonitor</strong>实现的（C++实现，主要数据结构如下）。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但<strong>当一个monitor被某个线程持有后，它便处于锁定状态</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ObjectMonitor</span>() &#123;<br>    _header       = <span class="hljs-literal">NULL</span>;<br>    _count        = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录重入次数</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;<br>    _object       = <span class="hljs-literal">NULL</span>;<br>    _owner        = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 锁持有者</span><br>    _WaitSet      = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 处于waiting、time_waiting状态的线程，会被加入到_WaitSet</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = <span class="hljs-literal">NULL</span> ;<br>    _succ         = <span class="hljs-literal">NULL</span> ;<br>    _cxq          = <span class="hljs-literal">NULL</span> ;<br>    FreeNext      = <span class="hljs-literal">NULL</span> ;<br>    _EntryList    = <span class="hljs-literal">NULL</span> ; <span class="hljs-comment">// 处于等待锁blocked状态的线程，会被加入到该列表</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure><p>ObjectMonitor中有两个队列，WaitSet 和 EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，owner指向持有ObjectMonitor对象的线程。</p><p>当多个线程同时访问一段同步代码时，首先会进入 EntryList 集合，<mark>当线程获取到对象的monitor 后把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1</mark>，竞争锁失败的线程则留在EntryList中。若线程调用 <code>wait()</code> 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor并复位变量的值，以便其他线程获取monitor。</p><p>后进入EntryList的线程被允许直接尝试获得锁，这说明<code>synchronized</code>是<strong>非公平锁</strong></p><h3 id="3-1-为什么需要EntryList、WaitSet两个集合呢？集合里的元素不都是在等待锁吗？"><a href="#3-1-为什么需要EntryList、WaitSet两个集合呢？集合里的元素不都是在等待锁吗？" class="headerlink" title="3.1 为什么需要EntryList、WaitSet两个集合呢？集合里的元素不都是在等待锁吗？"></a>3.1 为什么需要EntryList、WaitSet两个集合呢？集合里的元素不都是在等待锁吗？</h3><p>EntryList里的元素是竞争锁失败的线程，这是锁的互斥问题；而WaitSet里的元素是调用<code>wait()</code> 方法主动释放锁并等待唤醒的线程，这是线程通信的问题</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>sleep()和wait()、start()和run()</title>
    <link href="/2025/05/22/sleep()%E5%92%8Cwait()%E3%80%81start()%E5%92%8Crun()/"/>
    <url>/2025/05/22/sleep()%E5%92%8Cwait()%E3%80%81start()%E5%92%8Crun()/</url>
    
    <content type="html"><![CDATA[<h1 id="sleep-和wait-、start-和run"><a href="#sleep-和wait-、start-和run" class="headerlink" title="sleep()和wait()、start()和run()"></a>sleep()和wait()、start()和run()</h1><h2 id="1-sleep-、wait"><a href="#1-sleep-、wait" class="headerlink" title="1. sleep()、wait()"></a>1. sleep()、wait()</h2><h3 id="1-1-相同点"><a href="#1-1-相同点" class="headerlink" title="1.1 相同点"></a>1.1 相同点</h3><p>两者都可以暂停线程执行</p><h3 id="1-2-区别"><a href="#1-2-区别" class="headerlink" title="1.2 区别"></a>1.2 区别</h3><ul><li><code>wait()</code>方法释放了锁；<code>sleep()</code>方法没有释放锁</li><li><mark><code>wait()</code>方法通常被用于线程间的通信；<code>sleep()</code>方法通常被用于暂停执行</mark></li><li><code>wait()</code>方法调用后，需要别的线程使用<code>notify()</code>或<code>notifyAll()</code>方法唤醒当前线程，或者使用<code>wait(long timeout)</code>方法指定线程的苏醒时间；<code>sleep()</code>方法执行完成后会自动苏醒</li><li><code>wait()</code>方法属于<code>Object</code>类的本地方法；<code>sleep()</code>方法属于<code>Thread</code>类的静态方法</li></ul><h3 id="1-3-为什么wait-方法定义在Object类中"><a href="#1-3-为什么wait-方法定义在Object类中" class="headerlink" title="1.3 为什么wait()方法定义在Object类中"></a>1.3 为什么wait()方法定义在Object类中</h3><p><code>wait()</code>方法是让获得<strong>对象锁</strong>的线程实现等待，会释放当前线程占有的对象锁，对象锁是每个对象的拥有的，因此定义在<code>Object</code>类中</p><p>同理，<code>sleep()</code>方法是让当前线程暂停执行，不涉及到对象类、对象锁，因此定义在<code>Thread</code>类中</p><h2 id="2-start-、run"><a href="#2-start-、run" class="headerlink" title="2. start()、run()"></a>2. start()、run()</h2><ul><li><code>start()</code>方法会启动一个线程，并自动执行它的<code>run()</code>方法，这是真正的多线程内容</li><li>直接执行<code>run()</code>方法，会把<code>run()</code>方法当作main线程下一个普通的方法去执行，与多线程无关</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StartAndRun</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">MyThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName());<br>        &#125;);<br><br>        MyThread.start();<br>        MyThread.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505222020161.png" alt="image-20250522202024437"></p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>synchronized1</title>
    <link href="/2025/05/22/synchronized1/"/>
    <url>/2025/05/22/synchronized1/</url>
    
    <content type="html"><![CDATA[<h1 id="synchronized1"><a href="#synchronized1" class="headerlink" title="synchronized1"></a>synchronized1</h1><h2 id="1-synchronized的用法"><a href="#1-synchronized的用法" class="headerlink" title="1. synchronized的用法"></a>1. synchronized的用法</h2><h3 id="1-1-修饰实例方法"><a href="#1-1-修饰实例方法" class="headerlink" title="1.1 修饰实例方法"></a>1.1 修饰实例方法</h3><p>给当前对象实例加锁，进入同步代码前要获取当前对象实例的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-修饰静态方法"><a href="#1-2-修饰静态方法" class="headerlink" title="1.2 修饰静态方法"></a>1.2 修饰静态方法</h3><p>给当前类加锁，进入同步代码之前要获取当前class的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-修饰代码块"><a href="#1-3-修饰代码块" class="headerlink" title="1.3 修饰代码块"></a>1.3 修饰代码块</h3><p>对括号里指定的对象&#x2F;类加锁：</p><ul><li><code>synchronized(object)</code> 表示进入同步代码前要获得 <strong>给定对象的锁</strong></li><li><code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-为什么尽量不要使用synchronized-String-a-？"><a href="#1-4-为什么尽量不要使用synchronized-String-a-？" class="headerlink" title="1.4 为什么尽量不要使用synchronized(String a) ？"></a>1.4 为什么尽量不要使用synchronized(String a) ？</h3><p>因为我们使用<code>synchronized</code>通常是为了在多线程的情况下，不让多个线程同时执行<code>synchronized</code>代码块内的内容，所以<code>synchronized</code>括号内的对象需要是同一个对象，才能保证多个线程的同步执行。</p><p>如果使用<code>String a = new String(&quot;lock&quot;)，String b = new String(&quot;lock&quot;)</code>，很容易出现两个字符串对象的值虽然相同，但毕竟不是同一个对象，作用到两个同步代码块无法实现锁住的效果。所以要使用字符串充当锁对象时，一般会<strong>配合<code>intern()</code>方法使用</strong></p><h2 id="2-synchronized的特性"><a href="#2-synchronized的特性" class="headerlink" title="2. synchronized的特性"></a>2. synchronized的特性</h2><h3 id="2-1-原子性"><a href="#2-1-原子性" class="headerlink" title="2.1 原子性"></a>2.1 原子性</h3><p><code>synchronized</code>确保在执行同步代码块时，只有持有锁的线程可以访问该代码块，从而避免数据竞争。</p><h3 id="2-2-可见性"><a href="#2-2-可见性" class="headerlink" title="2.2 可见性"></a>2.2 可见性</h3><blockquote><p><code>volatile</code>是<strong>通过内存屏障来保证可见性的</strong>，<strong>Load屏障</strong>保证<code>volatile</code>变量每次读取数据的时候<strong>都强制从主内存读取</strong>；<strong>Store屏障</strong>保证每次<code>volatile</code><strong>修改之后强制将数据刷新回主内存</strong></p></blockquote><p>我们都知道<code>sychronized</code>底层是<strong>通过monitorenter的指令来进行加锁的、通过monitorexit指令来释放锁的</strong>。而这两个指令也具有上述的屏障作用</p><ul><li>通过<strong>monitorenter指令之后</strong>，<code>synchronized</code><strong>内部的共享变量</strong>，<strong>每次读取数据的时候被强制从主内存读取最新的数据</strong></li><li><strong>monitorexit指令</strong>也具有<strong>Store屏障</strong>的作用，也就是让<code>synchronized</code>代码块内的共享变量，如果数据有变更的，<strong>强制刷新回主内存</strong></li></ul><p>这样通过这种方式，<strong>数据修改之后立即刷新回主内存</strong>，其他线程进入<code>synchronized</code>代码块后，使用<strong>共享变量的时候强制读取主内存的数据</strong>，上一个线程对共享变量的变更操作，它就能立即看到了</p><h3 id="2-3-有序性"><a href="#2-3-有序性" class="headerlink" title="2.3 有序性"></a>2.3 有序性</h3><p>指令重排是指 <strong>CPU 或编译器</strong>为了提高程序的执行效率，<strong>改变代码执行顺序</strong>的一种优化技术。从 Java 源代码到最终执行的指令序列，会经历 3 种重排序：编译器重排序、指令并行重排序、内存系统重排序。</p><blockquote><p><strong>volatile通过内存屏障来保证有序性的</strong></p><ul><li>StoreStore屏障：禁止StoreStore屏障的前后Store写操作重排</li><li>LoadLoad屏障：禁止LoadLoad屏障的前后Load读操作进行重排</li><li>LoadStore屏障：禁止LoadStore屏障的前面Load读操作跟LoadStore屏障后面的Store写操作重排</li><li>StoreLoad屏障：禁止LoadStore屏障前面的Store写操作跟后面的Load&#x2F;Store 读写操作重排</li></ul></blockquote><p>同理，<code>synchronized</code>也是通过<strong>monitorenter</strong>和<strong>moniterexit</strong>的内存屏障功能，来保证代码执行的有序性</p><h2 id="3-synchronized和volatile的区别"><a href="#3-synchronized和volatile的区别" class="headerlink" title="3. synchronized和volatile的区别"></a>3. synchronized和volatile的区别</h2><ul><li>两者均能保证可见性和有序性</li><li><code>synchronized</code>可以保证原子性，即被<code>synchronized</code>修饰的代码块同一时间只有一个线程能执行；但<code>volatile</code>无法保证原子性，它仅保证了被修饰变量的读写操作是原子性的，但是，对于复合操作（例如i++），<code>volatile</code>无法保证原子性</li><li><code>volatile</code>关键字的性能开销相对较低，因为它仅仅是对变量的可见性进行了保证；<code>synchronized</code>关键字的性能开销相对较高，因为它需要在进入和退出临界区时获取和释放锁，并且涉及到线程的上下文切换</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-死锁</title>
    <link href="/2025/05/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/"/>
    <url>/2025/05/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统-死锁"><a href="#操作系统-死锁" class="headerlink" title="操作系统-死锁"></a>操作系统-死锁</h1><h2 id="1-死锁的概念"><a href="#1-死锁的概念" class="headerlink" title="1. 死锁的概念"></a>1. 死锁的概念</h2><p>死锁只有满足以下四个条件时才会产生：</p><ul><li>互斥条件：每个资源要么已经分配给了一个进程，要么就是可用的</li><li>持有并等待条件：已经得到了某个资源的进程可以再请求新的资源</li><li>不可剥夺条件：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放</li><li>环路等待条件：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源</li></ul><h2 id="2-死锁检测与死锁恢复"><a href="#2-死锁检测与死锁恢复" class="headerlink" title="2. 死锁检测与死锁恢复"></a>2. 死锁检测与死锁恢复</h2><blockquote><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复</p></blockquote><h3 id="2-1-每种类型一个资源的死锁检测"><a href="#2-1-每种类型一个资源的死锁检测" class="headerlink" title="2.1 每种类型一个资源的死锁检测"></a>2.1 每种类型一个资源的死锁检测</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505211535325.png" alt="img"></p><p>上图为资源分配图，其中<strong>方框表示资源，圆圈表示进程</strong>。资源指向进程表示该资源<strong>已经分配给</strong>该进程，进程指向资源表示进程<strong>请求获取</strong>该资源。图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。</p><p>每种类型一个资源的死锁检测算法是通过检测<strong>有向图是否存在环</strong>来实现，<mark>从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生</mark></p><h3 id="2-2-每种类型多个资源的死锁检测"><a href="#2-2-每种类型多个资源的死锁检测" class="headerlink" title="2.2 每种类型多个资源的死锁检测"></a>2.2 每种类型多个资源的死锁检测</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505211535326.png" alt="img"></p><p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p><ul><li>E 向量：资源总量</li><li>A 向量：资源剩余量</li><li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li><li>R 矩阵：每个进程请求的资源数量</li></ul><h3 id="2-3-死锁恢复"><a href="#2-3-死锁恢复" class="headerlink" title="2.3 死锁恢复"></a>2.3 死锁恢复</h3><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h2 id="3-死锁预防"><a href="#3-死锁预防" class="headerlink" title="3. 死锁预防"></a>3. 死锁预防</h2><blockquote><p>在程序运行之前预防死锁发生</p></blockquote><h3 id="3-1-破坏互斥条件"><a href="#3-1-破坏互斥条件" class="headerlink" title="3.1 破坏互斥条件"></a>3.1 破坏互斥条件</h3><h3 id="3-2-破坏持有并等待条件"><a href="#3-2-破坏持有并等待条件" class="headerlink" title="3.2 破坏持有并等待条件"></a>3.2 破坏持有并等待条件</h3><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源</p><h3 id="3-3-破坏不可剥夺条件"><a href="#3-3-破坏不可剥夺条件" class="headerlink" title="3.3 破坏不可剥夺条件"></a>3.3 破坏不可剥夺条件</h3><h3 id="3-4-破坏环路等待条件"><a href="#3-4-破坏环路等待条件" class="headerlink" title="3.4 破坏环路等待条件"></a>3.4 破坏环路等待条件</h3><p>给资源统一编号，进程只能按编号顺序来请求资源</p><h2 id="4-死锁避免"><a href="#4-死锁避免" class="headerlink" title="4. 死锁避免"></a>4. 死锁避免</h2><blockquote><p>在程序运行时避免发生死锁</p></blockquote><h3 id="4-1-安全状态"><a href="#4-1-安全状态" class="headerlink" title="4.1 安全状态"></a>4.1 安全状态</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505211535327.png" alt="img"></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。</p><p>从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然<strong>存在某种调度次序</strong>能够使得每一个进程运行完毕，则称该状态是<strong>安全的</strong>。</p><h3 id="4-2-单个资源的银行家算法"><a href="#4-2-单个资源的银行家算法" class="headerlink" title="4.2 单个资源的银行家算法"></a>4.2 单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是<mark>判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配</mark></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505211535328.png" alt="img"></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态</p><h3 id="4-3-多个资源的银行家算法"><a href="#4-3-多个资源的银行家算法" class="headerlink" title="4.3 多个资源的银行家算法"></a>4.3 多个资源的银行家算法</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505211535329.png" alt="img"></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0</p><p>检查一个状态是否安全的算法如下：</p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并<strong>将其已分配资源加到 A 中</strong>。</li><li>重复以上两步，直到所有进程都标记为终止，则状态是安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-进程管理</title>
    <link href="/2025/05/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2025/05/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统-进程管理"><a href="#操作系统-进程管理" class="headerlink" title="操作系统-进程管理"></a>操作系统-进程管理</h1><h2 id="1-进程与线程"><a href="#1-进程与线程" class="headerlink" title="1. 进程与线程"></a>1. 进程与线程</h2><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h3><p><strong>进程是资源分配的基本单位</strong></p><p><strong>进程控制块 (Process Control Block, PCB)</strong> 描述进程的基本信息和运行状态</p><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h3><p><strong>线程是独立调度的基本单位</strong></p><p>一个进程中可以有多个线程，它们共享进程资源</p><h3 id="1-3-进程与线程区别"><a href="#1-3-进程与线程区别" class="headerlink" title="1.3 进程与线程区别"></a>1.3 进程与线程区别</h3><table><thead><tr><th></th><th align="left">进程</th><th>线程</th></tr></thead><tbody><tr><td>拥有资源</td><td align="left">进程是资源分配的基本单位</td><td>线程不拥有资源，线程可以访问隶属进程的资源</td></tr><tr><td>调度</td><td align="left">从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换</td><td>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，</td></tr><tr><td>系统开销</td><td align="left">在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，开销大</td><td>线程切换时只需保存和设置少量寄存器内容，开销很小</td></tr><tr><td>通信方面</td><td align="left">进程通信需要借助 IPC</td><td>线程间可以通过直接读写同一进程中的数据进行通信</td></tr></tbody></table><h2 id="2-进程状态切换"><a href="#2-进程状态切换" class="headerlink" title="2. 进程状态切换"></a>2. 进程状态切换</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505211518939.jpg" alt="进程五种状态的变迁"></p><h2 id="3-进程调度算法"><a href="#3-进程调度算法" class="headerlink" title="3. 进程调度算法"></a>3. 进程调度算法</h2><h3 id="3-1-先来先服务FCFS"><a href="#3-1-先来先服务FCFS" class="headerlink" title="3.1 先来先服务FCFS"></a>3.1 先来先服务FCFS</h3><p>非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p><h3 id="3-2-短作业优先SJF"><a href="#3-2-短作业优先SJF" class="headerlink" title="3.2 短作业优先SJF"></a>3.2 短作业优先SJF</h3><p>非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p><h3 id="3-3-最短剩余时间优先SRTN"><a href="#3-3-最短剩余时间优先SRTN" class="headerlink" title="3.3 最短剩余时间优先SRTN"></a>3.3 最短剩余时间优先SRTN</h3><p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p><h3 id="3-4-时间片轮转"><a href="#3-4-时间片轮转" class="headerlink" title="3.4 时间片轮转"></a>3.4 时间片轮转</h3><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该<strong>进程可以执行一个时间片</strong>。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><h3 id="3-5-优先级调度"><a href="#3-5-优先级调度" class="headerlink" title="3.5 优先级调度"></a>3.5 优先级调度</h3><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h3 id="3-6-多级反馈队列"><a href="#3-6-多级反馈队列" class="headerlink" title="3.6 多级反馈队列"></a>3.6 多级反馈队列</h3><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，<strong>最上面的优先权最高</strong>。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是<strong>时间片轮转调度算法和优先级调度算法的结合</strong>。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505211544776.png" alt="img"></p><h2 id="4-进程同步"><a href="#4-进程同步" class="headerlink" title="4. 进程同步"></a>4. 进程同步</h2><h3 id="4-1-同步与互斥"><a href="#4-1-同步与互斥" class="headerlink" title="4.1 同步与互斥"></a>4.1 同步与互斥</h3><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的<strong>先后执行</strong>关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区（对临界资源进行访问的代码称为临界区）。</li></ul><h3 id="4-2-哲学家就餐问题"><a href="#4-2-哲学家就餐问题" class="headerlink" title="4.2 哲学家就餐问题"></a>4.2 哲学家就餐问题</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505211518940.jpg" alt="img"></p><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>下面是一种错误的解法，如果<strong>所有哲学家同时拿起左手边的筷子</strong>，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><ul><li>方案1：<strong>让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」</strong></li><li>方案2：用一个数组 state 来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。那么，<strong>一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态</strong></li></ul><h2 id="5-进程通信"><a href="#5-进程通信" class="headerlink" title="5. 进程通信"></a>5. 进程通信</h2><h3 id="5-1-管道通信"><a href="#5-1-管道通信" class="headerlink" title="5.1 管道通信"></a>5.1 管道通信</h3><ul><li>匿名管道：<strong>对于匿名管道，它的通信范围是存在父子关系的进程</strong>，因为管道没有实体，也就是没有管道文件，只能通过 <code>fork</code> 来复制父进程 fd 文件描述符，来达到通信的目的</li><li>命名管道：<strong>对于命名管道，它可以在不相关的进程间也能相互通信</strong>。因为命令管道提前创建了一个类型为管道的<strong>设备文件</strong>，在进程里只要使用这个设备文件，就可以相互通信</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505211518941.png" alt="管道通信"></p><h3 id="5-2-消息队列"><a href="#5-2-消息队列" class="headerlink" title="5.2 消息队列"></a>5.2 消息队列</h3><ul><li>a 进程要给 b 进程发消息，只需要把消息挂在消息队列（可以是中介邮局（间接），也可以是进程自己的信箱（直接））里就行了，b 进程需要的时候再去取消息队列里的消息。</li><li>消息队列可以独立于读写进程存在，就算进程终止时，消息队列的内容也不会被删除。</li><li>读进程可以根据消息类型<strong>有选择地接收消息</strong>，而不像 FIFO 那样只能默认接收。</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505211518943.png" alt="消息队列"></p><p>如果进程发送的数据较大，并且两个进程通信非常频繁的话，消息队列模型就不太合适了，因为如果发送的数据很大的话，意味着**发送消息（拷贝）**这个过程就需要很多时间来读写内存。</p><h3 id="5-3-共享内存"><a href="#5-3-共享内存" class="headerlink" title="5.3 共享内存"></a>5.3 共享内存</h3><ul><li>共享内存的方式就可以解决拷贝耗时很长的问题了。 </li><li>共享内存是最快的一种进程通信的方式，因为进程是直接对内存进行存取的。因为可以多个进程对共享内存同时操作，所以对共享空间的访问必须要求进程对共享内存的访问是互斥的。所以我们经常把<strong>信号量和共享内存一起使用</strong>来实现进程通信。</li></ul><h3 id="5-4-信号量"><a href="#5-4-信号量" class="headerlink" title="5.4 信号量"></a>5.4 信号量</h3><ul><li>共享内存最大的问题就是多进程竞争内存的问题，就像平时所说的线程安全的问题，那么就需要<strong>靠信号量来保证进程间的操作的同步与互斥</strong>。</li><li>信号量其实就是个计数器，例如信号量的初始值是 1，然后 a 进程访问临界资源的时候，把信号量设置为 0，然后进程 b 也要访问临界资源的时候，发现信号量是 0，就知道已有进程在访问临界资源了，这时进程 b 就访问不了了，所以说信号量也是进程间的一种通信方式。</li></ul><h3 id="5-5-套接字"><a href="#5-5-套接字" class="headerlink" title="5.5 套接字"></a>5.5 套接字</h3><p>套接字可以实现两个<strong>不同的机器</strong>之间的进程通信</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-调优参数</title>
    <link href="/2025/05/19/JVM-%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/"/>
    <url>/2025/05/19/JVM-%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM——调优参数"><a href="#JVM——调优参数" class="headerlink" title="JVM——调优参数"></a>JVM——调优参数</h1><p>JVM调优是通过调整Java虚拟机的配置来提升Java应用程序的性能的过程。这包括优化堆内存设置、选择合适的垃圾收集器以及调整其他性能相关的参数。JVM调优的目的是提高性能、优化资源利用，并增强稳定性。</p><h2 id="常用JVM调优参数"><a href="#常用JVM调优参数" class="headerlink" title="常用JVM调优参数"></a>常用JVM调优参数</h2><p>以下是一些常用的JVM调优参数，特别是对于JVM 8版本：</p><ul><li><strong>-Xms</strong> 和 <strong>-Xmx</strong>：设置堆的起始大小和最大大小。</li><li><strong>-XX:+UseG1GC</strong>：使用G1垃圾收集器，适合于大堆内存和多核处理器的场景。</li><li><strong>-XX:MaxGCPauseMillis</strong>：设置期望的最大GC暂停时间（毫秒），以便于优化延迟。</li><li><strong>-XX:ParallelGCThreads</strong>：设置并行垃圾收集线程数。一般设置为可用CPU核心数。</li><li><strong>-XX:ConcGCThreads</strong>：设置G1的并发标记线程数，一般为ParallelGCThreads的一半。</li><li><strong>-XX:MetaspaceSize</strong> 和 <strong>-XX:MaxMetaspaceSize</strong>：设置初始元空间大小和最大元空间大小，元空间用于存放类元数据。</li><li><strong>-XX:+PrintGCDetails</strong> 和 <strong>-XX:+PrintGCDateStamps</strong>：打印垃圾收集细节和时间戳。</li><li><strong>-Xloggc</strong>：将GC日志写入指定文件。</li><li><strong>-XX:+UseGCLogFileRotation</strong> 和 <strong>-XX:NumberOfGCLogFiles</strong>：开启GC日志文件的轮替和指定GC日志文件的数量。</li></ul><h2 id="JVM调优的步骤"><a href="#JVM调优的步骤" class="headerlink" title="JVM调优的步骤"></a>JVM调优的步骤</h2><p>JVM调优通常遵循以下步骤：</p><ol><li><strong>分析GC日志及dump文件</strong>：判断是否需要优化，确定瓶颈问题点。</li><li><strong>确定JVM调优量化目标</strong>：例如，Heap内存使用率应小于等于70%，Full GC次数应为0或平均间隔时间大于24小时。</li><li><strong>确定JVM调优参数</strong>：根据历史JVM参数来调整。</li><li><strong>依次调优内存、延迟、吞吐量等指标</strong>：对比观察调优前后的差异。</li><li><strong>不断的分析和调整</strong>：直到找到合适的JVM参数配置。</li></ol><h2 id="调优工具"><a href="#调优工具" class="headerlink" title="调优工具"></a>调优工具</h2><p>为了辅助JVM调优，可以使用如GCViewer等工具来分析GC日志文件。这些工具可以提供关于内存占用、GC次数和GC时长等的详细信息，帮助开发者更好地理解和优化JVM的性能。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>JVM调优是一个复杂的过程，可能需要根据应用程序的具体需求进行调整和优化。</li><li>应用性能监控工具可以帮助更好地了解应用的运行情况和调优效果。</li><li>在生产环境中逐渐调整并观察每次调整的效果，避免一次性大规模变更。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP2</title>
    <link href="/2025/05/19/TCP2/"/>
    <url>/2025/05/19/TCP2/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP2"><a href="#TCP2" class="headerlink" title="TCP2"></a>TCP2</h1><blockquote><p>TCP 是面向连接的、<strong>可靠的</strong>、基于字节流的传输层通信协议。</p><p>TCP为什么可靠？</p><ul><li>TCP通过三次握手、四次挥手保证连接的可靠性</li><li>然后通过校验和、序列号确认机制、超时重传、流量控制、拥塞控制等机制保证数据的可靠传输</li></ul></blockquote><h2 id="1-重传机制"><a href="#1-重传机制" class="headerlink" title="1. 重传机制"></a>1. 重传机制</h2><h3 id="1-1-超时重传"><a href="#1-1-超时重传" class="headerlink" title="1.1 超时重传"></a>1.1 超时重传</h3><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><blockquote><p><code>RTT</code>（Round-Trip Time 往返时延）：<strong>数据发送时刻到接收到确认的时刻的差值</strong></p><p><code>RTO</code>（Retransmission Timeout 超时重传时间）</p><p><strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</p></blockquote><p>实际上「报文往返 RTT 的值」是经常变化的，因为我们的网络也是时常变化的。也就因为「报文往返 RTT 的值」 是经常波动变化的，所以「超时重传时间 RTO 的值」应该是一个<strong>动态变化的值</strong>。</p><h3 id="1-2-快速重传"><a href="#1-2-快速重传" class="headerlink" title="1.2 快速重传"></a>1.2 快速重传</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191418177.jpg" alt="快速重传机制"></p><p>当<strong>发送端</strong>同时收到三个<code>ACK2</code>，发送端就知道<code>Seq2</code>没有送到，于是就会立刻重传丢失的<code>Seq2</code>。快速重传的工作方式是当<strong>收到三个相同的 ACK 报文</strong>时，会在定时器过期之前，重传丢失的报文段。</p><p>快速重传解决了超时重传中需要计算超时时间的问题，但它也有别的问题——当<code>Seq2</code>和<code>Seq3</code>都丢失了，发送端收到3个连续的<code>ACK2</code>，它是<strong>不知道<code>Seq3</code>是否丢失</strong>的，这时解决方法有两种：</p><ul><li>只重传<code>Seq2</code>一个报文，那么<code>Seq3</code>的重传还得等到发送端收到3个连续的<code>ACK3</code>，效率很低</li><li>重传<code>Seq2</code>后的所有报文，虽然能够同时重传丢失的<code>Seq2</code>和<code>Seq3</code>，但是后面没有丢失的报文还是会被重传一份，浪费资源</li></ul><h3 id="1-3-SACK-（Selective-Acknowledgment-选择性确认）"><a href="#1-3-SACK-（Selective-Acknowledgment-选择性确认）" class="headerlink" title="1.3 SACK （Selective Acknowledgment, 选择性确认）"></a>1.3 SACK （Selective Acknowledgment, 选择性确认）</h3><p>既然快速重传中发送端不知道哪些报文丢失，那让接收方告诉它不就好了。</p><p>SACK允许接收方告诉发送方哪些报文已收到，哪些丢失了，以减少不必要的数据传输，解决了快速重传中的问题</p><p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191418178.jpg" alt="选择性确认"></p><h3 id="1-4-Duplicate-SACK"><a href="#1-4-Duplicate-SACK" class="headerlink" title="1.4 Duplicate SACK"></a>1.4 Duplicate SACK</h3><p>用于<strong>通知发送方哪些数据被重复接收</strong>了，有助于发送方了解是 <strong>数据丢失</strong> 或 <strong><code>ACK</code>丢失</strong> 或 <strong>网络延迟</strong>导致的重传</p><h2 id="2-滑动窗口"><a href="#2-滑动窗口" class="headerlink" title="2. 滑动窗口"></a>2. 滑动窗口</h2><h3 id="2-1-发送方滑动窗口"><a href="#2-1-发送方滑动窗口" class="headerlink" title="2.1 发送方滑动窗口"></a>2.1 发送方滑动窗口</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191418179.jpg" alt="SND.WND、SND.UN、SND.NXT"></p><ul><li><p><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</p></li><li><p><code>SND.UNA</code>（<em>Send Unacknoleged</em>）：是一个绝对指针，它指向的是<strong>已发送但未收到确认</strong>的第一个字节的序列号，也就是 #2 的第一个字节。</p></li><li><p><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</p></li><li><p>指向 #4 的第一个字节是个相对指针，它需要 <code>SND.UNA</code> 指针加上 <code>SND.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</p></li></ul><h3 id="2-2-接收方滑动窗口"><a href="#2-2-接收方滑动窗口" class="headerlink" title="2.2 接收方滑动窗口"></a>2.2 接收方滑动窗口</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191418180.jpg" alt="接收窗口"></p><ul><li><code>RCV.WND</code>：表示接收窗口的大小，它会通告给发送方。</li><li><code>RCV.NXT</code>：是一个指针，它指向期望从发送方发送来的下一个数据字节的序列号，也就是 #3 的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针，它需要 <code>RCV.NXT</code>指针加上 <code>RCV.WND</code> 大小的偏移量，就可以指向 #4 的第一个字节了。</li></ul><h3 id="2-3-发送方和接收方的滑动窗口大小是相等的吗？"><a href="#2-3-发送方和接收方的滑动窗口大小是相等的吗？" class="headerlink" title="2.3 发送方和接收方的滑动窗口大小是相等的吗？"></a>2.3 发送方和接收方的滑动窗口大小是相等的吗？</h3><p>并不是完全相等，接收窗口的大小是<strong>约等于</strong>发送窗口的大小的。</p><p>当接收方读取数据速度非常快时，它的窗口很快就会空出来，通过TCP报文段中的<code>Windows</code>字段告诉发送方自己的接收窗口大小，这个<strong>传输过程是有时延</strong>的，故两者关系是约等于。</p><h2 id="3-流量控制"><a href="#3-流量控制" class="headerlink" title="3. 流量控制"></a>3. 流量控制</h2><p><strong>发送端根据接收端的实际接收能力控制发送的数据量</strong>（由滑动窗口大小来保证）</p><h3 id="3-1-窗口关闭"><a href="#3-1-窗口关闭" class="headerlink" title="3.1 窗口关闭"></a>3.1 窗口关闭</h3><p>当接收方接收窗口<code>rwnd</code> &#x3D; 0时，窗口关闭，发送方不再发送数据。当接收方处理完数据，给发送方发送<code>ACK</code>并告知发送方自己的接收窗口<code>rwnd</code>增大了，但如果此时<strong>该<code>ACK</code>丢失</strong>了，发送方就不知道接收方窗口已非0，接收方也还在等待发送方发送数据，造成死锁的现象。</p><p>解决方案：TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。<strong>如果持续计时器超时，就会发送</strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><h2 id="4-拥塞控制"><a href="#4-拥塞控制" class="headerlink" title="4. 拥塞控制"></a>4. 拥塞控制</h2><p><strong>流量控制是防止发送方数据填满接收方缓存</strong>，但它无法控制整个网络，当网络拥堵时，继续发送大量数据会导致数据包延时、丢失等，<strong>拥塞控制就是为了防止发送方的数据填满网络</strong>。</p><p>发送方通过维护一个拥塞窗口<code>cwnd</code>，该窗口随网络拥堵情况而动态变化。由于我们前面已知<code>swnd</code>约等于<code>rwnd</code>，那么加入拥塞窗口后，<strong><code>swnd</code> &#x3D; min(<code>cwnd</code>, <code>rwnd</code>)</strong></p><p>下面给出拥塞控制算法：</p><h3 id="4-1-慢启动"><a href="#4-1-慢启动" class="headerlink" title="4.1 慢启动"></a>4.1 慢启动</h3><p>TCP连接建立后，先不要发大量的数据，初始化<code>cwnd</code> &#x3D; 1<code>MSS</code>，每收到一个<code>ACK</code>，<code>cwnd</code> +&#x3D; 1<code>MSS</code>，直到<code>cwnd</code>达到<strong>慢启动阈值<code>ssthresh</code></strong>，进入拥塞避免算法</p><p>慢启动过程窗口<code>cwnd</code>的增长是指数级别的</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191418181.jpg" alt="慢启动算法"></p><h3 id="4-2-拥塞避免算法"><a href="#4-2-拥塞避免算法" class="headerlink" title="4.2 拥塞避免算法"></a>4.2 拥塞避免算法</h3><p>进入拥塞避免算法后，它的规则是：<strong>每当收到一个 <code>ACK</code> 时，<code>cwnd</code> 增加 1&#x2F;<code>cwnd</code>。</strong></p><p>接上前面的慢启动的例子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p><ul><li>当 8 个 <code>ACK</code> 应答确认到来时，每个确认增加 1&#x2F;8，8 个 ACK 确认 <code>cwnd</code> 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li></ul><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。<strong>当触发了重传机制，也就进入了「拥塞发生算法」</strong>。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191418182.jpg" alt="拥塞避免"></p><h3 id="4-3-拥塞发生算法"><a href="#4-3-拥塞发生算法" class="headerlink" title="4.3 拥塞发生算法"></a>4.3 拥塞发生算法</h3><p>重传机制主要有两种：</p><ul><li><p>超时重传：<code>ssthresh</code> &#x3D; <code>cwnd</code> &#x2F; 2，<code>cwnd</code> &#x3D; 1，<strong>进入慢启动</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191418183.jpg" alt="拥塞发送 —— 超时重传"></p></li><li><p>快速重传：<code>cwnd</code> &#x3D; <code>cwnd</code> &#x2F; 2，<code>ssthresh</code> &#x3D; <code>cwnd</code>，进入<strong>快速恢复算法</strong></p></li></ul><h3 id="4-4-快速恢复算法"><a href="#4-4-快速恢复算法" class="headerlink" title="4.4 快速恢复算法"></a>4.4 快速恢复算法</h3><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像超时重传那么强烈。</p><p>进入快速恢复之前，<code>cwnd</code>与<code>ssthresh</code>已经被更新了：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li></ul><p>然后进入快速恢复：</p><ul><li><p><strong><code>cwnd</code> &#x3D; <code>ssthresh</code> + 3</strong></p><blockquote><p>+3的原因</p><p>发送方收到3个重复的<code>ACK</code>，说明有3个数据已经被成功发送到接收方，它们已经离开网络了，<strong>这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中</strong>，可见现在网络中不是堆积了报文段而是减少了3个报文段，因此可以适当把拥塞窗口扩大些</p></blockquote></li><li><p>重传丢失的数据（即被重复的<code>ACK</code>）</p></li><li><p>若再收到重复的<code>ACK</code>，<code>cwnd</code> &#x3D; <code>cwnd</code> + 1（+1的道理同上）</p></li><li><p>若收到新的<code>ACK</code>，说明恢复过程已结束，令<code>cwnd</code> &#x3D; <code>ssthresh</code>，<strong>再次进入拥塞避免算法</strong></p><blockquote><p>为什么要<code>cwnd</code> &#x3D; <code>ssthresh</code>？</p><p>如果不将拥塞窗口设置回ssthresh的话，而是在原先的基础上进行拥塞避免，线性增长的话（<strong>起点较高</strong>，因为原先就是在这个节点附近触发的拥塞），会<strong>容易再次导致网络拥塞</strong>，导致丢包，又再次触发相应的快速重传快速恢复机制，导致发生概率较高，这就严重拖慢了协议的性能，因此需要<strong>将拥塞窗口先回退到一个较低的水平</strong>，一次先少发点数据，这样尽量避免拥塞重传，提高性能。</p></blockquote></li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191418184.png" alt="快速重传和快速恢复"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP1</title>
    <link href="/2025/05/19/TCP1/"/>
    <url>/2025/05/19/TCP1/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP1"><a href="#TCP1" class="headerlink" title="TCP1"></a>TCP1</h1><blockquote><p>引用：小林coding</p></blockquote><h2 id="1-什么是TCP"><a href="#1-什么是TCP" class="headerlink" title="1. 什么是TCP"></a>1. 什么是TCP</h2><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191110448.png" alt="TCP 头格式"></p><h2 id="2-TCP与UDP区别"><a href="#2-TCP与UDP区别" class="headerlink" title="2. TCP与UDP区别"></a>2. TCP与UDP区别</h2><table><thead><tr><th></th><th align="left">TCP</th><th>UDP</th></tr></thead><tbody><tr><td>连接</td><td align="left">TCP 是面向连接的传输层协议，传输数据前先要建立连接。</td><td>UDP 是不需要连接，即刻传输数据。</td></tr><tr><td>服务对象</td><td align="left">TCP 是一对一的两点服务，即一条连接只有两个端点。</td><td>UDP 支持一对一、一对多、多对多的交互通信</td></tr><tr><td>可靠性</td><td align="left">TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</td><td>UDP 是尽最大努力交付，不保证可靠交付数据。</td></tr><tr><td>拥塞控制、流量控制</td><td align="left">TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</td><td>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</td></tr><tr><td>首部开销</td><td align="left">TCP 首部长度较长，会有一定的开销。</td><td>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</td></tr><tr><td>传输方式</td><td align="left">TCP 是流式传输，没有边界，但保证顺序和可靠。</td><td>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</td></tr><tr><td>分片不同</td><td align="left">TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片</td><td>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片</td></tr></tbody></table><h2 id="3-TCP三次握手"><a href="#3-TCP三次握手" class="headerlink" title="3. TCP三次握手"></a>3. TCP三次握手</h2><h3 id="3-1-三次握手建立过程"><a href="#3-1-三次握手建立过程" class="headerlink" title="3.1 三次握手建立过程"></a>3.1 三次握手建立过程</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191110450.png" alt="TCP 三次握手"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191110451.png" alt="第一个报文 —— SYN 报文"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191110452.png" alt="第二个报文 —— SYN + ACK 报文"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191110453.png" alt="第三个报文 —— ACK 报文"></p><p>其中第三次握手是<strong>可以携带数据</strong>的</p><h3 id="3-2-为什么是三次握手，而不是两次、四次？"><a href="#3-2-为什么是三次握手，而不是两次、四次？" class="headerlink" title="3.2 为什么是三次握手，而不是两次、四次？"></a>3.2 为什么是三次握手，而不是两次、四次？</h3><ul><li><p>三次握手可以<strong>阻止重复的历史连接</strong>（最重要）</p><blockquote><p>由于网络超时导致客户端报文超时重发，序列号机制可以确保之前阻塞在网络中的报文不会起作用</p></blockquote></li><li><p>三次握手才可以同步双方的初始序列号</p><blockquote><p>客户端<code>SYN</code>报文告诉对方自己的初始序列号<code>client_isn</code>，服务端<code>ACK</code>这个报文<code>client_isn + 1</code>，<code>SYN</code>报文告诉对方自己的初始序列号<code>server_isn</code>，客户端<code>ACK</code>这个报文<code>server_isn + 1</code></p><p>序列号是TCP可靠传输的一个重要机制：</p><ul><li>接收方可以去除重复的数据；</li><li>接收方可以根据数据包的序列号按序接收；</li><li>可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 <code>ACK </code>报文中的序列号知道）；</li></ul></blockquote></li><li><p>三次握手可以避免资源浪费</p><blockquote><p>若只有两次握手，那么服务端回复<code>ACK</code>+<code>SYN</code>报文后，不知道对方能不能接收到，于是都会建立连接，如果客户端因为网络阻塞发送了多个<code>SYN</code>报文，服务端这边就会建立多个连接，造成资源浪费</p></blockquote></li></ul><p>故不用「两次握手」与「四次握手」的原因：</p><ul><li>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</li><li>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</li></ul><h3 id="3-3-为什么每次建立TCP连接时，初始序列号都不相同"><a href="#3-3-为什么每次建立TCP连接时，初始序列号都不相同" class="headerlink" title="3.3 为什么每次建立TCP连接时，初始序列号都不相同"></a>3.3 为什么每次建立TCP连接时，初始序列号都不相同</h3><p>若每次初始序列号都从0开始，<strong>很容易出现历史报文被下一个相同四元组的连接接收的问题</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191110454.png" alt="img"></p><h3 id="3-4-三次握手丢失分别会发生什么？"><a href="#3-4-三次握手丢失分别会发生什么？" class="headerlink" title="3.4 三次握手丢失分别会发生什么？"></a>3.4 三次握手丢失分别会发生什么？</h3><ul><li>第一次握手丢失：客户端由于没收到回应，超时重传<code>SYN</code>报文</li><li>第二次握手丢失：客户端由于没收到回应，超时重传<code>SYN</code>报文；服务端由于没收到回应，超时重传<code>ACK</code>+<code>SYN</code>报文</li><li>第三次握手丢失：<strong><code>ACK</code> 报文是不会有重传的，当 <code>ACK</code> 丢失了，就由对方重传对应的报文</strong>，即服务端超时重传<code>ACK</code>+<code>SYN</code>报文</li></ul><h2 id="4-TCP四次挥手"><a href="#4-TCP四次挥手" class="headerlink" title="4. TCP四次挥手"></a>4. TCP四次挥手</h2><h3 id="4-1-四次挥手建立过程"><a href="#4-1-四次挥手建立过程" class="headerlink" title="4.1 四次挥手建立过程"></a>4.1 四次挥手建立过程</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505191110455.png" alt="客户端主动关闭连接 —— TCP 四次挥手"></p><ul><li>关闭连接时，客户端向服务端发送 <code>FIN</code> 时，仅仅表示客户端不再发送数据了但是还能接收数据。</li><li>服务端收到客户端的 <code>FIN</code> 报文时，先回一个 <code>ACK</code> 应答报文，<strong>服务端可能还有数据需要处理和发送</strong>，等服务端不再发送数据时，才发送 <code>FIN</code> 报文给客户端来表示同意现在关闭连接。</li></ul><p>从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 <code>ACK</code> 和 <code>FIN</code> 一般都会<strong>分开发送</strong>，因此是需要四次挥手。</p><h3 id="4-2-四次挥手分别丢失会发生什么？"><a href="#4-2-四次挥手分别丢失会发生什么？" class="headerlink" title="4.2 四次挥手分别丢失会发生什么？"></a>4.2 四次挥手分别丢失会发生什么？</h3><ul><li>第一次挥手丢失：客户端超时重发<code>FIN</code>报文</li><li>第二次挥手丢失：由于<code>ACK</code>报文是不会重发的，故客户端超时重发<code>FIN</code>报文</li><li>第三次挥手丢失：服务端超时重传<code>FIN</code>报文</li><li>第四次挥手丢失：服务端超时重传<code>FIN</code>报文</li></ul><h3 id="4-3-为什么TIME-WAIT等待的时间是2MSL？"><a href="#4-3-为什么TIME-WAIT等待的时间是2MSL？" class="headerlink" title="4.3 为什么TIME_WAIT等待的时间是2MSL？"></a>4.3 为什么TIME_WAIT等待的时间是2MSL？</h3><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p><p>当客户端第四次挥手<code>ACK</code>报文没有传到服务端，服务端会超时重传第三次挥手的<code>FIN</code>报文，<code>TIME_WAIT</code>设置成<code>2MSL</code>可以<strong>保证客户端能够收到这个重传的<code>FIN</code>报文</strong>，收到重传报文后刷新<code>TIME_WAIT</code>时间并重发<code>ACK</code></p><p><code>TIME_WAIT</code>的作用：</p><ul><li><p>为了防止历史连接中的数据，被后面相同四元组的连接错误的接收，因此 TCP 设计了 TIME_WAIT 状态，状态会持续 <code>2MSL</code> 时长，这个时间<strong>足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的</strong></p></li><li><p><strong>等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP</title>
    <link href="/2025/05/17/HTTP/"/>
    <url>/2025/05/17/HTTP/</url>
    
    <content type="html"><![CDATA[<p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505171457205.jpg" alt="图片"></p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><blockquote><p>引用：小林coding</p></blockquote><h2 id="1-HTTP基本知识"><a href="#1-HTTP基本知识" class="headerlink" title="1. HTTP基本知识"></a>1. HTTP基本知识</h2><h3 id="1-1-HTTP是什么"><a href="#1-1-HTTP是什么" class="headerlink" title="1.1 HTTP是什么"></a>1.1 HTTP是什么</h3><p>HTTP 是超文本传输协议，也就是<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol。</p><h3 id="1-2-HTTP常见的状态码有哪些"><a href="#1-2-HTTP常见的状态码有哪些" class="headerlink" title="1.2 HTTP常见的状态码有哪些"></a>1.2 HTTP常见的状态码有哪些</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505171457297.jpg" alt="图片"></p><ul><li><p><em>1xx</em></p><blockquote><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。</p></blockquote></li><li><p><em>2xx</em></p><blockquote><p><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p></blockquote><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</li></ul></li><li><p><em>3xx</em></p><blockquote><p><code>3xx</code> 类状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p></blockquote><ul><li><p>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</p></li><li><p>「<strong>302 Moved Permanently</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</p><p>301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL</p></li><li><p>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</p></li></ul></li><li><p><em>4xx</em></p><blockquote><p><code>4xx</code> 类状态码表示<strong>客户端发送的报文有误</strong>，服务器无法处理，也就是错误码的含义。</p></blockquote><ul><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul></li><li><p><em>5xx</em></p><blockquote><p><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p></blockquote><ul><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应服务器，类似“网络服务正忙，请稍后重试”的意思。</li></ul></li></ul><h3 id="1-3-HTTP常见字段"><a href="#1-3-HTTP常见字段" class="headerlink" title="1.3 HTTP常见字段"></a>1.3 HTTP常见字段</h3><ul><li><code>Host</code>：客户端发送请求时，用来指定服务器的域名。</li><li><code>Content-Length</code>：服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次回应的数据长度。</li><li><code>Connection</code>：字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。（Connection：Keep-alive）</li><li><code>Content-Type</code>：用于服务器回应时，告诉客户端，本次数据是什么格式。</li><li><code>Content-Encoding</code>：说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式</li></ul><h2 id="2-HTTPS"><a href="#2-HTTPS" class="headerlink" title="2. HTTPS"></a>2. HTTPS</h2><h3 id="2-1-HTTP和HTTPS有什么区别"><a href="#2-1-HTTP和HTTPS有什么区别" class="headerlink" title="2.1 HTTP和HTTPS有什么区别"></a>2.1 HTTP和HTTPS有什么区别</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505171456914.jpeg" alt="HTTP 与 HTTPS 网络层"></p><ul><li>HTTP明文传输，存在风险；HTTPS加入了SSL&#x2F;TLS协议，报文能够密文传输</li><li>HTTP建立连接只需要TCP三次握手；HTTPS在TCP三次握手后还需要进行SSL&#x2F;TLS握手</li><li>HTTP默认80端口；HTTPS默认443端口</li></ul><h3 id="2-2-TLS握手过程（RSA算法）"><a href="#2-2-TLS握手过程（RSA算法）" class="headerlink" title="2.2 TLS握手过程（RSA算法）"></a>2.2 TLS握手过程（RSA算法）</h3><blockquote><p>SSL&#x2F;TLS 在加密过程中涉及到了两种类型的加密方法：</p><ul><li>非对称加密：服务器向客户端发送公钥，然后客户端用公钥加密自己的随机密钥，也就是会话密钥，发送给服务器，服务器用私钥解密，得到会话密钥。</li><li>对称加密：双方用会话密钥加密通信内容。</li></ul></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505171456663.png" alt="img"></p><h4 id="TLS第一次握手"><a href="#TLS第一次握手" class="headerlink" title="TLS第一次握手"></a>TLS第一次握手</h4><p>客户端首先会发一个<code>Client Hello</code>消息，这个消息里包含：客户端使用的TLS版本号、支持的密码套件列表（如RSA）、以及生成的<strong>随机数<code>Client Random</code></strong></p><h4 id="TLS第二次握手"><a href="#TLS第二次握手" class="headerlink" title="TLS第二次握手"></a>TLS第二次握手</h4><p>当服务端收到客户端的<code>Client Hello</code>，会确认是否支持客户端的TLS版本号，然后从密码套件列表中选一个密码套件，以及生成一个<strong>随机数<code>Server Random</code></strong>，然后返回<code>Server Hello</code>消息</p><p>然后，服务端为了证明自己的身份（没有被别人冒充），会发送<code>Server Certificate</code>给客户端，这个消息里含有<strong>数字证书</strong></p><p>最后，服务端发送<code>Server Hello Done</code></p><h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>一个证书通常包含了：</p><ul><li><strong>公钥</strong></li><li>持有者消息</li><li>证书认证机构（CA）的消息</li><li>CA对这份文件的数字签名及使用的算法</li><li>证书有效期</li></ul><p>下图为证书签发和验证流程：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505171455315.png" alt="img"></p><h4 id="TLS第三次握手"><a href="#TLS第三次握手" class="headerlink" title="TLS第三次握手"></a>TLS第三次握手</h4><p>客户端验证完证书后，认为可信则继续往下走。</p><p>客户端生成一个新的随机数<code>pre-master</code>，用服务器的RSA公钥加密<code>pre-master</code>，通过消息<code>Client Key Exchange</code>传给服务端，服务端收到后用RSA私钥解密</p><p>至此，客户端和服务端都得到了三个随机数：<code>Client Random</code>、<code>Server Random</code>、<code>pre-master</code>，<strong>基于这三个随机数生成一个会话密钥</strong>，用于后续信息传递的加解密</p><p>生成会话密钥后，客户端发一个<code>Change Cipher Spec</code>消息，告诉服务端开始使用加密方式发送消息</p><p>然后客户端再发一个<code>Encrypted Handshake Message(Finished)</code>消息，把之前所有握手数据做一个摘要</p><h4 id="TLS第四次握手"><a href="#TLS第四次握手" class="headerlink" title="TLS第四次握手"></a>TLS第四次握手</h4><p>服务端也发回<code>Change Cipher Spec</code>和<code>Encrypted Handshake Message</code>，握手正式完成</p><p>然后就能用会话密钥进行加密报文传输了</p><h2 id="3-HTTP1-0、1-1、2-0的区别"><a href="#3-HTTP1-0、1-1、2-0的区别" class="headerlink" title="3. HTTP1.0、1.1、2.0的区别"></a>3. HTTP1.0、1.1、2.0的区别</h2><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><ul><li><strong>无状态协议</strong>：HTTP 1.0 是无状态的，每个请求之间相互独立，服务器不保存任何请求的状态信息。</li><li><strong>非持久连接</strong>：默认情况下，每个 HTTP 请求&#x2F;响应对之后，连接会被关闭，属于短连接。这意味着对于同一个网站的每个资源请求，如 HTML 页面上的图片和脚本，都需要建立一个新的 TCP 连接。可以设置<code>Connection: keep-alive</code> 强制开启长连接。</li></ul><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><ul><li><strong>持久连接</strong>：HTTP 1.1 引入了持久连接（也称为 HTTP keep-alive），默认情况下不会立即关闭连接，可以在一个连接上发送多个请求和响应。极大减轻了 TCP 连接的开销。</li><li><strong>流水线处理</strong>：HTTP 1.1 支持客户端在前一个请求的响应到达之前发送下一个请求，以提高传输效率。</li></ul><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><ul><li><p><strong>二进制协议</strong>：HTTP 2.0 使用二进制而不是文本格式来传输数据，解析更加高效。</p></li><li><p><strong>多路复用</strong>：一个 TCP 连接上可以同时进行多个 HTTP 请求&#x2F;响应，解决了 HTTP 1.x 的队头阻塞问题。</p><blockquote><p>持久化连接允许多个请求通过同一个TCP连接发送，而管线化则允许客户端在不等待前一个请求响应的情况下发送多个请求。然而，响应必须按照请求的顺序接收，这就导致了队头阻塞的问题</p></blockquote></li><li><p><strong>头部压缩</strong>：HTTP 协议不带状态，所以每次请求都必须附上所有信息。HTTP 2.0 引入了头部压缩机制，可以使用 gzip 或 compress 压缩后再发送，减少了冗余头部信息的带宽消耗。</p></li><li><p><strong>服务端推送</strong>：服务器可以主动向客户端推送资源，而不需要客户端明确请求。</p></li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505171456048.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Interceptor</title>
    <link href="/2025/05/17/Interceptor/"/>
    <url>/2025/05/17/Interceptor/</url>
    
    <content type="html"><![CDATA[<h1 id="拦截器Interceptor的使用及原理"><a href="#拦截器Interceptor的使用及原理" class="headerlink" title="拦截器Interceptor的使用及原理"></a>拦截器Interceptor的使用及原理</h1><blockquote><p>引用：<a href="https://blog.csdn.net/qq_45875349/article/details/139187564?fromshare=blogdetail&sharetype=blogdetail&sharerId=139187564&sharerefer=PC&sharesource=m0_51140831&sharefrom=from_link">https://blog.csdn.net/qq_45875349/article/details/139187564?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=139187564&amp;sharerefer=PC&amp;sharesource=m0_51140831&amp;sharefrom=from_link</a></p></blockquote><h2 id="1-拦截器的实现"><a href="#1-拦截器的实现" class="headerlink" title="1. 拦截器的实现"></a>1. 拦截器的实现</h2><p>在 Spring Boot 应用程序开发中，拦截器（Interceptor）是一个非常有用的工具。它允许我们在 HTTP 请求到达 <strong>Controller</strong> 之前或响应离开 Controller 之后执行一些自定义逻辑。拦截器的实现可以分为以下两个步骤：</p><ol><li>创建自定义拦截器：<strong>实现<code>HandlerInterceptor</code>接口并重写接口的<code>preHander</code>方法</strong>（执行具体方法之前的预处理方法）</li><li>注册定义拦截器：<strong>将⾃定义拦截器加⼊ <code>WebMvcConfigurer</code> 的 <code>addInterceptors</code> ⽅法中</strong> （自定义配置类实现<code>WebMvcConfigurer</code> 并且重写<code>addInterceptors</code>方法，重写<code>addInterceptors</code>方法的目的就是将自定义的拦截器注册到项目中，在这个过程中可以配置拦截规则）</li></ol><h3 id="1-1-创建自定义拦截器"><a href="#1-1-创建自定义拦截器" class="headerlink" title="1.1 创建自定义拦截器"></a>1.1 创建自定义拦截器</h3><p>首先，我们需要创建一个实现 <code>HandlerInterceptor</code> 接口的类。<code>HandlerInterceptor</code> 接口提供了三个方法：</p><ul><li><code>preHandle</code>：在请求处理之前调用</li><li><code>postHandle</code>：在请求处理之后调用，但在视图渲染之前</li><li><code>afterCompletion</code>：在整个请求完成之后调用，通常用于资源清理</li></ul><p>下面给出一个登录拦截的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*自定义拦截器 实现HandlerInterceptor接口 */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br> <br>    <span class="hljs-comment">// 调用目标方法之前执行的方法</span><br>    <span class="hljs-comment">// 此方法返回 boolean 类型的值，</span><br>    <span class="hljs-comment">// 如果返回的是true 表示（拦截器）验证成功，继续走后续的流程，执行目标方法</span><br>    <span class="hljs-comment">// 如果返回的是 false 表示拦截器验证失败，后续的流程和目标方法就不执行。</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//用户登录判断业务</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span>(session != <span class="hljs-literal">null</span> &amp;&amp; session.getAttribute(<span class="hljs-string">&quot;admin&quot;</span>)!=<span class="hljs-literal">null</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;登录了&quot;</span>);<br>            <span class="hljs-comment">// 用户已登录了</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//用户没有登录</span><br>        System.out.println(<span class="hljs-string">&quot;还没有登录&quot;</span>);<br>        response.sendRedirect(<span class="hljs-string">&quot;/user/login&quot;</span>);<span class="hljs-comment">//可以重定向到系统的登录路由</span><br>        <span class="hljs-comment">//response.setStatus(401);//向前端返回相应的状态码  401：没有权限</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-注册自定义拦截器"><a href="#1-2-注册自定义拦截器" class="headerlink" title="1.2 注册自定义拦截器"></a>1.2 注册自定义拦截器</h3><p>在自定义拦截器之后我们还需要将自定义的拦截器注册到系统的配置中</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505171059707.png" alt="img"></p><ul><li><code>addPathPatterns</code>：表示需要拦截的 URL，“**”表示拦截任意⽅法（也就是所有⽅法）</li><li><code>excludePathPatterns</code>：表示需要排除的 URL</li><li><code>addInterceptors</code>方法里可以一次注册多个拦截器，按照拦截器的注册顺序进行拦截，如果前面的拦截器返回false即在前面拦截了，就不会执行后面的拦截器的逻辑</li></ul><h2 id="2-拦截器实现原理"><a href="#2-拦截器实现原理" class="headerlink" title="2. 拦截器实现原理"></a>2. 拦截器实现原理</h2><p>所有的 Controller 执⾏都会通过⼀个调度器 DispatcherServlet 来实现，这⼀点可以从 Spring Boot 控制台的打印信息看出，如下图所示：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505171059708.png" alt="img"></p><p>⽽<mark>所有⽅法都会执⾏ DispatcherServlet 中的 doDispatch 调度⽅法</mark>，doDispatch 源码如下 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">processedRequest</span> <span class="hljs-operator">=</span> request;<br><span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">mappedHandler</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">multipartRequestParsed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br> <br><span class="hljs-type">WebAsyncManager</span> <span class="hljs-variable">asyncManager</span> <span class="hljs-operator">=</span> WebAsyncUtils.getAsyncManager(request);<br> <br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Exception</span> <span class="hljs-variable">dispatchException</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br> <br><span class="hljs-keyword">try</span> &#123;<br>processedRequest = checkMultipart(request);<br>multipartRequestParsed = (processedRequest != request);<br> <br><span class="hljs-comment">// Determine handler for the current request.</span><br>mappedHandler = getHandler(processedRequest);<br><span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-literal">null</span>) &#123;<br>noHandlerFound(processedRequest, response);<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-comment">// Determine handler adapter for the current request.</span><br><span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> getHandlerAdapter(mappedHandler.getHandler());<br> <br><span class="hljs-comment">// Process last-modified header, if supported by the handler.</span><br><span class="hljs-type">String</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> request.getMethod();<br><span class="hljs-type">boolean</span> <span class="hljs-variable">isGet</span> <span class="hljs-operator">=</span> HttpMethod.GET.matches(method);<br><span class="hljs-keyword">if</span> (isGet || HttpMethod.HEAD.matches(method)) &#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">lastModified</span> <span class="hljs-operator">=</span> ha.getLastModified(request, mappedHandler.getHandler());<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletWebRequest</span>(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br> <br>        <span class="hljs-comment">// 关键部分：验证所有拦截器的preHandle方法是否返回true</span><br><span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-comment">// Actually invoke the handler.</span><br>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br> <br><span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br> <br>applyDefaultViewName(processedRequest, mv);<br>mappedHandler.applyPostHandle(processedRequest, response, mv);<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>dispatchException = ex;<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable err) &#123;<br><span class="hljs-comment">// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,</span><br><span class="hljs-comment">// making them available for @ExceptionHandler methods and other scenarios.</span><br>dispatchException = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;Handler dispatch failed: &quot;</span> + err, err);<br>&#125;<br>processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>triggerAfterCompletion(processedRequest, response, mappedHandler, ex);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>triggerAfterCompletion(processedRequest, response, mappedHandler,<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletException</span>(<span class="hljs-string">&quot;Handler processing failed: &quot;</span> + err, err));<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br><span class="hljs-comment">// Instead of postHandle and afterCompletion</span><br><span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-literal">null</span>) &#123;<br>mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// Clean up any resources used by a multipart request.</span><br><span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;<br>cleanupMultipart(processedRequest);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述源码可以看出在<mark>开始执⾏ Controller 之前，会先调⽤ 预处理⽅法 applyPreHandle</mark>，而applyPreHandle ⽅法的实现源码如下：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505171059709.png" alt="img"></p><p>从上述源码可以看出，在 applyPreHandle 中会获取所有的拦截器 HandlerInterceptor 并执⾏拦截器中的 preHandle ⽅法</p><h2 id="3-拦截器链配置"><a href="#3-拦截器链配置" class="headerlink" title="3. 拦截器链配置"></a>3. 拦截器链配置</h2><p>我们只添加了一个拦截器，如果有多个，该如何配置？配置多个后，执行顺序是什么？</p><p><code>preHandle</code>：与配置顺序相同，必定运行</p><p><code>postHandle</code>：与配置顺序相反，可能不运行</p><p><code>afterCompletion</code>：与配置顺序相反，可能不运行。</p><ul><li>当配置多个拦截器时，形成拦截器链</li><li>拦截器链的运行顺序参照拦截器添加顺序为准</li><li>当拦截器中出现对原始处理器的拦截，后面的拦截器均终止运行</li><li>当拦截器运行中断，仅运行配置在前面的拦截器的<code>afterCompletion</code>操作</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-垃圾回收器</title>
    <link href="/2025/05/16/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <url>/2025/05/16/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM——垃圾回收器"><a href="#JVM——垃圾回收器" class="headerlink" title="JVM——垃圾回收器"></a>JVM——垃圾回收器</h1><h2 id="1-垃圾回收器分类"><a href="#1-垃圾回收器分类" class="headerlink" title="1. 垃圾回收器分类"></a>1. 垃圾回收器分类</h2><p>分类标准：串行&#x2F;并行、并发&#x2F;独占、压缩式&#x2F;非压缩式、年轻代&#x2F;老年代</p><h2 id="2-回收器评价标准"><a href="#2-回收器评价标准" class="headerlink" title="2. 回收器评价标准"></a>2. 回收器评价标准</h2><ul><li>吞吐量：$\frac{t_{运行用户代码}}{t_{运行用户代码} + t_{垃圾回收}}$，即尽可能让单位时间内的STW时间最短</li><li>暂停时间：尽可能让单次STW时间最短</li></ul><h2 id="3-Serial回收器"><a href="#3-Serial回收器" class="headerlink" title="3. Serial回收器"></a>3. Serial回收器</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505161338540.png" alt="Serial 收集器"></p><p>串行；年轻代为Serial（标记-复制算法），老年代为Serial Old（标记-整理算法）</p><h2 id="4-ParNew回收器"><a href="#4-ParNew回收器" class="headerlink" title="4. ParNew回收器"></a>4. ParNew回收器</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505161338542.png" alt="ParNew 收集器 "></p><p>并行；只能用于年轻代（标记-复制算法），老年代仍为Serial-Old</p><h2 id="5-Parallel-Scavenge回收器"><a href="#5-Parallel-Scavenge回收器" class="headerlink" title="5. Parallel Scavenge回收器"></a>5. Parallel Scavenge回收器</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505161338543.png" alt="Parallel Old收集器运行示意图"></p><p>并行；关注吞吐量；年轻代为Parallel Scavenge（标记-复制算法），老年代为Parallel Old（标记-整理算法）</p><h2 id="6-CMS回收器（Concurrent-Mark-Sweep）"><a href="#6-CMS回收器（Concurrent-Mark-Sweep）" class="headerlink" title="6. CMS回收器（Concurrent-Mark-Sweep）"></a>6. CMS回收器（Concurrent-Mark-Sweep）</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505161338544.png" alt="CMS 收集器"></p><p>并发；只能用于老年代，但无法与Parallel Scavenge一起使用</p><h3 id="CMS回收器收集流程"><a href="#CMS回收器收集流程" class="headerlink" title="CMS回收器收集流程"></a>CMS回收器收集流程</h3><ol><li>初始标记：只标记出与GCRoots<strong>直接关联</strong>的对象，会发生STW但时间短</li><li>并发标记：从上面得到的与GCRoots直接关联的对象开始遍历标记，<strong>可与工作线程并发执行</strong>，无需STW</li><li>重新标记：修正并发标记过程中，由于<strong>用户程序继续运行导致标记产生变动的一部分对象的标记记录</strong>，会产生STW但时间也不长</li><li>并发清除：删除标记阶段判断死亡的对象，由于没移动对象（标记-清除），故可以与用户线程并发执行</li></ol><ul><li>优点：并发；低延迟</li><li>缺点：<ul><li>由于采用的是标记-清除算法，会产生<strong>内存碎片</strong>；</li><li>会产生**“浮动垃圾”**：由于并发清除阶段是与工作线程并发执行的，这期间产生的垃圾要等到下次gc次才能清除</li></ul></li></ul><h2 id="7-G1回收器（Garbage-First）"><a href="#7-G1回收器（Garbage-First）" class="headerlink" title="7. G1回收器（Garbage First）"></a>7. G1回收器（Garbage First）</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505161338545.png" alt="G1 收集器"></p><p>G1回收器将堆内存分割为许多个小区域region，<mark>G1跟踪各个region里垃圾堆积<strong>价值</strong>大小（回收获得空间大小 以及 回收所需时间的经验值）</mark>，在后台维护一个优先列表，每次根据允许时间，优先回收价值最大的region</p><h3 id="G1回收器收集流程："><a href="#G1回收器收集流程：" class="headerlink" title="G1回收器收集流程："></a>G1回收器收集流程：</h3><ol><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>筛选回收：制定回收计划，选择多个region作为回收集，把回收集中存活对象复制到空的region中，再清理旧region中的全部空间，需要STW</li></ol><h2 id="8-CMS-G1垃圾回收器的三色标记是什么？"><a href="#8-CMS-G1垃圾回收器的三色标记是什么？" class="headerlink" title="8. CMS G1垃圾回收器的三色标记是什么？"></a>8. <strong>CMS G1垃圾回收器的三色标记是什么？</strong></h2><p>三色标记是用于垃圾回收的标记算法，CMS 和 G1 垃圾回收器都有采用。它将对象分为三种颜色：</p><ul><li><p>白色：初始状态，代表<strong>尚未被垃圾回收器访问的对象</strong>。标记结束仍为白色的对象，意味着未被程序引用，会被当作垃圾回收。</p></li><li><p>灰色：表示对象已被访问，但<strong>它引用的其他对象还没全被访问</strong>，处于“中间状态”。</p></li><li><p>黑色：对<strong>象及其引用的所有对象都已被访问过</strong>。黑色对象在本轮标记中不会被回收。</p></li></ul><p>三色标记能在并发标记时，和用户线程并发执行，提高效率，但可能产生浮动垃圾和对象消失问题。 </p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-垃圾回收算法</title>
    <link href="/2025/05/16/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <url>/2025/05/16/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM——垃圾回收算法"><a href="#JVM——垃圾回收算法" class="headerlink" title="JVM——垃圾回收算法"></a>JVM——垃圾回收算法</h1><blockquote><p>垃圾：运行程序中没有任何指针指向的对象</p></blockquote><h2 id="1-标记阶段"><a href="#1-标记阶段" class="headerlink" title="1. 标记阶段"></a>1. 标记阶段</h2><ol><li><p>引用计数法：每个对象保存一个引用计数器，记录对象被引用的情况</p><ul><li><p>优点：实现简单</p></li><li><p>缺点：计数器增加了存储空间开销；计数器更新增加了时间开销；<strong>无法处理循环引用</strong></p></li></ul></li><li><p>可达性分析：以<strong>GCRoots</strong>集合为起始点，所有存活对象都会被GCRoots集合直接或间接连接</p><blockquote><p>GCRoots：一组必须活跃的引用（虚拟机栈中的引用对象、本地方法栈中的引用对象、方法区中的静态变量和常量、被synchronized所持有的对象……）</p></blockquote></li></ol><h2 id="2-finalize-方法"><a href="#2-finalize-方法" class="headerlink" title="2. finalize()方法"></a>2. finalize()方法</h2><p>若一个对象obj到GCRoots没有引用链，则开始判断：</p><ul><li>若obj没有<strong>重写finalize()方法 或 finalize()方法已被调用过</strong>，则obj被判为不可触及，准备清除；</li><li>若obj<strong>重写了finalize()方法 且 未执行过</strong>，则将obj插入 F-Queue中执行它的finalize()方法，这是它的最后一次逃脱死亡的机会，若执行finalize()方法过程中被引用则逃离死亡，这之后若再出现没有引用的情况就会直接被判为不可触及</li></ul><h2 id="3-清除阶段"><a href="#3-清除阶段" class="headerlink" title="3. 清除阶段"></a>3. 清除阶段</h2><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>从GCRoots出发，标记所有被引用的对象，然后对堆内存遍历，回收那些未被标记的对象。</p><p>缺点：效率不高；gc时需停止整个应用程序；<strong>有内存碎片</strong></p><h3 id="3-2-标记-复制算法"><a href="#3-2-标记-复制算法" class="headerlink" title="3.2 标记-复制算法"></a>3.2 标记-复制算法</h3><p>将内存空间分为两块，每次只使用其中一块，gc时将存活对象复制到另一块内存，然后清空当前内存块</p><p>优点：<strong>不会出现内存碎片</strong></p><p>缺点：需要<strong>两倍的内存空间</strong>；若<strong>大量对象存活</strong>，则需复制的对象较多，效率低</p><h3 id="3-3-标记-整理算法"><a href="#3-3-标记-整理算法" class="headerlink" title="3.3 标记-整理算法"></a>3.3 标记-整理算法</h3><p>从GCRoots出发，标记所有被引用的对象，然后将所有存活对象压缩到内存的一端，然后清理边界外的空间</p><p>优点：消除了“标记-清除”中的内存碎片，内存地址连续；消除了“标记-复制”中内存减半的代价</p><p>缺点：效率低于复制算法；移动对象需调整引用地址</p><h2 id="4-Stop-the-World"><a href="#4-Stop-the-World" class="headerlink" title="4. Stop-the-World"></a>4. Stop-the-World</h2><p>STW，指gc发生过程中产生应用程序的停顿</p><h2 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h2><ul><li>强引用Strong Reference：代码中普遍存在的赋值引用，只要强引用关系还在，对象就不会被回收</li><li>软引用Soft Reference：系统将要发生内存溢出时，才将这些对象纳入回收范围，回收后内存还是不足才报错OOM</li><li>弱引用Weak Reference：弱引用对象只能存活到下一次gc</li><li>虚引用Phantom Reference：一个对象是否有虚引用存在，不会对其生存时间产生影响，设置虚引用的唯一目的：这个对象被回收后收到一个系统通知</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-字符串常量池</title>
    <link href="/2025/05/16/JVM-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
    <url>/2025/05/16/JVM-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM——字符串常量池StringTable"><a href="#JVM——字符串常量池StringTable" class="headerlink" title="JVM——字符串常量池StringTable"></a>JVM——字符串常量池StringTable</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>JDK8及以前：final char[] value</li><li>JDK9及以后：final byte[] value</li></ul><p>因为大多数字符串只包括拉丁字符，只需1字节的存储空间，而char占2字节，若使用char[]，会有将近一半空间被浪费</p><h2 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h2><ul><li>String类型声明为final，说明String不可被继承</li><li>String内部存储内容的也是一个final数组，说明引用地址不变</li></ul><h2 id="字符串的拼接操作"><a href="#字符串的拼接操作" class="headerlink" title="字符串的拼接操作"></a>字符串的拼接操作</h2><ul><li>常量 + 常量：拼接结果在常量池（编译期优化）</li><li>常量 + 变量 &#x2F; 变量 + 常量 &#x2F; 变量 + 变量：拼接结果在堆中（底层创建一个<strong>StringBuilder对象</strong>用于拼接）</li></ul><h2 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h2><p>native方法，底层由C语言实现。判断字符串常量池中是否存在对应的值，若存在，则直接返回该字符串在常量池中的地址；若不存在，先在字符串常量池中加载一份，然后返回其在字符串常量池中的地址</p><p><mark>对于程序中存在很多重复字符串时，使用intern方法可以节省很大的内存空间</mark></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 由于s1是拼接得到的，故此时字符串常量池中只有“a”和“b”，没有“ab”</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s1.intern();<br></code></pre></td></tr></table></figure><ul><li>在JDK6时，<mark>由于字符串常量池中没有“ab”，执行s1.intern()会在常量池中创建一个“ab”，s2会指向这个常量池中的“ab”</mark>；</li><li>而在JDK7&#x2F;8时，由于堆中已经有s1 &#x3D; new String(“ab”)了，<mark>为了<strong>节省空间</strong>，直接将堆中s1的引用地址存储在字符串常量池中</mark>（即“ab” &#x3D;&#x3D; s1），即<strong>s2指向的是s1在堆中的地址</strong></li></ul><p>因此在JDK6中：s1 &#x3D;&#x3D; “ab”为false，s2 &#x3D;&#x3D; “ab”为true；</p><p>而在JDK7&#x2F;8中：s1 &#x3D;&#x3D; “ab” 与 s2 &#x3D;&#x3D; “ab”均为true，因为s2和“ab”指向的都是s1</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-执行引擎</title>
    <link href="/2025/05/16/JVM-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
    <url>/2025/05/16/JVM-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM——执行引擎"><a href="#JVM——执行引擎" class="headerlink" title="JVM——执行引擎"></a>JVM——执行引擎</h1><h2 id="为什么说JAVA是“半编译半解释型”语言？"><a href="#为什么说JAVA是“半编译半解释型”语言？" class="headerlink" title="为什么说JAVA是“半编译半解释型”语言？"></a>为什么说JAVA是“半编译半解释型”语言？</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505161056353.jpg" alt="IMG_4078"></p><h2 id="JVM的编译器"><a href="#JVM的编译器" class="headerlink" title="JVM的编译器"></a>JVM的编译器</h2><ul><li>Client Compiler（C1）：注重启动速度、局部优化</li><li>Server Compiler（C2）：注重全局优化</li></ul><h2 id="JVM的分层编译"><a href="#JVM的分层编译" class="headerlink" title="JVM的分层编译"></a>JVM的分层编译</h2><ul><li>层级0：解释器</li><li>层级1：C1编译器+轻量级优化</li><li>层级2：C1编译器+完整优化</li><li>层级3：C1编译器+分析数据收集</li><li>层级4：C2编译器</li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-运行时数据区</title>
    <link href="/2025/05/16/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <url>/2025/05/16/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM——运行时数据区"><a href="#JVM——运行时数据区" class="headerlink" title="JVM——运行时数据区"></a>JVM——运行时数据区</h1><blockquote><p>运行时数据区包含：PC寄存器、本地方法栈、<strong>虚拟机栈</strong>、<strong>堆</strong>、元数据区、CodeCache</p></blockquote><h2 id="1-PC寄存器"><a href="#1-PC寄存器" class="headerlink" title="1. PC寄存器"></a>1. PC寄存器</h2><p>存储下一条指令的地址（线程私有）</p><p>不存在StackOverflowError和OutofMemoryError</p><h2 id="2-本地方法栈"><a href="#2-本地方法栈" class="headerlink" title="2. 本地方法栈"></a>2. 本地方法栈</h2><p>管理本地方法的调用（线程私有）</p><p>存在StackOverflowError和OutofMemoryError</p><h2 id="3-虚拟机栈"><a href="#3-虚拟机栈" class="headerlink" title="3. 虚拟机栈"></a>3. 虚拟机栈</h2><p>线程私有，内部保存一个个<strong>栈帧</strong>，对应一次次java方法调用</p><p>每个栈帧存储着：</p><ul><li><p><strong>局部变量表</strong>：用于存储方法参数与定义在方法内部的局部变量</p><p>最基本的存储单元是<strong>变量槽slot</strong>，32位以内的类型占1个slot，64位的占2个slot；若一个局部变量过了其作用域，其slot可复用</p></li><li><p><strong>操作数栈</strong>：用于保存计算过程的<strong>中间结果</strong>，同时用于计算过程中变量临时的存储空间</p></li><li><p><strong>动态链接</strong>：每个栈帧内部包含一个<mark>指向运行时常量池中该栈帧所属方法的引用</mark> （一个栈帧对应一次java方法调用）</p><blockquote><p>当Java源文件编译为class字节码文件时，由于还没运行，所以不知道变量等具体存储在内存中的哪个地方，此时所有变量和引用都只能作为<strong>符号引用</strong>保存在class文件的常量池中，<mark>动态链接就是要将符号引用转化为直接引用</mark></p></blockquote></li><li><p><strong>方法返回地址</strong></p></li><li><p><strong>一些附加信息</strong></p></li></ul><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><p>线程共享，<strong>几乎所有</strong>对象示例和数组都应在运行时分配在堆上</p><blockquote><p>几乎所有：若一个对象在方法内定义，只在方法内使用，则认为没有发生逃逸，可以进行<strong>栈上分配</strong></p></blockquote><h3 id="4-1-堆内存细分"><a href="#4-1-堆内存细分" class="headerlink" title="4.1 堆内存细分"></a>4.1 堆内存细分</h3><ul><li>JDK7及以前：新生代（Eden+Survivor）+老年代+永久代</li><li>JDK8及以后：新生代（Eden+Survivor）+老年代+元空间</li></ul><h3 id="4-2-对象分配过程"><a href="#4-2-对象分配过程" class="headerlink" title="4.2 对象分配过程"></a>4.2 对象分配过程</h3><ol><li>先分配至Eden（若Eden放不下，则先进行Minor gc，若还是放不下，放入老年代，若老年代也放不下，报错OOM）</li><li>Eden内存不足，触发Minor gc，将不再被引用的对象销毁，幸存下来的移动至Survivor0</li><li>若此时再次触发Minor gc，上次幸存至Survivor0的若仍幸存，会将它们移动至Survivor1</li><li>若对象在Survivor0、Survivor1中来回了15次，则会进入到老年代 （15:对象头用一个4位的区域记录对象年龄）</li><li>老年代内存不足触发Major gc</li></ol><h3 id="4-3-堆空间分代思想"><a href="#4-3-堆空间分代思想" class="headerlink" title="4.3 堆空间分代思想"></a>4.3 堆空间分代思想</h3><p>大部分对象是临时对象，将他们放在同一位置（Eden），gc时优先回收</p><h3 id="4-4-对象内存分配策略"><a href="#4-4-对象内存分配策略" class="headerlink" title="4.4 对象内存分配策略"></a>4.4 对象内存分配策略</h3><ol><li>优先分配到Eden</li><li>大对象直接分配到老年代</li><li>长期存活对象分配到老年代</li><li><strong>动态年龄判断</strong>：<mark>Survivor区中相同年龄的对象总和大于Survivor空间一半，年龄 &gt;&#x3D; 该年龄的对象可直接进入老年代</mark></li><li><strong>空间分配担保</strong>：<mark>老年代连续空间大于<strong>新生代对象总大小</strong> 或 <strong>历次晋升平均大小</strong>，说明此时进行Minor gc是安全的</mark>，就会进行Minor gc</li></ol><h3 id="4-5-TLAB（Thread-Local-Allocation-Buffer）"><a href="#4-5-TLAB（Thread-Local-Allocation-Buffer）" class="headerlink" title="4.5 TLAB（Thread Local Allocation Buffer）"></a>4.5 TLAB（Thread Local Allocation Buffer）</h3><p>由于堆是内存共享的，且对象实例的创建在JVM中非常频繁，会带来线程不安全的问题。</p><p>为了避免多个线程操作同一地址，JVM在Eden区中为每个线程分配了一个<strong>私有缓存区域TLAB</strong>，当TLAB满了再使用Eden的公共区域</p><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><p>线程共享，<mark>方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、JIT的CodeCache等</mark>，永久代和元空间可类比为对方法区这一抽象概念的实现</p><p>JDK7及以前称为永久代，JDK8后用元空间取代了永久代，区别在于：永久代使用虚拟机内存，元空间使用本地内存，减少了OOM的概率</p><p>JDK7时，字符串常量池StringTable从永久代被调整到堆中，这是因为永久代回收效率低，而开发中有大量字符串被创建</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM-类加载器子系统</title>
    <link href="/2025/05/16/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/05/16/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM——类加载器子系统"><a href="#JVM——类加载器子系统" class="headerlink" title="JVM——类加载器子系统"></a>JVM——类加载器子系统</h1><blockquote><p>类加载器子系统：负责从文件系统&#x2F;网络中加载class文件</p></blockquote><h2 id="1-类加载器分类"><a href="#1-类加载器分类" class="headerlink" title="1. 类加载器分类"></a>1. 类加载器分类</h2><ul><li>启动类加载器Bootstrap ClassLoader</li><li>扩展类加载器Extension ClassLoader</li><li>系统类加载器AppClassLoader</li><li>用户自定义加载器</li></ul><p>除Bootstrap CLassLoader，其他类加载器都继承于ClassLoader</p><h2 id="2-双亲委派机制"><a href="#2-双亲委派机制" class="headerlink" title="2. 双亲委派机制"></a>2. 双亲委派机制</h2><ol><li>一个类加载器收到了类加载请求，先把请求一层层向上面的父类加载器委托，直到Bootstrap ClassLoader</li><li>若父类可加载则直接返回，否则向下层子加载器分配任务</li><li>若分配至AppClassLoader也无法加载，抛出ClassNotFound异常</li></ol><h3 id="双亲委派机制作用"><a href="#双亲委派机制作用" class="headerlink" title="双亲委派机制作用"></a>双亲委派机制作用</h3><ul><li>避免类重复加载</li><li>防止核心API被篡改</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505161005824.png" alt="双亲委派机制"></p><p>当执行main方法的时候，会出现如下问题：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505161005498.png" alt="在这里插入图片描述"></p><p>可想而知，编译器根据包名一层一层的向上请求，在请求 bootstrap classloader加载器的时候， bootstrap classloader发现自己可以加载java.lang包下的String类，所以对类库中的String进行了加载，但是类库中的String类并没有main方法，所以抛出了上述异常。</p><h3 id="判断两个类是否为同一个类"><a href="#判断两个类是否为同一个类" class="headerlink" title="判断两个类是否为同一个类"></a>判断两个类是否为同一个类</h3><ul><li>完整类名相同</li><li>加载该类的类加载器相同</li></ul><h3 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h3><p><mark>自定义ClassLoader并且重写loadClass方法</mark>。为什么需要打破双亲委派机制：</p><p>在一个 Web 容器（如 Tomcat）中，可能同时部署了两个 Web 应用 A 和 B。</p><ul><li><strong>问题</strong>：应用 A 需要 Spring 4.0，应用 B 需要 Spring 5.0。</li><li><strong>冲突</strong>：如果遵循双亲委派，共同的父类加载器加载了其中一个版本的 Spring，另一个应用就无法加载自己需要的版本了。</li><li><strong>解决</strong>：Tomcat 为每个 Web 应用创建了独立的 <code>WebAppClassLoader</code>，它会打破常规，<strong>优先加载应用自身目录下的类</strong>（WEB-INF&#x2F;classes），从而实现不同应用间的类库隔离。</li></ul><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><p><mark>继承ClassLoader并且重写findClass方法</mark>。<code>loadClass</code> 是负责协调委派流程的“管理者”，而 <code>findClass</code> 是负责去具体地方找字节码的“打工人”：</p><ul><li><p><code>loadClass</code> 是类加载的入口方法，它定义了<b>加载的策略</b>（即双亲委派机制）。</p><ul><li><b>默认行为</b>：它会先检查类是否已加载，如果没有，就问父加载器要；父加载器要不到，才调用自己的 <code>findClass</code>。</li><li><b>重写它的目的</b>：通常是为了<b>打破双亲委派机制</b>（例如 Tomcat 想要先加载自己的类，而不是先问父类）。</li></ul></li><li><p><code>findClass</code> 是 JDK 1.2 之后为了不破坏双亲委派而专门设计的<b>扩展点</b>。</p><ul><li><b>默认行为</b>：在基类 <code>ClassLoader</code> 中，它直接抛出 <code>ClassNotFoundException</code>。</li><li><b>重写它的目的</b>：在<b>遵循双亲委派机制</b>的前提下，告诉加载器如何去非标准路径（如数据库、网络、加密文件）获取类的字节码。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis哨兵</title>
    <link href="/2025/05/15/Redis%E5%93%A8%E5%85%B5/"/>
    <url>/2025/05/15/Redis%E5%93%A8%E5%85%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h1><h2 id="1-投票1：判断主服务器是否下线"><a href="#1-投票1：判断主服务器是否下线" class="headerlink" title="1. 投票1：判断主服务器是否下线"></a>1. 投票1：判断主服务器是否下线</h2><p>哨兵集群中的一个哨兵判定主节点下线后<b>（主观下线）</b>，会发起投票，若多数哨兵都认为主节点下线，则为<b>客观下线</b>，需要切换主节点。</p><h2 id="2-投票2：选举leader哨兵"><a href="#2-投票2：选举leader哨兵" class="headerlink" title="2. 投票2：选举leader哨兵"></a>2. 投票2：选举leader哨兵</h2><p>切换主从节点需要一个哨兵来做，这个哨兵称为leader哨兵，需要经过推选得到。</p><h2 id="3-leader哨兵进行主从切换"><a href="#3-leader哨兵进行主从切换" class="headerlink" title="3. leader哨兵进行主从切换"></a>3. leader哨兵进行主从切换</h2><ol><li>选出新主节点：先排除<strong>已离线</strong>的从节点，再排除<strong>网络状况不好</strong>的从节点，剩下的从节点依据<strong>优先级</strong>（从节点配置）、<strong>复制进度</strong>（谁更像主节点）、<strong>从节点id大小</strong>来选举新主节点</li><li>其他从节点更换新主节点</li><li>新主节点的信息通过Pub&#x2F;Sub机制通知客户端</li><li>监视旧主节点，当它上线，将它设为新主节点的从节点</li></ol>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis主从复制</title>
    <link href="/2025/05/15/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/2025/05/15/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h1><h2 id="1-第一次同步（全量复制）"><a href="#1-第一次同步（全量复制）" class="headerlink" title="1. 第一次同步（全量复制）"></a>1. 第一次同步（全量复制）</h2><ul><li><p>建立主从服务器连接</p></li><li><p>同步数据：主服务器执行<code>bgsave</code>生成RDB文件，发送给从服务器，从服务器加载RDB文件</p></li><li><p>在同步数据过程中新生成的写操作命令会被记录到从服务器的<code>replication_buffer</code>缓冲区，待从服务器加载完RDB文件后，执行这些写操作以实现主从一致。</p><blockquote><p>如果同步数据过程太长导致<code>replication_buffer</code>缓冲区满了，则重新连接后再做全量复制</p></blockquote></li></ul><h2 id="2-命令传播（异步）"><a href="#2-命令传播（异步）" class="headerlink" title="2. 命令传播（异步）"></a>2. 命令传播（异步）</h2><p>第一次同步后，主从服务器之间维护一个TCP长连接，将主服务器上的写操作命令异步发送给从服务器。</p><p>若从服务器非常多，如果主服务器要和所有从服务器做一次全量复制太麻烦，为了分摊主服务器的压力，可以<mark>选定一个或多个从服务器充当“经理”的角色，主服务器只关心与“经理”的同步，其余从服务器的同步交给“经理”去解决</mark></p><h2 id="3-增量复制"><a href="#3-增量复制" class="headerlink" title="3. 增量复制"></a>3. 增量复制</h2><p>若主从服务器之间网络断开，会造成主从不一致。</p><p>Redis2.8以前，主从断开重连后会采用全量复制保证一致性。</p><p>Redis2.8以后，采用增量复制：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505152036721.png" alt="图片"></p><p>主服务器维护一个<strong>环形缓冲区</strong><code>repl_backlog_buffer</code>，主从命令传播时，还会把写操作命令记录到<code>repl_backlog_buffer</code>中，用一个<code>master_repl_offset</code>来记录主服务器写到哪了，而从服务器维护一个<code>slave_repl_offset</code>来记录自己读到哪了。</p><p><mark>主从重连后，比较两个offset，只把相差的那一部分发送给从服务器，来实现同步。但由于这是一个环形缓冲区， 如果发现主服务器写的进度已经把从服务器读的进度“套圈”了，就还是会使用全量复制来同步</mark></p><blockquote><p><strong>环形缓冲区</strong><code>repl_backlog_buffer</code>的最小大小：重连平均时间 * 主服务器每秒生成写命令数据量大小，<code>repl_backlog_buffer</code>的大小至少要大于这个，以减少“套圈”的情况。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis过期删除策略与内存淘汰策略</title>
    <link href="/2025/05/15/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <url>/2025/05/15/Redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis过期删除与内存淘汰"><a href="#Redis过期删除与内存淘汰" class="headerlink" title="Redis过期删除与内存淘汰"></a>Redis过期删除与内存淘汰</h1><h2 id="1-Redis过期删除策略"><a href="#1-Redis过期删除策略" class="headerlink" title="1. Redis过期删除策略"></a>1. Redis过期删除策略</h2><h3 id="1-1-惰性删除"><a href="#1-1-惰性删除" class="headerlink" title="1.1 惰性删除"></a>1.1 惰性删除</h3><p>不主动删除，访问key时再判断是否过期，是否需要删除（节省cpu，但是占内存）</p><h3 id="1-2-定期删除"><a href="#1-2-定期删除" class="headerlink" title="1.2 定期删除"></a>1.2 定期删除</h3><p>一段时间（每秒10次）随机抽20个key检查，将过期的删除，若过期数量超25%即5个，重复前面流程再来一次。</p><h2 id="2-Redis内存淘汰策略"><a href="#2-Redis内存淘汰策略" class="headerlink" title="2. Redis内存淘汰策略"></a>2. Redis内存淘汰策略</h2><h3 id="2-1-不主动淘汰"><a href="#2-1-不主动淘汰" class="headerlink" title="2.1 不主动淘汰"></a>2.1 不主动淘汰</h3><p>不主动淘汰，当内存满了还想添加数据则报错</p><h3 id="2-2-在有过期时间的key中淘汰"><a href="#2-2-在有过期时间的key中淘汰" class="headerlink" title="2.2 在有过期时间的key中淘汰"></a>2.2 在有过期时间的key中淘汰</h3><ul><li>随机淘汰</li><li>淘汰ttl最短的</li><li>LRU（淘汰最近最久不使用的）</li><li>LFU（在最不常使用的key中淘汰最久不使用的）</li></ul><h3 id="2-3-在所有key中淘汰"><a href="#2-3-在所有key中淘汰" class="headerlink" title="2.3 在所有key中淘汰"></a>2.3 在所有key中淘汰</h3><ul><li>随机淘汰</li><li>LRU</li><li>LFU</li></ul>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis持久化</title>
    <link href="/2025/05/15/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <url>/2025/05/15/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="1-AOF日志"><a href="#1-AOF日志" class="headerlink" title="1. AOF日志"></a>1. AOF日志</h2><h3 id="1-1-AOF日志"><a href="#1-1-AOF日志" class="headerlink" title="1.1 AOF日志"></a>1.1 AOF日志</h3><p>在Redis执行完一条命令后，将该命令记录到AOF日志中</p><p><strong>为什么是在执行完命令之后记录日志呢？</strong></p><ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p>这样也带来了风险：</p><ul><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li><strong>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）</strong>。</li></ul><h3 id="1-2-写入操作"><a href="#1-2-写入操作" class="headerlink" title="1.2 写入操作"></a>1.2 写入操作</h3><p>如果直接将命令写回到磁盘中的AOF文件中，会出现如下问题：</p><ul><li>还没写会磁盘就宕机，数据丢失</li><li>阻塞下一条Redis命令执行（Redis单线程）</li></ul><p>因此，Redis会将命令先写到一个叫**“AOF缓冲区”**的地方，<code>write()</code>系统调用将AOF缓冲区数据写到内核缓冲区PageCache，再由内核决定什么时候将数据写回磁盘：</p><ul><li><em>Always</em>：每次写命令执行完就将记录写回磁盘</li><li><em>EverySec</em>：每次Redis写命令执行完放到PageCache，由内核每隔一秒写入磁盘</li><li><em>No</em>：由内核自己决定什么时候写入磁盘</li></ul><h3 id="1-3-AOF重写"><a href="#1-3-AOF重写" class="headerlink" title="1.3 AOF重写"></a>1.3 AOF重写</h3><blockquote><p>AOF文件会越来越大，超过一定阈值启用重写机制来压缩AOF文件</p></blockquote><p>对每条键值对数据，用一条日志记录它们的<strong>最新状态</strong>（因为一条键值对数据可能经过多次更改，原AOF日志文件里有多条关于它们的冗余数据），以达到压缩AOF文件的目的。</p><p>这个过程是在一个<strong>后台的子进程</strong>中进行的，也就是此时主进程仍可以执行写操作，在这个过程中执行的写操作命令不仅要加到AOF缓冲区中，还要加到一个叫**“AOF重写缓冲区”**的地方，<mark>用于让重写后新的AOF文件知道在它重写过程中又多了什么写操作</mark>，记录下后覆盖老的AOF文件，实现压缩。</p><h2 id="2-RDB快照"><a href="#2-RDB快照" class="headerlink" title="2. RDB快照"></a>2. RDB快照</h2><h3 id="2-1-RDB快照"><a href="#2-1-RDB快照" class="headerlink" title="2.1 RDB快照"></a>2.1 RDB快照</h3><p>相较于AOF日志记录的是一条条的命令，RDB快照直接记录某一个瞬间的所有数据。</p><p>两者相比，在Redis重启时，<mark>RDB快照的持久化方式加载速度更加快，不用像AOF日志那样一条一条执行命令</mark>。</p><h3 id="2-2-RDB快照记录"><a href="#2-2-RDB快照记录" class="headerlink" title="2.2 RDB快照记录"></a>2.2 RDB快照记录</h3><p><code>bgsave</code>使用一个子进程去对当前的数据做快照，如果这个过程中主进程中的都是读操作则没有影响；若主进程发生了写操作，则会发生<strong>写时复制</strong>，会将被修改的数据复制一份，主进程在这个新生成的副本上做修改，子进程继续对原数据做快照。</p><blockquote><p>极端情况下，所有数据都被修改，所有数据都要被复制，导致内存占用增大</p></blockquote><p>也就是说，<mark>在做RDB快照过程中发生的写操作只能等到下一次RDB才能被同步到磁盘中，这就导致了数据丢失的风险</mark>。</p><h2 id="3-混合持久化"><a href="#3-混合持久化" class="headerlink" title="3. 混合持久化"></a>3. 混合持久化</h2><p>综上所述，使用AOF日志虽然慢，但是没有数据丢失风险；而使用RDB快照虽然快，但是会有增量数据丢失的风险。于是有混合持久化AOF+RDB的方式：</p><p>重写AOF日志时，<mark>将数据以RDB的形式写入到AOF日志中，写完再去AOF重写缓冲区中，把记录RDB时新生成的AOF记录写到新的AOF日志中</mark>，于是新的AOF日志里既有RDB格式（前），又有AOF格式（后）。</p><blockquote><p>既快，又不怕增量数据丢失</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis数据结构</title>
    <link href="/2025/05/15/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2025/05/15/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><blockquote><p>引用：小林coding、JavaGuide</p></blockquote><h2 id="1-Redis是如何实现键值对数据库的？"><a href="#1-Redis是如何实现键值对数据库的？" class="headerlink" title="1. Redis是如何实现键值对数据库的？"></a>1. Redis是如何实现键值对数据库的？</h2><p>Redis是使用了一个哈希表保存所有键值对，哈希表其实就是一个数组，数组中的元素叫哈希桶。哈希桶存放的是指向键值对的指针（dictEntry*），键值对则保存了key和value的指针。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505151642009.png" alt="img"></p><p>特别说明下，void * key 和 void * value指针指向的是Redis对象，Redis中的每个对象都由redisObject结构表示：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505151642011.png" alt="img"></p><h2 id="2-Redis的基本数据类型"><a href="#2-Redis的基本数据类型" class="headerlink" title="2. Redis的基本数据类型"></a>2. Redis的基本数据类型</h2><p>Redis 共有 5 种基本数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p><p>这 5 种数据类型底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Dict（哈希表&#x2F;字典）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。Redis 5 种基本数据类型对应的底层数据结构实现如下表所示：</p><table><thead><tr><th align="left">String</th><th align="left">List</th><th align="left">Hash</th><th align="left">Set</th><th align="left">Zset</th></tr></thead><tbody><tr><td align="left">SDS</td><td align="left">LinkedList&#x2F;ZipList&#x2F;QuickList</td><td align="left">Dict、ZipList</td><td align="left">Dict、Intset</td><td align="left">ZipList、SkipList</td></tr></tbody></table><blockquote><p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 <strong>LinkedList 和 ZipList 的结合 QuickList</strong>，List 的底层实现变为 QuickList。从 Redis 7.0 开始， <strong>ZipList 被 ListPack 取代</strong>。</p></blockquote><h2 id="3-Redis的数据结构"><a href="#3-Redis的数据结构" class="headerlink" title="3. Redis的数据结构"></a>3. Redis的数据结构</h2><h3 id="3-1-动态字符串SDS"><a href="#3-1-动态字符串SDS" class="headerlink" title="3.1 动态字符串SDS"></a>3.1 动态字符串SDS</h3><p><img src="/Users/jjhwang/hexo/Hwang-jj.github.io/source/_posts/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7c7a4410969b46ffbac084cc63b7f487~tplv-73owjymdk6-jj-mark-v1:0:0:0:0:5o6Y6YeR5oqA5pyv56S-5Yy6IEAgQWlyTWFu:q75.awebp" alt="SDS数据结构"></p><p><code>SDS</code> 之所以叫做动态字符串，是因为它具备<b>动态扩容</b>的能力，当给<code>SDS</code>追加一段字符串时：</p><ul><li>如果新字符串小于 1M，<mark>则新空间为扩展后字符串长度的两倍+1</mark>（加 1 是因为申请的时候需要预留 <b>‘\0’</b> 位，用于兼容C字符串）</li><li>如果新字符串大于 1M，<mark>则新空间为扩展后字符串长度+1M+1</mark>。称为<b>内存预分配</b>。申请内存这件事本省是耗时的，所以 Redis 采用的是预分配，减少内存申请的次数</li></ul><p><b><code>SDS</code> 的优点</b>：</p><ol><li>获取字符串的长度的时间复杂度是 O(1)</li><li>遍历字符串的时候是根据 len 来运算的，所以是二进制安全的</li><li>支持动态扩容</li><li>减少内存的分配次数</li></ol><h3 id="3-2-IntSet"><a href="#3-2-IntSet" class="headerlink" title="3.2 IntSet"></a>3.2 IntSet</h3><h2 id="3-简单动态字符串SDS"><a href="#3-简单动态字符串SDS" class="headerlink" title="3. 简单动态字符串SDS"></a>3. 简单动态字符串SDS</h2><p>String数据类型是由SDS实现的，SDS包括字节数组buf[]，还包括了字符串长度len，以及给这个SDS分配的空间长度alloc，这样就能以O(1)的时间复杂度获取字符串的长度，同时还能方便计算剩余可用空间。</p><h2 id="4-压缩列表ZipList"><a href="#4-压缩列表ZipList" class="headerlink" title="4. 压缩列表ZipList"></a>4. 压缩列表ZipList</h2><p>ZipList是Redis为了节约内存而开发的，它是由<strong>连续内存块组成的顺序型数据结构</strong>：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505151642012.png" alt="img"></p><ul><li>zlbytes：记录整个ZipList占用的内存字节数</li><li>zltail：记录ZipList尾部节点距离起始地址有多少字节，也就是列表尾部的偏移量</li><li>zllen：记录ZipList包含的节点数</li><li>zlend：标记ZipList的结束点，固定值0xFF</li></ul><h2 id="5-跳表SkipList"><a href="#5-跳表SkipList" class="headerlink" title="5. 跳表SkipList"></a>5. 跳表SkipList</h2><p>Redis的有序集合zset是用ZipList或SkipList实现的，因为设计者考虑到 Redis 数据存放于内存，为了节约宝贵的内存空间，在<strong>有序集合元素小于 64 字节且个数小于 128</strong> 的时候，会使用 ziplist；一旦有序集合中的某个元素超出这两个其中的一个阈值它就会转为 skiplist。</p><p>也就是说，ZSet 有两种不同的实现，分别是 ziplist 和 skiplist，具体使用哪种结构进行存储的规则如下：</p><ul><li>当有序集合对象同时满足以下两个条件时，使用 ziplist： <ol><li>ZSet 保存的键值对数量少于 128 个；</li><li>每个元素的长度小于 64 字节。</li></ol></li><li>如果不满足上述两个条件，那么使用 skiplist 。</li></ul><h3 id="5-1-跳表是什么"><a href="#5-1-跳表是什么" class="headerlink" title="5.1 跳表是什么"></a>5.1 跳表是什么</h3><p>我们都知道有序链表在添加、查询、删除的平均时间复杂都都是 <strong>O(n)</strong> 即线性增长，所以一旦节点数量达到一定体量后其性能表现就会非常差劲。而跳表我们完全可以理解为在原始链表基础上，建立<strong>多级索引</strong>，通过多级索引检索定位将增删改查的时间复杂度变为 <strong>O(log n)</strong> 。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505151642013.png" alt="img"></p><p>假如我们需要查询元素 6，其工作流程如下：</p><ol><li>从 2 级索引开始，先来到节点 4。</li><li>查看 4 的后继节点，是 8 的 2 级索引，这个值大于 6，说明 2 级索引后续的索引都是大于 6 的，没有再往后搜寻的必要，我们索引向下查找。</li><li>来到 4 的 1 级索引，比对其后继节点为 6，查找结束。</li></ol><p>相较于原始有序链表需要 6 次，我们的跳表通过建立多级索引（每级索引的数量一般是下一层的数量的一半），我们只需两次就直接定位到了目标元素，其查询的复杂度被直接优化为<strong>O(log n)</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kafka工作原理</title>
    <link href="/2025/05/14/Kafka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2025/05/14/Kafka%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka工作原理"><a href="#Kafka工作原理" class="headerlink" title="Kafka工作原理"></a>Kafka工作原理</h1><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505151012092.png" alt="在这里插入图片描述"></p><h2 id="1-Kafka核心概念"><a href="#1-Kafka核心概念" class="headerlink" title="1. Kafka核心概念"></a>1. Kafka核心概念</h2><ul><li><p>Message（消息）：Kafka中的数据单元称为消息。可以将消息看成是数据库中的一条“数据行”或一条“记录”。消息是Kafka中最基本的单位，每一条消息都是一个独立的记录，包含消息的键、值、时间戳等信息。</p></li><li><p>Batch（批次）：为了提高效率，Kafka将消息进行批量处理。消息被分批写入Kafka，这种方式提高了吞吐量，但也会增加响应时间。批次处理使得Kafka能够以更高效的方式进行I&#x2F;O操作，从而提升整体性能。</p></li><li><p>Producer（生产者）：Producer即生产者，消息的产生者，是消息的入口。</p></li><li><p>Broker：Broker是kafka实例，每个服务器上有一个或多个kafka的实例，我们姑且认为每个broker对应一台服务器。每个kafka集群内的broker都有一个不重复的编号，如图中的broker-0、broker-1等……</p></li><li><p>主题（Topic）：主题是Kafka中用于<strong>消息分类</strong>的概念，类似于数据库中的表。每个主题都可以包含多个消息，生产者将消息发送到主题，消费者从主题中读取消息。通过主题，我们可以将不同类型的消息分开管理。在每个Broker都可以创建多个Topic。（<b>Topic是逻辑上的消息分类</b>）</p></li><li><p>分区（Partition）：为了方便扩展和管理，Kafka中的每个Topic可以分为多个Partition。分区使得Kafka能够横向扩展，将消息分布在多个节点上。单个分区内的消息是有序的，但在多个分区间无法保证全局有序。如果希望消息全局有序，可以将分区数设置为一。（<b>Partition是物理上的消息分类</b>）</p><blockquote><p>每个topic可以有多个partition，<mark>partition的作用是做负载，提高kafka的吞吐量</mark>。同一个topic在不同的分区的数据是不重复的，partition的表现形式就是一个一个的文件夹（里面存储Segment）！</p></blockquote></li><li><p>副本（Replication）：每一个分区都有多个副本，副本的作用是做备胎。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，<mark>follower和leader绝对是在不同的机器</mark>，同一机器对同一个分区也只可能存放一个副本（包括自己）。<mark>副本机制是Kafka高可靠性的基础</mark>。</p><blockquote><ul><li><code>AR</code>：分区中所有副本称为 AR</li><li><code>ISR</code>：所有与主副本保持一定程度同步的副本（包括主副本）称为 ISR</li><li><code>OSR</code>：与主副本滞后过多的副本组成 OSR</li></ul></blockquote></li><li><p>消费者（Consumer）：消费者，即消息的消费方，是消息的出口。</p></li><li><p>消费者组（Consumer Group）：我们可以将多个消费者组成一个消费者组，在kafka的设计中<mark>同一个分区的数据只能被消费者组中的某一个消费者消费</mark>。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量！(<b>一个消费者去处理一个Topic下的多个Partition效率 肯定不如 一个消费者组里的多个消费者一起去消费一个Topic下的不同Partition吧！  ————&gt;  消费者组也引出了rebalance的问题 </b>)</p></li></ul><h2 id="2-Kafka的优点"><a href="#2-Kafka的优点" class="headerlink" title="2. Kafka的优点"></a>2. Kafka的优点</h2><ul><li>高性能、高吞吐量、低延迟：Kafka 生产和消费消息的速度都达到每秒10万级</li><li>高可用：所有消息持久化存储到磁盘，并支持数据备份防止数据丢失</li><li>高并发：支持数千个客户端同时读写</li><li>容错性：允许集群中节点失败（若副本数量为n，则允许 n-1 个节点失败）</li><li>高扩展性：Kafka 集群支持热伸缩，无须停机</li></ul><h2 id="3-Kafka如何避免消息丢失？"><a href="#3-Kafka如何避免消息丢失？" class="headerlink" title="3. Kafka如何避免消息丢失？"></a>3. Kafka如何避免消息丢失？</h2><blockquote><p>引用：JavaGuide</p></blockquote><h3 id="3-1-生产者丢失消息的情况"><a href="#3-1-生产者丢失消息的情况" class="headerlink" title="3.1 生产者丢失消息的情况"></a>3.1 生产者丢失消息的情况</h3><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>所以，我们不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，我们要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是<strong>异步的操作</strong>，我们可以<strong>通过 <code>get()</code>方法获取调用结果</strong>，但是这样也让它变为了<strong>同步操作</strong>.</p><p>但是一般不推荐这么做！可以采用为其<strong>添加回调函数</strong>的形式</p><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p><h3 id="3-2-消费者丢失消息的情况"><a href="#3-2-消费者丢失消息的情况" class="headerlink" title="3.2 消费者丢失消息的情况"></a>3.2 消费者丢失消息的情况</h3><p>我们知道消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p>当消费者拉取到了分区的某个消息之后，消费者会<strong>自动提交</strong>了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p><p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，细心的朋友一定会发现，这样会带来<strong>消息被重新消费</strong>的问题。比如你刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h3 id="3-3-Kafka弄丢了消息"><a href="#3-3-Kafka弄丢了消息" class="headerlink" title="3.3 Kafka弄丢了消息"></a>3.3 Kafka弄丢了消息</h3><p>我们知道 Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p><ul><li><p><strong>设置 acks &#x3D; all</strong></p><p>解决办法就是我们设置 <strong>acks &#x3D; all</strong>。acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p><p><mark>acks 的默认值即为 1，代表我们的消息被 leader 副本接收之后就算被成功发送。当我们配置 acks &#x3D; all 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应. </mark>这种模式是最高级别的，也是最安全的，可以确保不止一个 Broker 接收到了消息. 该模式的延迟会很高</p><blockquote><p>Kafka的Producer有三种ack机制，参数值有0、1 和 -1</p><ul><li><strong>0：</strong> 相当于异步操作，Producer 不需要Leader给予回复，发送完就认为成功，继续发送下一条（批）Message。<strong>此机制具有最低延迟，但是持久性可靠性也最差，当服务器发生故障时，很可能发生数据丢失</strong></li><li><strong>1：</strong> Kafka 默认的设置。表示 Producer 要 Leader 确认已成功接收数据才发送下一条（批）Message。不过 Leader 宕机，Follower 尚未复制的情况下，数据就会丢失。<strong>此机制提供了较好的持久性和较低的延迟性</strong></li><li><strong>-1：</strong> Leader 接收到消息之后，还必须要求ISR列表里跟Leader保持同步的那些Follower都确认消息已同步，Producer 才发送下一条（批）Message。<strong>此机制持久性可靠性最好，但延时性最差</strong></li></ul></blockquote></li><li><p><strong>设置 replication.factor &gt;&#x3D; 3</strong></p><p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;&#x3D; 3</strong>。<mark>这样就可以保证每个 分区(partition) 至少有 3 个副本</mark>。虽然造成了数据冗余，但是带来了数据的安全性。</p></li><li><p><strong>设置 min.insync.replicas &gt; 1</strong></p><p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表<mark>消息至少要被写入到 2 个副本才算是被成功发送</mark>。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor &#x3D; min.insync.replicas + 1</strong>。</p></li><li><p><strong>设置 unclean.leader.election.enable &#x3D; false</strong></p><p><mark>多个 follower 副本之间的消息同步情况不一样</mark>，当我们配置了<strong>unclean.leader.election.enable &#x3D; false</strong> 时，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p></li></ul><h2 id="4-Kafka如何保证消息的消费顺序"><a href="#4-Kafka如何保证消息的消费顺序" class="headerlink" title="4. Kafka如何保证消息的消费顺序"></a>4. Kafka如何保证消息的消费顺序</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505151012093.png" alt="img"></p><p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p><ul><li><p>方法一：既然消费顺序不一致是由于一个Topic有多个Partition，而Kafka只能保证一个Partition内有序，那么令<strong>一个Topic只对应一个Partition</strong>就可以保证消息消费顺序。</p></li><li><p>方法二：发送消息时<strong>指定Partition</strong>，消息就会被发送到对应的Partition；发送消息时<strong>指定Key</strong>，同一个Key的消息会被发送到同一个Partition。</p><blockquote><p>选择的Partition &#x3D; hashcode(key) % Partition总数</p></blockquote></li></ul><h2 id="5-Kafka如何保证消息不被重复消费"><a href="#5-Kafka如何保证消息不被重复消费" class="headerlink" title="5. Kafka如何保证消息不被重复消费"></a>5. Kafka如何保证消息不被重复消费</h2><p><strong>kafka 出现消息重复消费的原因：</strong></p><ul><li><p>生产阶段由于网络波动导致同一条消息被重复发送</p></li><li><p>服务端侧已经消费的数据没有成功提交 offset（根本原因）。</p></li><li><p>Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 <strong>rebalance</strong>。</p><blockquote><p>为了维持Consumer与Consumer Group之间的关系，Consumer 会周期性地发送 hearbeat 到 Group Coodinator，如果有 hearbeat 超时或未收到 hearbeat，coordinator 会认为该Consumer已经退出，那么它所订阅的Partition会分配到同一组内的其他Consumer上，这个过程称为 rebalance。<mark>rebalance期间所有消费者暂停消费，提交当前消费状态，等待coordinator重新分配分区</mark></p></blockquote></li></ul><p><strong>解决方案：</strong></p><ul><li>Kafka幂等性生产：通过<code>Producer ID + 消息序列号Seq Number</code>来唯一标识一条消息，避免重复发送</li><li>消费消息服务做<strong>幂等校验</strong>，比如 Redis 的 set（消息的uuid存入Redis set中，消费前先检查是否存在）、MySQL 的主键等天然的幂等功能。这种方法最有效。</li><li>将 <code>enable.auto.commit</code>参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：什么时候提交 offset 合适？<ul><li>处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li><li>拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li></ul></li></ul><h2 id="6-Kafka重试机制"><a href="#6-Kafka重试机制" class="headerlink" title="6. Kafka重试机制"></a>6. Kafka重试机制</h2><h3 id="6-1-消费失败会怎么样？"><a href="#6-1-消费失败会怎么样？" class="headerlink" title="6.1 消费失败会怎么样？"></a>6.1 消费失败会怎么样？</h3><p>在消费过程中，当其中一个消息消费异常时，会不会卡住后续队列消息的消费？这样业务岂不是卡住了？</p><p>在默认配置下，当消费异常会进行重试，<mark>重试多次后会跳过当前消息，继续进行后续消息的消费</mark>，不会一直卡在当前消息。</p><h3 id="6-2-默认重试多少次？"><a href="#6-2-默认重试多少次？" class="headerlink" title="6.2 默认重试多少次？"></a>6.2 默认重试多少次？</h3><p>Kafka 消费者在<mark>默认配置下会进行最多 10 次 的重试，每次重试的时间间隔为 0，即立即进行重试</mark>。如果在 10 次重试后仍然无法成功消费消息，则不再进行重试，消息将被视为消费失败。</p><h3 id="6-3-重试失败后的消息如何再次处理？"><a href="#6-3-重试失败后的消息如何再次处理？" class="headerlink" title="6.3 重试失败后的消息如何再次处理？"></a>6.3 重试失败后的消息如何再次处理？</h3><p><strong>死信队列（Dead Letter Queue，简称 DLQ）</strong> 是消息中间件中的一种特殊队列。它主要用于处理无法被消费者正确处理的消息，通常是因为消息格式错误、处理失败、消费超时等情况导致的消息被”丢弃”或”死亡”的情况。</p><p>当消息进入队列后，消费者会尝试处理它。如果处理失败，或者超过一定的重试次数仍无法被成功处理，消息可以发送到死信队列中，而不是被永久性地丢弃。在死信队列中，可以进一步分析、处理这些无法正常消费的消息，以便定位问题、修复错误，并采取适当的措施。</p><h2 id="7-Kafka高性能原因"><a href="#7-Kafka高性能原因" class="headerlink" title="7. Kafka高性能原因"></a>7. Kafka高性能原因</h2><h3 id="7-1-使用批量消息提升服务端处理能力"><a href="#7-1-使用批量消息提升服务端处理能力" class="headerlink" title="7.1 使用批量消息提升服务端处理能力"></a>7.1 使用批量消息提升服务端处理能力</h3><ul><li>发送端：当我们调用send()方法发送一条消息后，无论我们是同步发送还是异步发送，Kafka并不会立刻把这条消息发送出去，它会先把这条消息存放在内存中，然后<mark>选择合适的时机把缓存的所有消息组成一批，一次性的发给Broker</mark>。<b>减少了网络调用次数</b>。</li><li>Broker：整个处理流程中，无论是写入磁盘、从磁盘读出来、还是复制到其他副本，批消息都不会被解开，一直是作为一条“批消息”进行处理的。<b>减少了磁盘IO次数</b>。</li><li>消费端：消息同样是以批为单位进行传递的，Consumer从Broker拉到一批消息后，在客户端把批消息解开，再一条一条交给用户代码处理。<b>减少了网络调用次数</b>。</li></ul><p>构建批消息和解开批消息分别在发送端和消费端的客户端完成，不仅减轻了Broker的压力，还减少了Broker处理请求的次数，提升了总体的处理能力</p><h3 id="7-2-顺序读写提升磁盘IO性能"><a href="#7-2-顺序读写提升磁盘IO性能" class="headerlink" title="7.2 顺序读写提升磁盘IO性能"></a>7.2 顺序读写提升磁盘IO性能</h3><p>每个分区，它把从Producer收到的消息，顺序地写入对应的log文件中，一个文件写完了，就开启一个新的文件继续顺序写下去。消费的时候，也是从某个全局的位置开始，顺序地把消息读出来</p><h3 id="7-3-利用PageCache加速消息读写"><a href="#7-3-利用PageCache加速消息读写" class="headerlink" title="7.3 利用PageCache加速消息读写"></a>7.3 利用PageCache加速消息读写</h3><p>当生产者发送消息时，这些数据并不是立即落盘，而是被写入操作系统提供的页缓存中。这是一块用于缓存磁盘数据的内存区域，可以延迟刷盘，从而显著提升写入性能。</p><p>在消费过程中，如果消费者在<mark>写入后短时间内就开始拉取数据，那么这些数据往往还停留在页缓存中</mark>，不需要再从磁盘读取，这就极大减少了磁盘IO。Kafka的“写后即读”特性与PageCache的缓存策略高度契合，形成了一种天然的局部性优化。</p><h3 id="7-4-使用零拷贝技术加速消费流程"><a href="#7-4-使用零拷贝技术加速消费流程" class="headerlink" title="7.4 使用零拷贝技术加速消费流程"></a>7.4 使用零拷贝技术加速消费流程</h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202601221406419.png" alt="image-20260122140621700" style="zoom: 33%;" /><h4 id="2次系统调用"><a href="#2次系统调用" class="headerlink" title="2次系统调用"></a>2次系统调用</h4><p>一次是<code>read()</code>，一次是<code>write()</code>，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态，所以共发生了<mark>4次用户态与内核态的上下文切换</mark>。<br>上下文切换到成本并不小，一次切换需要耗时几十纳秒到几微秒，虽然时间看上去很短，但是在高并发的场景下，这类时间容易被累积和放大，从而影响系统的性能。</p><h4 id="4次数据拷贝"><a href="#4次数据拷贝" class="headerlink" title="4次数据拷贝"></a>4次数据拷贝</h4><p>还发生了<mark>4次数据拷贝，其中两次是DMA的拷贝，另外两次则是通过CPU拷贝的</mark>，下面说一下这个过程:</p><ul><li>第一次拷贝：把磁盘上的数据拷到操作系统内核的缓冲区里，很多资料里也将其叫作Read Buffer，这个拷贝的过程是通过DMA搬运的。</li><li>第二次拷贝：把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由CPU完成的。</li><li>第三次拷贝：把刚才拷贝到用户的缓冲区里的数据，再拷到内核的socket的缓冲区里，这个过程依然还是由CPU搬运的。</li><li>第四次拷贝：把内核的socket缓冲区里的数据，拷到网卡的缓冲区里，这个过程又是由DMA这个控制器搬运的。</li></ul><p>我们回过头看这个数据传输的过程，我们只是搬运一份数据，结果却搬运了4次，过多的数据拷贝无疑会消耗CPU资源，大大降低了系统性能。</p><h4 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h4><p>减少系统调用 和 数据拷贝次数</p><ul><li>减少系统调用：一次系统调用会发生2次上下文切换，从用户态切换到内核态，内核执行完成后再从内核态切换回用户态</li><li>减少数据拷贝：上面的第二、三次拷贝是不必要的，因为在数据传输过程中，我们不会在用户态中对数据进行加工，也就没必要把数据搬运到用户态</li></ul><h4 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a>零拷贝技术</h4><blockquote><p>所谓的<b>零拷贝</b>是指<mark>将数据在内核空间直接从磁盘文件复制到网卡中</mark>，而不需要经由用户态的应用程序之手。这样既可以提高数据读取的性能，也能减少核心态和用户态之间的上下文切换，提高数据传输效率。<br>这种方式的优势非常明显。<mark>系统调用次数从两次降为一次，内核态和用户态的切换从四次降到两次，数据拷过程也由四次减少到两次</mark>。同时，配合DMA(直接内存访问)机制，还可以进一步减轻CPU的负担。</p></blockquote><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202601221416264.png" alt="image-20260122141626958" style="zoom:33%;" /><p>具体流程如下:</p><ol><li><code>sendfile</code>开启流程，可以看到<code>sendfile</code>是代替了<code>read</code>和<code>write</code>，相当于<mark>只有一次系统调用</mark>了</li><li>操作系统将数据从磁盘通过DMA加载到内核空间的缓存区</li><li>操作系统将数据的描述符拷贝到Socket缓冲区中。<mark>Socket缓冲区仅仅会拷贝一个描述符过去，不会拷贝数据</mark>。</li><li>操作系统直接将数据从内核空间的缓存区传输到网卡中，并通过网卡将数据发送给接收方，这也是通过DMA来做的，不过这里的DMA叫SG-DMA，基本上现阶段的网卡都是支持SG-DMA的，所以没有什么特别的，知道它是一种加强的DMA技术就行了，甚至面试时候就说是DMA也是一样的。</li></ol><h3 id="7-5-消息压缩"><a href="#7-5-消息压缩" class="headerlink" title="7.5 消息压缩"></a>7.5 消息压缩</h3><p><mark>Kafka支持在生产端或Broker端对消息进行压缩，以减少网络传输的数据体积</mark>。数据压缩适合带宽资源紧张而CPU资源相对宽裕的场景，能有效提升整体传输效率，是Kafka保持高吞吐的重要机制之一。</p><h2 id="8-Kafka的分层设计机制与索引设计"><a href="#8-Kafka的分层设计机制与索引设计" class="headerlink" title="8. Kafka的分层设计机制与索引设计"></a>8. Kafka的分层设计机制与索引设计</h2><h3 id="8-1-分层设计机制"><a href="#8-1-分层设计机制" class="headerlink" title="8.1 分层设计机制"></a>8.1 分层设计机制</h3><p>Kafka采用 <code>Topic - Partition - Segment</code> 的分层设计机制：</p><ul><li><p>Topic作为<mark>业务逻辑隔离</mark>的基本单位，实现数据独立性；</p></li><li><p>每个Topic进一步拆分为多个Partition，通过并行写入与消费实现<mark>横向扩展</mark>以提升吞吐能力；</p></li><li><p>每个Partition由多个按大小（默认1GB，可配置log.segment.size）滚动生成的Segment组成，每个Segment包含：</p><ul><li>.log数据文件</li><li>用于快速定位的.index（偏移量索引）</li><li>.timeindex（时间索引）文件</li></ul><p>索引文件加载至内存以优化查询效率，通过该分层结构实现高并发、高吞吐场景下的数据高效管理与扩展。</p></li></ul><h3 id="8-2-索引机制"><a href="#8-2-索引机制" class="headerlink" title="8.2 索引机制"></a>8.2 索引机制</h3><blockquote><p>根据offset定位消息的具体步骤</p></blockquote><h4 id="步骤一-确定消息所在的日志分段"><a href="#步骤一-确定消息所在的日志分段" class="headerlink" title="步骤一:确定消息所在的日志分段"></a>步骤一:确定消息所在的日志分段</h4><p>当你指定一个偏移量offset时，Kafka首先会<mark>根据offset的大小确定消息所在的日志分段segment</mark>。由于segment是按照偏移量顺序排列的，Kafka可以通过比较offset和每个segment的起始偏移量，快速找到包含该offset的日志分段.</p><h4 id="步骤二-使用索引文件加速查找"><a href="#步骤二-使用索引文件加速查找" class="headerlink" title="步骤二:使用索引文件加速查找"></a>步骤二:使用索引文件加速查找</h4><p>在确定了消息所在的日志分段后，Kafka会使用对应的索引文件来加速消息的查找过程。</p><ul><li>偏移量索引文件(.index)：该文件记录了<b>部分消息的偏移量和它们在.log文件中的物理位置</b>。Kafka会在这个索引文件中进行<mark>二分查找</mark>，找到<mark>小于或等于指定偏移量的最大偏移量记录</mark>，从而得到一个<mark>近似</mark>的物理文件位置。</li><li>时间戳索引文件(.timeindex)：如果需要根据时间戳来定位消息，Kafka会先在时间戳索引文件中查找指定时间戳对应的偏移量，然后再使用偏移量索引文件进一步定位消息。</li></ul><h4 id="步骤三-在日志文件中查找消息"><a href="#步骤三-在日志文件中查找消息" class="headerlink" title="步骤三:在日志文件中查找消息"></a>步骤三:在日志文件中查找消息</h4><p>通过索引文件得到近似的物理文件位置后，Kafka会从该位置开始在.log文件中<mark>顺序查找</mark>，直到找到指定偏移量的消息。由于已经通过索引文件缩小了查找范围，这个顺序查找的过程通常非常快。</p><h2 id="9-消息队列常见应用场景"><a href="#9-消息队列常见应用场景" class="headerlink" title="9. 消息队列常见应用场景"></a>9. 消息队列常见应用场景</h2><h3 id="9-1-解耦"><a href="#9-1-解耦" class="headerlink" title="9.1 解耦"></a>9.1 解耦</h3><h3 id="9-2-削峰"><a href="#9-2-削峰" class="headerlink" title="9.2 削峰"></a>9.2 削峰</h3><h3 id="9-3-异步处理"><a href="#9-3-异步处理" class="headerlink" title="9.3 异步处理"></a>9.3 异步处理</h3><h3 id="9-4-消息分发"><a href="#9-4-消息分发" class="headerlink" title="9.4 消息分发"></a>9.4 消息分发</h3>]]></content>
    
    
    <categories>
      
      <category>MQ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么Integer用双等号比较时127相等而128不相等</title>
    <link href="/2025/05/14/%E4%B8%BA%E4%BB%80%E4%B9%88Integer%E7%94%A8%E5%8F%8C%E7%AD%89%E5%8F%B7%E6%AF%94%E8%BE%83%E6%97%B6127%E7%9B%B8%E7%AD%89%E8%80%8C128%E4%B8%8D%E7%9B%B8%E7%AD%89/"/>
    <url>/2025/05/14/%E4%B8%BA%E4%BB%80%E4%B9%88Integer%E7%94%A8%E5%8F%8C%E7%AD%89%E5%8F%B7%E6%AF%94%E8%BE%83%E6%97%B6127%E7%9B%B8%E7%AD%89%E8%80%8C128%E4%B8%8D%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么Integer用-比较时127相等而128不相等？"><a href="#为什么Integer用-比较时127相等而128不相等？" class="headerlink" title="为什么Integer用&#x3D;&#x3D;比较时127相等而128不相等？"></a>为什么Integer用&#x3D;&#x3D;比较时127相等而128不相等？</h1><blockquote><p>引用：<a href="https://zhuanlan.zhihu.com/p/368421654">https://zhuanlan.zhihu.com/p/368421654</a></p></blockquote><h2 id="一、问题引出"><a href="#一、问题引出" class="headerlink" title="一、问题引出"></a>一、问题引出</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">150</span>; i++) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> i;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> i;<br>        System.out.println(i + <span class="hljs-string">&quot; &quot;</span> + (a == b));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>i取值从0到150，每次循环a与b的数值均相等，输出a &#x3D;&#x3D; b。运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> <span class="hljs-literal">true</span><br><span class="hljs-number">1</span> <span class="hljs-literal">true</span><br><span class="hljs-number">2</span> <span class="hljs-literal">true</span><br><span class="hljs-number">3</span> <span class="hljs-literal">true</span><br>...<br><span class="hljs-number">126</span> <span class="hljs-literal">true</span><br><span class="hljs-number">127</span> <span class="hljs-literal">true</span><br><span class="hljs-number">128</span> <span class="hljs-literal">false</span><br><span class="hljs-number">129</span> <span class="hljs-literal">false</span><br><span class="hljs-number">130</span> <span class="hljs-literal">false</span><br>...<br></code></pre></td></tr></table></figure><p>从128开始a和b就不再相等了</p><h2 id="二、自动装箱"><a href="#二、自动装箱" class="headerlink" title="二、自动装箱"></a>二、自动装箱</h2><p>首先回顾一下自动装箱。对于下面这行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>变量a为Integer类型，而1为int类型，且Integer和int之间并无继承关系，按照Java的一般处理方法，这行代码应该报错。</p><p>但因为自动装箱机制的存在，在为Integer类型的变量赋int类型值时，Java会自动将int类型转换为Integer类型，即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> Integer.valueOf(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>valueOf()方法返回一个Integer类型值，并将其赋值给变量a。这就是int的自动装箱。</p><h2 id="三、原理分析"><a href="#三、原理分析" class="headerlink" title="三、原理分析"></a>三、原理分析</h2><p>每次循环时，Integer a &#x3D; i和Integer b &#x3D; i都会触发自动装箱，而自动装箱会将int转换Integer类型值并返回；我们知道Java中两个new出来的对象因为是不同的实例，无论如何&#x3D;&#x3D;都会返回fasle。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>) == <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>就会返回false。</p><p>那么例子中Integer a &#x3D; i和Integer b &#x3D; i自动装箱产生的变量a和b就不应该时同一个对象了，那么&#x3D;&#x3D;的结果应该时false。</p><p>128以上为false容易理解，但为何0到127时返回true了呢？&#x3D;&#x3D;返回true的唯一情况是比较的两个对象为同一个对象，那不妨把例子中a和b的内存地址都打印出来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">150</span>;i++)&#123;<br>    Integer a=i;<br>    Integer b=i;<br>    System.out.println(a+<span class="hljs-string">&quot; &quot;</span>+b+<span class="hljs-string">&quot; &quot;</span>+System.identityHashCode(a)+<span class="hljs-string">&quot; &quot;</span>+System.identityHashCode(b));<br>&#125;<br></code></pre></td></tr></table></figure><p>identityHashCode()方法可以理解为输出对应变量的内存地址，输出为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">0 0 762119098 762119098<br>1 1 1278349992 1278349992<br>2 2 1801910956 1801910956<br>3 3 1468253089 1468253089<br>...<br>126 126 1605164995 1605164995<br>127 127 1318497351 1318497351<br>128 128 101224864 479240824<br>129 129 1373088356 636728630<br>130 130 587071409 1369296745<br>...<br></code></pre></td></tr></table></figure><p>竟然从0到127不同时候自动装箱得到的是同一个对象！从128开始才是正常情况。</p><h2 id="四、源码分析"><a href="#四、源码分析" class="headerlink" title="四、源码分析"></a>四、源码分析</h2><p>“从0到127不同时候自动装箱得到的是同一个对象”就只能有一种解释：自动装箱并不一定new出新的对象。</p><p>既然自动装箱涉及到的方法是Integer.valueOf()，不妨看看其源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果int型参数i在IntegerCache.low和IntegerCache.high范围内，则直接由IntegerCache返回；否则new一个新的对象返回。<mark>IntegerCache.low就是-128，IntegerCache.high就是127</mark>。</p><p>在IntegerCache的static块中就一次性生成了-128到127直接的Integer类型变量存储在cache[]中，对于-128到127之间的int类型，返回的都是同一个Integer类型对象。</p><p>这下真相大白了，整个工作过程就是：Integer.class在装载（Java虚拟机启动）时，其内部类型IntegerCache的static块即开始执行，实例化并暂存数值在-128到127之间的Integer类型对象。当自动装箱int型值在-128到127之间时，即直接返回IntegerCache中暂存的Integer类型对象。</p><p>为什么Java这么设计？我想是出于效率考虑，因为自动装箱经常遇到，尤其是小数值的自动装箱；而如果每次自动装箱都触发new，在堆中分配内存，就显得太慢了；所以不如预先将那些常用的值提前生成好，自动装箱时直接拿出来返回。哪些值是常用的？就是-128到127了。</p>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>点评项目面经总结</title>
    <link href="/2025/05/13/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2025/05/13/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="点评项目面经总结"><a href="#点评项目面经总结" class="headerlink" title="点评项目面经总结"></a>点评项目面经总结</h1><h2 id="1-使用Redis解决了在集群模式下的Session共享问题，使用拦截器实现用户的登录校验和权限刷新"><a href="#1-使用Redis解决了在集群模式下的Session共享问题，使用拦截器实现用户的登录校验和权限刷新" class="headerlink" title="1. 使用Redis解决了在集群模式下的Session共享问题，使用拦截器实现用户的登录校验和权限刷新"></a>1. 使用Redis解决了在集群模式下的Session共享问题，使用拦截器实现用户的登录校验和权限刷新</h2><blockquote><p>Session共享问题：在多台Tomcat服务器的集群模式下，多台Tomcat之间不会共享Session，导致在Tomcat1中携带有用户的登录信息，但Tomcat2中没有，当用户使用Tomcat2时，会判断为未登录</p></blockquote><ul><li>基于Redis实现：<ul><li>将随机生成的<strong>token</strong>作为key值，保证了唯一性的同时又方便携带，同时token有对应的<strong>存活时间</strong></li><li>使用<code>Redis</code>的 <strong>Hash</strong> 数据结构存储用户数据（对象）</li></ul></li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131430982.webp" alt="img"></p><ul><li>登录校验+权限刷新（两个拦截器）<ul><li>权限刷新：第一个拦截器拦截一切路径，获取网页携带过来的token，使用这个token去查询Redis中对应的用户信息，将查到的用户保存到ThreadLocal中，刷新对应token的ttl，然后放行。</li><li>登录校验：第二个拦截器只拦截需要登录的路径，查询上面的ThreadLocal中是否有用户信息（在上面一步中，如果token查不到Redis中有对应的用户信息，说明用户没登录，ThreadLocal中是空值），如果没有则拦截；否则放行。</li></ul></li></ul><h2 id="2-基于Cache-Aside模式解决数据库与缓存的一致性问题"><a href="#2-基于Cache-Aside模式解决数据库与缓存的一致性问题" class="headerlink" title="2. 基于Cache Aside模式解决数据库与缓存的一致性问题"></a>2. 基于Cache Aside模式解决数据库与缓存的一致性问题</h2><blockquote><p><strong>Cache Aside</strong>（旁路缓存）是一种常用的缓存策略，用于优化系统性能并减少数据库的压力。在这种模式下，缓存被视为辅助存储介质，当需要访问某个数据时，系统首先尝试从缓存中获取数据，如果缓存中不存在该数据，则从数据库中获取数据，并将其缓存起来。</p><p>读写策略</p><ul><li><p>读策略</p><ol><li><strong>读取缓存</strong>：首先尝试从缓存中读取数据。</li><li><strong>缓存未命中</strong>：如果缓存中没有数据，则从数据库中读取数据。</li><li><strong>更新缓存</strong>：将从数据库中读取的数据写入缓存，以便下次访问时可以直接从缓存中获取。</li></ol></li><li><p>写策略</p><ol><li><strong>更新数据库</strong>：首先更新数据库中的数据。</li><li><strong>使缓存失效</strong>：然后使缓存中的数据失效，而不是直接更新缓存。这是为了避免数据不一致的问题</li></ol></li></ul></blockquote><p>操作缓存和数据库时有三个问题需要考虑：</p><h3 id="删除缓存还是更新缓存？"><a href="#删除缓存还是更新缓存？" class="headerlink" title="删除缓存还是更新缓存？"></a>删除缓存还是更新缓存？</h3><ul><li>更新缓存：每次更新数据库都更新缓存，无效写操作较多</li><li><strong>删除缓存</strong>：更新数据库时让缓存失效，查询时再更新缓存</li></ul><p>如果采用第一个方案，那么假设我们每次操作数据库后，都更新缓存，但是中间如果没有人查询，那么这个更新动作实际上意义并不大；我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来</p><h3 id="如何保证缓存与数据库的操作同时成功或失败？"><a href="#如何保证缓存与数据库的操作同时成功或失败？" class="headerlink" title="如何保证缓存与数据库的操作同时成功或失败？"></a>如何保证缓存与数据库的操作同时成功或失败？</h3><ul><li>单体系统：将缓存和数据库的操作放在一个事务</li><li>分布式系统：分布式事务</li></ul><h3 id="先操作缓存还是先操作数据库？"><a href="#先操作缓存还是先操作数据库？" class="headerlink" title="先操作缓存还是先操作数据库？"></a>先操作缓存还是先操作数据库？</h3><ul><li><strong>先删除缓存再操作数据库</strong></li><li><a href="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752308.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752308.png" alt="image-20250211203731172" style="zoom:50%;" /></a><a href="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752090.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752090.png" alt="image-20250211203755582" style="zoom:50%;" /></a></li><li><mark>先操作数据库再删除缓存</mark></li><li><a href="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752210.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752210.png" alt="image-20250211203939763" style="zoom:50%;" /></a><a href="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752102.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752102.png" alt="image-20250211203955306" style="zoom:50%;" /></a></li><li>左边为正常情况，右边为异常情况</li><li>相比之下，前者出现异常情况的概率较大，而后者出现异常情况的概率较小，<strong>这是因为更新数据库的耗时相对而言较长导致的</strong>，因此可以选择后者。</li></ul><h2 id="3-使用Redis对高频访问的信息进行缓存，降低了数据库查询的压力，解决了缓存穿透、雪崩、击穿等问题"><a href="#3-使用Redis对高频访问的信息进行缓存，降低了数据库查询的压力，解决了缓存穿透、雪崩、击穿等问题" class="headerlink" title="3. 使用Redis对高频访问的信息进行缓存，降低了数据库查询的压力，解决了缓存穿透、雪崩、击穿等问题"></a>3. 使用Redis对高频访问的信息进行缓存，降低了数据库查询的压力，解决了缓存穿透、雪崩、击穿等问题</h2><blockquote><p><strong>缓存穿透</strong></p><p>缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库，从而对数据库造成巨大压力。</p></blockquote><ul><li><p><strong>方案一：缓存空对象</strong> 如果查询的这个数据在数据库中也不存在，我们也把这个空数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据</p><blockquote><p>实现简单，维护方便，但会造成额外的内存消耗，以及可能造成短期的不一致</p></blockquote></li><li><p><strong>方案二：布隆过滤</strong> 布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><blockquote><p>内存占用较少，没有多余key，缺点是实现复杂，存在误判可能(<strong>哈希冲突</strong>)</p></blockquote></li></ul><hr><blockquote><p><strong>缓存雪崩</strong></p><p>缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p></blockquote><p>解决方案：</p><ul><li>对于大量key同时失效的情况，可以给不同key的ttl添加随机值</li><li>对于Redis服务宕机的情况，可以利用Redis集群提高服务的可用性，还可以给缓存业务添加降级限流策略</li></ul><hr><blockquote><p><strong>缓存击穿</strong></p><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p></blockquote><ul><li><p><strong>方案一：互斥锁</strong> 给<strong>第一个未命中缓存的线程加锁</strong>、查询数据库并写入缓存后再释放锁，<strong>其他线程在此期间需要等待</strong>。</p><blockquote><ul><li>优点：1. 没有额外的内存消耗 2. 保证一致性 3. 实现简单</li><li>缺点：1. 线程需要等待，性能受影响 2. 可能有死锁风险</li></ul></blockquote></li><li><p><strong>方案二：逻辑过期</strong> 不设置TTL，而是设置一个逻辑过期时间，首个发现逻辑时间过期的线程会<strong>开启一个新的线程用于更新数据</strong>，其本身以及在此期间查询的其他线程则会<strong>返回当下的过期数据</strong>。</p><blockquote><ul><li>优点：线程无需等待，性能良好</li><li>缺点：1. 不保证一致性 2. 有额外内存消耗 3. 实现复杂</li></ul></blockquote></li></ul><h2 id="4-基于乐观锁CAS解决秒杀产生的超卖问题"><a href="#4-基于乐观锁CAS解决秒杀产生的超卖问题" class="headerlink" title="4. 基于乐观锁CAS解决秒杀产生的超卖问题"></a>4. 基于乐观锁CAS解决秒杀产生的超卖问题</h2><blockquote><p>超卖问题：当库存只剩最后一个时，同时有多个线程在对方扣减库存之前，查询并判断库存充足，然后对库存进行减少，导致最终库存为负数</p></blockquote><h3 id="CAS解决超卖问题"><a href="#CAS解决超卖问题" class="headerlink" title="CAS解决超卖问题"></a>CAS解决超卖问题</h3><p>乐观锁的常见实现方式有两种：<strong>版本号法、CAS（Compare and Swap）</strong></p><ul><li>版本号法：在原有数据基础上，为每个数据添加一个版本号version，数据每进行一次修改就使版本号增加。当要修改数据时，比较之前查询该数据得到的版本号与当前的版本号是否一致，若不一致则说明数据出现了修改。</li><li>CAS：在版本号的基础上，直接拿数据中要进行修改的字段进行比较，若前后不一致则说明发生了修改。</li></ul><p><a href="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754859.png"><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131430201.png" alt="image-20250212170924768"></a></p><h3 id="CAS解决超卖问题时出现的问题"><a href="#CAS解决超卖问题时出现的问题" class="headerlink" title="CAS解决超卖问题时出现的问题"></a>CAS解决超卖问题时出现的问题</h3><p>我们选择使用上方的CAS方法解决超卖问题，在jMeter压力测试中，选择使用200个线程同时对100张秒杀优惠券进行抢购，这一次优惠券的库存没有变为负数，但是优惠券只卖出了20张，秒杀成功率大大减少了。</p><p>这是因为当有<strong>多个线程同时查到了同样的库存</strong>时，<strong>只有一个线程能够抢到优惠券</strong>，其他线程会因为当前剩余库存与前面查询到的库存不一致导致秒杀失败。</p><p>解决方案：将sql语句中的：stock &#x3D; 前面查询到的stock 更改为 <strong>stock &gt; 0</strong> 即可。</p><h3 id="为什么超卖问题需要加锁？"><a href="#为什么超卖问题需要加锁？" class="headerlink" title="为什么超卖问题需要加锁？"></a>为什么超卖问题需要加锁？</h3><p>超卖问题是因为多个用户对不足的库存同时进行库存查询及获取导致库存减为负数的情况，为每个用户加一个乐观锁，能够保证一个商品只被一个用户购买。</p><h2 id="5-基于Redisson分布式锁解决集群下一人一单的并发安全问题"><a href="#5-基于Redisson分布式锁解决集群下一人一单的并发安全问题" class="headerlink" title="5. 基于Redisson分布式锁解决集群下一人一单的并发安全问题"></a>5. 基于Redisson分布式锁解决集群下一人一单的并发安全问题</h2><blockquote><p><strong>集群下一人一单的并发安全问题</strong></p><p>在单体系统下，我们解决一人一单问题的实现方式是在对应代码上加锁，在单体部署的情况下是没有问题的，因为此时只有一台Tomcat1，即只有一台JVM1，线程获取的锁都是这台JVM1中的同一把锁（锁的UUID保存在常量池中），故<strong>多个线程竞争这一把锁</strong>，保证了线程安全。</p><p>但是如果在集群部署的情况下，就说明有<strong>多台Tomcat提供服务，即有多台JVM</strong>，故Tomcat1中的线程竞争的是JVM1中的锁，而Tomcat2中的线程竞争的是JVM2中的锁，<strong>此时有多把锁</strong>。故此时如果一个用户在两台Tomcat中都实现了下单操作，则<strong>两边都能获取到锁</strong>，故生成了两个订单，违背了一人一单的规定，这就导致了集群下一人一单问题的并发安全问题。</p></blockquote><h3 id="解决方案一：Redis实现分布式锁"><a href="#解决方案一：Redis实现分布式锁" class="headerlink" title="解决方案一：Redis实现分布式锁"></a>解决方案一：Redis实现分布式锁</h3><ol><li><p>使用redis实现分布式锁就会出现一个问题：当一个进程占有锁时，若此时redis宕机了，就会导致锁无法被释放，造成<strong>死锁现象</strong>的产生。解决这个问题也很简单，我们只需要给这个锁设置一个<strong>过期时间</strong>，超时自动释放锁，就不会出现由于redis宕机导致的死锁现象。</p></li><li><p>但是，正是由于给锁设置了过期时间，新的问题产生了——<strong>锁的误删问题</strong>。如下图所示，当线程1获取锁但是业务阻塞导致<strong>超时释放锁</strong>，在线程1业务完成之前，<strong>线程2趁虚而入拿到了锁并开始执行业务</strong>，这时候线程1完成了业务并按部就班去释放锁，但是这时候占用锁的是线程2，也就是说<strong>线程1把线程2的锁给释放了</strong>，这时候如果又有一个线程3来获取锁是能够获取成功的，这就导致了线程2、线程3同时执行业务，产生了并发安全问题。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131430284.png" alt="image-20250213130001479"></p><p>解决锁的误删问题可以采用如下方法：在给锁设置<strong>value值</strong>时，使用<strong>线程ID作为锁的value值</strong>，这样就能知道当前的锁是不是本线程所设置的，当线程业务执行完毕想要释放锁时，先执行一个判断，<strong>判断当前锁的value值与自身线程ID是否相同</strong>，如果相同说明是同一把锁可以释放，否则说明是别的线程的锁，不做操作，这样就避免了锁的误删问题。</p><p>当然，仅仅只使用线程ID作为value值是不够的，因为在不同的进程之间可能存在相同的线程ID，有小概率出现混淆的情况，我们可以选择在<strong>线程ID之前拼接一个UUID确保唯一性</strong>，将拼接的结果作为锁的value值。</p></li><li><p>但是，还会有一个问题：当线程1获取锁之后，未执行业务就发生了阻塞，此时如果锁释放了，线程2来获取锁是能够获取得到的，这就会造成线程1、2同时执行业务的情况出现，还是会发生一个用户下了多个订单的情况。如上图中<strong>线程1、2执行业务有重叠的部分</strong>。</p></li></ol><h3 id="解决方案二：Redisson分布式锁"><a href="#解决方案二：Redisson分布式锁" class="headerlink" title="解决方案二：Redisson分布式锁"></a>解决方案二：Redisson分布式锁</h3><p>具体原理可见：<a href="https://hwang-jj.github.io/2025/05/13/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%BA%E5%88%B6/">Redisson分布式锁原理</a></p><p>总之，使用Redisson分布式锁可以解决Redis分布式锁的：不可重入问题（Redisson可重入锁）、不可重试问题（Redisson锁重试机制）、超时释放带来的问题（WatchDog机制）、主从一致性问题（MultiLock）</p><h3 id="为什么要加这个分布式锁"><a href="#为什么要加这个分布式锁" class="headerlink" title="为什么要加这个分布式锁"></a>为什么要加这个分布式锁</h3><p>一人一单出现线程安全问题是因为一个用户可能在多个线程同时下单导致一人多单的情况。是针对一个用户的多个线程加的锁。</p><h2 id="6-利用Kafka-Lua脚本实现异步秒杀功能，提高系统秒杀功能"><a href="#6-利用Kafka-Lua脚本实现异步秒杀功能，提高系统秒杀功能" class="headerlink" title="6. 利用Kafka+Lua脚本实现异步秒杀功能，提高系统秒杀功能"></a>6. 利用Kafka+Lua脚本实现异步秒杀功能，提高系统秒杀功能</h2><blockquote><p>秒杀下单流程：查询优惠券、判断秒杀库存是否足够、查询订单、校验是否一人一单、扣减库存、创建订单（串行执行，需要异步优化）</p></blockquote><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p><strong>将耗时较短的逻辑判断放到Redis</strong>中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。</p><h3 id="为什么选用Kafka，它和别的MQ有什么区别、优势？"><a href="#为什么选用Kafka，它和别的MQ有什么区别、优势？" class="headerlink" title="为什么选用Kafka，它和别的MQ有什么区别、优势？"></a>为什么选用Kafka，它和别的MQ有什么区别、优势？</h3><h2 id="7-使用Redis的ZSet数据结构实现了点赞排行榜的功能，使用Set集合实现关注、共同关注功能"><a href="#7-使用Redis的ZSet数据结构实现了点赞排行榜的功能，使用Set集合实现关注、共同关注功能" class="headerlink" title="7. 使用Redis的ZSet数据结构实现了点赞排行榜的功能，使用Set集合实现关注、共同关注功能"></a>7. 使用Redis的ZSet数据结构实现了点赞排行榜的功能，使用Set集合实现关注、共同关注功能</h2><h3 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a>点赞排行榜</h3><ul><li>当我们点击探店笔记详情页面时，应该按点赞顺序展示点赞用户，比如显示最早点赞的TOP5，形成点赞排行榜。之前的点赞是放到Set集合中，但是Set集合又不能排序，所以这个时候，我们就可以改用<strong>SortedSet(Zset)</strong>，将<strong>时间戳作为zset对应用户id的得分</strong>，根据得分排序即可实现显示最早点赞的top5。</li><li>而Zset没有ismember的方法，我们可以选择score方法，该方法查询对应用户ID的score，如果没有这个用户，就返回空值。</li></ul><h3 id="关注与取关"><a href="#关注与取关" class="headerlink" title="关注与取关"></a><strong>关注与取关</strong></h3><p>关注与取关会传入一个isFollow参数，true表示关注，false表示取关</p><ul><li>关注只需要创建一个Follow对象，将关注者（当前用户）id与被关注者id赋给这个Follow对象，然后直接保存到数据库中即可</li><li>同理，取关只需要把数据库中<code>user_id = userId</code>且<code>follow_user_id = followUserId</code>的记录删除即可。</li></ul><h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a><strong>共同关注</strong></h3><p>共同关注可以利用redis中<strong>set</strong>数据类型，对<strong>两个key的set取交集来实现</strong></p><ul><li>key用于区分用户，模式为<code>follow:userId</code></li><li>value则是对应用户的关注对象的set集合</li><li>因此，需要在关注时，同步将关注信息传入redis中；同理取关时也要将被关注者从当前用户的set集合中删除</li><li>使用set数据结构的intersect功能来实现取交集</li><li>取得共同关注id集合（String集合）后，要将id集合解析（String转化为Long），然后查询各id对应的用户信息user并<strong>封装到userDTO</strong>中确保安全，然后返回。</li></ul><h2 id="8-其他问题"><a href="#8-其他问题" class="headerlink" title="8. 其他问题"></a>8. 其他问题</h2><h3 id="Redis的大Key问题？"><a href="#Redis的大Key问题？" class="headerlink" title="Redis的大Key问题？"></a>Redis的大Key问题？</h3><blockquote><p>**通俗易懂的讲，Big Key就是某个key对应的value很大，占用的redis空间很大，本质上是大value问题。**key往往是程序可以自行设置的，value往往不受程序控制，因此可能导致value很大。</p><ul><li>一个String类型的Key，它的值为5MB（数据过大）；</li><li>一个List类型的Key，它的列表数量为20000个（列表数量过多）；</li><li>一个ZSet类型的Key，它的成员数量为10000个（成员数量过多）；</li><li>一个Hash格式的Key，它的成员数量虽然只有1000个但这些成员的value总大小为100MB（成员体积过大）；</li></ul><p>假设我们使用List数据结构保存某个明星&#x2F;网红的粉丝，或者保存热点新闻的评论列表，因为粉丝数量巨大，热点新闻因为点击率、评论数会很多，这样List集合中存放的元素就会很多，可能导致value过大，进而产生Big Key问题。</p></blockquote><ul><li><p>大key的危害</p><ul><li>阻塞请求：Big Key对应的value较大，我们对其进行读写的时候，需要耗费较长的时间，这样就可能阻塞后续的请求处理。Redis的核心线程是单线程，单线程中请求任务的处理是串行的，前面的任务完不成，后面的任务就处理不了。</li><li>内存增大：引发OOM</li><li>阻塞网络：读取单value较大时会占用服务器网卡较多带宽，自身变慢的同时可能会影响该服务器上的其他Redis实例或者应用。</li></ul></li><li><p>如何识别大key</p><p>Redis官方客户端redis-cli加上–bigkeys参数，可以找到某个实例5种数据类型(String、hash、list、set、zset)的最大key</p></li><li><p>如何解决大key</p><ul><li>对大key进行拆分</li><li>对大Key进行清理</li><li>压缩value</li><li>定期清理失效数据</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Redisson分布式锁机制</title>
    <link href="/2025/05/13/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <url>/2025/05/13/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h1><h2 id="一、基于Redis的setnx实现的分布式锁存在的问题"><a href="#一、基于Redis的setnx实现的分布式锁存在的问题" class="headerlink" title="一、基于Redis的setnx实现的分布式锁存在的问题"></a>一、基于Redis的setnx实现的分布式锁存在的问题</h2><ul><li>不可重入：同一个线程无法多次获取同一把锁</li><li>不可重试：获取锁只尝试一次，失败就返回 false，没有重试机制</li><li>超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患</li><li>主从一致性：如果 Redis 提供了主从集群，主从同步存在延迟，此时某个线程从主节点中获取到了锁，但是尚未同步给从节点，而恰巧主节点在这个时候发生宕机。就会从从机中选择出一个节点成为新的主节点，这时候新的主节点上没有锁的信息，那么其他线程就有可能趁虚而入，从新的主节点中获取到锁，这样就出现多个线程拿到多把锁，在极端情况下，可能会出现安全问题</li></ul><hr><h2 id="二、Redisson的可重入锁原理"><a href="#二、Redisson的可重入锁原理" class="headerlink" title="二、Redisson的可重入锁原理"></a>二、Redisson的可重入锁原理</h2><p><strong>核心</strong>：基于 Redis 中的<strong>Hash结构</strong>实现的分布式锁，利用 key 来锁定资源（锁名称），对于 field 来标识唯一成功获取锁的对象（持有该锁的对象），而对于 value 来累计同一个线程成功获取相同的锁的次数（锁被获取的次数）。</p><p>具体实现思路：</p><ul><li><strong>尝试获取锁</strong>：先判断缓存中是否存在 key 字段，如果存在，则说明锁已经被成功获取，这时候需要继续判断成功获取锁的对象是否为当前线程，如果根据 key field 来判断是当前线程，则 value +&#x3D; 1 且还需要重置锁的超时时间；如果根据 key field 判断不是当前线程，则直接返回 null。如果缓存中不存在 key 字段，则说明锁还没有被其他线程获取，则获取锁成功。</li><li><strong>释放锁</strong>：当业务完成之后，在释放锁之前，先判断获取锁的对象是不是当前线程，如果不是当前线程，则说明可能由于超时，锁已经被自动释放了，这时候直接返回 null；如果是当前线程，则进行 value -&#x3D; 1 ，最后再来判断 value 是否大于 0 ，当大于 0 时，则不能直接释放锁，需要重置锁的超时时间；当 value &#x3D; 0 时，则可以真正的释放锁。</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131141327.png" alt="在这里插入图片描述"></p><p><strong>又因为使用 Java 实现不能保证原子性，所以需要借助 Lua 脚本实现多条 Redis 命令来保证原则性。</strong></p><p>尝试获取锁的Lua脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>];  <span class="hljs-comment">-- 锁的key</span><br><span class="hljs-keyword">local</span> threadId = ARGV[<span class="hljs-number">1</span>]; <span class="hljs-comment">-- 线程唯一标识</span><br><span class="hljs-keyword">local</span> releaseTime = ARGV[<span class="hljs-number">2</span>]; <span class="hljs-comment">-- 锁的自动释放时间</span><br><br><span class="hljs-comment">-- 判断是否存在</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, key) == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 不存在，获取锁</span><br>    redis.call(<span class="hljs-string">&#x27;hset&#x27;</span>, key, threadId, <span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-comment">-- 设置有效期</span><br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, key, releaseTime);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- 返回结果</span><br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-comment">-- 锁已经存在，判断threadId是否是自己</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 存在，获取锁，重入次数+1</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-comment">-- 设置有效期</span><br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, key, releaseTime);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- 返回结果</span><br><span class="hljs-keyword">end</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">-- 代码走到这里，说明获取锁的不是自己，获取锁失败</span><br></code></pre></td></tr></table></figure><p>释放锁的Lua脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>];  <span class="hljs-comment">-- 锁的key</span><br><span class="hljs-keyword">local</span> threadId = ARGV[<span class="hljs-number">1</span>]; <span class="hljs-comment">-- 线程唯一标识</span><br><span class="hljs-keyword">local</span> releaseTime = ARGV[<span class="hljs-number">2</span>]; <span class="hljs-comment">-- 锁的自动释放时间</span><br><br><span class="hljs-comment">-- 判断当前锁是否还是被自己持有</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, key, threadId) == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>; <span class="hljs-comment">-- 如果已经不是自己，则直接返回</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 是自己的锁，则重入次数-1</span><br><span class="hljs-keyword">local</span> count = redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, key, threadId, <span class="hljs-number">-1</span>);<br><span class="hljs-comment">-- 判断重入次数是否已经为0</span><br><span class="hljs-keyword">if</span>(count &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 大于0说明不能是释放锁，重置有效期然后返回</span><br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, threadId, releaseTime);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><span class="hljs-keyword">else</span><br>    redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, key); <span class="hljs-comment">-- 等于 0 说明可以释放锁，直接删除</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><hr><h2 id="三、Redisson的锁重试和WatchDog机制"><a href="#三、Redisson的锁重试和WatchDog机制" class="headerlink" title="三、Redisson的锁重试和WatchDog机制"></a>三、Redisson的锁重试和WatchDog机制</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131141329.png" alt="在这里插入图片描述"></p><ul><li><strong>锁重试</strong>：利用信号量、发布消息publish、订阅消息subscribe功能，实现获取锁失败后的一段时间（ttl）内重新尝试获取锁。而重新尝试获取锁<strong>并不是立刻重新尝试</strong>，而是通过<strong>订阅</strong>释放锁的消息，接收到锁释放的消息后去重试，<strong>减轻了cpu的负担</strong>，因此在线程释放锁后需要向外<strong>发布</strong>释放锁的消息。当然，重试并不是无限次的，会有一个等待时间，如果超过等待时间，就结束重试。</li><li><strong>WatchDog机制</strong>：给锁添加过期时间，虽然能够解决死锁的问题，但是如果事务发生了阻塞导致超时释放锁，还是会出现多个线程同时执行业务的情况，失去了锁的作用，造成了一人多单的情况。因此，关键点就是<mark>不要让事务阻塞导致超时释放锁，超时释放只应该在redis服务宕机、或持有锁的线程挂掉时起作用</mark>，于是就引出了WatchDog机制。<ul><li>WatchDog就是持有锁的线程给锁加了一条看门狗，<strong>只要这个线程存在，狗就会不断给锁续期不让它过期</strong>，<mark>直到线程执行完事务并亲自释放锁</mark>。</li><li>既然WatchDog会给锁不断续期，那么锁设置过期时间还有意义吗？答案是有的。因为这个<strong>过期时间主要是为了防止线程挂掉、redis宕机导致的死锁，过期时间只应在这些情况下释放锁</strong>，如果过期时间是因为线程事务发生阻塞超时释放锁，就会产生上面的并发问题，而WatchDog就是引进来不让这种情况发生的。</li></ul></li></ul><hr><h2 id="四、Redisson的MultiLock原理"><a href="#四、Redisson的MultiLock原理" class="headerlink" title="四、Redisson的MultiLock原理"></a>四、Redisson的MultiLock原理</h2><ul><li>为了提高Redis的可用性，我们会搭建集群或者主从，现在以主从为例</li><li>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设<strong>主机还没来得及把数据写入到从机去的时候，主机宕机了</strong></li><li>哨兵会发现主机宕机了，于是选举一个slave(从机)变成master(主机)，而此时<strong>新的master(主机)上并没有锁的信息</strong>，那么其他线程就可以获取锁，又会引发安全问题</li><li>为了解决这个问题。Redisson提出来了MutiLock锁，使用这把锁的话，那我们就不用主从了，每个节点的地位都是一样的，都可以当做是主机，那我们就<mark>需要将加锁的逻辑写入到每一个主从节点上，只有所有的服务器都写入成功，此时才是加锁成功</mark>，假设现在某个节点挂了，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性</li></ul><hr><h2 id="五、Redisson小结"><a href="#五、Redisson小结" class="headerlink" title="五、Redisson小结"></a>五、Redisson小结</h2><ol><li>不可重入Redis分布式锁<ul><li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入Redis分布式锁<ul><li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：Redis宕机引起锁失效问题</li></ul></li><li>Redisson的multiLock<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li><li>缺陷：运维成本高、实现复杂</li></ul></li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal原理</title>
    <link href="/2025/05/13/ThreadLocal%E5%8E%9F%E7%90%86/"/>
    <url>/2025/05/13/ThreadLocal%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://luming.blog.csdn.net/article/details/141071290?fromshare=blogdetail&sharetype=blogdetail&sharerId=141071290&sharerefer=PC&sharesource=m0_51140831&sharefrom=from_link">https://luming.blog.csdn.net/article/details/141071290?fromshare=blogdetail&amp;sharetype=blogdetail&amp;sharerId=141071290&amp;sharerefer=PC&amp;sharesource=m0_51140831&amp;sharefrom=from_link</a></p></blockquote><h2 id="一、什么是ThreadLocal"><a href="#一、什么是ThreadLocal" class="headerlink" title="一、什么是ThreadLocal"></a>一、什么是ThreadLocal</h2><p>在Java中，ThreadLocal 类提供了一种方式，使得每个线程可以独立地持有自己的变量副本，而不是共享变量。这可以避免线程间的同步问题，因为<strong>每个线程只能访问自己的ThreadLocal变量</strong>。通过ThreadLocal为线程添加的值只能由这个线程访问到，其他的线程无法访问，因此就避免了多线程之间的同步问题</p><p>使用ThreadLocal时，通常需要实现以下步骤：</p><ul><li>初始化：创建ThreadLocal变量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;T&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><ul><li>设置值：使用set(T value)方法为当前线程设置值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">threadLocal.set(value);<br></code></pre></td></tr></table></figure><ul><li>获取值：使用get()方法获取当前线程的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> threadLocal.get();<br></code></pre></td></tr></table></figure><ul><li>移除值：使用remove()方法在线程结束时清除ThreadLocal变量，以避免内存泄漏。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">threadLocal.remove();<br></code></pre></td></tr></table></figure><ul><li>示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 设置线程局部变量的值</span><br>        threadLocal.set(<span class="hljs-number">10</span>);<br> <br>        <span class="hljs-comment">// 这个值在其他线程中是取不到获取的</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> threadLocal.get();<span class="hljs-comment">//null</span><br>            System.out.println(<span class="hljs-string">&quot;Thread value: &quot;</span> + value);<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131013254.png" alt="img"></p><h2 id="二、ThreadLocal的数据结构"><a href="#二、ThreadLocal的数据结构" class="headerlink" title="二、ThreadLocal的数据结构"></a>二、ThreadLocal的数据结构</h2><p>在JDK8之后每一个线程都会维护一个ThreadLocalMap，这个Map是一个哈希散列结构，如下图所示，每一个元素（Entry）都是一个键值对，key为ThreadLocal，Value为存储的数据，也就是set()方法存储的内容。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131013255.png" alt="img"></p><h2 id="三、ThreadLocal的内存泄露问题"><a href="#三、ThreadLocal的内存泄露问题" class="headerlink" title="三、ThreadLocal的内存泄露问题"></a>三、ThreadLocal的内存泄露问题</h2><p>首先是内存泄漏的概念：</p><ul><li>内存溢出：没有足够的内存供申请者使用</li><li>内存泄漏：程序中已经动态分配的内存由于某种原因未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至崩溃。此外内存泄漏的堆积最终也会导致内存溢出。</li></ul><p>下图是ThreadLocal相关的内存结构图，在栈区中有threadLocal对象和当前线程对象，分别指向堆区真正存储的类对象，<strong>这俩个指向都是强引用</strong>。在堆区中当前线程肯定是只有自己的Map的信息的，而Map中又存储着一个个的Entry节点；在Entry节点中每一个Key都是ThreadLocal的实例，同时Value又指向了真正的存储的数据位置，以上便是下图的引用关系。<br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131013257.png" alt="img"></p><p>那么所谓的内存泄漏，其实就是指的<strong>Entry这块内存不能正确释放</strong></p><blockquote><p>强弱引用的概念：</p><ul><li>强引用(StrongReference)：就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾回收器就不会回收这种对象。</li><li>弱引用(WeakReference)：垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</li></ul></blockquote><h3 id="如果Key是强引用"><a href="#如果Key是强引用" class="headerlink" title="如果Key是强引用"></a>如果Key是强引用</h3><p>当我们在业务代码中使用完ThreadLocal，在栈区指向堆区的这个指向关系就会被回收掉了，但是由于Key是强引用指向ThreadLocal，故而堆区中的ThreadLocal无法被回收，此时的Key指向ThreadLocal，另外由于当前线程还没有结束，则下面那条强引用指向关系任然存在。故为下图的关系状态<br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131013258.png" alt="img"></p><p>在这样的情况下，由于栈上的指向已经消失了，我们无法访问到堆上的ThreadLocal，故而无法访问到Entry，但是Entry又有Map指向它，故而无法进行回收。那么此时的Entry即无法访问也无法回收，这就造成了<mark>Entry的内存泄露</mark>。</p><h3 id="如果Key是弱引用"><a href="#如果Key是弱引用" class="headerlink" title="如果Key是弱引用"></a>如果Key是弱引用</h3><p>其次是弱引用的情况，当我们在业务代码中使用完ThreadLocal就通过垃圾回收（GC）进行了回收，那么由于Key是弱引用，Key此时就指向null，但是由于当前线程还没有结束，则下面那条强引用指向关系仍然存在</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202505131013259.png" alt="img"></p><p>在这样的情况下，Entry由于仍然有Map指向它所以不会被GC回收掉，但是此时的Key又为null，所以我们无法访问到这个Value。这就导致了这个Value我们即不能访问到也不能进行回收，此时就造成了<mark>Value的内存泄漏</mark>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过以上分析，我们得知了不管Entry中的Key是否为弱引用，都会造成内存泄漏的情况，只不过强引用下是Entry的内存泄漏，弱引用下是Value的内存泄漏。造成这样内存泄漏的情况都有这样的共同特性：</p><ul><li>都没有手动删除Entry</li><li>当前线程都在运行</li></ul><p>也就是说，只要我们在使用完ThreadLocal后，调用其remove()方法删除对应的Entry就可以避免内存泄漏的问题。</p><p>并且由于ThreadLoaclMap是Thread的一个属性，故而它的生命周期和线程一样，那么当线程的生命周期结束，自然也就没有Map指向Entry，这也就在根源上解决了问题。</p><p>综上所述，造成ThreadLocal内存泄漏的根本原因是：<mark>由于ThreadLocalMap的生命周期和Thread一样长，如果没有手动删除对应的Key就会导致内存泄漏</mark>。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2025/03/12/RabbitMQ/"/>
    <url>/2025/03/12/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="队列相关消息"><a href="#队列相关消息" class="headerlink" title="队列相关消息"></a>队列相关消息</h2><h3 id="1-Provider"><a href="#1-Provider" class="headerlink" title="1.Provider"></a>1.Provider</h3><p>消息生产者，就是投递消息的程序。</p><h3 id="2-Consumer"><a href="#2-Consumer" class="headerlink" title="2.Consumer"></a>2.Consumer</h3><p>消息消费者，就是接受消息的程序。</p><h3 id="3-没有使用消息队列时消息传递方式"><a href="#3-没有使用消息队列时消息传递方式" class="headerlink" title="3.没有使用消息队列时消息传递方式"></a>3.没有使用消息队列时消息传递方式</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909948.png"></p><h3 id="4-使用消息队列后消息传递方式"><a href="#4-使用消息队列后消息传递方式" class="headerlink" title="4.使用消息队列后消息传递方式"></a>4.使用消息队列后消息传递方式</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909949.png"></p><h3 id="5-什么是队列？"><a href="#5-什么是队列？" class="headerlink" title="5.什么是队列？"></a>5.什么是队列？</h3><p>队列就像存放了商品的仓库或者商店，是生产商品的工厂和购买商品的用户之间的中转站。</p><h3 id="6-队列里存储了什么？"><a href="#6-队列里存储了什么？" class="headerlink" title="6.队列里存储了什么？"></a>6.队列里存储了什么？</h3><p>在 rabbitMQ 中，信息流从你的应用程序出发，来到 Rabbitmq 的队列，所有信息可以只存储在一个队列中。队列可以存储很多信息，因为它基本上是一个无限制的缓冲区，前提是你的机器有足够的存储空间。</p><h3 id="7-队列和应用程序的关系？"><a href="#7-队列和应用程序的关系？" class="headerlink" title="7.队列和应用程序的关系？"></a>7.队列和应用程序的关系？</h3><p>多个生产者可以将消息发送到同一个队列中，多个消息者也可以只从同一个队列接收数据。</p><h2 id="RabbitMQ相关概念"><a href="#RabbitMQ相关概念" class="headerlink" title="RabbitMQ相关概念"></a>RabbitMQ相关概念</h2><h3 id="1-Message"><a href="#1-Message" class="headerlink" title="1.Message"></a>1.Message</h3><p>消息。消息是不具名的，它由消息头消息体组成。消息体是不透明的，而消息头则由<br>一系列可选属性组成，这些属性包括：routing-key(路由键)、priority(相对于其他消息的优先<br>权)、delivery-mode(指出消息可能持久性存储)等。</p><h3 id="2-Publisher"><a href="#2-Publisher" class="headerlink" title="2.Publisher"></a>2.Publisher</h3><p>消息的生产者。也是一个向交换器发布消息的客户端应用程序。</p><h3 id="3-Consumer"><a href="#3-Consumer" class="headerlink" title="3.Consumer"></a>3.Consumer</h3><p>消息的消费者。表示一个从消息队列中取得消息的客户端应用程序。</p><h3 id="4-Exchange"><a href="#4-Exchange" class="headerlink" title="4.Exchange"></a>4.Exchange</h3><p>交换器。用来接收生产者发送的消息并将这些消息路由给服务器中的队列。<br>三种常用的交换器类型</p><ol><li>direct(发布与订阅 完全匹配)</li><li>fanout(广播)</li><li>topic(主题，规则匹配)</li></ol><h3 id="5-Binding"><a href="#5-Binding" class="headerlink" title="5.Binding"></a>5.Binding</h3><p>绑定。用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息<br>队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p><h3 id="6-Queue"><a href="#6-Queue" class="headerlink" title="6.Queue"></a>6.Queue</h3><p>消息队列。用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一<br>个消息可投入一个或多个队列。消息一直在队列里面，等待消费者链接到这个队列将其取<br>走。</p><h3 id="7-Routing-key"><a href="#7-Routing-key" class="headerlink" title="7.Routing-key"></a>7.Routing-key</h3><p>路由键。RabbitMQ 决定消息该投递到哪个队列的规则。<br>队列通过路由键绑定到交换器。<br>消息发送到 MQ 服务器时，消息将拥有一个路由键，即便是空的，RabbitMQ 也会将其<br>和绑定使用的路由键进行匹配。<br>如果相匹配，消息将会投递到该队列。<br>如果不匹配，消息将会进入黑洞。</p><h3 id="8-Connection"><a href="#8-Connection" class="headerlink" title="8.Connection"></a>8.Connection</h3><p>链接。指 rabbit 服务器和服务建立的 TCP 链接。</p><h3 id="9-Channel"><a href="#9-Channel" class="headerlink" title="9.Channel"></a>9.Channel</h3><p>信道。<br>1，Channel 中文叫做信道，是 TCP 里面的虚拟链接。例如：电缆相当于 TCP，信道是<br>一个独立光纤束，一条 TCP 连接上创建多条信道是没有问题的。<br>2，TCP 一旦打开，就会创建 AMQP 信道。<br>3，无论是发布消息、接收消息、订阅队列，这些动作都是通过信道完成的。</p><h3 id="10-Virtual-Host"><a href="#10-Virtual-Host" class="headerlink" title="10.Virtual Host"></a>10.Virtual Host</h3><p>虚拟主机。表示一批交换器，消息队列和相关对象。虚拟主机是共享相同的身份认证<br>和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有<br>自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在链接时指定，<br>RabbitMQ 默认的 vhost 是&#x2F;</p><h3 id="11-Borker"><a href="#11-Borker" class="headerlink" title="11.Borker"></a>11.Borker</h3><p>表示消息队列服务器实体。</p><h3 id="12-交换器和队列的关系"><a href="#12-交换器和队列的关系" class="headerlink" title="12.交换器和队列的关系"></a>12.交换器和队列的关系</h3><p>交换器是通过路由键和队列绑定在一起的，如果消息拥有的路由键跟队列和交换器的<br>路由键匹配，那么消息就会被路由到该绑定的队列中。<br>也就是说，消息到队列的过程中，消息首先会经过交换器，接下来交换器在通过路由<br>键匹配分发消息到具体的队列中。<br>路由键可以理解为匹配的规则。</p><h3 id="13-RabbitMQ-为什么需要信道？为什么不是-TCP-直接通信？"><a href="#13-RabbitMQ-为什么需要信道？为什么不是-TCP-直接通信？" class="headerlink" title="13.RabbitMQ 为什么需要信道？为什么不是 TCP 直接通信？"></a>13.RabbitMQ 为什么需要信道？为什么不是 TCP 直接通信？</h3><ol><li>TCP 的创建和销毁开销特别大。创建需要 3 次握手，销毁需要 4 次分手。</li><li>如果不用信道，那应用程序就会以 TCP 链接 Rabbit，高峰时每秒成千上万条链接<br>会造成资源巨大的浪费，而且操作系统每秒处理 TCP 链接数也是有限制的，必定造成性能<br>瓶颈。</li><li>信道的原理是一条线程一条通道，多条线程多条通道同用一条 TCP 链接。一条 TCP<br>链接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能的瓶颈。</li></ol><h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li>安装Erlang：<a href="http://erlang.org/download/otp_win64_21.3.exe">http://erlang.org/download/otp_win64_21.3.exe</a></li><li>下载rabbitmq：<a href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe">https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe</a></li><li>按照提示进行安装，安装完成后进入rabbitmq的安装目录:D:\RabbitMQ Server\rabbitmq_server-3.7.14\sbin</li><li>在地址栏输入cmd并回车启动命令行输入以下命令：rabbitmq-plugins enable rabbitmq_management</li><li>访问地址查看是否安装成功：<a href="http://127.0.0.1:15672/">http://127.0.0.1:15672/</a></li><li>输入账号密码登录：guest guest</li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><p>安装erlang：<code>yum install erlang</code>，如报错No package erlang available，需要安装EPEL库。</p></li><li><p>安装wget：<code>yum -y install wget</code></p></li><li><p>安装EPEL库：</p><ul><li><pre><code class="language-shell">wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpmrpm -ivh epel-release-6-8.noarch.rpm<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><br>- 安装RabbitMQ rpm包：<br><br>  - ```shell<br>    wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.5.0/rabbitmq-server<span class="hljs-string">-3</span>.5.0<span class="hljs-string">-1</span>.noarch.rpm<br>    <br>    rpm -ivh rabbitmq-server<span class="hljs-string">-3</span>.5.0<span class="hljs-string">-1</span>.noarch.rpm<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>启动RabbitMQ，并验证启动情况：<code>rabbitmq-server --detached &amp;ps aux |grep rabbitmq</code></p></li><li><p>以服务的方式启动：<code>service rabbitmq-server start</code></p></li><li><p>检查5672端口是否打开：</p><ul><li><pre><code class="language-shell">/sbin/iptables -I INPUT -p tcp --dport 5672 -j ACCEPT/etc/rc.d/init.d/iptables save/etc/init.d/iptables restart/etc/init.d/iptables status<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-title">- 启用维护插件（web管理界面）:</span><br><br>  - ```shell<br>    rabbitmq-plugins enable rabbitmq_management<br></code></pre></td></tr></table></figure></code></pre></li></ul></li><li><p>重启RabbitMQ：</p><ul><li><pre><code class="language-shell">service rabbitmq-server restart<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><br><span class="hljs-bullet">-</span> <span class="hljs-string">访问UI界面：http://ip/15672。账号密码：guest</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-string">无法登陆解决：</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">```shell</span><br>    vim /etc/rabbitmq/rabbitmq.config<br>    <span class="hljs-comment">#写入以下信息，并保存</span><br>    [&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].<br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p><strong>使用docker镜像中国下载Rabbitmq镜像，选择带有management的，因为这个是有WEB界面：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">使用docker镜像中国下载Rabbitmq镜像，选择带有management的，因为这个是有WEB界面。</span><br>[root@docker ~]# docker pull registry.docker-cn.com/library/rabbitmq:3.7-management<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909950.png"></p><p><strong>选择官方的：</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909951.png"></p><p><strong>我选择的是这个3.7版本：</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909952.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看镜像</span><br>[root@docker ~]# docker images<br>REPOSITORY                                TAG                 IMAGE ID            CREATED             SIZE<br>registry.docker-cn.com/library/rabbitmq   3.7-management      24cb552c7c00        12 days ago         212 MB<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">运行容器</span><br>[root@docker ~]# docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq 24cb552c7c00<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看进程</span><br>[root@docker ~]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                                        NAMES<br>73943a64f336        24cb552c7c00        &quot;docker-entrypoint...&quot;   7 minutes ago       Up 7 minutes        4369/tcp, 5671/tcp, 0.0.0.0:5672-&gt;5672/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:15672-&gt;15672/tcp   rabbitmq<br>[root@docker ~]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">关闭防火墙设置开机不启动</span><br>[root@docker ~]# systemctl stop firewalld<br>[root@docker ~]# systemctl disable firewalld<br></code></pre></td></tr></table></figure><p><strong>此时就可以登录Rabbitmq的WEB界面了，访问地址是[ip:15672]默认用户名和密码都是guest。</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909953.png"></p><h2 id="RabbitMQ交换器"><a href="#RabbitMQ交换器" class="headerlink" title="RabbitMQ交换器"></a>RabbitMQ交换器</h2><h3 id="Direct交换器"><a href="#Direct交换器" class="headerlink" title="Direct交换器"></a>Direct交换器</h3><blockquote><p>  发布与订阅，完全匹配。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909954.png"></p><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;project xmlns=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>         xsi:schemaLocation=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;<br>    &lt;modelVersion&gt;<span class="hljs-number">4.0</span>.<span class="hljs-number">0</span>&lt;/modelVersion&gt;<br>    &lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring<span class="hljs-literal">-boot-starter-parent</span>&lt;/artifactId&gt;<br>        &lt;version&gt;<span class="hljs-number">2.1</span>.<span class="hljs-number">4</span>.RELEASE&lt;/version&gt;<br>        &lt;relativePath/&gt; &lt;!<span class="hljs-literal">--</span> lookup parent from repository <span class="hljs-literal">--</span>&gt;<br>    &lt;/parent&gt;<br>    &lt;groupId&gt;com.lzhpo.rabbitmq&lt;/groupId&gt;<br>    &lt;artifactId&gt;rabbitmq<span class="hljs-literal">-direct-provider</span>&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span><span class="hljs-literal">-SNAPSHOT</span>&lt;/version&gt;<br>    &lt;name&gt;rabbitmq<span class="hljs-literal">-direct-provider</span>&lt;/name&gt;<br>    &lt;description&gt;Demo project <span class="hljs-keyword">for</span> Spring Boot&lt;/description&gt;<br><br>    &lt;properties&gt;<br>        &lt;java.version&gt;<span class="hljs-number">1.8</span>&lt;/java.version&gt;<br>    &lt;/properties&gt;<br><br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring<span class="hljs-literal">-boot-starter-amqp</span>&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring<span class="hljs-literal">-boot-starter-web</span>&lt;/artifactId&gt;<br>        &lt;/dependency&gt;<br><br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring<span class="hljs-literal">-boot-starter-test</span>&lt;/artifactId&gt;<br>            &lt;scope&gt;test&lt;/scope&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br><br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>                &lt;artifactId&gt;spring<span class="hljs-literal">-boot-maven-plugin</span>&lt;/artifactId&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br><br>&lt;/project&gt;<br></code></pre></td></tr></table></figure><h5 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.direct</span><br><span class="hljs-comment">#info 路由键</span><br><span class="hljs-attr">mq.config.queue.info.routing.key</span>=<span class="hljs-string">log.info.routing.key</span><br><span class="hljs-comment">#error 路由键</span><br><span class="hljs-attr">mq.config.queue.error.routing.key</span>=<span class="hljs-string">log.error.routing.key</span><br><span class="hljs-comment">#error 队列名称</span><br><span class="hljs-attr">mq.config.queue.error</span>=<span class="hljs-string">log.error</span><br></code></pre></td></tr></table></figure><h5 id="Sender"><a href="#Sender" class="headerlink" title="Sender"></a>Sender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdirectprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sender</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><br><span class="hljs-comment">//routingkey 路由键</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.queue.error.routing.key&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String routingkey;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange, <span class="hljs-built_in">this</span>.routingkey, msg);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="RabbitmqDirectProviderApplicationTests测试类"><a href="#RabbitmqDirectProviderApplicationTests测试类" class="headerlink" title="RabbitmqDirectProviderApplicationTests测试类"></a>RabbitmqDirectProviderApplicationTests测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdirectprovider;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqDirectProviderApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Sender sender;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试消息队列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-built_in">this</span>.sender.send(<span class="hljs-string">&quot;Hello RabbitMQ&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><h5 id="pom-xml和生产者的一样。"><a href="#pom-xml和生产者的一样。" class="headerlink" title="pom.xml和生产者的一样。"></a>pom.xml和生产者的一样。</h5><h5 id="application-properties-1"><a href="#application-properties-1" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.direct</span><br><span class="hljs-comment">#info 队列名称</span><br><span class="hljs-attr">mq.config.queue.info</span>=<span class="hljs-string">log.info</span><br><span class="hljs-comment">#info 路由键</span><br><span class="hljs-attr">mq.config.queue.info.routing.key</span>=<span class="hljs-string">log.info.routing.key</span><br><span class="hljs-comment">#error 队列名称</span><br><span class="hljs-attr">mq.config.queue.error</span>=<span class="hljs-string">log.error</span><br><span class="hljs-comment">#error 路由键</span><br><span class="hljs-attr">mq.config.queue.error.routing.key</span>=<span class="hljs-string">log.error.routing.key</span><br></code></pre></td></tr></table></figure><h5 id="ErrorReceiver"><a href="#ErrorReceiver" class="headerlink" title="ErrorReceiver"></a>ErrorReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.error&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">key=&quot;$&#123;mq.config.queue.error.routing.key&#125;&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Error..........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="InfoReceiver"><a href="#InfoReceiver" class="headerlink" title="InfoReceiver"></a>InfoReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.info&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">key=&quot;$&#123;mq.config.queue.info.routing.key&#125;&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Info........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqDirectConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitmqDirectConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>先启动消费者，再运行生产者的测试类<code>RabbitmqDirectProviderApplicationTests</code>测试类。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909955.png"></p><h3 id="Topic交换器"><a href="#Topic交换器" class="headerlink" title="Topic交换器"></a>Topic交换器</h3><blockquote><p>  主题，规则匹配。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909956.png"></p><h4 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h4><h5 id="application-properties-2"><a href="#application-properties-2" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.topic</span><br></code></pre></td></tr></table></figure><h5 id="OrderSender"><a href="#OrderSender" class="headerlink" title="OrderSender"></a>OrderSender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderSender</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;order.log.debug&quot;</span>, <span class="hljs-string">&quot;order.log.debug.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;order.log.info&quot;</span>, <span class="hljs-string">&quot;order.log.info.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;order.log.warn&quot;</span>,<span class="hljs-string">&quot;order.log.warn.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;order.log.error&quot;</span>, <span class="hljs-string">&quot;order.log.error.....&quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ProductSender"><a href="#ProductSender" class="headerlink" title="ProductSender"></a>ProductSender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductSender</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;product.log.debug&quot;</span>, <span class="hljs-string">&quot;product.log.debug.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;product.log.info&quot;</span>, <span class="hljs-string">&quot;product.log.info.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;product.log.warn&quot;</span>,<span class="hljs-string">&quot;product.log.warn.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;product.log.error&quot;</span>, <span class="hljs-string">&quot;product.log.error.....&quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="UserSender"><a href="#UserSender" class="headerlink" title="UserSender"></a>UserSender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserSender</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;user.log.debug&quot;</span>, <span class="hljs-string">&quot;user.log.debug.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;user.log.info&quot;</span>, <span class="hljs-string">&quot;user.log.info.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;user.log.warn&quot;</span>,<span class="hljs-string">&quot;user.log.warn.....&quot;</span>+msg);<br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;user.log.error&quot;</span>, <span class="hljs-string">&quot;user.log.error.....&quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RabbitmqTopicProviderApplicationTests测试类"><a href="#RabbitmqTopicProviderApplicationTests测试类" class="headerlink" title="RabbitmqTopicProviderApplicationTests测试类"></a>RabbitmqTopicProviderApplicationTests测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicprovider;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqTopicProviderApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserSender usersender;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductSender productsender;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderSender ordersender;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试消息队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.usersender.send(<span class="hljs-string">&quot;UserSender.....&quot;</span>);<br>        <span class="hljs-built_in">this</span>.productsender.send(<span class="hljs-string">&quot;ProductSender....&quot;</span>);<br>        <span class="hljs-built_in">this</span>.ordersender.send(<span class="hljs-string">&quot;OrderSender......&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h4><h5 id="application-properties-3"><a href="#application-properties-3" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.topic</span><br><span class="hljs-comment">#info 队列名称</span><br><span class="hljs-attr">mq.config.queue.info</span>=<span class="hljs-string">log.info</span><br><span class="hljs-comment">#error 队列名称</span><br><span class="hljs-attr">mq.config.queue.error</span>=<span class="hljs-string">log.error</span><br><span class="hljs-comment">#log 队列名称</span><br><span class="hljs-attr">mq.config.queue.logs</span>=<span class="hljs-string">log.all</span><br></code></pre></td></tr></table></figure><h5 id="ErrorReceiver-1"><a href="#ErrorReceiver-1" class="headerlink" title="ErrorReceiver"></a>ErrorReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.error&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">key=&quot;*.log.error&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;......Error........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="InfoReceiver-1"><a href="#InfoReceiver-1" class="headerlink" title="InfoReceiver"></a>InfoReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.info&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">key=&quot;*.log.info&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;......Info........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="LogsReceiver"><a href="#LogsReceiver" class="headerlink" title="LogsReceiver"></a>LogsReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.logs&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.TOPIC),</span><br><span class="hljs-meta">key=&quot;*.log.*&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogsReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;......All........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Main-1"><a href="#Main-1" class="headerlink" title="Main"></a>Main</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqtopicconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqTopicConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitmqTopicConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h4><p>先启动消费者，然后再运行<code>RabbitmqTopicProviderApplicationTests</code>测试类。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909957.png"></p><h3 id="Fanout交换器"><a href="#Fanout交换器" class="headerlink" title="Fanout交换器"></a>Fanout交换器</h3><blockquote><p>  广播。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909958.png"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909959.png"></p><h4 id="生产者-2"><a href="#生产者-2" class="headerlink" title="生产者"></a>生产者</h4><h5 id="application-properties-4"><a href="#application-properties-4" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">order.fanout</span><br></code></pre></td></tr></table></figure><h5 id="Sender-1"><a href="#Sender-1" class="headerlink" title="Sender"></a>Sender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sender</span> &#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;&quot;</span>,<br>msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RabbitmqFanoutProviderApplicationTests测试类"><a href="#RabbitmqFanoutProviderApplicationTests测试类" class="headerlink" title="RabbitmqFanoutProviderApplicationTests测试类"></a>RabbitmqFanoutProviderApplicationTests测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutprovider;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqFanoutProviderApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Sender sender;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试消息队列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-built_in">this</span>.sender.send(<span class="hljs-string">&quot;Hello RabbitMQ&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-2"><a href="#消费者-2" class="headerlink" title="消费者"></a>消费者</h4><h5 id="application-properties-5"><a href="#application-properties-5" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><span class="hljs-comment">#设置交换器的名称</span><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">order.fanout</span><br><span class="hljs-comment">#短信服务队列名称</span><br><span class="hljs-attr">mq.config.queue.sms</span>=<span class="hljs-string">order.sms</span><br><span class="hljs-comment">#push 服务队列名称</span><br><span class="hljs-attr">mq.config.queue.push</span>=<span class="hljs-string">order.push</span><br></code></pre></td></tr></table></figure><h5 id="SmsReceiver"><a href="#SmsReceiver" class="headerlink" title="SmsReceiver"></a>SmsReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> *                key:路由键</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.sms&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.FANOUT)</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Sms........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="PushReceiver"><a href="#PushReceiver" class="headerlink" title="PushReceiver"></a>PushReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.push&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.FANOUT)</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Error..........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Main-2"><a href="#Main-2" class="headerlink" title="Main"></a>Main</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqFanoutConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitmqFanoutConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h4><p>先启动消费者，然后再启动生产者<code>RabbitmqFanoutProviderApplicationTests</code>测试类。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909960.png"></p><h2 id="使用-RabbitMQ-实现松耦合设计"><a href="#使用-RabbitMQ-实现松耦合设计" class="headerlink" title="使用 RabbitMQ 实现松耦合设计"></a>使用 RabbitMQ 实现松耦合设计</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909961.png"></p><h3 id="生产者-3"><a href="#生产者-3" class="headerlink" title="生产者"></a>生产者</h3><h5 id="application-properties-6"><a href="#application-properties-6" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">order.fanout</span><br></code></pre></td></tr></table></figure><h5 id="Sender-2"><a href="#Sender-2" class="headerlink" title="Sender"></a>Sender</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sender</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br>    <span class="hljs-comment">//exchange 交换器名称</span><br>    <span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String exchange;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 发送消息的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br>        <span class="hljs-comment">//向消息队列发送消息</span><br>        <span class="hljs-comment">//参数一：交换器名称。</span><br>        <span class="hljs-comment">//参数二：路由键</span><br>        <span class="hljs-comment">//参数三：消息</span><br>        <span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange,<span class="hljs-string">&quot;&quot;</span>, msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RabbitmqFanoutOuheProviderApplicationTests测试类"><a href="#RabbitmqFanoutOuheProviderApplicationTests测试类" class="headerlink" title="RabbitmqFanoutOuheProviderApplicationTests测试类"></a>RabbitmqFanoutOuheProviderApplicationTests测试类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheprovider;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqFanoutOuheProviderApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Sender sender;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试消息队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.sender.send(<span class="hljs-string">&quot;Hello RabbitMQ&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消费者-3"><a href="#消费者-3" class="headerlink" title="消费者"></a>消费者</h3><h5 id="application-properties-7"><a href="#application-properties-7" class="headerlink" title="application.properties"></a>application.properties</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">order.fanout</span><br><br><span class="hljs-attr">mq.config.queue.sms</span>=<span class="hljs-string">order.sms</span><br><br><span class="hljs-attr">mq.config.queue.push</span>=<span class="hljs-string">order.push</span><br><br><span class="hljs-attr">mq.config.queue.red</span>=<span class="hljs-string">red</span><br></code></pre></td></tr></table></figure><h5 id="PushReceiver-1"><a href="#PushReceiver-1" class="headerlink" title="PushReceiver"></a>PushReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.push&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.FANOUT)</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Push..........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RedReceiver"><a href="#RedReceiver" class="headerlink" title="RedReceiver"></a>RedReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> *                key:路由键</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.red&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.FANOUT)</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;给用户发送10元红包........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="SmsReceiver-1"><a href="#SmsReceiver-1" class="headerlink" title="SmsReceiver"></a>SmsReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> *                key:路由键</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.sms&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.FANOUT)</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SmsReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Sms........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Main-3"><a href="#Main-3" class="headerlink" title="Main"></a>Main</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqfanoutouheconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqFanoutOuheConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitmqFanoutOuheConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="测试结果-3"><a href="#测试结果-3" class="headerlink" title="测试结果"></a>测试结果</h4><p>先运行消费者，然后再运行生产者的<code>RabbitmqFanoutOuheProviderApplicationTests</code>测试类。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909962.png"></p><h2 id="RabbitMQ消息处理"><a href="#RabbitMQ消息处理" class="headerlink" title="RabbitMQ消息处理"></a>RabbitMQ消息处理</h2><blockquote><p>  消息的可靠性是 RabbitMQ 的一大特色，那么 RabbitMQ 是如何保证消息可靠性的呢——消息持久化。</p></blockquote><h3 id="RabbitMQ的消息持久化处理"><a href="#RabbitMQ的消息持久化处理" class="headerlink" title="RabbitMQ的消息持久化处理"></a>RabbitMQ的消息持久化处理</h3><h4 id="生产者-4"><a href="#生产者-4" class="headerlink" title="生产者"></a>生产者</h4><h6 id="application-properties-8"><a href="#application-properties-8" class="headerlink" title="application.properties"></a>application.properties</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.direct</span><br><br><span class="hljs-attr">mq.config.queue.info.routing.key</span>=<span class="hljs-string">log.info.routing.key</span><br><br><span class="hljs-attr">mq.config.queue.error.routing.key</span>=<span class="hljs-string">log.error.routing.key</span><br><br><span class="hljs-attr">mq.config.queue.error</span>=<span class="hljs-string">log.error</span><br></code></pre></td></tr></table></figure><h6 id="Sender-3"><a href="#Sender-3" class="headerlink" title="Sender"></a>Sender</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdurabledirectprovider;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.AmqpTemplate;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sender</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> AmqpTemplate rabbitAmqpTemplate;<br><br><span class="hljs-comment">//exchange 交换器名称</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.exchange&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String exchange;<br><br><span class="hljs-comment">//routingkey 路由键</span><br><span class="hljs-meta">@Value(&quot;$&#123;mq.config.queue.error.routing.key&#125;&quot;)</span><br><span class="hljs-keyword">private</span> String routingkey;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 发送消息的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(String msg)</span>&#123;<br><span class="hljs-comment">//向消息队列发送消息</span><br><span class="hljs-comment">//参数一：交换器名称。</span><br><span class="hljs-comment">//参数二：路由键</span><br><span class="hljs-comment">//参数三：消息</span><br><span class="hljs-built_in">this</span>.rabbitAmqpTemplate.convertAndSend(<span class="hljs-built_in">this</span>.exchange, <span class="hljs-built_in">this</span>.routingkey, msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="RabbitmqDurableDirectProviderApplicationTests测试类"><a href="#RabbitmqDurableDirectProviderApplicationTests测试类" class="headerlink" title="RabbitmqDurableDirectProviderApplicationTests测试类"></a>RabbitmqDurableDirectProviderApplicationTests测试类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdurabledirectprovider;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqDurableDirectProviderApplicationTests</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Sender sender;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试消息队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">contextLoads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            flag++;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            <span class="hljs-built_in">this</span>.sender.send(<span class="hljs-string">&quot;Hello RabbitMQ &quot;</span>+flag);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-4"><a href="#消费者-4" class="headerlink" title="消费者"></a>消费者</h4><h6 id="application-properties-9"><a href="#application-properties-9" class="headerlink" title="application.properties"></a>application.properties</h6><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rabbitmq.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-attr">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><br><span class="hljs-attr">mq.config.exchange</span>=<span class="hljs-string">log.direct</span><br><br><span class="hljs-attr">mq.config.queue.info</span>=<span class="hljs-string">log.info</span><br><br><span class="hljs-attr">mq.config.queue.info.routing.key</span>=<span class="hljs-string">log.info.routing.key</span><br><br><span class="hljs-attr">mq.config.queue.error</span>=<span class="hljs-string">log.error</span><br><br><span class="hljs-attr">mq.config.queue.error.routing.key</span>=<span class="hljs-string">log.error.routing.key</span><br><br></code></pre></td></tr></table></figure><h6 id="ErrorReceiver-2"><a href="#ErrorReceiver-2" class="headerlink" title="ErrorReceiver"></a>ErrorReceiver</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdurabledirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.error&#125;&quot;,autoDelete=&quot;false&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">key=&quot;$&#123;mq.config.queue.error.routing.key&#125;&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Error..........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="InfoReceiver-2"><a href="#InfoReceiver-2" class="headerlink" title="InfoReceiver"></a>InfoReceiver</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdurabledirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.amqp.core.ExchangeTypes;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Exchange;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.Queue;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.QueueBinding;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitHandler;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息接收者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Administrator</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RabbitListener</span> bindings:绑定队列</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@QueueBinding</span>  value:绑定队列的名称</span><br><span class="hljs-comment"> *                exchange:配置交换器</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Queue</span> value:配置队列名称</span><br><span class="hljs-comment"> *        autoDelete:是否是一个可删除的临时队列</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Exchange</span> value:为交换器起个名称</span><br><span class="hljs-comment"> *           type:指定具体的交换器类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener(</span><br><span class="hljs-meta">bindings=@QueueBinding(</span><br><span class="hljs-meta">value=@Queue(value=&quot;$&#123;mq.config.queue.info&#125;&quot;,autoDelete=&quot;true&quot;),</span><br><span class="hljs-meta">exchange=@Exchange(value=&quot;$&#123;mq.config.exchange&#125;&quot;,type=ExchangeTypes.DIRECT),</span><br><span class="hljs-meta">key=&quot;$&#123;mq.config.queue.info.routing.key&#125;&quot;</span><br><span class="hljs-meta">)</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InfoReceiver</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收消息的方法。采用消息队列监听机制</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RabbitHandler</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(String msg)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Info........receiver: &quot;</span>+msg);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Main-4"><a href="#Main-4" class="headerlink" title="Main"></a>Main</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.rabbitmqdurabledirectconsumer;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitmqDurableDirectConsumerApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(RabbitmqDurableDirectConsumerApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="测试结果-4"><a href="#测试结果-4" class="headerlink" title="测试结果"></a>测试结果</h5><p>先启动消费者，再运行<code>RabbitmqDurableDirectProviderApplicationTests</code>测试类。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909963.png"></p><h3 id="RabbitMQ中的消息确认ACK机制"><a href="#RabbitMQ中的消息确认ACK机制" class="headerlink" title="RabbitMQ中的消息确认ACK机制"></a>RabbitMQ中的消息确认ACK机制</h3><blockquote><p>  什么是消息确认ACK？</p></blockquote><p>如果在处理消息的过程中，消费者的服务器在处理消息时出现异常，那可能这条正常在处理的消息就没有完成消息消费，数据就会丢失。为了确保数据不会丢失，RabbitMQ支持消息确认ACK。</p><blockquote><p>  ACK的消息确认机制？</p></blockquote><p>ACK机制是消费者从RabbitMQ手到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除。</p><ol><li>如果一个消费者在处理消息出现了网络不稳定、服务器异常等现象，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将消息重新放入队列中。</li><li>如果在集群的环境下：RabbitMQ会立即将这个消息推送给这个在线的其它消费者。这种机制保证了再消费者服务端故障的时候，不会丢失任何消息和任务。</li><li>消息永远不会从RabbitMQ中删除：只有当消费者正确发送ACK反馈，RabbitMQ确认收到后，消息才会从RabbitMQ服务器的数据中删除。</li><li>消息的ACK确认机制默认是打开的。</li></ol><blockquote><p>  ACK机制的开发注意事项？</p></blockquote><p>如果忘记了ACK，那么后果很严重。当Consumer退出时，Message会一直重新分发。然后RabbitMQ会占用越来越多的内存，由于RabbitMQ会长时间运行，因此这个“内存泄漏”是致命的。</p><blockquote><p>  修改 Consusmer 配置文件解决 ACK 反馈问题。</p></blockquote><p>在<code>application.properties</code>配置文件中添加以下</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">############Rabbitmq的消息确认ACK机制############</span><br><span class="hljs-comment">#开启重试</span><br><span class="hljs-attr">spring.rabbitmq.listener.retry.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#重试次数，默认为 3 次</span><br><span class="hljs-attr">spring.rabbitmq.listener.retry.max-attempts</span>=<span class="hljs-string">5</span><br></code></pre></td></tr></table></figure><h2 id="RabbitMQ六种消息模式"><a href="#RabbitMQ六种消息模式" class="headerlink" title="RabbitMQ六种消息模式"></a>RabbitMQ六种消息模式</h2><p>pom依赖:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs powershell">&lt;dependency&gt;<br>    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;<br>    &lt;artifactId&gt;amqp<span class="hljs-literal">-client</span>&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">4.0</span>.<span class="hljs-number">2</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>    &lt;artifactId&gt;slf4j<span class="hljs-literal">-api</span>&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">1.7</span>.<span class="hljs-number">10</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>    &lt;artifactId&gt;slf4j<span class="hljs-literal">-log4j12</span>&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">1.7</span>.<span class="hljs-number">5</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;log4j&lt;/groupId&gt;<br>    &lt;artifactId&gt;log4j&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">1.2</span>.<span class="hljs-number">17</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;dependency&gt;<br>    &lt;groupId&gt;junit&lt;/groupId&gt;<br>    &lt;artifactId&gt;junit&lt;/artifactId&gt;<br>    &lt;version&gt;<span class="hljs-number">4.11</span>&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>RabbitMQ的连接工具（我单独写出来了一个工具类，方便使用）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.ConnectionFactory;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeoutException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：获取Rabbitmq的连接工具&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionUtils</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取Rabbitmq的连接</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> TimeoutException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException &#123;<br>        <span class="hljs-comment">//定义一个连接工厂</span><br>        <span class="hljs-type">ConnectionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionFactory</span>();<br><br>        <span class="hljs-comment">//设置服务地址</span><br>        factory.setHost(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br><br>        <span class="hljs-comment">//AMQP 5672</span><br>        factory.setPort(<span class="hljs-number">5672</span>);<br><br>        <span class="hljs-comment">//vhost</span><br>        factory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br><br>        <span class="hljs-comment">//用户名</span><br>        factory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-comment">//密码</span><br>        factory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> factory.newConnection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="简单队列"><a href="#简单队列" class="headerlink" title="简单队列"></a>简单队列</h3><blockquote><p>  简单队列：一个生产者P发送消息到队列Q,一个消费者C接收。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909964.png"></p><h4 id="生产者-Send"><a href="#生产者-Send" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.simplequeues;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：生产者生产消息&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_simple_queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//获取一个连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br><br>        <span class="hljs-comment">//从连接中获取一个通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//创建队列声明</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">//需要发送的消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello simple!&quot;</span>;<br><br>        channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, msg.getBytes());<br><br>        System.out.println(<span class="hljs-string">&quot;---send msg：&quot;</span> +msg);<br><br>        <span class="hljs-comment">//关闭</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者-Recv"><a href="#消费者-Recv" class="headerlink" title="消费者(Recv)"></a>消费者(Recv)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.simplequeues;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：消费者获取消息&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>  <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_simple_queue&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * main()入口</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//oldApi();//老版本api</span><br>        newApi();<span class="hljs-comment">//新版本api</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新版本api</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newApi</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//获取一个连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br><br>        <span class="hljs-comment">//从连接中获取一个通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//创建队列声明</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">//定义消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;new api recv：&quot;</span> + msg);<br>            &#125;<br>        &#125;;<br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, consumer);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 老版本api</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oldApi</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//获取一个连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br><br>        <span class="hljs-comment">//从连接中获取一个通道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">//创建队列声明</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-comment">//定义队列的消费者</span><br>        <span class="hljs-type">QueueingConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueingConsumer</span>(channel);<br><br>        <span class="hljs-comment">//监听队列</span><br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, consumer);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>            QueueingConsumer.<span class="hljs-type">Delivery</span> <span class="hljs-variable">delivery</span> <span class="hljs-operator">=</span> consumer.nextDelivery();<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">msgString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;[recv] msg: &quot;</span> +msgString);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h3><h4 id="轮询分发"><a href="#轮询分发" class="headerlink" title="轮询分发"></a>轮询分发</h4><blockquote><p>  【轮询分发】：结果就是不管谁忙或清闲，都不会给谁多一个任务或少一个任务，任务总是你一个我一个的分。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909965.png"></p><h5 id="生产者-Send-1"><a href="#生产者-Send-1" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.lunxun;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：【轮询分发】&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * 备注:消费者 1 我们处理时间是 1s ;而消费者 2 中处理时间是 2s;</span><br><span class="hljs-comment"> * 但是我们看到的现象并不是 1 处理的多 消费者 2 处理的少。</span><br><span class="hljs-comment"> * -----------------------------------</span><br><span class="hljs-comment"> * 消费者1【Recv1】：</span><br><span class="hljs-comment"> *  [1] Received &#x27;.0&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  [1] Received &#x27;.2&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  ......</span><br><span class="hljs-comment"> *  [1] Received &#x27;.46&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  [1] Received &#x27;.48&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  消费者 1 将偶数部分处理掉了</span><br><span class="hljs-comment"> * -----------------------------------</span><br><span class="hljs-comment"> * 消费者2【Recv2】：</span><br><span class="hljs-comment"> *  [2] Received &#x27;.1&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  [2] Received &#x27;.3&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  ......</span><br><span class="hljs-comment"> *  [2] Received &#x27;.47&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> *  [2] Received &#x27;.49&#x27;</span><br><span class="hljs-comment"> *  [x] Done</span><br><span class="hljs-comment"> * 消费者 2 中将奇数部分处理掉了。</span><br><span class="hljs-comment"> * -----------------------------------</span><br><span class="hljs-comment"> * 我想要的是 1 处理的多,而 2 处理的少</span><br><span class="hljs-comment"> * 测试结果:</span><br><span class="hljs-comment"> * 1.消费者 1 和消费者 2 获取到的消息内容是不同的,同一个消息只能被一个消费者获取</span><br><span class="hljs-comment"> * 2.消费者 1 和消费者 2 货到的消息数量是一样的 一个奇数一个偶数</span><br><span class="hljs-comment"> * 按道理消费者 1 获取的比消费者 2 要多</span><br><span class="hljs-comment"> * -----------------------------------</span><br><span class="hljs-comment"> * 这种方式叫做【轮询分发】：结果就是不管谁忙或清闲，都不会给谁多一个任务或少一个任务，任务总是你一个我一个的分。</span><br><span class="hljs-comment"> * -----------------------------------</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-comment">//消息内容</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.&quot;</span> +i;<br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot; [x] Sent &#x27;&quot;</span> +message +<span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            Thread.sleep(i*<span class="hljs-number">10</span>);<br>        &#125;<br><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="消费者1-Recv1"><a href="#消费者1-Recv1" class="headerlink" title="消费者1(Recv1)"></a>消费者1(Recv1)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.lunxun;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列，主要为了防止消息接收者先运行此程序，队列还不存在时创建队列。</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//定义一个消息的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot; [1] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    doWork(message);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot; [x] Done&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//消息的确认模式自动应答</span><br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(String task)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unused&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oldAPi</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 定义队列的消费者</span><br>        <span class="hljs-type">QueueingConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueingConsumer</span>(channel);<br>        <span class="hljs-comment">// 监听队列，手动返回完成状态false 自动true 自动应答 不需要手动确认</span><br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">true</span>, consumer);<br>        <span class="hljs-comment">// 获取消息</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            QueueingConsumer.<span class="hljs-type">Delivery</span> <span class="hljs-variable">delivery</span> <span class="hljs-operator">=</span> consumer.nextDelivery();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="消费者2-Recv2"><a href="#消费者2-Recv2" class="headerlink" title="消费者2(Recv2)"></a>消费者2(Recv2)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.lunxun;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">//定义一个消息的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot; [2] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot; [x] Done&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//</span><br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="公平分发"><a href="#公平分发" class="headerlink" title="公平分发"></a>公平分发</h4><blockquote><p>  使用公平分发，必须关闭自动应答，改为手动应答。</p></blockquote><h5 id="生产者-Send-2"><a href="#生产者-Send-2" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.gongping;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：【公平分发】&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * 虽然上面的分配法方式也还行，但是有个问题就是：比如：现在有 2 个消费者，所有的偶数的消息都是繁忙的，而</span><br><span class="hljs-comment"> * 奇数则是轻松的。按照轮询的方式，偶数的任务交给了第一个消费者，所以一直在忙个不停。奇数的任务交给另一</span><br><span class="hljs-comment"> * 个消费者，则立即完成任务，然后闲得不行。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 而 RabbitMQ 则是不了解这些的。他是不知道你消费者的消费能力的,这是因为当消息进入队列，RabbitMQ 就会分派</span><br><span class="hljs-comment"> * 消息。而 rabbitmq 只是盲目的将消息轮询的发给消费者。你一个我一个的这样发送.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 为了解决这个问题，我们使用 basicQos( prefetchCount = 1)方法，来限制 RabbitMQ 只发不超过 1 条的消息给同</span><br><span class="hljs-comment"> * 一个消费者。当消息处理完毕后，有了反馈 ack，才会进行第二次发送。(也就是说需要手动反馈给 Rabbitmq )</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 还有一点需要注意，使用【公平分发】，必须关闭自动应答，改为手动应答。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 这时候现象就是消费者 1 速度大于消费者 2</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-comment">// 创建一个频道</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 指定一个队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">prefetchCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//每个消费者发送确认信号之前，消息队列不发送下一个消息过来，一次只处理一个消息</span><br>        <span class="hljs-comment">//限制发给同一个消费者不得超过1条消息</span><br>        channel.basicQos(prefetchCount);<br>        <span class="hljs-comment">// 发送的消息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.&quot;</span> + i;<br>            <span class="hljs-comment">// 往队列中发出一条消息</span><br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>, QUEUE_NAME, <span class="hljs-literal">null</span>, message.getBytes());<br>            System.out.println(<span class="hljs-string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            Thread.sleep(i * <span class="hljs-number">10</span>);<br>        &#125;<br>        <span class="hljs-comment">// 关闭频道和连接</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="消费者1-Recv1-1"><a href="#消费者1-Recv1-1" class="headerlink" title="消费者1(Recv1)"></a>消费者1(Recv1)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.gongping;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列，主要为了防止消息接收者先运行此程序，队列还不存在时创建队列。</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.basicQos(<span class="hljs-number">1</span>);<span class="hljs-comment">//保证一次只分发一个</span><br>        <span class="hljs-comment">//定义一个消息的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot; [1] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    doWork(message);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot; [x] Done&quot;</span>);<br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">/**手动应答**/</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//手动确认消息</span><br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(String task)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="消费者2-Recv2-1"><a href="#消费者2-Recv2-1" class="headerlink" title="消费者2(Recv2)"></a>消费者2(Recv2)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.workqueues.gongping;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * Message acknowledgment（消息应答）：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * boolean autoAck = false;</span><br><span class="hljs-comment"> * channel.basicConsume(QUEUE_NAME, autoAck, consumer);</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * boolean autoAck = true;(自动确认模式)一旦 RabbitMQ 将消息分发给了消费者，就会从内存中删除。</span><br><span class="hljs-comment"> * 在这种情况下，如果杀死正在执行任务的消费者，会丢失正在处理的消息，也会丢失已经分发给这个消</span><br><span class="hljs-comment"> * 费者但尚未处理的消息。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * boolean autoAck = false; (手动确认模式) 我们不想丢失任何任务，如果有一个消费者挂掉了，那么</span><br><span class="hljs-comment"> * 我们应该将分发给它的任务交付给另一个消费者去处理。 为了确保消息不会丢失，RabbitMQ 支持消</span><br><span class="hljs-comment"> * 息应答。消费者发送一个消息应答，告诉 RabbitMQ 这个消息已经接收并且处理完毕了。RabbitMQ 可</span><br><span class="hljs-comment"> * 以删除它了。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 消息应答是默认打开的。也就是 boolean autoAck =false;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_work&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        channel.basicQos(<span class="hljs-number">1</span>);<span class="hljs-comment">//保证一次只分发一个</span><br>        <span class="hljs-comment">//定义一个消息的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot; [2] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    doWork(message);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot; [x] Done&quot;</span>);<br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<span class="hljs-comment">/**关闭自动确认应答，手动应答**/</span><br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">/**关闭自动应答**/</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">//关闭自动确认</span><br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(String task)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">oldAPi</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 定义队列的消费者</span><br>        <span class="hljs-type">QueueingConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueueingConsumer</span>(channel);<br>        <span class="hljs-comment">// 监听队列，手动返回完成状态</span><br>        channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">false</span>, consumer);<br>        <span class="hljs-comment">// 获取消息</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            QueueingConsumer.<span class="hljs-type">Delivery</span> <span class="hljs-variable">delivery</span> <span class="hljs-operator">=</span> consumer.nextDelivery();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot; [x] Received &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>            <span class="hljs-comment">// 休眠1秒</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<span class="hljs-comment">/**关闭自动确认应答，手动应答**/</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="消息订阅模式"><a href="#消息订阅模式" class="headerlink" title="消息订阅模式"></a>消息订阅模式</h3><blockquote><p>  【订阅模式】：一个消息被多个消费者消费。</p><ol><li>一个生产者，多个消费者。</li><li>每一个消费者都有自己的队列。</li><li>生产者没有直接把消息发送到队列，而是发送到了交换机、转发器exchange。</li><li>每个队列都要绑定到交换机上。</li><li>生产者发送的消息经过交换机到达队列，就能实现一个消息被多个消费者消费。</li></ol></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909966.png"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909966.png"></p><h4 id="生产者-Send-3"><a href="#生产者-Send-3" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.subscribeModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * 先运行Send创建交换器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 但是这个发送的消息到哪了呢? 消息丢失了!!!因为交换机没有存储消息的能力,在 rabbitmq 中只有队列存储消息的</span><br><span class="hljs-comment"> * 能力.因为这时还没有队列,所以就会丢失;</span><br><span class="hljs-comment"> * 小结:消息发送到了一个没有绑定队列的交换机时,消息就会丢失!</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 【订阅模式】：一个消息被多个消费者消费。</span><br><span class="hljs-comment"> * 1.一个生产者，多个消费者。</span><br><span class="hljs-comment"> * 2.每一个消费者都有自己的队列。</span><br><span class="hljs-comment"> * 3.生产者没有直接把消息发送到队列，而是发送到了交换机、转发器exchange</span><br><span class="hljs-comment"> * 4.每个队列都要绑定到交换机上</span><br><span class="hljs-comment"> * 5.生产者发送的消息经过交换机到达队列，就能实现一个消息被多个消费者消费。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 邮件-&gt;注册-&gt;短信</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_fanout&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br><br>        <span class="hljs-comment">// 声明exchange 交换机 转发器</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;fanout&quot;</span>); <span class="hljs-comment">//订阅模式</span><br><br>        <span class="hljs-comment">// 消息内容</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello PB&quot;</span>;<br>        channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">null</span>, msg.getBytes());<br>        System.out.println(<span class="hljs-string">&quot;Send: &quot;</span> +msg);<br><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者1-Recv1-2"><a href="#消费者1-Recv1-2" class="headerlink" title="消费者1(Recv1)"></a>消费者1(Recv1)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.subscribeModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_fanout_email&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_fanout&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">/** 绑定队列到交换机 **/</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//------------下面逻辑和work模式一样-----</span><br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 定义一个消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[1] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[1] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者2-Recv2-2"><a href="#消费者2-Recv2-2" class="headerlink" title="消费者2(Recv2)"></a>消费者2(Recv2)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.subscribeModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_fanout_sms&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_fanout&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">/** 绑定队列到交换机 **/</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        <span class="hljs-comment">// 定义一个消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[2] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[2] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><blockquote><ol><li>发送消息到交换机并且要指定路由key 。</li><li>消费者将队列绑定到交换机时需要指定路由key。</li></ol></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909967.png"></p><h4 id="生产者-Send-4"><a href="#生产者-Send-4" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.routingModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * 先运行Send创建交换器</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_direct&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明exchange</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-comment">// 消息内容</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello direct!&quot;</span>;<br>        <span class="hljs-comment">//routingKey</span><br>        <span class="hljs-comment">//String routingKey = &quot;error&quot;;//error两个都可以收到</span><br>        <span class="hljs-comment">//String routingKey = &quot;info&quot;;//info只有Recv2能收到</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">routingKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;warning&quot;</span>;<span class="hljs-comment">//warning只有Recv2能收到</span><br>        channel.basicPublish(EXCHANGE_NAME, routingKey, <span class="hljs-literal">null</span>, msg.getBytes());<br><br>        System.out.println(<span class="hljs-string">&quot;-------------send: &quot;</span> +msg);<br><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者1-Recv1-3"><a href="#消费者1-Recv1-3" class="headerlink" title="消费者1(Recv1)"></a>消费者1(Recv1)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.routingModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_direct_1&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_direct&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">/** 绑定队列到交换机 **/</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;error&quot;</span>);<br><br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//定义消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[1] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[1] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者2-Recv2-3"><a href="#消费者2-Recv2-3" class="headerlink" title="消费者2(Recv2)"></a>消费者2(Recv2)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.routingModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_direct_2&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_direct&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">/** 绑定队列到交换机 **/</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;error&quot;</span>);<br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;info&quot;</span>);<br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;warning&quot;</span>);<br><br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//定义消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[2] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[2] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="主题模式"><a href="#主题模式" class="headerlink" title="主题模式"></a>主题模式</h3><blockquote><p>  Topic主题模式：将路由键和某模式进行匹配，此时队列需要绑定在一个模式上，“#”匹配一个词或多个词，“*”只匹配一个词。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909968.png"></p><h4 id="生产者-Send-5"><a href="#生产者-Send-5" class="headerlink" title="生产者(Send)"></a>生产者(Send)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.topicModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.Connection;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：</span><br><span class="hljs-comment"> * Topic主题模式：将路由键和某种模式匹配。</span><br><span class="hljs-comment"> * &lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Send</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_topic&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明exchange</span><br>        channel.exchangeDeclare(EXCHANGE_NAME, <span class="hljs-string">&quot;topic&quot;</span>);<br>        <span class="hljs-comment">// 消息内容</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;id=1001&quot;</span>;<br>        channel.basicPublish(EXCHANGE_NAME, <span class="hljs-string">&quot;item.delete&quot;</span>, <span class="hljs-literal">null</span>, message.getBytes());<br>        System.out.println(<span class="hljs-string">&quot; [x] Sent &#x27;&quot;</span> + message + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者1-Recv1-4"><a href="#消费者1-Recv1-4" class="headerlink" title="消费者1(Recv1)"></a>消费者1(Recv1)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.topicModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_topic_1&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_topic&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 绑定队列到交换机</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;item.update&quot;</span>);<br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;item.delete&quot;</span>);<br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 定义队列的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[2] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[2] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="消费者2-Recv2-4"><a href="#消费者2-Recv2-4" class="headerlink" title="消费者2(Recv2)"></a>消费者2(Recv2)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lzhpo.rabbitmq.model5.topicModel;<br><br><span class="hljs-keyword">import</span> com.lzhpo.rabbitmq.ConnectionUtils;<br><span class="hljs-keyword">import</span> com.rabbitmq.client.*;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt; Author：lzhpo &lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Title：&lt;/p&gt;</span><br><span class="hljs-comment"> * &lt;p&gt; Description：&lt;/p&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Recv2</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QUEUE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_queue_topic_2&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXCHANGE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test_exchange_topic&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] argv)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取到连接以及mq通道</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> ConnectionUtils.getConnection();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> connection.createChannel();<br>        <span class="hljs-comment">// 声明队列</span><br>        channel.queueDeclare(QUEUE_NAME, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">/** 绑定队列到交换机 **/</span><br>        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="hljs-string">&quot;item.#&quot;</span>);<span class="hljs-comment">//全匹配：item.#</span><br>        <span class="hljs-comment">// 同一时刻服务器只会发一条消息给消费者</span><br>        channel.basicQos(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 定义队列的消费者</span><br>        <span class="hljs-type">DefaultConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultConsumer</span>(channel) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-type">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">//super.handleDelivery(consumerTag, envelope, properties, body);</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(body, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;[2] Recv msg:&quot;</span> + msg);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[2] done &quot;</span>);<br>                    <span class="hljs-comment">// 手动回执</span><br>                    channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">autoAck</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        channel.basicConsume(QUEUE_NAME, autoAck, consumer);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="RPC远程调用模式"><a href="#RPC远程调用模式" class="headerlink" title="RPC远程调用模式"></a>RPC远程调用模式</h3><blockquote><p>  前面学习了如何使用work队列在多个worker之间分配任务，但是如果需要在远程机器上运行个函数并等待结果，就需要使用RPC（远程过程调用）模式来实现。</p></blockquote><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202503121909969.png"></p><p>参考官网教程【模拟RPC服务来返回斐波那契数列】：<a href="https://www.rabbitmq.com/tutorials/tutorial-six-java.html">https://www.rabbitmq.com/tutorials/tutorial-six-java.html</a></p>]]></content>
    
    
    <categories>
      
      <category>MQ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MYDB record</title>
    <link href="/2025/02/21/MYDB-record/"/>
    <url>/2025/02/21/MYDB-record/</url>
    
    <content type="html"><![CDATA[<h1 id="MYDB"><a href="#MYDB" class="headerlink" title="MYDB"></a><strong>MYDB</strong></h1><h1 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502211203817.jpg" alt="img"></p><ol><li>Transaction Manager（TM）</li><li>Data Manager（DM）</li><li>Version Manager（VM）</li><li>Index Manager（IM）</li><li>Table Manager（TBM）</li></ol><p>每个模块的职责如下：</p><ol><li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li><li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li><li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li><li>IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。</li><li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li></ol><h1 id="2-Transaction-Manager"><a href="#2-Transaction-Manager" class="headerlink" title="2. Transaction Manager"></a>2. Transaction Manager</h1><blockquote><p>TM模块通过维护一个XID文件来维护事务状态，并提供接口供其他模块来查询某个事务的状态</p></blockquote><h2 id="XID文件"><a href="#XID文件" class="headerlink" title="XID文件"></a>XID文件</h2><p>在 MYDB 中，每一个事务都有一个 XID，这个 ID 唯一标识了这个事务。事务的 XID 从 1 开始标号，并自增，不可重复。并特殊规定 <strong>XID 0 是一个超级事务（Super Transaction）</strong>。当一些操作想在没有申请事务的情况下进行，那么可以将操作的 XID 设置为 0。XID 为 0 的事务的状态永远是 committed。</p><p>TransactionManager 维护了一个 XID 格式的文件，用来记录各个事务的状态。MYDB 中，每个事务都有下面的三种状态：</p><ol><li><code>active</code>，正在进行，尚未结束</li><li><code>committed</code>，已提交</li><li><code>aborted</code>，已撤销（回滚）</li></ol><p>XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，<strong>事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处</strong>，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。（XID文件头8个字节用于记录此XID文件管理的事务数量，后面记录事务的状态）</p><h2 id="必要的常量及变量"><a href="#必要的常量及变量" class="headerlink" title="必要的常量及变量"></a>必要的常量及变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XID文件头长度</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LEN_XID_HEADER_LENGTH</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 每个事务的占用长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">XID_FIELD_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 事务的三种状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ACTIVE</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_COMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ABORTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 超级事务，永远为commited状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SUPER_XID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// XID 文件后缀</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">XID_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.xid&quot;</span>;<br><br><span class="hljs-comment">// 用于获取XID文件</span><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-comment">// 文件通道，用于文件的读写</span><br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-comment">// 用于记录XID文件中事务的数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> xidCounter;<br><span class="hljs-keyword">private</span> Lock counterLock;<br></code></pre></td></tr></table></figure><h2 id="XID文件校验"><a href="#XID文件校验" class="headerlink" title="XID文件校验"></a>XID文件校验</h2><p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，通过<strong>文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比</strong>。如果不同则认为 XID 文件不合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">fileLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 记录文件的实际长度</span><br>        fileLen = file.length();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br>  <span class="hljs-comment">// 文件实际长度比文件头的8字节还小，说明文件不合法</span><br>    <span class="hljs-keyword">if</span>(fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 设置FileChannel的position</span><br>        fc.position(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">// 从文件通道读取内容到ByteBuffer中</span><br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.xidCounter = Parser.parseLong(buf.array());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> getXidPosition(<span class="hljs-built_in">this</span>.xidCounter + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(end != fileLen) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 根据事务xid取得其在xid文件中对应的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getXidPosition</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-keyword">return</span> LEN_XID_HEADER_LENGTH + (xid-<span class="hljs-number">1</span>)*XID_FIELD_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="更新事务状态"><a href="#更新事务状态" class="headerlink" title="更新事务状态"></a>更新事务状态</h2><ul><li><code>begin()</code>：开启一个事务，首先设置<code>xid = xidCounter+1</code>的事务状态为<code>active</code>，随后<strong>xidCounter自增</strong></li><li><code>commit()</code>：提交一个事务，将<code>xid</code>事务的状态设置为<code>committed</code></li><li><code>abort()</code>：取消一个事务，将<code>xid</code>事务的状态设置为<code>aborted</code></li><li>这三个更新操作都可借助下面的<code>updateXID()</code>方法实现，同时开启事务还需要实现一个xidCounter自增的方法<code>incrXIDCounter()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 更新xid事务的状态为status</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">byte</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE];<br>    tmp[<span class="hljs-number">0</span>] = status;<br>  <span class="hljs-comment">// tmp数组包装成bytebuffer数组</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(tmp);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 将ByteBuffer中的内容写入到文件通道中的offset位置，即更改事务状态</span><br>        fc.position(offset);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 所有文件操作，在执行后都需要立刻刷入文件中，防止在崩溃后文件丢失数据，fileChannel 的 force() 方法，强制同步缓存内容到文件中。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。</span><br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将XID加一，并更新XID Header（开启一个新事务时需要此操作）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    xidCounter ++;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(<span class="hljs-number">0</span>);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="检查事务状态"><a href="#检查事务状态" class="headerlink" title="检查事务状态"></a>检查事务状态</h2><p><code>isActive()</code>、<code>isCommitted()</code> 和 <code>isAborted()</code> 都是检查一个 xid 的状态，可以用一个通用的方法解决：（检查时需要排除<code>SUPER_XID</code>的情况，因为该情况一定是<code>committed</code>的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检测XID事务是否处于status状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE]);<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf.array()[<span class="hljs-number">0</span>] == status;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建和打开XID文件"><a href="#创建和打开XID文件" class="headerlink" title="创建和打开XID文件"></a>创建和打开XID文件</h2><p>在接口中创建的两个静态方法<code>create()</code>和<code>open()</code></p><ul><li><code>create()</code>：创建一个XID文件，并创建TM（TM的构造器需要XID文件和FileChannel）</li><li><code>open()</code>：从一个已有的XID文件来创建TM</li></ul><h1 id="3-Data-Manager"><a href="#3-Data-Manager" class="headerlink" title="3. Data Manager"></a>3. Data Manager</h1><blockquote><p>DataManager（DM）功能归纳：</p><ul><li>上层模块和文件系统中的一个抽象层。向上，提供数据包装；向下，直接读写文件。</li><li>提供日志功能。</li></ul></blockquote><h2 id="计数缓存框架"><a href="#计数缓存框架" class="headerlink" title="计数缓存框架"></a>计数缓存框架</h2><blockquote><p>分页管理和数据项（DataItem）管理涉及缓存，故抽象出一个<strong>通用缓存框架</strong>。</p></blockquote><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>**引用计数法（Reference counting）**是一种内存管理技术，它通过计算每个对象被引用的次数来判断是否需要回收该对象。当对象被创建时，引用计数为 1，每当有一个新的引用指向该对象时，计数加 1，当引用失效时，计数减 1。<strong>当计数为 0 时，该对象就可以被回收</strong>。</p><p>在 MYDB 的实践中，需要的效果是，只有上层模块<strong>主动释放引用</strong>，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。于是，选择引用计数法。增加了一个方法 <code>release (key)</code>，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p><p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>**LRU（least recently used）**是一种缓存淘汰算法。它的特点是根据数据最近被访问的时间来决定哪些数据应该被保留，哪些数据应该被淘汰。当缓存达到一定容量时，会淘汰掉最近最少使用的数据。</p><p>如果使用 LRU 缓存，那么只需要设计一个<code>get (key)</code>接口即可，释放缓存可以在缓存满了之后自动完成。</p><p>however，当某时刻缓存满了，缓存驱逐一个资源，此时上层模块想将某个资源强制刷回数据源，这个资源恰恰是刚被驱逐的资源。此时的上层模块会发现，资源在缓存中消失了，那么，是否有必要做回源操作？</p><ul><li><strong>不回源</strong>。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li><li><strong>回源</strong>。如果数据项被驱逐时的数据和现在又是相同的，那就是一次<strong>无效回源</strong></li><li><strong>放回缓存里，等下次被驱逐时回源</strong>。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致<strong>缓存抖动</strong>问题。</li></ul><h3 id="必要的变量"><a href="#必要的变量" class="headerlink" title="必要的变量"></a>必要的变量</h3><p><code>AbstractCache&lt;T&gt;</code>是一个抽象类，内部有两个抽象方法，留给实现类去实现具体的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当资源不在缓存时的获取行为（去数据源中获取）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当资源被驱逐时的写回行为</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(T obj)</span>;<br></code></pre></td></tr></table></figure><p>由于我们选择使用的是引用计数法实现缓存，因此除了普通的缓存功能，还需要另外<strong>维护一个计数</strong>，用于记录资源被引用的个数。除此以外，为了应对<strong>多线程场景</strong>，还需要记录哪些资源正在从数据源获取中（<strong>从数据源获取资源是一个相对费时的操作</strong>）。于是有下面三个 Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="hljs-comment">// 实际缓存的数据</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="hljs-comment">// 资源的引用个数</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="hljs-comment">// 正在被获取的资源</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxResource;                            <span class="hljs-comment">// 缓存的最大缓存资源数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                              <span class="hljs-comment">// 缓存中元素的个数</span><br><span class="hljs-keyword">private</span> Lock lock;<br></code></pre></td></tr></table></figure><h3 id="get-方法获取资源"><a href="#get-方法获取资源" class="headerlink" title="get()方法获取资源"></a>get()方法获取资源</h3><ol><li>判断请求的资源是否正在被其他线程获取，若是，则过一段时间再来查看</li><li>没有其他线程在获取目标资源，到缓存中查看是否有需要的资源，若有，则直接返回</li><li>资源不在缓存中，且缓存已满，抛出<code>CacheFullException</code>异常</li><li>资源不在缓存中且缓存没满，尝试去数据源获取该资源</li><li>在数据源中没找到该资源，抛出异常</li><li>在数据源中找到需要的资源，添加到缓存中后返回</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        lock.lock();<br>        <span class="hljs-comment">// 1.1.首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看</span><br>        <span class="hljs-keyword">if</span>(getting.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 请求的资源正在被其他线程获取</span><br>            lock.unlock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 1.2.如果没有其他线程在获取这个资源，那么就可以尝试从缓存中获取了</span><br>        <span class="hljs-keyword">if</span>(cache.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 资源在缓存中，直接返回</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-comment">// 记得给资源的引用计数加一</span><br>            references.put(key, references.get(key) + <span class="hljs-number">1</span>);<br>            lock.unlock();<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br><br>        <span class="hljs-comment">// 1.3.尝试获取该资源</span><br>        <span class="hljs-comment">// a.判断缓存是否已满，如果已满，就抛出一个异常</span><br>        <span class="hljs-keyword">if</span>(maxResource &gt; <span class="hljs-number">0</span> &amp;&amp; count == maxResource) &#123;<br>            lock.unlock();<br>            <span class="hljs-keyword">throw</span> Error.CacheFullException;<br>        &#125;<br>        <span class="hljs-comment">// b.如果缓存未满，就在 getting 中注册一下，该线程准备从数据源获取资源了</span><br>        count ++;<br>        getting.put(key, <span class="hljs-literal">true</span>);<br>        lock.unlock();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.从数据源获取资源</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用抽象方法从数据源中获取资源</span><br>        obj = getForCache(key);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 如果获取失败，就把 getting 中的注册信息清除掉</span><br>        lock.lock();<br>        count --;<br>        getting.remove(key);<br>        lock.unlock();<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br><br>    lock.lock();<br>    getting.remove(key);       <span class="hljs-comment">// 获取完成要从 getting 中清除注册信息</span><br>    cache.put(key, obj);<br>    references.put(key, <span class="hljs-number">1</span>);<br>    lock.unlock();<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="release-方法释放资源"><a href="#release-方法释放资源" class="headerlink" title="release()方法释放资源"></a>release()方法释放资源</h3><p>当引用计数references减到0后，就可以回源并删除缓存中的相关结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3.释放资源</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 释放一个缓存时，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> references.get(key) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(ref == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-comment">// 调用抽象方法释放缓存</span><br>            releaseForCache(obj);<br>            <span class="hljs-comment">// 删除缓存中所有相关的结构</span><br>            references.remove(key);<br>            cache.remove(key);<br>            count --;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            references.put(key, ref);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="close-方法关闭缓存"><a href="#close-方法关闭缓存" class="headerlink" title="close()方法关闭缓存"></a>close()方法关闭缓存</h3><p>缓存应当还有以一个安全关闭的功能，在关闭时，需要将缓存中所有的资源强行回源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Set&lt;Long&gt; keys = cache.keySet();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> key : keys) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            releaseForCache(obj);<br>            references.remove(key);<br>            cache.remove(key);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，一个简单的缓存框架就实现完了，其他的缓存只需要继承这个类，并实现那两个抽象方法即可。</p><h2 id="数据页的缓存与管理"><a href="#数据页的缓存与管理" class="headerlink" title="数据页的缓存与管理"></a>数据页的缓存与管理</h2><h3 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h3><p>参考大部分数据库的设计，将<strong>默认数据页大小定为 8K</strong>。如果想要提升向数据库写入大量数据情况下的性能的话，也可以适当增大这个值。</p><p>上一节我们已经实现了一个通用的缓存框架，那么这一节我们需要缓存页面，就可以直接借用那个缓存的框架了。但是首先，需要<strong>定义出页面的结构</strong>。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。定义一个页面如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Page</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pageNumber;<span class="hljs-comment">// 页号，从1开始</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] data;<span class="hljs-comment">// 此页面实际包含的字节数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> dirty;<span class="hljs-comment">// 标识该页面是否是脏页面，在缓存驱逐的时候，脏页面需要被写回磁盘</span><br>    <span class="hljs-keyword">private</span> Lock lock;<br><br>    <span class="hljs-keyword">private</span> PageCache pc;<span class="hljs-comment">// 这里保存了一个 PageCache（还未定义）的引用，用来方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>页面缓存接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageCache</span> &#123;<br>  <br>  <span class="hljs-comment">// 页面大小8192</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PAGE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>;<br>  <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span>;<br>    Page <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Page page)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">truncateByBgno</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPgno)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getPageNumber</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">flushPage</span><span class="hljs-params">(Page pg)</span>;<br>  <br>  <span class="hljs-comment">// 创建一个新的.db文件</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageCacheImpl <span class="hljs-title function_">create</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> memory)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+PageCacheImpl.DB_SUFFIX);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(!f.createNewFile()) &#123;<br>                Panic.panic(Error.FileExistsException);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;<br>            Panic.panic(Error.FileCannotRWException);<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br>            fc = raf.getChannel();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageCacheImpl</span>(raf, fc, (<span class="hljs-type">int</span>)memory/PAGE_SIZE);<br>    &#125;<br><br>  <span class="hljs-comment">// 打开一个.db文件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageCacheImpl <span class="hljs-title function_">open</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> memory)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+PageCacheImpl.DB_SUFFIX);<br>        <span class="hljs-keyword">if</span>(!f.exists()) &#123;<br>            Panic.panic(Error.FileNotExistsException);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;<br>            Panic.panic(Error.FileCannotRWException);<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br>            fc = raf.getChannel();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageCacheImpl</span>(raf, fc, (<span class="hljs-type">int</span>)memory/PAGE_SIZE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>页面缓存的具体实现类<code>PageCacheImpl</code>，需要继承抽象缓存框架AbstractCache，并且实现<code>getForCache() </code>和 <code>releaseForCache() </code>两个抽象方法。由于数据源就是文件系统（<strong>.db文件</strong>），<code>getForCache() </code>直接从文件中读取，并包裹成 Page 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据pageNumber从数据库文件中读取页数据，并包裹成Page</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Page <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// 页号</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)key;<br>  <span class="hljs-comment">// 页号对应的页在文件中的位置</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageCacheImpl.pageOffset(pgno);<br><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(PAGE_SIZE);<br>    fileLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    fileLock.unlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, buf.array(), <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pageOffset</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> &#123;<br>    <span class="hljs-comment">// 页号从 1 开始</span><br>    <span class="hljs-keyword">return</span> (pgno-<span class="hljs-number">1</span>) * PAGE_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code> releaseForCache()</code>驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-keyword">if</span>(pg.isDirty()) &#123;<br>        flush(pg);<br>        pg.setDirty(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pg.getPageNumber();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> pageOffset(pgno);<br><br>    fileLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(pg.getData());<br>        fc.position(offset);<br>        fc.write(buf);<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        fileLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pageNumbers.incrementAndGet();<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, initData, <span class="hljs-literal">null</span>);<br>    flush(pg);  <span class="hljs-comment">// 新建的页面需要立刻写回</span><br>    <span class="hljs-keyword">return</span> pgno;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据页管理"><a href="#数据页管理" class="headerlink" title="数据页管理"></a>数据页管理</h3><h4 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h4><p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是<strong>用来做启动检查</strong>。具体的原理是，在每次数据库<strong>启动</strong>时，会生成一串随机字节，存储在 <strong>100 ~ 107</strong> 字节。在数据库<strong>正常关闭</strong>时，会将这串字节，拷贝到第一页的 1<strong>08 ~ 115</strong> 字节。</p><p>这样数据库在每次启动时，就会<strong>检查第一页两处的字节是否相同</strong>，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p><p>启动时设置初始字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(Page pg)</span> &#123;<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    setVcOpen(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="hljs-number">0</span>, raw, OF_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭时拷贝字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(Page pg)</span> &#123;<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    setVcClose(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure><p>校验字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-keyword">return</span> checkVc(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    <span class="hljs-keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="hljs-number">2</span>*LEN_VC));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="普通页"><a href="#普通页" class="headerlink" title="普通页"></a>普通页</h4><p>一个普通页面以一个 <strong>2 字节无符号数</strong>起始，表示<strong>这一页的空闲位置的偏移</strong>。剩下的部分都是实际存储的数据。对普通页的管理，基本都是围绕着对 <strong>FSO（Free Space Offset）进行的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageX</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">short</span> <span class="hljs-variable">OF_FREE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">short</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">// 数据起始位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_FREE_SPACE</span> <span class="hljs-operator">=</span> PageCache.PAGE_SIZE - OF_DATA;<span class="hljs-comment">// 页面最大空闲空间</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] initRaw() &#123;<br>        <span class="hljs-type">byte</span>[] raw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[PageCache.PAGE_SIZE];<br>        setFSO(raw, OF_DATA);<br>        <span class="hljs-keyword">return</span> raw;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> ofData)</span> &#123;<br>        System.arraycopy(Parser.short2Byte(ofData), <span class="hljs-number">0</span>, raw, OF_FREE, OF_DATA);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取pg的FSO</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(Page pg)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFSO(pg.getData());<br>    &#125;<br><span class="hljs-comment">// 获取页面数据row的前两个字节（这两个字节标识空闲位置的起始位置）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>        <span class="hljs-keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中，返回插入位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>        setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset + raw.length));<br>        <span class="hljs-keyword">return</span> offset;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取页面的空闲空间大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFreeSpace</span><span class="hljs-params">(Page pg)</span> &#123;<br>        <span class="hljs-keyword">return</span> PageCache.PAGE_SIZE - (<span class="hljs-type">int</span>)getFSO(pg.getData());<br>    &#125;<br><br>  <span class="hljs-comment">// 下面两个函数在updateLog 和 insertLog 的重做和撤销处理中涉及，用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用</span><br>    <span class="hljs-comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverInsert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br><br>        <span class="hljs-type">short</span> <span class="hljs-variable">rawFSO</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>        <span class="hljs-keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;<br>            setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset+raw.length));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中的offset位置，不更新update</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverUpdate</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="日志文件与恢复策略"><a href="#日志文件与恢复策略" class="headerlink" title="日志文件与恢复策略"></a>日志文件与恢复策略</h2><blockquote><p>MYDB 提供了崩溃后的数据恢复功能。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库崩溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 必要的常量及变量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SEED</span> <span class="hljs-operator">=</span> <span class="hljs-number">13331</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 单条记录Size的起始位置：0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_CHECKSUM</span> <span class="hljs-operator">=</span> OF_SIZE + <span class="hljs-number">4</span>;<span class="hljs-comment">// 单条记录CheckSum起始位置：4</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> OF_CHECKSUM + <span class="hljs-number">4</span>;<span class="hljs-comment">// 单条记录数据起始位置：8</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOG_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.log&quot;</span>;<span class="hljs-comment">// 日志文件后缀</span><br><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-keyword">private</span> Lock lock;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> position;  <span class="hljs-comment">// 当前日志指针的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> fileSize;  <span class="hljs-comment">// 初始化时记录，log操作不更新</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> xChecksum;  <span class="hljs-comment">// 总校验和</span><br></code></pre></td></tr></table></figure><h3 id="日志读写"><a href="#日志读写" class="headerlink" title="日志读写"></a>日志读写</h3><h4 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h4><p>日志的二进制文件，按照如下的格式排布：</p><blockquote><p>[<code>XCheckSum</code>] [<code>Log1</code>] [<code>Log2</code>] [<code>Log3</code>] … [<code>LogN</code>] [<code>BadTail</code>]</p></blockquote><p>其中 <code>XChecksum</code> 是一个四字节的整数int，是<strong>对后续所有日志计算的校验和</strong>。<code>Log1</code> ~ <code>LogN</code> 是常规的日志数据，<code>BadTail</code> 是在数据库崩溃时，<strong>没有来得及写完的日志数据</strong>，这个 <code>BadTail</code> 不一定存在。</p><p>每条日志的格式如下：</p><blockquote><p>[<code>Size</code>] [<code>CheckSum</code>] [<code>Data</code>]</p></blockquote><p>其中，Size 是一个四字节整数int，标识了 <strong>Data 段的字节数</strong>。Checksum 则是<strong>该条日志的校验和int</strong>。单条日志的校验和，其实就是通过一个指定的种子实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calChecksum</span><span class="hljs-params">(<span class="hljs-type">int</span> xCheck, <span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : log) &#123;<br>        xCheck = xCheck * SEED + b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> xCheck;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，对所有日志求出校验和<code>CheckSum</code>，每条校验和再求和（❌）就能得到日志文件的校验和<code>XCheckSum</code>了。</p><blockquote><p>注意，文件里的<code>XCheckSum</code>和每条日志的<code>CheckSum</code>计算对象是不一样的：</p><ul><li><code>XCheckSum</code>是用后续所有日志（包括日志里的<code>size</code>、<code>checkSum</code>、<code>data</code>字段）计算得到的<ul><li><code>XCheckSum</code>是用来保证文件的完整性的，关心的是整个文件，故可以用一整条日志参与计算</li></ul></li><li>每条日志里的<code>CheckSum</code>只用到日志里的<code>data</code>字段计算得到<ul><li>这是因为每条日志里的<code>CheckSum</code>是用来确保当前日志<code>data</code>部分的完整性，故只用<code>data</code>部分计算</li><li>此外，每条日志里的<code>CheckSum</code>的计算也无法用到整条日志进行计算，这是因为整条日志里也包含自身，如果用整条日志计算<code>CheckSum</code>会用到<code>CheckSum</code>自身，这是有问题的</li></ul></li><li>因此<code>XCheckSum</code>  !&#x3D; <code>calChecksum( calChecksum( calChecksum(0, data1), data2), ... dataN)</code></li></ul></blockquote><h4 id="遍历日志文件中的每一条日志"><a href="#遍历日志文件中的每一条日志" class="headerlink" title="遍历日志文件中的每一条日志"></a>遍历日志文件中的每一条日志</h4><p>Logger 被实现成迭代器模式，通过 <code>next()</code> 方法，不断地从文件中<strong>读取下一条日志</strong>，并<strong>将其中的 <code>Data</code> 解析出来并返回</strong>，<code>next()</code> 方法的实现主要依靠 <code>internNext()</code>，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] internNext() &#123;<br>  <span class="hljs-comment">// 位置超出文件大小</span><br>    <span class="hljs-keyword">if</span>(position + OF_DATA &gt;= fileSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取size，读取后position指针向后移动4位，指向checkSum开头</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    fc.position(position);<br>    fc.read(tmp);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Parser.parseInt(tmp.array());<br>    <span class="hljs-keyword">if</span>(position + size + OF_DATA &gt; fileSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取checksum+data，log中包含size+checkSum+data</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(OF_DATA + size);<br>    fc.position(position);<br>    fc.read(buf);<br>    <span class="hljs-type">byte</span>[] log = buf.array();<br><br>    <span class="hljs-comment">// 校验 checksum，确保本条日志的完整性</span><br>  <span class="hljs-comment">// checkSum1:手动计算该条日志的校验和，从log的第8位到最后一位读取</span><br>  <span class="hljs-comment">// checkSum2:从日志数据log中读取该条日志的校验和，从log的4到8位读取</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">checkSum1</span> <span class="hljs-operator">=</span> calChecksum(<span class="hljs-number">0</span>, Arrays.copyOfRange(log, OF_DATA, log.length));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">checkSum2</span> <span class="hljs-operator">=</span> Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));<br>    <span class="hljs-keyword">if</span>(checkSum1 != checkSum2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  <span class="hljs-comment">// position指针位置指向下一条日志</span><br>    position += log.length;<br>  <span class="hljs-comment">// 返回这条日志</span><br>    <span class="hljs-keyword">return</span> log;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="校验日志文件"><a href="#校验日志文件" class="headerlink" title="校验日志文件"></a>校验日志文件</h4><p>在<strong>打开一个日志文件</strong>时，需要首先<strong>校验日志文件</strong>的 <code>XChecksum</code>，并移除文件尾部可能存在的 <code>BadTail</code>，由于 <code>BadTail</code> 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 <code>BadTail</code> 即可保证日志文件的一致性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndRemoveTail</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 设置position为4，也就是XCheckSum后面，第一条日志开头的位置</span><br>    rewind();<br><br>  <span class="hljs-comment">// 对每条日志的!!所有字段!!(区别于一条日志的校验和计算)计算校验和，校验和再求和得到总校验和xCheck</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">xCheck</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">byte</span>[] log = internNext();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        xCheck = calChecksum(xCheck, log);<br>    &#125;<br>  <br>  <span class="hljs-comment">// xCheckSum是从日志文件开头4个字节获得的</span><br>    <span class="hljs-keyword">if</span>(xCheck != xChecksum) &#123;<br>        Panic.panic(Error.BadLogFileException);<br>    &#125;<br><br>    <span class="hljs-comment">// 截断文件到正常日志的末尾</span><br>    truncate(position);<br>  <span class="hljs-comment">// position指针回到起点</span><br>    rewind();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rewind</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算总校验和是用不到它，因为它只返回了日志的数据部分</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] next() &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">byte</span>[] log = internNext();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(log, OF_DATA, log.length);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="写入日志"><a href="#写入日志" class="headerlink" title="写入日志"></a>写入日志</h4><p>向日志文件写入日志时，也是首先<strong>将数据包裹成日志格式</strong>，写入文件后，再<strong>更新文件的校验和</strong>，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>  <span class="hljs-comment">// 将数据包装成日志格式[Size][CheckSum][Data]</span><br>    <span class="hljs-type">byte</span>[] log = wrapLog(data);<br>  <span class="hljs-comment">// 将包装好的一条日志包装成ByteBuffer格式</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(log);<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 将日志写到文件通道中的末尾</span><br>        fc.position(fc.size());<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>  <span class="hljs-comment">// 更新总校验和xCheckSum（这里的log是[Size][CheckSum][Data]这样一整条日志的格式）</span><br>    updateXChecksum(log);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXChecksum</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-built_in">this</span>.xChecksum = calChecksum(<span class="hljs-built_in">this</span>.xChecksum, log);<br>  <span class="hljs-comment">// 将更新后的总校验和xCheckSum写到文件开头4个字节的位置</span><br>    fc.position(<span class="hljs-number">0</span>);<br>    fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));<br>    fc.force(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 在数据前面拼接上Size和CheckSum</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] wrapLog(<span class="hljs-type">byte</span>[] data) &#123;<br>    <span class="hljs-type">byte</span>[] checksum = Parser.int2Byte(calChecksum(<span class="hljs-number">0</span>, data));<br>    <span class="hljs-type">byte</span>[] size = Parser.int2Byte(data.length);<br>    <span class="hljs-keyword">return</span> Bytes.concat(size, checksum, data);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h3><p>DM 为上层模块，提供了两种操作，分别是<strong>插入新数据（I）<strong>和</strong>更新现有数据（U）</strong>。（不包含删除操作）DM 的日志策略很简单，一句话就是：</p><blockquote><p>在进行 I 和 U 操作之前，<strong>必须先进行对应的日志操作</strong>，在保证日志写入磁盘后，才进行数据操作。</p></blockquote><p>这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后<strong>没有来得及同步到磁盘</strong>，<strong>数据库就发生了崩溃</strong>，后续也可以<strong>通过磁盘上的日志恢复该数据</strong>。</p><p>对于两种数据操作，DM 记录的日志如下：</p><ul><li>(Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x</li><li>(Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx</li></ul><p>我们首先不考虑并发的情况，那么在某一时刻，只可能有一个事务在操作数据库。日志会看起来像下面那样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(Ti, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Ti, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), (Tj, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Tj, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), (Tk, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Tk, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>)<br></code></pre></td></tr></table></figure><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下<strong>利用日志恢复</strong>很简单，假设日志中<strong>最后一个事务是 Ti</strong>：</p><ol><li>对 <strong>Ti 之前所有的事务</strong>的日志，进行<strong>重做（redo）</strong></li><li>接着检查 <strong>Ti 的状态（XID 文件）</strong>，如果 Ti 的状态是<strong>已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo）</strong></li></ol><p>接着，是如何对事务 T 进行 <strong>redo</strong>：</p><ol><li><strong>正序扫描</strong>事务 T 的所有日志</li><li>如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置</li><li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx</li></ol><p><strong>undo</strong> 也很好理解：</p><ol><li><strong>倒序扫描</strong>事务 T 的所有日志</li><li>如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除</li><li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx</li></ol><p>注意，MYDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>考虑以下两种情况：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 情况1</span><br><br>T1 <span class="hljs-keyword">begin</span><br>T2 <span class="hljs-keyword">begin</span><br>T2 U(<span class="hljs-variable language_">x</span>)<br>T1 R(<span class="hljs-variable language_">x</span>)<br>...<br>T1 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure><p>在系统崩溃时，T2 仍然是<strong>活跃</strong>状态（active）。那么当数据库重新启动，执行恢复例程时，会<strong>撤销 T2</strong>，它对数据库的影响会被消除。但是<strong>由于 T1 读取了 T2 更新的值</strong>，既然 T2 被撤销，那么 <strong>T1 也应当被撤销</strong>。这种情况，就是<strong>级联回滚Cascading Rollback</strong>。但是，T1 已经 commit 了，所有 commit 的事务的影响，应当被持久化。这里就造成了矛盾。所以这里需要保证：</p><blockquote><p>规定1:正在进行的事务，不会读取其他未提交的事务产生的数据（读提交Read Committed）</p></blockquote><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 情况2，假设x的初值为0</span><br><br>T1 <span class="hljs-keyword">begin</span><br>T2 <span class="hljs-keyword">begin</span><br>T1 set <span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 产生的日志为(T1, U, A, 0, 1)</span><br>T2 set <span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 产生的日志为(T1, U, A, 1, 2)</span><br>T2 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure><p>在系统崩溃时，T1 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，<strong>会对 T1 进行撤销，对 T2 进行重做</strong>，但是，无论撤销和重做的先后顺序如何，x 最后的结果，要么是 0，要么是 2，这都是错误的。</p><blockquote><p>出现这种问题的原因, 归根结底是因为我们的<strong>日志太过简单</strong>, 仅仅记录了**”前相”和”后相”<strong>. 并单纯的</strong>依靠”前相”undo, 依靠”后相”redo.** 这种简单的日志方式和恢复方式, 并不能涵盖住所有数据库操作形成的语义</p></blockquote><p>解决方法有两种：</p><ol><li>增加日志种类</li><li>限制数据库操作</li></ol><p>MYDB 采用的是<strong>限制数据库操作</strong>，需要保证：</p><blockquote><p>规定2：正在进行的事务，<strong>不会修改其他任何未提交的事务修改或产生的数据</strong>。</p></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="两种日志的格式"><a href="#两种日志的格式" class="headerlink" title="两种日志的格式"></a><strong>两种日志的格式</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">LOG_TYPE_INSERT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">LOG_TYPE_UPDATE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// updateLog:</span><br><span class="hljs-comment">// [LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><br><span class="hljs-comment">// insertLog:</span><br><span class="hljs-comment">// [LogType] [XID] [Pgno] [Offset] [Raw]</span><br></code></pre></td></tr></table></figure><p>和原理中描述的类似，recover 例程主要也是两步：<strong>重做所有已完成事务，撤销所有未完成事务</strong></p><h5 id="重做所有已完成事务（committed、aborted）"><a href="#重做所有已完成事务（committed、aborted）" class="headerlink" title="重做所有已完成事务（committed、aborted）"></a><strong>重做所有已完成事务（committed、aborted）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重做所有已完成事务（committed、aborted）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">redoTranscations</span><span class="hljs-params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;<br>  <span class="hljs-comment">// 从第一个事务开始（重做redo要按顺序重做）</span><br>    lg.rewind();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-comment">// 一个一个事务遍历</span><br>        <span class="hljs-type">byte</span>[] log = lg.next();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>          <span class="hljs-comment">// 如果是插入事务</span><br>            <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> li.xid;<br>            <span class="hljs-keyword">if</span>(!tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 事务状态是committed或aborted，重做插入操作</span><br>                doInsertLog(pc, log, REDO);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果是更新事务</span><br>            <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xi.xid;<br>            <span class="hljs-keyword">if</span>(!tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 事务状态是committed或aborted，重做更新操作</span><br>                doUpdateLog(pc, log, REDO);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="撤销所有未完成事务（active）"><a href="#撤销所有未完成事务（active）" class="headerlink" title="撤销所有未完成事务（active）"></a><strong>撤销所有未完成事务（active）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 撤销所有未完成事务（active）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undoTranscations</span><span class="hljs-params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;<br>  <span class="hljs-comment">// 用于记录(要撤回事务的xid，事务xid要撤回的操作列表)，一个事务可能要撤回多个操作，所以要用列表记录</span><br>    Map&lt;Long, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt; logCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    lg.rewind();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">byte</span>[] log = lg.next();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>          <span class="hljs-comment">// 如果是插入事务</span><br>            <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> li.xid;<br>          <span class="hljs-comment">// 事务状态是active</span><br>            <span class="hljs-keyword">if</span>(tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 把事务xid及其要撤回的操作加入到logCache中</span><br>                <span class="hljs-keyword">if</span>(!logCache.containsKey(xid)) &#123;<br>                    logCache.put(xid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                logCache.get(xid).add(log);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果是更新事务</span><br>            <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xi.xid;<br>          <span class="hljs-comment">// 事务状态是active</span><br>            <span class="hljs-keyword">if</span>(tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 把事务xid及其要撤回的操作加入到logCache中</span><br>                <span class="hljs-keyword">if</span>(!logCache.containsKey(xid)) &#123;<br>                    logCache.put(xid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                logCache.get(xid).add(log);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对所有active log进行倒序undo</span><br>    <span class="hljs-keyword">for</span>(Entry&lt;Long, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt; entry : logCache.entrySet()) &#123;<br>        List&lt;<span class="hljs-type">byte</span>[]&gt; logs = entry.getValue();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> logs.size()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-type">byte</span>[] log = logs.get(i);<br>            <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>                doInsertLog(pc, log, UNDO);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                doUpdateLog(pc, log, UNDO);<br>            &#125;<br>        &#125;<br>        tm.abort(entry.getKey());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判读是否是插入事务，否则是更新事务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInsertLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-keyword">return</span> log[<span class="hljs-number">0</span>] == LOG_TYPE_INSERT;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="解析插入事务与更新事务"><a href="#解析插入事务与更新事务" class="headerlink" title="解析插入事务与更新事务"></a><strong>解析插入事务与更新事务</strong></h5><ul><li><strong>解析插入事务日志</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解析插入事务日志 [LogType] [XID] [Pgno] [Offset] [Raw]</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// LogType位置：0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XID</span> <span class="hljs-operator">=</span> OF_TYPE+<span class="hljs-number">1</span>;<span class="hljs-comment">// XID位置：1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_PGNO</span> <span class="hljs-operator">=</span> OF_XID+<span class="hljs-number">8</span>;<span class="hljs-comment">// 插入事务发生的页号位置：9</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_OFFSET</span> <span class="hljs-operator">=</span> OF_INSERT_PGNO+<span class="hljs-number">4</span>;<span class="hljs-comment">// 插入事务发生在页中的位置：13</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_RAW</span> <span class="hljs-operator">=</span> OF_INSERT_OFFSET+<span class="hljs-number">2</span>;<span class="hljs-comment">// 插入数据位置：15</span><br><br><span class="hljs-comment">// 插入事务日志信息</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertLogInfo</span> &#123;<br>    <span class="hljs-type">long</span> xid;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] raw;<br>&#125;<br><br><span class="hljs-comment">// 解析插入事务日志</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InsertLogInfo <span class="hljs-title function_">parseInsertLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsertLogInfo</span>();<br>    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_INSERT_PGNO));<br>    li.pgno = Parser.parseInt(Arrays.copyOfRange(log, OF_INSERT_PGNO, OF_INSERT_OFFSET));<br>    li.offset = Parser.parseShort(Arrays.copyOfRange(log, OF_INSERT_OFFSET, OF_INSERT_RAW));<br>    li.raw = Arrays.copyOfRange(log, OF_INSERT_RAW, log.length);<br>    <span class="hljs-keyword">return</span> li;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析更新事务日志</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解析更新事务日志 [LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_UPDATE_UID</span> <span class="hljs-operator">=</span> OF_XID+<span class="hljs-number">8</span>;<span class="hljs-comment">// UID位置：9</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_UPDATE_RAW</span> <span class="hljs-operator">=</span> OF_UPDATE_UID+<span class="hljs-number">8</span>;<span class="hljs-comment">// 更新数据位置：17</span><br><br><span class="hljs-comment">// 更新事务日志信息</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateLogInfo</span> &#123;<br>    <span class="hljs-type">long</span> xid;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] oldRaw;<br>    <span class="hljs-type">byte</span>[] newRaw;<br>&#125;<br><br><span class="hljs-comment">// 解析更新事务日志</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UpdateLogInfo <span class="hljs-title function_">parseUpdateLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateLogInfo</span>();<br>    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_UPDATE_UID));<br>    <span class="hljs-type">long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> Parser.parseLong(Arrays.copyOfRange(log, OF_UPDATE_UID, OF_UPDATE_RAW));<br>    li.offset = (<span class="hljs-type">short</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">16</span>) - <span class="hljs-number">1</span>));<br>    uid &gt;&gt;&gt;= <span class="hljs-number">32</span>;<br>    li.pgno = (<span class="hljs-type">int</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (log.length - OF_UPDATE_RAW) / <span class="hljs-number">2</span>;<br>    li.oldRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW, OF_UPDATE_RAW+length);<br>    li.newRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW+length, OF_UPDATE_RAW+length*<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> li;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="updateLog-和-insertLog-的重做和撤销处理"><a href="#updateLog-和-insertLog-的重做和撤销处理" class="headerlink" title="updateLog 和 insertLog 的重做和撤销处理"></a><strong>updateLog 和 insertLog 的重做和撤销处理</strong></h5><p>updateLog 和 insertLog 的重做和撤销处理，分别合并为一个方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// updateLog的重做和撤销处理</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doUpdateLog</span><span class="hljs-params">(PageCache pc, <span class="hljs-type">byte</span>[] log, <span class="hljs-type">int</span> flag)</span> &#123;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] raw;<br>    <span class="hljs-keyword">if</span>(flag == REDO) &#123;<br>      <span class="hljs-comment">// 重做</span><br>        <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>        pgno = xi.pgno;<br>        offset = xi.offset;<br>        raw = xi.newRaw;<span class="hljs-comment">// 重做要设置数据到最新</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 撤销</span><br>        <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>        pgno = xi.pgno;<br>        offset = xi.offset;<br>        raw = xi.oldRaw;<span class="hljs-comment">// 撤销要设置数据到久版本</span><br>    &#125;<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(pgno);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 见普通页部分</span><br>        PageX.recoverUpdate(pg, raw, offset);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        pg.release();<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// insertLog的重做和撤销操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInsertLog</span><span class="hljs-params">(PageCache pc, <span class="hljs-type">byte</span>[] log, <span class="hljs-type">int</span> flag)</span> &#123;<br>    <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(li.pgno);<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(flag == UNDO) &#123;<br>          <span class="hljs-comment">// 撤销插入，逻辑删除，大致的作用，就是将该条 DataItem 的有效位设置为无效，来进行逻辑删除。</span><br>            DataItem.setDataItemRawInvalid(li.raw);<br>        &#125;<br>      <span class="hljs-comment">// 见普通页部分</span><br>        PageX.recoverInsert(pg, li.raw, li.offset);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        pg.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="页面索引与DM的实现"><a href="#页面索引与DM的实现" class="headerlink" title="页面索引与DM的实现"></a>页面索引与DM的实现</h2><blockquote><p>本节将为 DM 层做收尾，介绍一个实现简单的页面索引。并且实现了 DM 层对于上层的抽象：DataItem。</p></blockquote><h3 id="页面索引"><a href="#页面索引" class="headerlink" title="页面索引"></a>页面索引</h3><p>页面索引，<strong>缓存了每一页的空闲空间</strong>。用于在上层模块进行插入操作时，能够快速找到一个合适空间的页面，而<strong>无需从磁盘或者缓存中检查每一个页面的信息</strong>。</p><p>MYDB 用一个比较粗略的算法实现了页面索引，将一页的空间划分成了 <strong>40 个区间</strong>。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这 40 个区间中。insert 在请求一个页时，会首先将所需的空间<strong>向上取整</strong>，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。</p><p><code>PageIndex</code> 的实现也很简单，一个 List 类型的数组。</p><blockquote><p><code>lists</code>的作用是将页面信息根据页面的剩余空间分组存储，<code>THRESHOLD</code> &#x3D; 8192 &#x2F; 40 &#x3D; 204.8，这意味着，页面的剩余空间将被按大约 <strong>204.8 字节</strong>划分成多个区间，每个页面的剩余空间将根据这个阈值来计算自己属于哪个区间，并将自己的页面信息PageInfo放到对应的<code>list</code>下。打个比方：</p><ul><li>如果页面的<strong>剩余空间是 500 字节</strong>，那么它将**被划分到 500 &#x2F; 204.8 ≈ 2 的区间中（即 lists[2]）。**此时如果有一个数据，大小在 <code>[1 * 204.8, 2 * 204.8] </code>之间，那么他就会先到lists[2]中找到这个页面，并将数据保存在这个页面。</li><li>如果剩余空间是 1500 字节，那么它将被划分到 1500 &#x2F; 204.8 ≈ 7 的区间中（即 lists[7]）。</li><li>如果有多个页面，它们的<strong>剩余空间都在同一个区间内</strong>，那就会<strong>放在同一个<code>list</code>中</strong>，要取的时候，从列表头取起。</li><li>通过这个操作，要保存数据的时候就不用到磁盘中去一个个找哪个页面能够容纳这个数据，直接在<code>PageIndex</code>中就能够知道哪一页是能容纳该数据的。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageIndex</span> &#123;<br>    <span class="hljs-comment">// 将一页划成40个区间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERVALS_NO</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br>  <span class="hljs-comment">// 一个区间的大小，8192 / 40 = 204.8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> PageCache.PAGE_SIZE / INTERVALS_NO;<br><br>    <span class="hljs-keyword">private</span> Lock lock;<br>  <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">private</span> List&lt;PageInfo&gt;[] lists;<br>  <br>  <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PageIndex</span><span class="hljs-params">()</span> &#123;<br>        lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[INTERVALS_NO+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; INTERVALS_NO+<span class="hljs-number">1</span>; i ++) &#123;<br>            lists[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageInfo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> freeSpace;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PageInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno, <span class="hljs-type">int</span> freeSpace)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pgno = pgno;<br>        <span class="hljs-built_in">this</span>.freeSpace = freeSpace;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当来了一个大小为<code>spaceSize</code>的数据要保存到页面时，使用<code>select()</code>方法，直接算出区间号，直接取即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> PageInfo <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> spaceSize)</span> &#123;<br>  <span class="hljs-comment">// 计算哪个区间内的页面能容纳该数据（大于number的list中包含能容纳该数据的页面）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> spaceSize / THRESHOLD;<br>    <span class="hljs-keyword">if</span>(number &lt; INTERVALS_NO) number ++;<br>    <span class="hljs-keyword">while</span>(number &lt;= INTERVALS_NO) &#123;<br>      <span class="hljs-comment">// lists[number]中没有页面，那就往下找</span><br>        <span class="hljs-keyword">if</span>(lists[number].size() == <span class="hljs-number">0</span>) &#123;<br>            number ++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>      <span class="hljs-comment">// 找到一个符合的页面，返回页面信息PageInfo，并将该页从list中移除</span><br>        <span class="hljs-keyword">return</span> lists[number].remove(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以注意到，被选择的页，会<strong>直接从 <code>PageIndex</code> 中移除</strong>，这意味着，<strong>同一个页面是不允许并发写的</strong>。在上层模块使用完这个页面后，需要将其重新插入 <code>PageIndex</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno, <span class="hljs-type">int</span> freeSpace)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> freeSpace / THRESHOLD;<br>    lists[number].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>(pgno, freeSpace));<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>DataManager</code> 被创建时，需要获取所有页面并填充 <code>PageIndex</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化pageIndex</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">fillPageIndex</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageNumber</span> <span class="hljs-operator">=</span> pc.getPageNumber();<br>  <span class="hljs-comment">// 第一页用于启动检查，页面从1开始，故int i = 2</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= pageNumber; i ++) &#123;<br>        <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// getPage调用了AbstractCache中get方法，调用这个方法会先到缓存（HashMap cache）中找对应页号i的页面，若没有再到数据源（文件系统）找</span><br>            pg = pc.getPage(i);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>      <span class="hljs-comment">// 将对应的页面信息添加到PageIndex中</span><br>        pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));<br>      <span class="hljs-comment">// 注意在使用完 Page 后需要及时 release，否则可能会撑爆缓存</span><br>        pg.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DataItem"><a href="#DataItem" class="headerlink" title="DataItem"></a>DataItem</h3><p><code>DataItem</code>是 DM 层<strong>向上层提供的数据抽象</strong>。上层模块通过地址，向 DM 请求到对应的 <code>DataItem</code>，再获取到其中的数据。<code>DataItem</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dataItem 结构如下：</span><br><span class="hljs-comment"> * [ValidFlag] [DataSize] [Data]</span><br><span class="hljs-comment"> * ValidFlag 1字节，0为合法，1为非法</span><br><span class="hljs-comment"> * DataSize  2字节，标识Data的长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataItemImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataItem</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_VALID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">private</span> SubArray raw;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] oldRaw;<br>    <span class="hljs-keyword">private</span> Lock rLock;<br>    <span class="hljs-keyword">private</span> Lock wLock;<br>    <span class="hljs-keyword">private</span> DataManagerImpl dm;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> uid;<br>    <span class="hljs-keyword">private</span> Page pg;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] raw;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> start;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SubArray</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-built_in">this</span>.raw = raw;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>DataItem</code>中<code>SubArray raw</code>的大概意思：</p><ul><li>因为数据都是放在页面里的，取数据的时候也是按页为单位取的，故**<code>raw.raw</code>一般表示的是数据所在页那一整页的数据**</li><li>所以**<code>raw.start</code>表示的是<code>DataItem</code>所表示的数据在这一页中的起始位置**（偏移<code>offset</code>）</li></ul></blockquote><p>DataItem 中保存的数据，结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[ValidFlag]</span> <span class="hljs-selector-attr">[DataSize]</span> <span class="hljs-selector-attr">[Data]</span><br></code></pre></td></tr></table></figure><p>其中 <code>ValidFlag</code> 占用 1 字节，<strong>标识了该 <code>DataItem</code> 是否有效</strong>。<strong>删除一个 <code>DataItem</code>，只需要简单地将其有效位设置为 1</strong>。<code>DataSize</code> 占用 2 字节，标识了后面 <code>Data</code> 的长度。</p><blockquote><p>根据上面<code>DataItem</code>的结构，我们有：</p><ul><li><code>offset = raw.start</code></li><li><code>ValidFlag = raw.raw[offset + OF_VALID]</code></li><li><code>DataSize = Parser.parseShort(Arrays.copyOfRange(raw, offset+DataItemImpl.OF_SIZE, offset+DataItemImpl.OF_DATA))</code></li></ul></blockquote><p>上层模块在获取到 <code>DataItem</code> 后，可以通过 <code>data()</code> 方法，该方法返回的数组是数据共享的，而不是拷贝实现的，所以使用了 <code>SubArray</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SubArray <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(raw.raw, raw.start+OF_DATA, raw.end);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上层模块试图对 <code>DataItem</code> 进行修改时，需要遵循一定的流程：在<strong>修改之前</strong>需要调用 <code>before()</code> 方法，想要<strong>撤销修改</strong>时，调用 <code>unBefore()</code> 方法，在<strong>修改完成</strong>后，调用 <code>after()</code> 方法。整个流程，<strong>主要是为了保存前相数据，并及时落日志</strong>。DM 会保证对 <code>DataItem</code> 的修改是原子性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>    wLock.lock();<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    System.arraycopy(raw.raw, raw.start, oldRaw, <span class="hljs-number">0</span>, oldRaw.length);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unBefore</span><span class="hljs-params">()</span> &#123;<br>    System.arraycopy(oldRaw, <span class="hljs-number">0</span>, raw.raw, raw.start, oldRaw.length);<br>    wLock.unlock();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>  <span class="hljs-comment">// 调用 dm 中的一个方法，对修改操作落日志</span><br>    dm.logDataItem(xid, <span class="hljs-built_in">this</span>);<br>    wLock.unlock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> raw.raw[raw.start+OF_VALID] == (<span class="hljs-type">byte</span>)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用完 <code>DataItem</code> 后，也应当及时调用 <code>release()</code>方法，释放掉 <code>DataItem</code> 的缓存（由 DM 缓存 <code>DataItem</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    dm.releaseDataItem(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DM的实现"><a href="#DM的实现" class="headerlink" title="DM的实现"></a>DM的实现</h3><h4 id="DM读取、释放数据DataItem"><a href="#DM读取、释放数据DataItem" class="headerlink" title="DM读取、释放数据DataItem"></a>DM读取、释放数据DataItem</h4><p><code>DataManager</code> 是 DM 层直接对外提供方法的类，同时，也实现成 <code>DataItem</code> 对象的<strong>缓存</strong>，继承<code>AbstractCache</code>。<code>DataItem</code> 存储的 <strong>key</strong>，是<strong>由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4 字节</strong>。</p><p>DataItem 缓存，<code>getForCache()</code>，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> DataItem <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">16</span>) - <span class="hljs-number">1</span>));<br>    uid &gt;&gt;&gt;= <span class="hljs-number">32</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>));<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> pc.getPage(pgno);<br>    <span class="hljs-keyword">return</span> DataItem.parseDataItem(pg, offset, <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 从页面的offset处解析处DataItem</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataItem <span class="hljs-title function_">parseDataItem</span><span class="hljs-params">(Page pg, <span class="hljs-type">short</span> offset, DataManagerImpl dm)</span> &#123;<br>  <span class="hljs-comment">// 获取这个页面的所有数据</span><br>    <span class="hljs-type">byte</span>[] raw = pg.getData();<br>  <span class="hljs-comment">// 获取这个DataItem的Data字段的长度</span><br>    <span class="hljs-type">short</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Parser.parseShort(Arrays.copyOfRange(raw, offset+DataItemImpl.OF_SIZE, offset+DataItemImpl.OF_DATA));<br>  <span class="hljs-comment">// 获取这个DataItem总长度，则这个DataItem在这个页面中的范围是[offset， offset + length]</span><br>    <span class="hljs-type">short</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(size + DataItemImpl.OF_DATA);<br>  <span class="hljs-comment">// 获取这个DataItem的uid</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> Types.addressToUid(pg.getPageNumber(), offset);<br>  <span class="hljs-comment">// 拼装成一个DataItem返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataItemImpl</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(raw, offset, offset+length), <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length], pg, uid, dm);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DataItem</code> 缓存释放，需要将 <code>DataItem</code> 写回数据源，由于对文件的读写是以页为单位进行的，只需要<strong>将 <code>DataItem</code> 所在的页 release</strong> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(DataItem di)</span> &#123;<br>    di.page().release();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DM的创建与打开"><a href="#DM的创建与打开" class="headerlink" title="DM的创建与打开"></a>DM的创建与打开</h4><p>从<strong>已有文件</strong>创建 <code>DataManager</code> 和从<strong>空文件</strong>创建 <code>DataManager</code> 的流程稍有不同，除了 PageCache 和 Logger 的创建方式有所不同以外，从<strong>空文件创建首先需要对第一页进行初始化</strong>，而<strong>从已有文件创建，则是需要对第一页进行校验</strong>，来判断是否需要执行恢复流程。并重新对第一页生成随机字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataManager <span class="hljs-title function_">create</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem, TransactionManager tm)</span> &#123;<br>    <span class="hljs-type">PageCache</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> PageCache.create(path, mem);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> Logger.create(path);<br>    <span class="hljs-type">DataManagerImpl</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataManagerImpl</span>(pc, lg, tm);<br>    dm.initPageOne();<br>    <span class="hljs-keyword">return</span> dm;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataManager <span class="hljs-title function_">open</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem, TransactionManager tm)</span> &#123;<br>    <span class="hljs-type">PageCache</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> PageCache.open(path, mem);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> Logger.open(path);<br>    <span class="hljs-type">DataManagerImpl</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataManagerImpl</span>(pc, lg, tm);<br>    <span class="hljs-keyword">if</span>(!dm.loadCheckPageOne()) &#123;<br>        Recover.recover(tm, lg, pc);<br>    &#125;<br>    dm.fillPageIndex();<br>    PageOne.setVcOpen(dm.pageOne);<br>    dm.pc.flushPage(dm.pageOne);<br>    <span class="hljs-keyword">return</span> dm;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，初始化第一页，和校验第一页，基本都是调用 PageOne 类中的方法实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在创建文件时初始化PageOne</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">initPageOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pc.newPage(PageOne.InitRaw());<br>    <span class="hljs-keyword">assert</span> pgno == <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pageOne = pc.getPage(pgno);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    pc.flushPage(pageOne);<br>&#125;<br><br><span class="hljs-comment">// 在打开已有文件时时读入PageOne，并验证正确性</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">loadCheckPageOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pageOne = pc.getPage(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> PageOne.checkVc(pageOne);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DM读、插入数据"><a href="#DM读、插入数据" class="headerlink" title="DM读、插入数据"></a>DM读、插入数据</h4><p>DM 层提供了三个功能<strong>供上层使用</strong>，分别是读、插入和修改。修改是通过读出的 <code>DataItem</code> 实现的，于是 <code>DataManager</code> 只需要提供 <code>read()</code> 和 <code>insert()</code> 方法。</p><ul><li><code>read()</code> 根据 UID 从缓存中获取 DataItem，并校验有效位：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> DataItem <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DataItemImpl</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> (DataItemImpl)<span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">if</span>(!di.isValid()) &#123;<br>        di.release();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> di;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>insert()</code> 方法，在 <code>pageIndex</code> 中获取一个<strong>足以存储插入内容的页面的页号</strong>，获取页面后，<strong>首先需要写入插入日志</strong>，接着才可以<strong>通过 pageX 插入数据</strong>，并返回插入位置的偏移。最后需要<strong>将页面信息重新插入 pageIndex</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] wrapDataItemRaw(<span class="hljs-type">byte</span>[] raw) &#123;<br>    <span class="hljs-type">byte</span>[] valid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span>];<span class="hljs-comment">// 起始默认值为0，表示合法</span><br>    <span class="hljs-type">byte</span>[] size = Parser.short2Byte((<span class="hljs-type">short</span>)raw.length);<br>    <span class="hljs-keyword">return</span> Bytes.concat(valid, size, raw);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// 包装成DataItem</span><br>    <span class="hljs-type">byte</span>[] raw = DataItem.wrapDataItemRaw(data);<br>    <span class="hljs-keyword">if</span>(raw.length &gt; PageX.MAX_FREE_SPACE) &#123;<br>        <span class="hljs-keyword">throw</span> Error.DataTooLargeException;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试获取可用页</span><br>    <span class="hljs-type">PageInfo</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) &#123;<br>        pi = pIndex.select(raw.length);<br>        <span class="hljs-keyword">if</span> (pi != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newPgno</span> <span class="hljs-operator">=</span> pc.newPage(PageX.initRaw());<br>            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pi == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> Error.DatabaseBusyException;<br>    &#125;<br><br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">freeSpace</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(pi.pgno);<br>        <span class="hljs-comment">// 首先做日志</span><br>        <span class="hljs-type">byte</span>[] log = Recover.insertLog(xid, pg, raw);<br>        logger.log(log);<br>        <span class="hljs-comment">// 再执行插入操作</span><br>        <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageX.insert(pg, raw);<br><br>        pg.release();<br>        <span class="hljs-keyword">return</span> Types.addressToUid(pi.pgno, offset);<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 将取出的pg重新插入pIndex</span><br>        <span class="hljs-keyword">if</span>(pg != <span class="hljs-literal">null</span>) &#123;<br>            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pIndex.add(pi.pgno, freeSpace);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DM的关闭"><a href="#DM的关闭" class="headerlink" title="DM的关闭"></a>DM的关闭</h4><p><code>DataManager</code> 正常关闭时，需要执行缓存和日志的关闭流程，不要忘了设置<strong>第一页的字节校验</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// DataManager缓存关闭</span><br>    <span class="hljs-built_in">super</span>.close();<br>  <span class="hljs-comment">// 日志关闭</span><br>    logger.close();<br><br>  <br>  <span class="hljs-comment">// 第一页的字节校验</span><br>    PageOne.setVcClose(pageOne);<br>    pageOne.release();<br>  <span class="hljs-comment">// 页面缓存关闭</span><br>    pc.close();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-Version-Manager"><a href="#4-Version-Manager" class="headerlink" title="4. Version Manager"></a>4. Version Manager</h1><blockquote><p>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。类似于 Data Manager 是 MYDB 的数据管理核心，Version Manager 是 MYDB 的<strong>事务和数据版本的管理核心</strong>。</p></blockquote><h2 id="2PL与MVCC"><a href="#2PL与MVCC" class="headerlink" title="2PL与MVCC"></a>2PL与MVCC</h2><h3 id="冲突与2PL"><a href="#冲突与2PL" class="headerlink" title="冲突与2PL"></a>冲突与2PL</h3><p>首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这<strong>两个操作相互冲突</strong>：</p><ol><li>这两个操作是由不同的事务执行的</li><li>这两个操作操作的是同一个数据项</li><li>这两个操作至少有一个是更新操作</li></ol><p>那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：</p><ol><li>两个不同事务的 U 操作冲突</li><li>两个不同事务的 U、R 操作冲突</li></ol><p>那么冲突或者不冲突，意义何在？作用在于，<strong>交换两个互不冲突的操作的顺序，不会对最终的结果造成影响</strong>，而交换两个冲突操作的顺序，则是会有影响的。 </p><p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。<strong>MYDB 采用两段锁协议（2PL）来实现。<strong>当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作</strong>相互冲突</strong>的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的<strong>读或者写操作都会被阻塞</strong>，T2 必须等待 T1 释放掉对 x 的锁。</p><p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了<strong>事务间的相互阻塞</strong>，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>在介绍 MVCC 之前，首先明确记录和版本的概念。</p><p>DM 层向上层提供了数据项（<code>DataItem</code>）的概念，VM 通过管理所有的数据项，向上层提供了记录（<code>Entry</code>）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（<code>Version</code>）。每当上层模块对某个记录进行修改时，VM 就会为这个记录<strong>创建一个新的版本</strong>。</p><p>MYDB 通过 MVCC，<strong>降低了事务的阻塞概率</strong>。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是<strong>创建了一个新的 X 的版本，假设为 x3</strong>。假设 T1 <strong>还没有释放</strong> X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会<strong>返回一个较老版本的 X，例如 x2</strong>。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X <strong>没有一个更老的版本</strong>，那<strong>只能等待 T1 释放锁</strong>了。所以只是<strong>降低了概率</strong>。</p><h2 id="记录的实现"><a href="#记录的实现" class="headerlink" title="记录的实现"></a>记录的实现</h2><p>对于一条记录来说，MYDB 使用 <code>Entry</code> 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 <code>Update</code> 操作，对于字段的<strong>更新操作由后面的表和字段管理（TBM）实现</strong>。所以在 VM 的实现中，一条记录只有一个版本。</p><p>一条记录存储在一条 <code>DataItem</code> 中，所以 <code>Entry</code> 中保存一个 <code>DataItem</code> 的引用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM向上层抽象出entry</span><br><span class="hljs-comment"> * entry结构：</span><br><span class="hljs-comment"> * [XMIN] [XMAX] [data]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XMIN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// entry XMIN的起始位置：0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XMAX</span> <span class="hljs-operator">=</span> OF_XMIN+<span class="hljs-number">8</span>;<span class="hljs-comment">// entry XMAX的起始位置：8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> OF_XMAX+<span class="hljs-number">8</span>;<span class="hljs-comment">// 注意⚠️，这里的OF_DATA=16要和DataItemImpl中的OF_DATA=3区分开来</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> uid;<br>    <span class="hljs-keyword">private</span> DataItem dataItem;<br>    <span class="hljs-keyword">private</span> VersionManager vm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title function_">loadEntry</span><span class="hljs-params">(VersionManager vm, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DataItem</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);<br>        <span class="hljs-keyword">return</span> newEntry(vm, di, uid);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        dataItem.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们规定，一条 <code>Entry</code> 中存储的数据格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">// XMIN和XMAX都是一个<span class="hljs-number">8</span>字节的byte<span class="hljs-selector-attr">[]</span><br><span class="hljs-selector-attr">[XMIN]</span> <span class="hljs-selector-attr">[XMAX]</span> <span class="hljs-selector-attr">[DATA]</span><br></code></pre></td></tr></table></figure><p><code>XMIN</code> 是<strong>创建该条记录（版本）的事务编号</strong>，而 <code>XMAX</code> 则是<strong>删除该条记录（版本）的事务编号</strong>。它们的作用将在下一节中说明。<code>DATA</code> 就是<strong>这条记录持有的数据</strong>。根据这个结构，在<strong>创建记录</strong>时调用的 <code>wrapEntryRaw()</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] wrapEntryRaw(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data) &#123;<br>    <span class="hljs-type">byte</span>[] xmin = Parser.long2Byte(xid);<br>    <span class="hljs-type">byte</span>[] xmax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">return</span> Bytes.concat(xmin, xmax, data);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，如果要<strong>获取记录中持有的数据</strong>，也就需要按照这个结构来解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以拷贝的形式返回内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] data() &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 从DataItem中取出数据部分：也就是除去VaildFlag和DataSize后面的数据部分，也是一个SubArray</span><br>        <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> dataItem.data();<br>      <span class="hljs-comment">// 取出来的数据sa也被分为[XMIN] [XMAX] [DATA]的结构，这里的OF_DATA=16</span><br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[sa.end - sa.start - OF_DATA];<br>        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="hljs-number">0</span>, data.length);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里以拷贝的形式返回数据，如果需要修改的话，需要对 <code>DataItem</code> 执行 <code>before()</code> 方法，这个在设置 <code>XMAX</code> 的值中体现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setXmax</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    dataItem.before();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> dataItem.data();<br>      <span class="hljs-comment">// 将sa的XMAX部分修改为当前的xid</span><br>        System.arraycopy(Parser.long2Byte(xid), <span class="hljs-number">0</span>, sa.raw, sa.start+OF_XMAX, <span class="hljs-number">8</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.after(xid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="读提交（Read-Committed-RC）"><a href="#读提交（Read-Committed-RC）" class="headerlink" title="读提交（Read Committed, RC）"></a>读提交（Read Committed, RC）</h3><p>上面提到，如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，MYDB 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是<strong>版本可见性</strong>的概念就诞生了。</p><p>版本的可见性与事务的隔离度是相关的。MYDB 支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。</p><p>MYDB 实现读提交，为每个版本维护了两个变量，就是上面提到的 <code>XMIN</code>和 <code>XMAX</code>：</p><ul><li><code>XMIN</code>：创建该版本的事务编号</li><li><code>XMAX</code>：删除该版本的事务编号</li></ul><p><strong><code>XMIN</code> 应当在版本创建时填写，而 <code>XMAX</code> 则在版本被删除，或者有新版本出现时填写。</strong></p><p><code>XMAX</code> 这个变量，也就解释了为什么 DM 层不提供删除操作，<strong>当想删除一个版本时，只需要设置其 <code>XMAX</code></strong>，这样，<strong>这个版本对每一个 <code>XMAX</code> 之后的事务都是不可见的</strong>，也就等价于删除了。</p><p>如此，在读提交下，版本对事务的可见性逻辑如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 对于当前事务Ti，当如下逻辑判断为true时，该版本对当前事务Ti可见</span><br><br>(XMIN == Ti <span class="hljs-keyword">and</span>                             <span class="hljs-comment">// 由Ti创建且</span><br>    XMAX == NULL                            <span class="hljs-comment">// 还未被删除</span><br>)<br><span class="hljs-symbol">or</span>                                          <span class="hljs-comment">// 或</span><br>(XMIN is commited <span class="hljs-keyword">and</span>                       <span class="hljs-comment">// 由一个已提交的事务创建且</span><br>    (XMAX == NULL or                        <span class="hljs-comment">// 尚未删除或</span><br>    (XMAX != Ti <span class="hljs-keyword">and</span> XMAX is not commited)   <span class="hljs-comment">// 由一个未提交的事务删除</span><br>    )<br>)<br></code></pre></td></tr></table></figure><p>若条件为 true，则版本对 Ti 可见。那么获取 Ti 适合的版本，只需要<strong>从最新版本开始，依次向前检查可见性</strong>，如果为 true，就可以直接返回。以下方法判断某个记录对事务 t 是否可见：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readCommitted</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>  <span class="hljs-comment">// 当前事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> t.xid;<br>  <span class="hljs-comment">// 该条记录的XMIN，即创建该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmin</span> <span class="hljs-operator">=</span> e.getXmin();<br>  <span class="hljs-comment">// 该条记录的XMAX，即删除该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  <br>  <span class="hljs-comment">// 该记录由当前事务创建，且还未被删除，则对当前事务可见</span><br>    <span class="hljs-keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 该记录由一条已提交事务创建</span><br>    <span class="hljs-keyword">if</span>(tm.isCommitted(xmin)) &#123;<br>      <span class="hljs-comment">// 该记录还未被删除，则对当前事务可见</span><br>        <span class="hljs-keyword">if</span>(xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 该记录已被删除，但不是当前事务删除的，且删除这条记录的事务还没提交，则对当前事务可见</span><br>        <span class="hljs-keyword">if</span>(xmax != xid) &#123;<br>            <span class="hljs-keyword">if</span>(!tm.isCommitted(xmax)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">// 对当前事务不可见</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可重复读（Repeatable-Read-RR）"><a href="#可重复读（Repeatable-Read-RR）" class="headerlink" title="可重复读（Repeatable Read, RR）"></a>可重复读（Repeatable Read, RR）</h3><p>读提交会导致的问题大家也都很清楚，八股也背了不少。那就是不可重复读和幻读。这里我们来解决<strong>不可重复读</strong>的问题。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">T1 begin<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1 读得 0</span><br>T2 begin<br><span class="hljs-function"><span class="hljs-title">U2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// 将 X 修改为 1</span><br>T2 commit<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1 读的 1</span><br></code></pre></td></tr></table></figure><p>T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定：</p><blockquote><p>事务只能读取<strong>它开始时, 就已经结束的那些事务产生的数据版本</strong></p></blockquote><p>这条规定，相当于，事务需要<strong>忽略</strong>：</p><ol><li>在<strong>本事务后开始的事务的数据</strong>;</li><li><strong>本事务开始时还是 active 状态的事务的数据</strong></li></ol><p>对于第一条，只需要<strong>比较事务 ID，即可确定，因为事务ID是自增的</strong>。而对于第二条，则需要在<strong>事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)</strong>，如果记录的某个版本，XMIN 在 SP(Ti) 中，说明<strong>创建这个版本记录的事务，在当前事务开始时处于active状态</strong>，也应当对 Ti 不可见。于是，可重复读的判断逻辑如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 对于当前事务Ti，当如下逻辑判断为true时，该版本对当前事务Ti可见</span><br><br>(XMIN == Ti <span class="hljs-keyword">and</span>                 <span class="hljs-comment">// 由Ti创建且</span><br> (XMAX == NULL)                 <span class="hljs-comment">// 尚未被删除</span><br>)<br><span class="hljs-symbol">or</span>                              <span class="hljs-comment">// 或</span><br>(XMIN is commited <span class="hljs-keyword">and</span>           <span class="hljs-comment">// 由一个已提交的事务创建且</span><br> XMIN &lt; XID <span class="hljs-keyword">and</span>                 <span class="hljs-comment">// 这个事务小于Ti且</span><br> XMIN is not in <span class="hljs-built_in">SP</span>(Ti) <span class="hljs-keyword">and</span>      <span class="hljs-comment">// 这个事务在Ti开始前提交且</span><br> (XMAX == NULL or               <span class="hljs-comment">// 尚未被删除或</span><br>  (XMAX != Ti <span class="hljs-keyword">and</span>               <span class="hljs-comment">// 由其他事务删除但是</span><br>   (XMAX is not commited or     <span class="hljs-comment">// 这个事务尚未提交或</span><br><span class="hljs-symbol">XMAX</span> &gt; Ti or                    <span class="hljs-comment">// 这个事务在Ti开始之后才开始或</span><br><span class="hljs-symbol">XMAX</span> is in <span class="hljs-built_in">SP</span>(Ti)               <span class="hljs-comment">// 这个事务在Ti开始前还未提交</span><br>))))<br></code></pre></td></tr></table></figure><p>于是，需要提供一个结构，来抽象一个事务，以保存<strong>快照数据</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> xid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> level;<br>  <span class="hljs-comment">// snapshot用来保存活跃事务id</span><br>    <span class="hljs-keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;<br>    <span class="hljs-keyword">public</span> Exception err;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> autoAborted;<br><br>  <span class="hljs-comment">// 构造方法，active保存着当前所有状态为active的事务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Transaction <span class="hljs-title function_">newTransaction</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;<br>        <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transaction</span>();<br>        t.xid = xid;<br>        t.level = level;<br>      <span class="hljs-comment">// 如果是可重复读隔离级别，会将当前处于active的事务id保存到snapshot中</span><br>        <span class="hljs-keyword">if</span>(level != <span class="hljs-number">0</span>) &#123;<br>            t.snapshot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(Long x : active.keySet()) &#123;<br>                t.snapshot.put(x, <span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInSnapshot</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>        <span class="hljs-keyword">if</span>(xid == TransactionManagerImpl.SUPER_XID) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> snapshot.containsKey(xid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是，可重复读的隔离级别下，一个版本是否对事务可见的判断如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatableRead</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>  <span class="hljs-comment">// 当前事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> t.xid;<br>  <span class="hljs-comment">// 创建该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmin</span> <span class="hljs-operator">=</span> e.getXmin();<br>  <span class="hljs-comment">// 删除该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  <span class="hljs-comment">// 当前事务创建了该记录 且 该记录还没被删除</span><br>    <span class="hljs-keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 创建该记录的事务已提交 且 创建该记录的事务比当前事务早 且 当前事务创建时，创建该记录的事务不处于active状态</span><br>    <span class="hljs-keyword">if</span>(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;<br>      <span class="hljs-comment">// 该记录还未被删除</span><br>        <span class="hljs-keyword">if</span>(xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 该记录被删除，但不是当前事务删除的</span><br>        <span class="hljs-keyword">if</span>(xmax != xid) &#123;<br>          <span class="hljs-comment">// 删除该记录的事务未提交 或 删除该记录的事务比当前事务晚 或 当前事务创建时，删除该记录的事务处于active状态</span><br>            <span class="hljs-keyword">if</span>(!tm.isCommitted(xmax) || xmax &gt; xid || t.isInSnapshot(xmax)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="版本跳跃问题"><a href="#版本跳跃问题" class="headerlink" title="版本跳跃问题"></a>版本跳跃问题</h2><p>版本跳跃问题，考虑如下的情况，假设 X 最初只有 x0 版本，T1 和 T2 都是可重复读的隔离级别：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">T1 begin<br>T2 begin<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1读取x0</span><br><span class="hljs-function"><span class="hljs-title">R2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T2读取x0</span><br><span class="hljs-function"><span class="hljs-title">U1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1将X更新到x1</span><br>T1 commit<br><span class="hljs-function"><span class="hljs-title">U2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T2将X更新到x2</span><br>T2 commit<br></code></pre></td></tr></table></figure><p>这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 <strong>T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本</strong>。</p><p>**读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。**解决版本跳跃的思路也很简单：<strong>如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚</strong>。</p><p>上一节中就总结了，<strong>Ti 不可见的 Tj</strong>，有两种情况：</p><ol><li>XID(Tj) &gt; XID(Ti)</li><li>Tj in SP(Ti)</li></ol><p>于是版本跳跃的检查也就很简单了，取出要修改的数据 X 的最新提交版本，并<strong>检查该最新版本的创建者对当前事务是否可见</strong>：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502221957403.jpg" alt="IMG_3883 2" style="zoom:10%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检查版本跳跃 -&gt; 检查当前事务要修改的数据最新版本的创建者是否对当前事务可见</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVersionSkip</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  <span class="hljs-comment">// level = 0是读提交，可以接受版本跳跃</span><br>    <span class="hljs-keyword">if</span>(t.level == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 创建该数据的最新版本的事务已提交 且 （这个事务比当前事务创建晚 或 这个事务在当前事务创建时处于active状态），而我们当前事务想要更改这个数据，就会发生版本跳跃</span><br>        <span class="hljs-keyword">return</span> tm.isCommitted(xmax) &amp;&amp; <br>          (xmax &gt; t.xid || t.isInSnapshot(xmax));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj –&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要<strong>查看这个图中是否有环即可</strong>。</p><p>MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="hljs-comment">// 某个XID已经获得的资源的UID列表</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="hljs-comment">// UID被某个XID持有</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="hljs-comment">// 正在等待UID的XID列表</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="hljs-comment">// 正在等待资源的XID的锁</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="hljs-comment">// XID正在等待的UID</span><br>    <span class="hljs-keyword">private</span> Lock lock;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在<strong>每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测</strong>。如果<strong>检测到死锁，就撤销这条边，不允许添加，并撤销该事务</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// xid事务想要获得uid资源</span><br><span class="hljs-comment">// 不需要等待则返回null，否则返回锁对象</span><br><span class="hljs-comment">// 会造成死锁则抛出异常</span><br><span class="hljs-keyword">public</span> Lock <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// xid事务已获得uid资源</span><br>        <span class="hljs-keyword">if</span>(isInList(x2u, xid, uid)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      <span class="hljs-comment">// 没有事务持有uid资源，则xid事务可以获取</span><br>        <span class="hljs-keyword">if</span>(!u2x.containsKey(uid)) &#123;<br>            u2x.put(uid, xid);<br>            putIntoList(x2u, xid, uid);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      <span class="hljs-comment">// xid事务正在等待uid资源</span><br>        waitU.put(xid, uid);<br>      <span class="hljs-comment">// 将xid事务加入到等待uid资源的事务列表里</span><br>        putIntoList(wait, xid, uid);<br>      <span class="hljs-comment">// 发生死锁，抛出异常</span><br>        <span class="hljs-keyword">if</span>(hasDeadLock()) &#123;<br>            waitU.remove(xid);<br>            removeFromList(wait, uid, xid);<br>            <span class="hljs-keyword">throw</span> Error.DeadlockException;<br>        &#125;<br>      <span class="hljs-comment">// 没发生死锁，则将一个上了锁的Lock对象加入到xid事务的锁map里，返回这个锁</span><br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        l.lock();<br>        waitLock.put(xid, l);<br>        <span class="hljs-keyword">return</span> l;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 add，如果<strong>需要等待的话，会返回一个上了锁的 Lock 对象</strong>。调用方在<strong>获取到该对象时，需要尝试获取该对象的锁，由此实现阻塞线程的目的</strong>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ⚠️</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> lt.add(xid, uid);<br><span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>    l.lock();   <span class="hljs-comment">// 阻塞在这一步？ l是一个可重入锁，同一个线程再执行加锁不会阻塞吧？</span><br>    l.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>查找<strong>图中是否有环</strong>的算法也非常简单，就是一个深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasDeadLock</span><span class="hljs-params">()</span> &#123;<br>    xidStamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    stamp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> xid : x2u.keySet()) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> xidStamp.get(xid);<br>        <span class="hljs-keyword">if</span>(s != <span class="hljs-literal">null</span> &amp;&amp; s &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        stamp ++;<br>        <span class="hljs-keyword">if</span>(dfs(xid)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">stp</span> <span class="hljs-operator">=</span> xidStamp.get(xid);<br>    <span class="hljs-keyword">if</span>(stp != <span class="hljs-literal">null</span> &amp;&amp; stp == stamp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(stp != <span class="hljs-literal">null</span> &amp;&amp; stp &lt; stamp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    xidStamp.put(xid, stamp);<br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> waitU.get(xid);<br>    <span class="hljs-keyword">if</span>(uid == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> u2x.get(uid);<br>    <span class="hljs-keyword">assert</span> x != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> dfs(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>在一个事务 commit 或者 abort 时，就可以释放<strong>所有</strong>它持有的锁，并将自身从等待图中删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        List&lt;Long&gt; l = x2u.get(xid);<br>        <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 把所有资源都释放</span><br>            <span class="hljs-keyword">while</span>(l.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> l.remove(<span class="hljs-number">0</span>);<br>              <span class="hljs-comment">// 被释放的资源，从它的等待队列中选一个xid事务来占用该uid资源</span><br>                selectNewXID(uid);<br>            &#125;<br>        &#125;<br>      <br>      <span class="hljs-comment">// abort时可能还在等别的资源，abort后就不用等了，故移除waitU中的东西</span><br>        waitU.remove(xid);<br>      <span class="hljs-comment">// xid事务已释放所有资源，将xid从获得资源map中移除</span><br>        x2u.remove(xid);<br>      <span class="hljs-comment">// 因为abort时可能还在等资源，故waitLock中还有东西，要移除</span><br>        waitLock.remove(xid);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从等待队列中选择一个xid来占用uid</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectNewXID</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> &#123;<br>  <span class="hljs-comment">// 当前uid已不被占有</span><br>    u2x.remove(uid);<br>  <span class="hljs-comment">// 去uid资源的等待列表中找一个xid事务来占用</span><br>    List&lt;Long&gt; l = wait.get(uid);<br>  <span class="hljs-comment">// 没有xid想要uid</span><br>    <span class="hljs-keyword">if</span>(l == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">assert</span> l.size() &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l.size() &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 选取等待列表中最前面的xid，并将其从wait中移除</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> l.remove(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">// 若xid没有等待资源锁，说明xid已获得过了资源，跳过这个xid</span><br>      <span class="hljs-comment">// 至于为什么获得过了还会在wait中，因为在remove那里xid释放所有资源时并没有将wait的(uid, xid)记录删除，故导致wait中xid还在等uid，但是实际上xid已经获取并释放过uid了；但是如下方所示，获取资源后会将xid从waitLock中删除，故用waitLock来判断这个xid是否还需要资源。</span><br>        <span class="hljs-keyword">if</span>(!waitLock.containsKey(xid)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// xid占有uid</span><br>            u2x.put(uid, xid);<br>          <span class="hljs-comment">// xid的资源列表要加上uid</span><br>          <span class="hljs-comment">// putIntoList(x2u, xid, uid);</span><br>          <br>          <span class="hljs-comment">// xid的等待资源锁要移除</span><br>            <span class="hljs-type">Lock</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> waitLock.remove(xid);<br>          <span class="hljs-comment">// 将(xid,uid)从waitU中移除</span><br>            waitU.remove(xid);<br>          <span class="hljs-comment">// xid的等待资源锁解锁，才能进行获得资源后的操作</span><br>            lo.unlock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">// uid资源分配出去后，发现没有事务在等它了，将它从wait中移除</span><br>    <span class="hljs-keyword">if</span>(l.size() == <span class="hljs-number">0</span>) wait.remove(uid);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="VM的实现"><a href="#VM的实现" class="headerlink" title="VM的实现"></a>VM的实现</h2><p>VM 层通过 <code>VersionManager</code> 接口，向上层提供功能，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VersionManager</span> &#123;<br>    <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，VM 的实现类还**被设计为 <code>Entry</code> 的缓存，需要继承 <code>AbstractCache&lt;Entry&gt;</code>。**需要实现的获取到缓存和从缓存释放的方法很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Entry <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> Entry.loadEntry(<span class="hljs-built_in">this</span>, uid);<br>    <span class="hljs-keyword">if</span>(entry == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> Error.NullEntryException;<br>    &#125;<br>    <span class="hljs-keyword">return</span> entry;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Entry entry)</span> &#123;<br>    entry.remove();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title function_">loadEntry</span><span class="hljs-params">(VersionManager vm, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DataItem</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);<br>    <span class="hljs-keyword">return</span> newEntry(vm, di, uid);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    dataItem.release();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>begin()</code> 开启一个事务，并<strong>初始化事务的结构</strong>，将其<strong>存放在 <code>activeTransaction</code> 中</strong>，用于检查和快照使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 创建一个新事务，事务id自增并返回</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> tm.begin();<br>      <span class="hljs-comment">// 创建事务时传入activeTransaction是为了创造快照</span><br>        <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Transaction.newTransaction(xid, level, activeTransaction);<br>      <span class="hljs-comment">// 创建完将这个事务也加入active事务组中</span><br>        activeTransaction.put(xid, t);<br>        <span class="hljs-keyword">return</span> xid;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>commit()</code> 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(NullPointerException n) &#123;<br>        System.out.println(xid);<br>        System.out.println(activeTransaction.keySet());<br>        Panic.panic(n);<br>    &#125;<br>    lock.lock();<br>  <span class="hljs-comment">// 将xid事务从active事务中中移除</span><br>    activeTransaction.remove(xid);<br>    lock.unlock();<br>  <span class="hljs-comment">// 释放xid事务所拥有的所有资源</span><br>    lt.remove(xid);<br>  <span class="hljs-comment">// 提交xid事务</span><br>    tm.commit(xid);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>abort</code> 事务的方法则有两种，<strong>手动和自动</strong>。手动指的是调用 <code>abort()</code> 方法；而<strong>自动</strong>，则是在事务被检测出出现<strong>死锁</strong>时，会自动撤销回滚事务；或者出现<strong>版本跳跃</strong>时，也会自动回滚：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internAbort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">boolean</span> autoAborted)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    <span class="hljs-keyword">if</span>(!autoAborted) &#123;<br>        activeTransaction.remove(xid);<br>    &#125;<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.autoAborted) <span class="hljs-keyword">return</span>;<br>    lt.remove(xid);<br>    tm.abort(xid);<br>&#125;<br><br><span class="hljs-comment">// 手动abort</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    internAbort(xid, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">// 自动abort，t.autoAborted默认值为false</span><br>internAbort(xid, <span class="hljs-literal">true</span>); 然后-&gt; t.autoAborted = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><code>read()</code> 方法读取一个 <code>entry</code>，注意判断下可见性即可：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502221935459.png" alt="image-20250222193536630" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid) <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 想要读取的资源是对于当前事务是可见的</span><br>        <span class="hljs-keyword">if</span>(Visibility.isVisible(tm, t, entry)) &#123;<br>            <span class="hljs-keyword">return</span> entry.data();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        entry.release();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVisible</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t.level == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 读提交隔离级别下查看是否可见</span><br>        <span class="hljs-keyword">return</span> readCommitted(tm, t, e);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 可重复读隔离级别下查看是否可见</span><br>        <span class="hljs-keyword">return</span> repeatableRead(tm, t, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>insert()</code> 则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>  <span class="hljs-comment">// 将数据包裹成Entry格式：[XMIN] [XMAX] [data]，然后交给DM层</span><br>    <span class="hljs-type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data);<br>  <span class="hljs-comment">// 插入时DM会再将entry包裹成DataItem格式：[ValidFlag] [DataSize] [Data]</span><br>  <span class="hljs-comment">// Entry就是这里的Data</span><br>    <span class="hljs-keyword">return</span> dm.insert(xid, raw);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>delete()</code> 方法看起来略为复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br><br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 要删除的资源对这个事务不可见，无法删除</span><br>        <span class="hljs-keyword">if</span>(!Visibility.isVisible(tm, t, entry)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 可见，就让xid去获取uid</span><br>            l = lt.add(xid, uid);<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            t.err = Error.ConcurrentUpdateException;<br>            internAbort(xid, <span class="hljs-literal">true</span>);<br>            t.autoAborted = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>      <span class="hljs-comment">// 获取非空，是一把锁</span><br>        <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// ⚠️由于l是一把可重入锁，当获取到一把已上锁的锁时，再在这里上锁也能上锁成功，不会发生阻塞。。。</span><br>          <span class="hljs-comment">// 而我们这段代码的思路就是要让程序阻塞在这里。。。</span><br>            l.lock();<br>            l.unlock();<br>        &#125;<br>      <span class="hljs-comment">// 本事务已经删除过了（同一个事务，前面删除过了，这次再删当然删不了）</span><br>        <span class="hljs-keyword">if</span>(entry.getXmax() == xid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      <span class="hljs-comment">// 发生版本跳跃，抛出异常</span><br>        <span class="hljs-keyword">if</span>(Visibility.isVersionSkip(tm, t, entry)) &#123;<br>            t.err = Error.ConcurrentUpdateException;<br>            internAbort(xid, <span class="hljs-literal">true</span>);<br>            t.autoAborted = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>      <span class="hljs-comment">// 设置XMAX为本事务的xid，表明事务xid已删除这条数据</span><br>        entry.setXmax(xid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        entry.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上主要是前置的三件事：<strong>一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置 <code>XMAX</code>。</strong></p><h1 id="5-Index-Manager"><a href="#5-Index-Manager" class="headerlink" title="5. Index Manager"></a>5. Index Manager</h1><blockquote><p>IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的聚簇索引。目前 <strong>MYDB 只支持基于索引查找数据</strong>，不支持全表扫描。</p></blockquote><h2 id="二叉树索引"><a href="#二叉树索引" class="headerlink" title="二叉树索引"></a>二叉树索引</h2><p>二叉树由一个个 <code>Node</code> 组成，每个 <code>Node</code> 都存储在一条 <code>DataItem</code> 中。结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[LeafFlag]</span><span class="hljs-selector-attr">[KeyNumber]</span><span class="hljs-selector-attr">[SiblingUid]</span><br><span class="hljs-selector-attr">[Son0]</span><span class="hljs-selector-attr">[Key0]</span><span class="hljs-selector-attr">[Son1]</span><span class="hljs-selector-attr">[Key1]</span>...<span class="hljs-selector-attr">[SonN]</span><span class="hljs-selector-attr">[KeyN]</span><br></code></pre></td></tr></table></figure><p>其中 <code>LeafFlag</code> 标记了该节点是否是个叶子节点；<code>KeyNumber</code> 为该节点中 key 的个数；<code>SiblingUid</code> 是其兄弟节点存储在 DM 中的 UID。后续是穿插的子节点（<code>SonN</code>）和 <code>KeyN</code>。最后的一个 <code>KeyN</code> 始终为 <code>MAX_VALUE</code>，以此方便查找。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502231400050.jpg" alt="IMG_3885"></p><p><code>Node</code> 类持有了其 B+ 树结构的引用，<code>DataItem</code> 的引用和 <code>SubArray</code> 的引用，用于方便快速修改数据和释放数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>  <br>  <span class="hljs-comment">// LeafFlag起始位置：0</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">IS_LEAF_OFFSET</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// KeyNumber起始位置：1</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NO_KEYS_OFFSET</span> <span class="hljs-operator">=</span> IS_LEAF_OFFSET+<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// SiblingUid起始位置：3</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIBLING_OFFSET</span> <span class="hljs-operator">=</span> NO_KEYS_OFFSET+<span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// Node头文件大小：[LeafFlag][KeyNumber][SiblingUid]</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NODE_HEADER_SIZE</span> <span class="hljs-operator">=</span> SIBLING_OFFSET+<span class="hljs-number">8</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BALANCE_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NODE_SIZE</span> <span class="hljs-operator">=</span> NODE_HEADER_SIZE + (<span class="hljs-number">2</span>*<span class="hljs-number">8</span>)*(BALANCE_NUMBER*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>);<br>  <br>    BPlusTree tree;<br>    DataItem dataItem;<br>    SubArray raw;<br>    <span class="hljs-type">long</span> uid;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>于是<strong>生成一个根节点</strong>的数据可以写成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该根节点的初始两个子节点为 left 和 right, 初始键值为 key。</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] newRootRaw(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right, <span class="hljs-type">long</span> key)  &#123;<br>    <span class="hljs-type">SubArray</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[NODE_SIZE], <span class="hljs-number">0</span>, NODE_SIZE);<br>  <span class="hljs-comment">// 根结点为非叶节点，LeafFlag = 0</span><br>    setRawIsLeaf(raw, <span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">// 有left、right两个子节点，KeyNumber = 2</span><br>    setRawNoKeys(raw, <span class="hljs-number">2</span>);<br>  <span class="hljs-comment">// 根结点没有兄弟节点，SiblingUid = 0</span><br>    setRawSibling(raw, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// left子节点为第一个子节点</span><br>    setRawKthSon(raw, left, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 给left子节点设置初始键值：key</span><br>    setRawKthKey(raw, key, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// right子节点为第二个子节点</span><br>    setRawKthSon(raw, right, <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 给right子节点设置键值MAX_VALUE</span><br>    setRawKthKey(raw, Long.MAX_VALUE, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> raw.raw;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的，生成一个<strong>空的根节点</strong>数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] newNilRootRaw()  &#123;<br>    <span class="hljs-type">SubArray</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[NODE_SIZE], <span class="hljs-number">0</span>, NODE_SIZE);<br>    setRawIsLeaf(raw, <span class="hljs-literal">true</span>);<br>    setRawNoKeys(raw, <span class="hljs-number">0</span>);<br>    setRawSibling(raw, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> raw.raw;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Node</code> 类有两个方法，用于辅助 B+ 树做插入和搜索操作，分别是 <code>searchNext</code> 方法和 <code>leafSearchRange</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SearchNextRes</span> &#123;<br>    <span class="hljs-type">long</span> uid;<br>    <span class="hljs-type">long</span> siblingUid;<br>&#125;<br><br><span class="hljs-comment">// searchNext 寻找对应 key 的 UID, 如果找不到, 则返回兄弟节点的 UID。</span><br><span class="hljs-keyword">public</span> SearchNextRes <span class="hljs-title function_">searchNext</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SearchNextRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchNextRes</span>();<br>      <span class="hljs-comment">// 根据raw数据，获取当前Node节点的key数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">noKeys</span> <span class="hljs-operator">=</span> getRawNoKeys(raw);<br>      <span class="hljs-comment">// 遍历所有key</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">kth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; kth &lt; noKeys; kth ++) &#123;<br>          <span class="hljs-comment">// 获取第kth个key</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>            <span class="hljs-keyword">if</span>(key &lt; ik) &#123;<br>                res.uid = getRawKthSon(raw, kth);<br>                res.siblingUid = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        res.uid = <span class="hljs-number">0</span>;<br>        res.siblingUid = getRawSibling(raw);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>leafSearchRange</code> 方法在<strong>当前节点进行范围查找</strong>，范围是 <code>[leftKey, rightKey]</code>，这里约定如果 <code>rightKey</code> 大于等于该节点的最大的 key, 则还<strong>同时返回兄弟节点的 UID</strong>，方便继续搜索下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> LeafSearchRangeRes <span class="hljs-title function_">leafSearchRange</span><span class="hljs-params">(<span class="hljs-type">long</span> leftKey, <span class="hljs-type">long</span> rightKey)</span> &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">noKeys</span> <span class="hljs-operator">=</span> getRawNoKeys(raw);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">kth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(kth &lt; noKeys) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>          <span class="hljs-comment">// 从leftKey开始找起</span><br>            <span class="hljs-keyword">if</span>(ik &gt;= leftKey) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            kth ++;<br>        &#125;<br>        List&lt;Long&gt; uids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-comment">// 在不超出key数量的前提下</span><br>        <span class="hljs-keyword">while</span>(kth &lt; noKeys) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>          <span class="hljs-comment">// 若key在[leftKey, rightKey]范围内</span><br>            <span class="hljs-keyword">if</span>(ik &lt;= rightKey) &#123;<br>              <span class="hljs-comment">// 将符合条件的节点的uid加入</span><br>                uids.add(getRawKthSon(raw, kth));<br>                kth ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 在key数量范围内找完了 [leftKey, rightKey]范围的节点</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">siblingUid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 发现rightKey大于等于该节点的最大的 key</span><br>        <span class="hljs-keyword">if</span>(kth == noKeys) &#123;<br>          <span class="hljs-comment">// 返回兄弟节点的uid</span><br>            siblingUid = getRawSibling(raw);<br>        &#125;<br>        <span class="hljs-type">LeafSearchRangeRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeafSearchRangeRes</span>();<br>        res.uids = uids;<br>        res.siblingUid = siblingUid;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 B+ 树在插入删除时，会动态调整，<strong>根节点不是固定节点</strong>，于是设置一个 <code>bootDataItem</code>，该 <code>DataItem</code> 中存储了根节点的 UID。可以注意到，IM 在操作 DM 时，使用的事务都是 <strong>SUPER_XID</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BPlusTree</span> &#123;<br>    DataItem bootDataItem;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">rootUid</span><span class="hljs-params">()</span> &#123;<br>        bootLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> bootDataItem.data();<br>            <span class="hljs-keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+<span class="hljs-number">8</span>));<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bootLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateRootUid</span><span class="hljs-params">(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right, <span class="hljs-type">long</span> rightKey)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        bootLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] rootRaw = Node.newRootRaw(left, right, rightKey);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">newRootUid</span> <span class="hljs-operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);<br>            bootDataItem.before();<br>            <span class="hljs-type">SubArray</span> <span class="hljs-variable">diRaw</span> <span class="hljs-operator">=</span> bootDataItem.data();<br>            System.arraycopy(Parser.long2Byte(newRootUid), <span class="hljs-number">0</span>, diRaw.raw, diRaw.start, <span class="hljs-number">8</span>);<br>            bootDataItem.after(TransactionManagerImpl.SUPER_XID);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bootLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可能会有疑问，IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 <code>Entry</code>，实际的操作是设置其 <code>XMAX</code>。如果不去删除对应索引的话，当后续再次尝试读取该 <code>Entry</code> 时，是可以通过索引寻找到的，但是由于设置了 <code>XMAX</code>，寻找不到合适的版本而返回一个找不到内容的错误。</p><h1 id="6-Table-Manager"><a href="#6-Table-Manager" class="headerlink" title="6. Table Manager"></a>6. Table Manager</h1><blockquote><p>本章概述 TBM，即表管理器的实现。TBM 实现了对字段结构和表结构的管理。同时简要介绍 MYDB 使用的类 SQL 语句的解析。</p></blockquote><h2 id="SQL解析器"><a href="#SQL解析器" class="headerlink" title="SQL解析器"></a>SQL解析器</h2><p>Parser 实现了对类 SQL 语句的结构化解析，将<strong>语句中包含的信息封装为对应语句的类</strong>，这些类可见 top.guoziyang.mydb.backend.parser.statement 包。</p><p>MYDB 实现的 SQL 语句语法如下：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 开启事务，isolation level设置事务隔离级别，默认为RC<br><span class="hljs-variable">&lt;begin statement&gt;</span><br>    begin [isolation level (read committedrepeatable read)]<br>        begin isolation level read committed<br><br>// 提交事务<br><span class="hljs-variable">&lt;commit statement&gt;</span><br>    commit<br><br>// 撤销事务<br><span class="hljs-variable">&lt;abort statement&gt;</span><br>    abort<br><br>// 建表语句<br><span class="hljs-variable">&lt;create statement&gt;</span><br>    create <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;table name&gt;</span><br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    ...<br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    [(index <span class="hljs-variable">&lt;field name list&gt;</span>)]<br>        create <span class="hljs-built_in">table</span> students<br>        id int32,<br>        name string,<br>        age int32,<br>        (index id name)<br><br>// 删表语句<br><span class="hljs-variable">&lt;drop statement&gt;</span><br>    <span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;table name&gt;</span><br>        <span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> students<br><br>// 查询语句<br><span class="hljs-variable">&lt;select statement&gt;</span><br>    select (*<span class="hljs-variable">&lt;field name list&gt;</span>) <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;table name&gt;</span> [<span class="hljs-variable">&lt;where statement&gt;</span>]<br>        select * <span class="hljs-keyword">from</span> student where id = <span class="hljs-number">1</span><br>        select name <span class="hljs-keyword">from</span> student where id &gt; <span class="hljs-number">1</span> and id <span class="hljs-variable">&lt; 4</span><br><span class="hljs-variable">        select name, age, id from student where id = 12</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">// 插入语句</span><br><span class="hljs-variable">&lt;insert statement&gt;</span><br>    insert into <span class="hljs-variable">&lt;table name&gt;</span> values <span class="hljs-variable">&lt;value list&gt;</span><br>        insert into student values <span class="hljs-number">5</span> <span class="hljs-string">&quot;Zhang Yuanjia&quot;</span> <span class="hljs-number">22</span><br><br>// 删除语句<br><span class="hljs-variable">&lt;delete statement&gt;</span><br>    delete <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;table name&gt;</span> <span class="hljs-variable">&lt;where statement&gt;</span><br>        delete <span class="hljs-keyword">from</span> student where name = <span class="hljs-string">&quot;Zhang Yuanjia&quot;</span><br><br>// 更新语句<br><span class="hljs-variable">&lt;update statement&gt;</span><br>    update <span class="hljs-variable">&lt;table name&gt;</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">&lt;field name&gt;</span>=<span class="hljs-variable">&lt;value&gt;</span> [<span class="hljs-variable">&lt;where statement&gt;</span>]<br>        update student <span class="hljs-built_in">set</span> name = <span class="hljs-string">&quot;ZYJ&quot;</span> where id = <span class="hljs-number">5</span><br><br>// where查询<br><span class="hljs-variable">&lt;where statement&gt;</span><br>    where <span class="hljs-variable">&lt;field name&gt;</span> (&gt;<span class="hljs-variable">&lt;=) &lt;value&gt;</span> [(andor) <span class="hljs-variable">&lt;field name&gt;</span> (&gt;<span class="hljs-variable">&lt;=) &lt;value&gt;</span>]<br>        where age &gt; <span class="hljs-number">10</span> or age <span class="hljs-variable">&lt; 3</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">// 字段名命名规则</span><br><span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;table name&gt;</span><br>    [a-zA-Z][a-zA-Z0-<span class="hljs-number">9</span>_]*<br><br>// 字段类型只有下面三种<br><span class="hljs-variable">&lt;field type&gt;</span><br>    int32 int64 string<br><br><span class="hljs-variable">&lt;value&gt;</span><br>    .*<br></code></pre></td></tr></table></figure><p>parser 包的 <code>Tokenizer</code> 类，对语句进行逐字节解析，根据空白符或者上述词法规则，<strong>将语句切割成多个 token</strong>。对外提供了 <code>peek()</code>、<code>pop()</code> 方法方便取出 <code>Token</code> 进行解析。</p><p><code>Parser</code> 类则直接对外提供了 <code>Parse(byte[] statement)</code> 方法，核心就是一个调用 <code>Tokenizer</code> 类分割 <code>Token</code>，并根据词法规则包装成具体的 <code>Statement</code> 类并返回。解析过程很简单，仅仅是<strong>根据第一个 <code>Token</code> 来区分语句类型</strong>，并分别处理，不再赘述。</p><h2 id="字段和表管理"><a href="#字段和表管理" class="headerlink" title="字段和表管理"></a>字段和表管理</h2><p>由于 TBM 基于 VM，单个字段信息和表信息都是直接保存在 Entry 中。字段的二进制表示如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[FieldName]</span><span class="hljs-selector-attr">[TypeName]</span><span class="hljs-selector-attr">[IndexUid]</span><br></code></pre></td></tr></table></figure><p>这里 <code>FieldName</code> 和 <code>TypeName</code>，以及后面的表名，存储的都是字节形式的字符串。这里规定一个字符串的存储方式，以明确其存储边界。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[StringLength]</span><span class="hljs-selector-attr">[StringData]</span><br></code></pre></td></tr></table></figure><p>TypeName 为字段的类型，<strong>限定为 int32、int64 和 string 类型</strong>。<strong>如果这个字段有索引，那个 IndexUID 指向了索引二叉树的根</strong>，否则该字段为 0。</p><p>根据这个结构，通过一个 UID 从 VM 中读取并解析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取字段信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Field <span class="hljs-title function_">loadField</span><span class="hljs-params">(Table tb, <span class="hljs-type">long</span> uid)</span> &#123;<br>    <span class="hljs-type">byte</span>[] raw = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        raw = ((TableManagerImpl)tb.tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">assert</span> raw != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Field</span>(uid, tb).parseSelf(raw);<br>&#125;<br><br><span class="hljs-comment">// 解析字段信息</span><br><span class="hljs-keyword">private</span> Field <span class="hljs-title function_">parseSelf</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 第一个res，包含FieldName的[StringLength][StringData]</span><br>  <span class="hljs-comment">// 返回的res.str 是 FieldName，res.next 是 [StringLength][StringData]的长度</span><br>    <span class="hljs-type">ParseStringRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Parser.parseString(raw);<br>    fieldName = res.str;<br>    position += res.next;<br>  <br>  <span class="hljs-comment">// 第二个res，包含TypeName的[StringLength][StringData]</span><br>  <span class="hljs-comment">// 返回的res.str 是 TypeName，res.next 是 [StringLength][StringData]的长度</span><br>    res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));<br>    fieldType = res.str;<br>    position += res.next;<br>  <br>  <span class="hljs-comment">// 若有index，则继续解析index</span><br>    <span class="hljs-built_in">this</span>.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position+<span class="hljs-number">8</span>));<br>    <span class="hljs-keyword">if</span>(index != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm);<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个字段的方法类似，将相关的信息通过 VM 持久化即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">persistSelf</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">byte</span>[] nameRaw = Parser.string2Byte(fieldName);<br>    <span class="hljs-type">byte</span>[] typeRaw = Parser.string2Byte(fieldType);<br>    <span class="hljs-type">byte</span>[] indexRaw = Parser.long2Byte(index);<br>    <span class="hljs-built_in">this</span>.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));<br>&#125;<br><br><span class="hljs-comment">// [StringLength] + [StringData]</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] string2Byte(String str) &#123;<br>    <span class="hljs-type">byte</span>[] l = int2Byte(str.length());<br>    <span class="hljs-keyword">return</span> Bytes.concat(l, str.getBytes());<br>&#125;<br></code></pre></td></tr></table></figure><p>一个数据库中存在多张表，TBM 使用链表的形式将其组织起来，每一张表都保存一个指向下一张表的 UID。表的二进制结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[TableName]</span><span class="hljs-selector-attr">[NextTable]</span><br><span class="hljs-selector-attr">[Field1Uid]</span><span class="hljs-selector-attr">[Field2Uid]</span>...<span class="hljs-selector-attr">[FieldNUid]</span><br></code></pre></td></tr></table></figure><p>这里由于每个 Entry 中的数据，字节数是确定的，于是<strong>无需保存字段的个数</strong>。根据 UID 从 Entry 中读取表数据的过程和读取字段的过程类似。</p><p>对表和字段的操作，有一个很重要的步骤，就是计算 Where 条件的范围，目前 MYDB 的 Where <strong>只支持两个条件的与和或</strong>。MYDB 只支持<strong>已索引字段</strong>作为 Where 的条件。。计算 Where 的范围，具体可以查看 <code>Table</code> 的 <code>parseWhere()</code> 和 <code>calWhere()</code> 方法，以及 Field 类的 <code>calExp()</code> 方法。</p><ul><li><code>parseWhere()</code>：解析Where语句，返回一个<code>Where</code>，<code>Where.singleExp1</code>表示第一个条件，<code>Where.logicOp</code>表示两个条件之间是and还是or，<code>Where.singleExp2</code>表示第二个条件<ul><li>其中条件<code>singleExp</code>所属类<code>SingleExpression</code>包含属性：字段<code>field</code>、条件比较符号<code>compareOp</code>、和字段比较的数值<code>value</code></li></ul></li><li><code>calWhere()</code>：处理逻辑连接词and和or</li><li><code>calExp()</code>：根据Where的条件，返回一个区间：<ul><li>如果<code>compareOp</code>是<code>&lt;</code>，表示字段<code> &lt; value</code>的一个区间。区间left &#x3D; 0，区间right &#x3D; 条件的<code>value</code> - 1；</li><li>如果<code>compareOp</code>是<code>&gt;</code>，表示字段<code>&gt; value</code>的一个区间。区间left &#x3D; <code>value</code>，区间right &#x3D; <code>Long.MAX_VALUE</code>；</li><li>如果如果<code>compareOp</code>是<code>=</code>，表示字段<code>= value</code>的一个区间。区间left &#x3D; right &#x3D; <code>value</code></li></ul></li></ul><p>由于 TBM 的表管理，使用的是链表串起的 Table 结构，所以就必须<strong>保存一个链表的头节点</strong>，即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。</p><p>MYDB 使用 Booter 类和 bt 文件，来管理 MYDB 的启动信息，虽然现在所需的启动信息，只有一个：头表的 UID。<strong>Booter 类对外提供了两个方法：load 和 update，并保证了其原子性。<strong>update 在修改 bt 文件内容时，没有直接对 bt 文件进行修改，而是首先将内容写入一个 bt_tmp 文件中，随后将这个文件重命名为 bt 文件。以期</strong>通过操作系统重命名文件的原子性，来保证操作的原子性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path + BOOTER_TMP_SUFFIX);<br>    <span class="hljs-keyword">try</span> &#123;<br>        tmp.createNewFile();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!tmp.canRead() || !tmp.canWrite()) &#123;<br>        Panic.panic(Error.FileCannotRWException);<br>    &#125;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(tmp)) &#123;<br>        out.write(data);<br>        out.flush();<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Files.move(tmp.toPath(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+BOOTER_SUFFIX);<br>    <span class="hljs-keyword">if</span>(!file.canRead() || !file.canWrite()) &#123;<br>        Panic.panic(Error.FileCannotRWException);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TableManager"><a href="#TableManager" class="headerlink" title="TableManager"></a>TableManager</h2><p>TBM 层对外提供服务的是 TableManager 接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableManager</span> &#123;<br>    BeginRes <span class="hljs-title function_">begin</span><span class="hljs-params">(Begin begin)</span>;<br>    <span class="hljs-type">byte</span>[] commit(<span class="hljs-type">long</span> xid) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] abort(<span class="hljs-type">long</span> xid);<br><br>    <span class="hljs-type">byte</span>[] show(<span class="hljs-type">long</span> xid);<br>    <span class="hljs-type">byte</span>[] create(<span class="hljs-type">long</span> xid, Create create) <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-type">byte</span>[] insert(<span class="hljs-type">long</span> xid, Insert insert) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, Select select) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] update(<span class="hljs-type">long</span> xid, Update update) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] delete(<span class="hljs-type">long</span> xid, Delete delete) <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 TableManager 已经是直接被最外层 Server 调用（MYDB 是 <strong>C&#x2F;S</strong> 结构），这些方<strong>法直接返回执行的结果</strong>，例如<strong>错误信息</strong>或者<strong>结果信息的字节数组</strong>（可读）。</p><h1 id="7-服务端客户端的实现及其通信规则"><a href="#7-服务端客户端的实现及其通信规则" class="headerlink" title="7. 服务端客户端的实现及其通信规则"></a>7. 服务端客户端的实现及其通信规则</h1><blockquote><p>MYDB 被设计为 C&#x2F;S 结构，类似于 MySQL。支持启动一个服务器，并有多个客户端去连接，通过 socket 通信，执行 SQL 返回结果。</p></blockquote><h2 id="C-S通信"><a href="#C-S通信" class="headerlink" title="C&#x2F;S通信"></a>C&#x2F;S通信</h2><p>MYDB 使用了一种特殊的二进制格式，用于客户端和服务端通信。传输的最基本结构，是 <code>Package</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Package</span> &#123;<br>    <span class="hljs-type">byte</span>[] data;<br>    Exception err;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 <code>Package</code> 在发送前，由 <code>Encoder</code> <strong>编码</strong>为字节数组，在对方收到后同样会由 <code>Encoder</code> 解<strong>码</strong>成 <code>Package</code> 对象。编码和解码的规则如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Flag]</span><span class="hljs-selector-attr">[data]</span><br></code></pre></td></tr></table></figure><p><strong>若 flag 为 0，表示发送的是数据</strong>，那么 data 即为这份数据本身；<strong>如果 flag 为 1，表示发送的是错误</strong>，data 是 Exception.getMessage() 的错误提示信息。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Encoder</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] encode(Package pkg) &#123;<br>        <span class="hljs-keyword">if</span>(pkg.getErr() != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 发送错误信息</span><br>            <span class="hljs-type">Exception</span> <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> pkg.getErr();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Intern server error!&quot;</span>;<br>            <span class="hljs-keyword">if</span>(err.getMessage() != <span class="hljs-literal">null</span>) &#123;<br>                msg = err.getMessage();<br>            &#125;<br>            <span class="hljs-keyword">return</span> Bytes.concat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>&#125;, msg.getBytes());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 发送数据信息</span><br>            <span class="hljs-keyword">return</span> Bytes.concat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0</span>&#125;, pkg.getData());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Package <span class="hljs-title function_">decode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span>(data.length &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> Error.InvalidPkgDataException;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(data[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// 接受数据</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(Arrays.copyOfRange(data, <span class="hljs-number">1</span>, data.length), <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-comment">// 接受错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Arrays.copyOfRange(data, <span class="hljs-number">1</span>, data.length))));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> Error.InvalidPkgDataException;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码之后的信息会通过 <code>Transporter</code> 类，写入输出流发送出去。为了避免特殊字符造成问题，这里会<strong>将数据转成十六进制字符串</strong>（Hex String），并为<strong>信息末尾加上换行符</strong>。这样在发送和接收数据时，就可以很简单地使用 <code>BufferedReader</code> 和 <code>Writer</code> 来直接按行读写了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transporter</span> &#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> BufferedReader reader;<br>    <span class="hljs-keyword">private</span> BufferedWriter writer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Transporter</span><span class="hljs-params">(Socket socket)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>        <span class="hljs-built_in">this</span>.reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>        <span class="hljs-built_in">this</span>.writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> hexEncode(data);<br>        writer.write(raw);<br>        writer.flush();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] receive() <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-comment">// 按行读取</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> reader.readLine();<br>        <span class="hljs-keyword">if</span>(line == <span class="hljs-literal">null</span>) &#123;<br>            close();<br>        &#125;<br>        <span class="hljs-keyword">return</span> hexDecode(line);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        writer.close();<br>        reader.close();<br>        socket.close();<br>    &#125;<br><br>  <span class="hljs-comment">// 编码后的数据转成：16进制字符串+换行符</span><br>  <span class="hljs-comment">// 换行符方便接收方收到数据后直接按行读取，一行就是一条数据</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">hexEncode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buf)</span> &#123;<br>        <span class="hljs-keyword">return</span> Hex.encodeHexString(buf, <span class="hljs-literal">true</span>)+<span class="hljs-string">&quot;n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] hexDecode(String buf) <span class="hljs-keyword">throws</span> DecoderException &#123;<br>        <span class="hljs-keyword">return</span> Hex.decodeHex(buf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Packager</code> 则是 <code>Encoder</code> 和 <code>Transporter</code> 的结合体，直接对外提供 <code>send</code> 和 <code>receive</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Packager</span> &#123;<br>    <span class="hljs-keyword">private</span> Transporter transpoter;<br>    <span class="hljs-keyword">private</span> Encoder encoder;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Packager</span><span class="hljs-params">(Transporter transpoter, Encoder encoder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.transpoter = transpoter;<br>        <span class="hljs-built_in">this</span>.encoder = encoder;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(Package pkg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] data = encoder.encode(pkg);<br>        transpoter.send(data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Package <span class="hljs-title function_">receive</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] data = transpoter.receive();<br>        <span class="hljs-keyword">return</span> encoder.decode(data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        transpoter.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Server和Client的实现"><a href="#Server和Client的实现" class="headerlink" title="Server和Client的实现"></a>Server和Client的实现</h2><p><code>Server</code> 和 <code>Client</code>，偷懒直接使用了 Java 的 socket。</p><p><code>Server</code> 启动一个 <code>ServerSocket</code> 监听端口，当有请求到来时直接<strong>把请求丢给一个新线程处理</strong>。</p><p><code>HandleSocket</code> 类实现了 <code>Runnable</code> 接口，在建立连接后初始化 <code>Packager</code>，随后就循环接收来自客户端的数据并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleSocket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> TableManager tbm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HandleSocket</span><span class="hljs-params">(Socket socket, TableManager tbm)</span> &#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>        <span class="hljs-built_in">this</span>.tbm = tbm;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> (InetSocketAddress)socket.getRemoteSocketAddress();<br>        System.out.println(<span class="hljs-string">&quot;Establish connection: &quot;</span> + address.getAddress().getHostAddress()+<span class="hljs-string">&quot;:&quot;</span>+address.getPort());<br>        <span class="hljs-type">Packager</span> <span class="hljs-variable">packager</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Transporter</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transporter</span>(socket);<br>            <span class="hljs-type">Encoder</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Encoder</span>();<br>            packager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Packager</span>(t, e);<br>        &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>                e1.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">exe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Executor</span>(tbm);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Package</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 收数据</span><br>                pkg = packager.receive();<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-type">byte</span>[] sql = pkg.getData();<br>            <span class="hljs-type">byte</span>[] result = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Exception</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                result = exe.execute(sql);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>                e = e1;<br>                e.printStackTrace();<br>            &#125;<br>            pkg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(result, e);<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 发回去</span><br>                packager.send(pkg);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>                e1.printStackTrace();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        exe.close();<br>        <span class="hljs-keyword">try</span> &#123;<br>            packager.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;    <br></code></pre></td></tr></table></figure><p>处理的核心是 <code>Executor</code> 类，<code>Executor</code> 调用 <code>Parser</code> <strong>获取到对应语句的结构化信息对象</strong>，并<strong>根据对象的类型，调用 TBM 的不同方法进行处理</strong>。</p><p>top.guoziyang.mydb.backend.Launcher 类，则是<strong>服务器的启动入口</strong>。这个类<strong>解析了命令行参数</strong>。很重要的参数就是 -open 或者 -create。<code>Launcher</code> 根据两个参数，来决定是<strong>创建数据库</strong>文件，还是<strong>启动一个已有的数据库</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createDB</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-type">TransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> TransactionManager.create(path);<br>    <span class="hljs-type">DataManager</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> DataManager.create(path, DEFALUT_MEM, tm);<br>    <span class="hljs-type">VersionManager</span> <span class="hljs-variable">vm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VersionManagerImpl</span>(tm, dm);<br>    TableManager.create(path, vm, dm);<br>    tm.close();<br>    dm.close();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openDB</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem)</span> &#123;<br>    <span class="hljs-type">TransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> TransactionManager.open(path);<br>    <span class="hljs-type">DataManager</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> DataManager.open(path, mem, tm);<br>    <span class="hljs-type">VersionManager</span> <span class="hljs-variable">vm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VersionManagerImpl</span>(tm, dm);<br>    <span class="hljs-type">TableManager</span> <span class="hljs-variable">tbm</span> <span class="hljs-operator">=</span> TableManager.open(path, vm, dm);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(port, tbm).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端有一个简单的 Shell，实际上只是<strong>读入用户的输入</strong>，并调用 Client.execute()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] execute(<span class="hljs-type">byte</span>[] stat) <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Package</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(stat, <span class="hljs-literal">null</span>);<br>    <span class="hljs-type">Package</span> <span class="hljs-variable">resPkg</span> <span class="hljs-operator">=</span> rt.roundTrip(pkg);<br>    <span class="hljs-keyword">if</span>(resPkg.getErr() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> resPkg.getErr();<br>    &#125;<br>    <span class="hljs-keyword">return</span> resPkg.getData();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RoundTripper</code> 类实际上实现了<strong>单次收发</strong>动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Package <span class="hljs-title function_">roundTrip</span><span class="hljs-params">(Package pkg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    packager.send(pkg);<br>    <span class="hljs-keyword">return</span> packager.receive();<br>&#125;<br></code></pre></td></tr></table></figure><p>最后附上<strong>客户端的启动入口</strong>，很简单，把 Shell run 起来即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Launcher</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnknownHostException, IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>        <span class="hljs-type">Encoder</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Encoder</span>();<br>        <span class="hljs-type">Transporter</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transporter</span>(socket);<br>        <span class="hljs-type">Packager</span> <span class="hljs-variable">packager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Packager</span>(t, e);<br><br>        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>(packager);<br>        <span class="hljs-type">Shell</span> <span class="hljs-variable">shell</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shell</span>(client);<br>        shell.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-项目总结"><a href="#8-项目总结" class="headerlink" title="8. 项目总结"></a>8. 项目总结</h1><p>为充分理解数据库知识，本项目参考MySQL数据库的设计原理，基于Java实现了简易的数据库MYDB，实现的功能如下：</p><ul><li>事务状态：active、committed、aborted</li><li>数据库日志管理，保证数据的可靠性和数据恢复</li><li>基本的缓存框架，用于缓存数据、日志等信息</li><li>2PL和MVCC</li><li>两种事务隔离级别（读提交和可重复读）和死锁处理</li><li>基于B+树的聚簇索引，支持基于索引查找数据</li><li>简单的表管理器和SQL解析器，支持SQL语句操作表</li><li>基于socket的Server和Client</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC</title>
    <link href="/2025/02/17/RPC/"/>
    <url>/2025/02/17/RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC（Remote-Procedure-Call）"><a href="#RPC（Remote-Procedure-Call）" class="headerlink" title="RPC（Remote Procedure Call）"></a><strong>RPC（Remote Procedure Call）</strong></h1><blockquote><p>本文参考：</p><p>​JavaGuide星球RPC文档</p><p>​<a href="https://javaguide.cn/distributed-system/rpc/http_rpc.html#http-%E5%92%8C-rpc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">https://javaguide.cn/distributed-system/rpc/http_rpc.html#http-%E5%92%8C-rpc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB</a></p></blockquote><h1 id="1-什么是RPC？RPC原理是什么？"><a href="#1-什么是RPC？RPC原理是什么？" class="headerlink" title="1. 什么是RPC？RPC原理是什么？"></a><strong>1. 什么是RPC？RPC原理是什么？</strong></h1><h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h2><p><strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p><p><strong>为什么要 RPC ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。</p><p><strong>RPC 能帮助我们做什么呢？</strong>  简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p><p>一言蔽之：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p><h2 id="RPC原理是什么？"><a href="#RPC原理是什么？" class="headerlink" title="RPC原理是什么？"></a>RPC原理是什么？</h2><p>可以将整个 RPC 的 核心功能看作是下面 5 个部分实现的：</p><ol><li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li><li><strong>客户端 Stub（桩）</strong> ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li><li><strong>网络传输</strong> ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。</li><li><strong>服务端 Stub（桩）</strong> ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li><li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li></ol><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154285.jpg" alt="1594701419183-13976b20-36c8-44fa-a797-5f16ce27c495"></p><ol><li>服务消费端（client）以本地调用的方式调用远程服务；</li><li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li><li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: <code>RpcRequest</code>；</li><li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li><li>客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:<code>RpcResponse</code> ，这样也就得到了最终结果。over!</li></ol><h1 id="2-有了HTTP协议，为什么还要有RPC？"><a href="#2-有了HTTP协议，为什么还要有RPC？" class="headerlink" title="2. 有了HTTP协议，为什么还要有RPC？"></a><strong>2. 有了HTTP协议，为什么还要有RPC？</strong></h1><h2 id="从TCP聊起"><a href="#从TCP聊起" class="headerlink" title="从TCP聊起"></a><strong>从TCP聊起</strong></h2><p>假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。这时候，我们可选项一般也就<strong>TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。</strong></p><p>类似下面这样。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">fd</span> = socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>其中<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP 协议</strong>。</p><p>在定义了 socket 之后，我们就可以愉快的对这个 socket 进行操作，比如用<code>bind()</code>绑定 IP 端口，用<code>connect()</code>发起建连。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154286.png" alt="f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>在连接建立之后，我们就可以使用<code>send()</code>发送数据，<code>recv()</code>接收数据。光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？不行，这么用会有问题。</p><h2 id="使用纯裸TCP会有什么问题"><a href="#使用纯裸TCP会有什么问题" class="headerlink" title="使用纯裸TCP会有什么问题"></a><strong>使用纯裸TCP会有什么问题</strong></h2><p>TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 <strong>01 串</strong> 。纯裸 TCP 收发的这些 01 串之间是 <strong>没有任何边界</strong> 的，你根本不知道到哪个地方才算一条完整消息。正因为这个没有任何边界的特点，所以当我们选择使用 TCP 发送 <strong>“夏洛”和”特烦恼”</strong> 的时候，接收端收到的就是 <strong>“夏洛特烦恼”</strong> ，这时候接收端没发区分你是想要表达 <strong>“夏洛”+”特烦恼”</strong> 还是 <strong>“夏洛特”+”烦恼”</strong> ，这就是所谓的<strong>粘包问题</strong>。</p><p>因此，纯裸TCP是不能直接拿来用的，你需要在这个基础上加入一些 <strong>自定义的规则</strong> ，用于区分 <strong>消息边界</strong> 。于是我们会把每条要发送的数据都包装一下，比如加入 <strong>消息头</strong> ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的 <strong>消息体</strong> 。</p><p>而这里头提到的 <strong>消息头</strong> ，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的 **协议。**每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能 <strong>有区别，但原理都类似</strong>。</p><p><strong>于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p><h2 id="HTTP和RPC"><a href="#HTTP和RPC" class="headerlink" title="HTTP和RPC"></a><strong>HTTP和RPC</strong></h2><h3 id="RPC其实是一直调用方式"><a href="#RPC其实是一直调用方式" class="headerlink" title="RPC其实是一直调用方式"></a><strong>RPC其实是一直调用方式</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154287.png" alt="04b603b5bd2443209233deea87816161~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p><strong>TCP 是传输层的协议</strong> ，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的 <strong>应用层协议</strong> 而已。</p><p><strong>HTTP</strong>（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol）协议又叫做 <strong>超文本传输协议</strong> 。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154288.png" alt="8f07a5d1c72a4c4fa811c6c3b5aadd3d~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>而 <strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all）又叫做 <strong>远程过程调用</strong>，它本身并不是一个具体的协议，而是一种 <strong>调用方式</strong> 。举个例子，我们平时调用一个 <strong>本地方法</strong> 就像下面这样。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">res</span> <span class="hljs-operator">=</span> localFunc(req)<br></code></pre></td></tr></table></figure><p>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法<code>remoteFunc</code>，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">res</span> <span class="hljs-operator">=</span> remoteFunc(req)<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154289.png" alt="761da6c30af244e19b1c44075d8b4254~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>基于这个思路，大佬们造出了非常多款式的 RPC 协议，比如比较有名的<code>gRPC</code>，<code>thrift</code>。</p><p>值得注意的是，虽然大部分 RPC 协议底层使用 TCP，但实际上 <strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p><h3 id="那既然有-RPC-了，为什么还要有-HTTP-呢？"><a href="#那既然有-RPC-了，为什么还要有-HTTP-呢？" class="headerlink" title="那既然有 RPC 了，为什么还要有 HTTP 呢？"></a><strong>那既然有 RPC 了，为什么还要有 HTTP 呢？</strong></h3><p>其实，TCP 是 <strong>70 年</strong> 代出来的协议，而 HTTP 是 <strong>90 年代</strong> 才开始流行的。而直接使用裸 TCP 会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有 <strong>80 年代</strong> 出来的<code>RPC</code>。</p><p>所以我们该问的不是 <strong>既然有 HTTP 协议为什么要有 RPC</strong> ，而是 <strong>为什么有 RPC 还要有 HTTP 协议?</strong></p><p>现在电脑上装的各种联网软件，比如 xx 管家，xx 卫士，它们都作为客户端（Client） 需要跟服务端（Server） 建立连接收发消息，此时都会用到应用层协议，在这种 Client&#x2F;Server (C&#x2F;S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。</p><p>但有个软件不同，浏览器（Browser） ，不管是 Chrome 还是 IE，它们不仅要能访问自家公司的<strong>服务器（Server）</strong> ，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 <strong>Browser&#x2F;Server (B&#x2F;S)</strong> 的协议。</p><p>也就是说在多年以前，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。</strong> 很多软件同时支持多端，比如某度云盘，既要支持<strong>网页版</strong>，还要支持<strong>手机端和 PC 端</strong>，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p><p>那这么说的话，<strong>都用 HTTP 得了，还用什么 RPC？</strong></p><h3 id="HTTP和RPC有什么区别"><a href="#HTTP和RPC有什么区别" class="headerlink" title="HTTP和RPC有什么区别"></a><strong>HTTP和RPC有什么区别</strong></h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a><strong>服务发现</strong></h4><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 <strong>IP 地址和端口</strong> 。这个找到服务对应的 IP 端口的过程，其实就是 <strong>服务发现</strong>。</p><p>在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong> 去解析得到它背后的 IP 地址，默认 <strong>80 端口</strong>。</p><p>而 <strong>RPC</strong> 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 <strong>Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 <strong>CoreDNS</strong>。</p><p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p><h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a><strong>底层连接形式</strong></h4><p>以主流的 <strong>HTTP1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p><p>而 <strong>RPC</strong> 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 <strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154290.png" alt="72fcad064c9e4103a11f1a2d579f79b2~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。</p><h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a><strong>传输的内容</strong></h4><p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p><p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p><p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p><p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154291.png" alt="d501dfc6f764430188ce61fda0f3e5d9~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154292.png" alt="HTTP报文"></p><p>可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 <code>Content-Type</code>，就不需要每次都真的把 <code>Content-Type</code> 这个字段都传过来，类似的情况其实在 Body 的 JSON 结构里也特别明显。</p><p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154293.png" alt="HTTP原理"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154294.png" alt="RPC原理"></p><p>当然上面说的 HTTP，其实 <strong>特指的是现在主流使用的 HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以 <strong>性能可能比很多 RPC 协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p><h3 id="为什么既然有了HTTP2，还要有RPC"><a href="#为什么既然有了HTTP2，还要有RPC" class="headerlink" title="为什么既然有了HTTP2，还要有RPC"></a><strong>为什么既然有了HTTP2，还要有RPC</strong></h3><p>这个是由于 HTTP2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 <strong>消息边界</strong> 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li><li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li><li>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。</strong> 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li><li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li><li><strong>HTTP2.0</strong> 在 <strong>HTTP1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li></ul><h1 id="3-如何自己实现一个RPC框架"><a href="#3-如何自己实现一个RPC框架" class="headerlink" title="3.如何自己实现一个RPC框架"></a><strong>3.如何自己实现一个RPC框架</strong></h1><p>一般情况下， RPC 框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这样的 RPC 框架才算真正合格的。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410865.png" alt="e13cfb04-a05c-4882-92c9-ea0861e5cc10"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410866.png" alt="06f58c75-1637-456b-bea9-a83060a62c01"></p><p>从上图我们可以看出：服务提供端 Server 向注册中心注册服务，服务消费者 Client 通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端 Server。</p><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a><strong>注册中心</strong></h2><p><strong>注册中心负责服务地址的注册与查找，相当于目录服务。</strong> 服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。结合Dubbo到架构图：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410867.png" alt="d0ba7446-455a-40e8-bba2-58f03634860d"></p><p>上述节点简单说明：</p><ul><li><strong>Provider：</strong> 暴露服务的服务提供方</li><li><strong>Consumer：</strong> 调用远程服务的服务消费方</li><li><strong>Registry：</strong> 服务注册与发现的注册中心</li><li><strong>Monitor：</strong> 统计服务的调用次数和调用时间的监控中心</li><li><strong>Container：</strong> 服务运行容器</li></ul><p>调用关系说明：</p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于<strong>长连接推送</strong>变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于<strong>软负载均衡算法</strong>，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a><strong>网络传输</strong></h2><p><strong>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。</strong></p><p>网络传输具体实现你可以使用 <strong>Socket</strong> （ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。</p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a><strong>序列化与反序列化</strong></h2><p>要在网络传输数据就要涉及到<strong>序列化</strong>。<strong>为什么需要序列化和反序列化呢？</strong><br>因为网络传输的数据必须是二进制的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够让 Java 对象在网络中传输我们需要将其<strong>序列化</strong>为二进制的数据。我们最终需要的还是目标 Java 对象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次<strong>反序列化</strong>。</p><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可，不过这种方式不推荐，因为不支持跨语言调用并且性能比较差。现在比较常用序列化的有 <strong>hessian</strong>、<strong>kryo</strong>、<strong>protostuff</strong> ……</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a><strong>动态代理</strong></h2><p>我们知道代理模式就是： 我们给某一个对象提供一个代理对象，并由代理对象来代替真实对象做一些事情。你可以把代理对象理解为一个幕后的工具人。 举个例子：我们真实对象调用方法的时候，我们可以通过代理对象去做一些事情比如安全校验、日志打印等等。但是，这个过程是完全对真实对象屏蔽的。</p><p>讲完了代理模式，再来说动态代理在 RPC 框架中的作用。</p><ul><li>前面第一节的时候，我们就已经提到 ：<strong>RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输</strong>。</li></ul><p><strong>怎样才能屏蔽远程方法调用的底层细节呢？</strong></p><ul><li>答案就是<strong>动态代理</strong>。简单来说，当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法。</li><li>因为消费端没有服务的实现类，无法获得一个实例进行方法调用，所以只能通过动态代理获得一个代理对象。然后通过<strong>代理对象替我们调用方法</strong>。</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h2><p>我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a><strong>传输协议</strong></h2><p>我们还需要设计一个私有的 RPC 协议，这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。</p><p>简单来说：**通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二进制数据之后，就可以正确的解析出我们需要的数据。**这有一点像密文传输的感觉。</p><p>通常一些标准的 RPC 协议包含下面这些内容：</p><ul><li><strong>魔数</strong> ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。 </li><li><strong>序列化器编号</strong> ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kryo 等序列化方式。 </li><li><strong>消息体长度</strong> ： 运行时计算出来。</li></ul><h1 id="4-序列化介绍以及序列化协议选择"><a href="#4-序列化介绍以及序列化协议选择" class="headerlink" title="4. 序列化介绍以及序列化协议选择"></a><strong>4. 序列化介绍以及序列化协议选择</strong></h1><h2 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h2><ul><li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><h2 id="序列化协议对应于TCP-IP-4层模型中的哪一层？"><a href="#序列化协议对应于TCP-IP-4层模型中的哪一层？" class="headerlink" title="序列化协议对应于TCP&#x2F;IP 4层模型中的哪一层？"></a><strong>序列化协议对应于TCP&#x2F;IP 4层模型中的哪一层？</strong></h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410868.png" alt="64adec3d-78ee-488f-92ad-ad3013006985"></p><p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p><p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以<strong>序列化协议属于 TCP&#x2F;IP 协议应用层的一部分</strong>。</p><h2 id="常见的序列化协议有哪些？"><a href="#常见的序列化协议有哪些？" class="headerlink" title="常见的序列化协议有哪些？"></a><strong>常见的序列化协议有哪些？</strong></h2><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p><h3 id="JDK自带的序列化方式"><a href="#JDK自带的序列化方式" class="headerlink" title="JDK自带的序列化方式"></a><strong>JDK自带的序列化方式</strong></h3><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1905122041950251207L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-keyword">private</span> Object[] parameters;<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] paramTypes;<br>    <span class="hljs-keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="serialVersionUID有什么作用？"><a href="#serialVersionUID有什么作用？" class="headerlink" title="serialVersionUID有什么作用？"></a><strong>serialVersionUID有什么作用？</strong></h4><ul><li>序列化号 <code>serialVersionUID</code> 属于<strong>版本控制</strong>的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。</li></ul><h4 id="serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？"><a href="#serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？" class="headerlink" title="serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？"></a><strong>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</strong></h4><ul><li><p><code>static</code> 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。但是，<code>serialVersionUID</code> 的序列化做了特殊处理，在序列化时，会将 <code>serialVersionUID</code> 序列化到二进制字节流中；在反序列化时，也会解析它并做一致性判断。</p></li><li><blockquote><p>A serializable class can declare its own serialVersionUID explicitly by declaring a field named <code>&quot;serialVersionUID&quot;</code> that must be <code>static</code>, <code>final</code>, and of type <code>long</code>;</p><p>如果想显式指定 <code>serialVersionUID</code> ，则需要在类中使用 <code>static</code> 和 <code>final</code> 关键字来修饰一个 <code>long</code> 类型的变量，变量名字必须为 <code>&quot;serialVersionUID&quot;</code> 。</p></blockquote></li><li><p>也就是说，<code>serialVersionUID</code> 只是用来被 JVM 识别，实际并没有被序列化。</p></li></ul><h4 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a><strong>如果有些字段不想进行序列化怎么办？</strong></h4><p>对于不想进行序列化的变量，可以使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：<strong>阻止实例中那些用此关键字修饰的的变量序列化</strong>；当对象被反序列化时，被 <code>transient</code> 修饰的变量值<strong>不会被持久化和恢复</strong>。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成<strong>类型的默认值</strong>。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h4 id="为什么不推荐使用-JDK-自带的序列化？"><a href="#为什么不推荐使用-JDK-自带的序列化？" class="headerlink" title="为什么不推荐使用 JDK 自带的序列化？"></a><strong>为什么不推荐使用 JDK 自带的序列化？</strong></h4><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong> ：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li></ul><h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a><strong>Kryo</strong></h3><p>Kryo 是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月13日 19:29:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KryoSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializer</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;<br>        <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>        kryo.register(RpcResponse.class);<br>        kryo.register(RpcRequest.class);<br>        <span class="hljs-keyword">return</span> kryo;<br>    &#125;);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] serialize(Object obj) &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>             <span class="hljs-type">Output</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Output</span>(byteArrayOutputStream)) &#123;<br>            <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoThreadLocal.get();<br>            <span class="hljs-comment">// Object-&gt;byte:将对象序列化为byte数组</span><br>            kryo.writeObject(output, obj);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> output.toBytes();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializeException</span>(<span class="hljs-string">&quot;Serialization failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">byteArrayInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>             <span class="hljs-type">Input</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Input</span>(byteArrayInputStream)) &#123;<br>            <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoThreadLocal.get();<br>            <span class="hljs-comment">// byte-&gt;Object:从byte数组中反序列化出对象</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> kryo.readObject(input, clazz);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> clazz.cast(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializeException</span>(<span class="hljs-string">&quot;Deserialization failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Socket网络通信"><a href="#5-Socket网络通信" class="headerlink" title="5. Socket网络通信"></a><strong>5. Socket网络通信</strong></h1><h2 id="什么是Socket（套接字）"><a href="#什么是Socket（套接字）" class="headerlink" title="什么是Socket（套接字）"></a><strong>什么是Socket（套接字）</strong></h2><p>Socket 是一个抽象概念，应用程序可以通过它发送或接收数据。在使用 Socket 进行网络通信的时候，通过 Socket 就可以让我们的数据在网络中传输。操作套接字的时候，和我们读写文件很像。套接字是 IP 地址与端口的组合，套接字 Socket&#x3D;（IP 地址：端口号）。</p><p>要通过互联网进行通信，至少需要一对套接字：</p><ol><li>运行于服务器端的 Server Socket。</li><li>运行于客户机端的 Client Socket</li></ol><p>在 Java 开发中使用 Socket 时会常用到两个类，都在 <code>java.net</code> 包中：</p><ol><li><code>Socket</code>: 一般用于客户端</li><li><code>ServerSocket</code> :用于服务端</li></ol><h2 id="Socket网络通信过程"><a href="#Socket网络通信过程" class="headerlink" title="Socket网络通信过程"></a><strong>Socket网络通信过程</strong></h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171451051.png" alt="aacf635e-4ed6-4ba5-9346-d45500b48098"></p><p><strong>Socket 网络通信过程简单来说分为下面 4 步：</strong></p><ol><li>建立服务端并且监听客户端请求</li><li>客户端请求，服务端和客户端建立连接</li><li>两端之间可以传递数据</li><li>关闭资源</li></ol><p>对应到服务端和客户端的话，是下面这样的。</p><p><strong>服务器端：</strong></p><ol><li>创建 <code>ServerSocket</code> 对象并且绑定地址（ip）和端口号(port)：<code>server.bind(new InetSocketAddress(host, port))</code></li><li>通过 <code>accept()</code>方法监听客户端请求</li><li>连接建立后，通过输入流读取客户端发送的请求信息</li><li>通过输出流向客户端发送响应信息</li><li>关闭相关资源</li></ol><p><strong>客户端：</strong></p><ol><li>创建<code>Socket</code> 对象并且连接指定的服务器的地址（ip）和端口号(port)：<code>socket.connect(inetSocketAddress)</code></li><li>连接建立后，通过输出流向服务器端发送请求信息</li><li>通过输入流获取服务器响应的信息</li><li>关闭相关资源</li></ol><h2 id="Socket网络通信实战"><a href="#Socket网络通信实战" class="headerlink" title="Socket网络通信实战"></a><strong>Socket网络通信实战</strong></h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloServer.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-comment">//1.创建 ServerSocket 对象并且绑定一个端口</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);) &#123;<br>            Socket socket;<br>            <span class="hljs-comment">//2.通过 accept()方法监听客户端请求</span><br>            <span class="hljs-keyword">while</span> ((socket = server.accept()) != <span class="hljs-literal">null</span>) &#123;<br>                logger.info(<span class="hljs-string">&quot;client connected&quot;</span>);<br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());<br>                     <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream())) &#123;<br>                   <span class="hljs-comment">//3.通过输入流读取客户端发送的请求信息</span><br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (Message) objectInputStream.readObject();<br>                    logger.info(<span class="hljs-string">&quot;server receive message:&quot;</span> + message.getContent());<br>                    message.setContent(<span class="hljs-string">&quot;new content&quot;</span>);<br>                    <span class="hljs-comment">//4.通过输出流向客户端发送响应信息</span><br>                    objectOutputStream.writeObject(message);<br>                    objectOutputStream.flush();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                    logger.error(<span class="hljs-string">&quot;occur exception:&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur IOException:&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HelloServer</span> <span class="hljs-variable">helloServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloServer</span>();<br>        helloServer.start(<span class="hljs-number">6666</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ServerSocket</code> 的 <code>accept（）</code> 方法是<strong>阻塞方法</strong>，也就是说 <code>ServerSocket</code> 在调用 <code>accept（)</code>等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p><p>很明显，上面演示的代码片段有一个很严重的问题：**只能同时处理一个客户端的连接，如果需要管理多个客户端的话，就需要为我们请求的客户端单独创建一个线程。**对应的 Java 代码可能是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>   <span class="hljs-comment">// 创建 socket 连接</span><br>&#125;).start();<br></code></pre></td></tr></table></figure><p>但是，这样会导致一个很严重的问题：<strong>资源浪费</strong>。</p><p>我们知道线程是很宝贵的资源，如果我们为每一次连接都用一个线程处理的话，就会导致<strong>线程越来越多</strong>，最后达到了极限之后，就无法再创建线程处理请求了。处理的不好的话，甚至可能直接就宕机掉了。很多人就会问了：那有没有改进的方法呢？</p><p>当然有！ 比较简单并且实际的改进方法就是使用<strong>线程池</strong>。线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。<strong>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的 BIO 模型的事实，因此无法从根本上解决问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> Executors.defaultThreadFactory();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, TimeUnit.MINUTES, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>), threadFactory);<br>threadPool.execute(() -&gt; &#123;<br>     <span class="hljs-comment">// 创建 socket 连接</span><br> &#125;);<br></code></pre></td></tr></table></figure><blockquote><p>bio的话，线程池最多防止资源耗费过多，因为你读完数据，下一轮还是会阻塞到read方法，并不会结束这个线程的任务，所以线程还不回线程池。</p></blockquote><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloClient.class);<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">send</span><span class="hljs-params">(Message message, String host, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-comment">//1. 创建Socket对象并且指定服务器的地址和端口号</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(host, port)) &#123;<br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream());<br>            <span class="hljs-comment">//2.通过输出流向服务器端发送请求信息</span><br>            objectOutputStream.writeObject(message);<br>            <span class="hljs-comment">//3.通过输入流获取服务器响应的信息</span><br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());<br>            <span class="hljs-keyword">return</span> objectInputStream.readObject();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur exception:&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HelloClient</span> <span class="hljs-variable">helloClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloClient</span>();<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (Message) helloClient.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;content from client&quot;</span>), <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br>        System.out.println(<span class="hljs-string">&quot;client receive message:&quot;</span> + message.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先运行服务端，然后再运行客户端，控制台输出如下：</p><p>服务端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[main] INFO github.javaguide.socket.HelloServer - client connected<br>[main] INFO github.javaguide.socket.HelloServer - server receive message:content from client<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">client receive message:<span class="hljs-keyword">new</span> <span class="hljs-title class_">content</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>点评项目</title>
    <link href="/2025/02/15/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/02/15/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="点评项目"><a href="#点评项目" class="headerlink" title="点评项目"></a>点评项目</h1><h2 id="短信登录功能"><a href="#短信登录功能" class="headerlink" title="短信登录功能"></a>短信登录功能</h2><h3 id="基于Session实现登录"><a href="#基于Session实现登录" class="headerlink" title="基于Session实现登录"></a>基于Session实现登录</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151751207.png" alt="image-20250211151403643"></p><h4 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a><strong>Session原理</strong></h4><ul><li>Session会为每一次会话分配一个Session对象</li><li>同一个浏览器发起的多次请求，同属于一次会话（Session）</li><li>首次使用到Session时，服务器会自动创建Session，并创建<strong>Cookie</strong>存储SessionId发送回客户端</li></ul><h4 id="Session在项目中的使用"><a href="#Session在项目中的使用" class="headerlink" title="Session在项目中的使用"></a><strong>Session在项目中的使用</strong></h4><ul><li><strong>保存验证码到session</strong>：session.setAttribute(“code”, code)</li><li><strong>校验验证码</strong>：session.getAttribute(“code”)获取前面生成的验证码，与提交表单中的验证码进行比较，相同则说明输入正确</li><li><strong>保存用户到session</strong>：session.setAttribute(“user”,BeanUtil.copyProperties(user,UserDTO.class))<ul><li>其中这里保存的并非User对象，而是UserDTO对象</li><li>这是因为user对象中包含密码等敏感信息，若直接将User对象保存到session不安全，故将UserDTO对象保存到session中，用于后面的登录校验</li></ul></li></ul><h4 id="登录校验功能"><a href="#登录校验功能" class="headerlink" title="登录校验功能"></a><strong>登录校验功能</strong></h4><p>登录校验功能用于检验用户的登录状态，因为某些功能需要用户登录才能实现，比如：用户主页、用户私信。但是每次执行这些功能，都需要在对应功能的service实现类中实现从session中获取用户的操作，这样会很麻烦。</p><p>于是，我们选择在前面加一层拦截器，用于实现session中获取用户的操作，具体实现如下：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151751652.png" alt="image-20250211154537472"></p><h4 id="拦截器的实现"><a href="#拦截器的实现" class="headerlink" title="拦截器的实现"></a><strong>拦截器的实现</strong></h4><p>我们用于实现登录状态校验的拦截器<strong>LoginInterceptor</strong>，需要实现<strong>HandlerInterceptor</strong>，拦截器的执行流程分为三个主要阶段：<em><strong>preHandle</strong></em>、<em><strong>postHandle</strong></em>和<em><strong>afterCompletion</strong></em>。</p><ul><li>在请求处理的前期，<em>preHandle</em>方法会被调用，如果返回<em>true</em>，则继续执行后续的拦截器和请求处理器；如果返回<em>false</em>，则中断执行流程。</li><li>在请求处理完毕后，<em>postHandle</em>方法会被调用，用于进行后处理操作。</li><li>最后，在请求完成后，<em>afterCompletion</em>方法会被调用，用于进行资源清理等操作。</li></ul><h4 id="拦截器的注册"><a href="#拦截器的注册" class="headerlink" title="拦截器的注册"></a><strong>拦截器的注册</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 登录拦截器,order(1)表示顺序</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<br>                        <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/voucher/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/login&quot;</span><br>                ).order(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 获取用户token并刷新token</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshTokenInterceptor</span>(stringRedisTemplate))<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="保存用户到ThreadLocal"><a href="#保存用户到ThreadLocal" class="headerlink" title="保存用户到ThreadLocal"></a><strong>保存用户到ThreadLocal</strong></h4><p>ThreadLocal的三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.set(T value); <span class="hljs-comment">//设置值</span><br>ThreadLocal.get(); <span class="hljs-comment">//获取值</span><br>ThreadLocal.remove(); <span class="hljs-comment">//移除值</span><br></code></pre></td></tr></table></figure><p>所以我们可以借助这个ThreadLocal来存储登录用户的信息，在一个请求中，所有调用的方法都在同一个线程中去处理，这样就实现了在任何地方都可以获取到用户信息了，从而摆脱了HttpServletRequest的束缚。</p><h4 id="基于MybatisPlus实现的增删改查操作"><a href="#基于MybatisPlus实现的增删改查操作" class="headerlink" title="基于MybatisPlus实现的增删改查操作"></a><strong>基于MybatisPlus实现的增删改查操作</strong></h4><p>项目中使用MybatisPlus，简化了对数据库的增删改查操作，这是由service实现类通过继承MybatisPlus的<strong>ServiceImpl</strong>&lt;UserMapper, User&gt;实现的</p><ul><li><p><strong>根据手机号查询用户</strong>：User user &#x3D; query().eq(“phone”, phone).one()</p></li><li><p><strong>根据手机号生成新用户</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建用户</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>user.setPhone(phone);<br>user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="hljs-number">10</span>));<br><span class="hljs-comment">// 2.保存用户</span><br>save(user);<br></code></pre></td></tr></table></figure></li></ul><h4 id="集群的Session共享问题"><a href="#集群的Session共享问题" class="headerlink" title="集群的Session共享问题"></a><strong>集群的Session共享问题</strong></h4><p>当使用<strong>Tomcat集群</strong>时，多台Tomcat并不共享session的存储空间，当请求切换到不同tomcat服务时会导致数据丢失问题。如：用户登录时，使用Tomcat1，其对应的用户登录信息存储在Tomcat1的session中，当用户访问其他功能时，系统负载均衡分配了Tomcat2，这时的Tomcat2中不存在该用户存在session中的信息，于是会导致用户即使刚刚才登录，此时又需要再登录一遍。</p><p>session的替代方案应满足如下需求：</p><ul><li>数据共享</li><li>内存存储：session是基于内存存储的，它的读写效率高。而登录校验的访问频率非常高</li><li>key、value结构</li></ul><p><strong>——Redis</strong></p><h3 id="基于Redis实现共享session登录"><a href="#基于Redis实现共享session登录" class="headerlink" title="基于Redis实现共享session登录"></a><strong>基于Redis实现共享session登录</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752686.png" alt="image-20250211160014180"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752612.png" alt="image-20250211161336341"></p><h4 id="redis在项目中的使用"><a href="#redis在项目中的使用" class="headerlink" title="redis在项目中的使用"></a><strong>redis在项目中的使用</strong></h4><ul><li><p><strong>保存验证码到redis</strong>：stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES)，key设置为如上格式，能够清晰读懂redis各条键值对的功能，同时设置验证码的过期时间</p></li><li><p><strong>校验验证码</strong>：stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone)</p></li><li><p><strong>保存用户到redis</strong>：以随机token为key存储用户数据，用户对象使用Hash类型存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 7.保存用户信息到redis中</span><br><span class="hljs-comment">// 7.1随机生成token作为登陆令牌</span><br><span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 7.2 将User对象转换为HashMap存储</span><br><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO);<br>userMap.replace(<span class="hljs-string">&quot;id&quot;</span>, userDTO.getId().toString());<br><span class="hljs-comment">// 7.3存储</span><br><span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);<br><span class="hljs-comment">// 7.4设置有效期</span><br>stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure></li><li><p><strong>刷新过期时间</strong>：在拦截器中更新用户的过期时间</p></li></ul><p>通过上述改动，我们完成了使用redis实现共享session登录</p><h4 id="刷新过期时间问题"><a href="#刷新过期时间问题" class="headerlink" title="刷新过期时间问题"></a><strong>刷新过期时间问题</strong></h4><p>因为刷新过期时间是在拦截器中实现的，因此只有请求通过拦截器才会刷新过期时间，即使用户一直浏览主界面也不会刷新过期时间。为了解决这个问题，我们又添加了一个拦截器在前面</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752570.png" alt="image-20250211162311047"></p><ul><li>第一个拦截器RefreshTokenInterceptor的核心工作是得到用户、保存起来并刷新过期时间</li><li>第二个拦截器LoginInterceptor的核心工作是对不存在的用户进行拦截</li></ul><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a><strong>添加商户缓存</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752594.png" alt="image-20250211201328475"></p><p>使用redis中的<strong>string类型</strong>存储商铺缓存：</p><ul><li>若redis中存在要查询的商户，利用redis查到的json字符串结合hutool中的JSONUtil工具实现：Shop shop &#x3D; JSONUtil.toBean(shopJson, Shop.class)</li><li>若redis中不存在要查询的商户，到数据库中去查找，将找到的Shop对象通过hutool中的JSONUtil工具转换为json字符串：JSONUtil.toJsonStr(shop)</li></ul><h3 id="添加商户类型缓存"><a href="#添加商户类型缓存" class="headerlink" title="添加商户类型缓存"></a><strong>添加商户类型缓存</strong></h3><p>查询商户类型返回的是多个商户类型，即List<ShopType>，因此将商户类型存储在redis中时，我们选择使用<strong>redis中的list类型</strong>进行存储：</p><ul><li><p>先在缓存中查询：<strong>List<String></strong> shopTypeJsonList &#x3D; stringRedisTemplate.opsForList().range(CACHE_SHOPTYPE_LIST, 0, -1)，0、-1表示从头查到尾&#x3D;&#x3D;（注意，list类型查询返回只能得到一个List<String>类型的集合，因此我们每一个对象都要先转为json字符串再存储）&#x3D;&#x3D;</p></li><li><p>若redis中存在，即shopTypeJsonList非空，则将这个json字符串集合一个个转换为ShopType对象后，返回一个ShopTypeList集合</p></li><li><p>若redis中不存在，则需要到数据库中查找，注意，我们需要按照“sort”字段排序查找</p></li><li><p>查找到之后，将这些ShopType对象的集合一个个push到redis中去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(ShopType shopType : shopTypeList) &#123;<br>  stringRedisTemplate.opsForList().rightPush(CACHE_SHOPTYPE_LIST, JSONUtil.toJsonStr(shopType));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后返回一个ShopTypeList集合</p></li></ul><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752321.png" alt="image-20250211202918433"></p><ul><li>低一致性需求：使用内存淘汰机制。如商户类型查询的缓存。</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案。如店铺详情查询的缓存。</li></ul><h4 id="操作缓存和数据库需要考虑的问题"><a href="#操作缓存和数据库需要考虑的问题" class="headerlink" title="操作缓存和数据库需要考虑的问题"></a><strong>操作缓存和数据库需要考虑的问题</strong></h4><ul><li>删除缓存还是更新缓存？<ul><li>更新缓存：每次更新数据库都更新缓存，无效的写操作较多。</li><li>&#x3D;&#x3D;删除缓存&#x3D;&#x3D;：更新数据库时让缓存失效，查询时再更新缓存。</li></ul></li><li>如何保证缓存和数据库的操作<strong>同时成功或失败</strong>？<ul><li>单体系统：将缓存和数据库的操作放在同一个事务内。如放在同一个方法内，并用**@Transactional**修饰这个方法。</li><li>分布式系统：利用TCC等分布式事务。</li></ul></li><li><strong>先操作缓存还是先操作数据库？</strong><ul><li><strong>先删除缓存再操作数据库</strong></li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752308.png" alt="image-20250211203731172" style="zoom: 33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752090.png" alt="image-20250211203755582" style="zoom: 33%;" /></li><li>&#x3D;&#x3D;<strong>先操作数据库再删除缓存</strong>&#x3D;&#x3D;</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752210.png" alt="image-20250211203939763" style="zoom:33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752102.png" alt="image-20250211203955306" style="zoom:33%;" /></li><li>左边为正常情况，右边为异常情况</li><li>相比之下，前者出现异常情况的概率较大，而后者出现异常情况的概率较小，<strong>这是因为更新数据库的耗时相对而言较长导致的</strong>，因此可以选择后者。</li></ul></li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752365.png" alt="image-20250211204527433" style="zoom: 25%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752605.png" alt="image-20250211205011369" style="zoom:33%;" /></p><p>缓存穿透是指客户端请求的数据<strong>在缓存和数据库中都不存在</strong>，这样<strong>缓存永远不会生效</strong>，这些请求都会打到数据库。常见的解决方案有两种：</p><ul><li><p><strong>缓存空对象</strong>：将这种数据在redis中使用一个空对象如 “” 缓存起来，并设置一个<strong>较短的TTL</strong>，当下次再有这样的请求过来时就不会打到数据库了。</p><ul><li>优点：实现简单，维护方便</li><li>缺点：额外的内存消耗、可能造成短期的不一致</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752212.png" alt="image-20250211205343702" style="zoom:33%;" /></li></ul></li><li><p><strong>布隆过滤</strong></p><ul><li>布隆过滤算法是一种数据统计算法，用于检索一个元素是否在集合中。但是布隆过滤无需存储元素到集合，而是把元素映射到一个很长的二进制数位上。利用布隆过滤算法，在请求进入redis之前先判断是否存在，如果不存在则直接拒绝请求</li><li>优点：内存占用较少，没有多余的key</li><li>缺点：实现复杂、存在误判可能</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752022.png" alt="image-20250212135951528" style="zoom:33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752918.png" alt="image-20250212140747872" style="zoom:33%;" /></li></ul></li><li><p><strong>其他</strong></p><ul><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul></li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753143.png" alt="image-20250211205458168" style="zoom: 33%;" /><p>缓存雪崩是指在<strong>同一时段大量的缓存key同时失效</strong>或者redis服务宕机，导致大量请求打到数据库，带来巨大压力。解决方案：</p><ul><li>给不同的key的TTL添加随机值</li><li>利用redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753170.png" alt="image-20250211205931115" style="zoom: 33%;" /><p>缓存击穿问题也叫<strong>热点key问题</strong>，就是一个被高并发访问并且缓存重建业务比较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大冲击。常见的解决方案有两种：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753133.png" alt="image-20250211210042375" style="zoom:50%;" /><ul><li>互斥锁：给<strong>第一个未命中缓存的线程加锁</strong>、查询数据库并写入缓存后再释放锁，<strong>其他线程在此期间需要等待</strong>。<ul><li>优点：1. 没有额外的内存消耗    2. 保证一致性    3. 实现简单</li><li>缺点：1. 线程需要等待，性能受影响     2. 可能有死锁风险</li></ul></li><li>逻辑过期：不设置TTL，而是设置一个逻辑过期时间，首个发现逻辑时间过期的线程会<strong>开启一个新的线程用于更新数据</strong>，其本身以及在此期间查询的其他线程则会<strong>返回当下的过期数据</strong>。<ul><li>优点：线程无需等待，性能良好</li><li>缺点：1. 不保证一致性    2. 有额外内存消耗    3. 实现复杂</li></ul></li></ul><h4 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a><strong>利用互斥锁解决缓存击穿问题</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753969.png" alt="image-20250212113031052" style="zoom:50%;" /><ul><li>利用redis中的&#x3D;&#x3D;<strong>setnx（SET if Not eXists）命令</strong>&#x3D;&#x3D;实现互斥锁。</li><li>setnx基本语法：SETNX KEY_NAME VALUE在指定的 key 不存在时，为 key 设置指定的值，返回设置的值；若指定的key存在时，返回0。</li><li>Java中如何使用setnx方法实现<strong>获取互斥锁</strong>？stringRedisTemplate.opsForValue().<strong>setIfAbsent</strong>，这个方法返回一个Boolean值，在需要获取互斥锁时，在redis中设置<strong>setnx lockKey 1（TTL &#x3D; 20s）</strong>，如果设置成功，则返回true；而<strong>其他想要获取互斥锁的线程都会在setnx lockKey 1这一步中被堵住</strong>，故只有一个最早的线程能够到达后面的数据库，并进行缓存重建。</li><li>Java中如何使用setnx方法实现<strong>释放互斥锁</strong>？只需要进行缓存重建的线程在重建完毕后，将lockKey删除即可，这样后面想要获取互斥锁的线程就能够得到互斥锁了。注意，为了避免互斥锁无法释放，一般将释放锁操作放在finally代码块中执行。</li><li>由于缓存重建的过程需要先查找数据库，再写入redis，<strong>这一过程需要花费一定时间</strong>，在这段时间中，因为缓存未命中而想要重建缓存的线程都会被互斥锁挡住，直到缓存重建完毕，因此<strong>不会存在不一致的情况</strong>，即这段时间内所有的线程返回的值都是缓存重建完后的值。</li></ul><h4 id="利用逻辑过期解决缓存击穿问题"><a href="#利用逻辑过期解决缓存击穿问题" class="headerlink" title="利用逻辑过期解决缓存击穿问题"></a><strong>利用逻辑过期解决缓存击穿问题</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753395.png" alt="image-20250212113214513" style="zoom:33%;" /><ul><li>因为要处理的数据一般为热点数据，所以会提前写入缓存中预热，且只有逻辑过期时间、没有TTL，永不过期。因此，如果发现缓存未命中，说明不存在这样的数据，则直接返回空。</li><li>由于存到redis中的数据还需要包含一个逻辑过期的时间，因此创建一个新的对象redisData将商铺对象、逻辑过期时间包含起来。</li><li>将取得的逻辑过期时间与当前时间对比，若未过期，说明当前的商铺信息仍在有效期内，故直接返回。</li><li>若已过期，则先获取一个lockKey的互斥锁，获取方法同上。然后<strong>开启一个独立的线程</strong>，进行缓存重建，重建完释放互斥锁。而当前线程则直接返回获取到的过期数据。</li><li>在缓存重建期间，其他线程到达想要获取互斥锁，获取失败后也直接返回过期数据。</li><li>因为该方法存在返回过期数据的情况，因此这个方法会有不一致的情况出现。</li><li>注意⚠️：由于本项目中选择的缓存更新策略是——更新数据库时让缓存失效，查询时再更新缓存。但是在本方法中，<strong>删除缓存之后会导致其他线程无法命中缓存就直接返回空值</strong>，因此逻辑过期不适用于当前方法。可以采用更新缓存的策略——每次更新数据库都更新缓存。</li></ul><h3 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a><strong>缓存工具封装</strong></h3><p><strong>&#x3D;&#x3D;泛型&#x3D;&#x3D;</strong></p><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a><strong>优惠券秒杀</strong></h2><h3 id="全局唯一ID生成策略"><a href="#全局唯一ID生成策略" class="headerlink" title="全局唯一ID生成策略"></a><strong>全局唯一ID生成策略</strong></h3><p>当用户购买商品时，就会生成订单并保存到订单表中，而如果订单表采用数据库自增ID就会出现一些问题：</p><ul><li>ID的规律性太过明显，不安全</li><li>受单表数据量的限制，因为订单是会不断累积的，而单表所能容纳的数据量是有限的，后期会需要用到分库分表。而如果此时还使用数据库的自增ID，就会出现多个订单有相同的订单ID。</li></ul><p>故我们需要选择一种方法实现全局ID的生成，这种方法需要满足：唯一性、高可用、高性能、递增性、安全性的特点——<strong>redis</strong>。</p><ul><li>递增性：INCR key。当执行 INCR 命令时，如果键不存在，Redis 会先创建一个新的键，并将其初始值设置为0，然后再进行自增操作。</li><li>安全性：INCR 命令是原子操作，这意味着当多个客户端同时对同一个键执行 INCR 命令时，Redis 会确保操作的原子性。这意味着在多线程或并发环境下，不会出现竞态条件或数据不一致的情况。为了增加ID的安全性，我们可以不直接使用redis自增的数值，而是拼接一些其他的信息，如：时间戳（31位）+计数位（32位）</li></ul><h3 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a><strong>添加优惠券</strong></h3><p>本项目中的优惠券分为普通优惠券与秒杀优惠券，普通优惠券不限量且没有购买时间要求，而秒杀优惠券有库存，且需要在指定时间范围内才能购买。两者的数据表如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> `tb_voucher`  (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键&#x27;</span>,<br>  `shop_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商铺id&#x27;</span>,<br>  `title` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">CHARACTER SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;代金券标题&#x27;</span>,<br>  `sub_title` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">CHARACTER SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;副标题&#x27;</span>,<br>  `rules` <span class="hljs-type">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">CHARACTER SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;使用规则&#x27;</span>,<br>  `pay_value` <span class="hljs-type">bigint</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;支付金额，单位是分。例如200代表2元&#x27;</span>,<br>  `actual_value` <span class="hljs-type">bigint</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;抵扣金额，单位是分。例如200代表2元&#x27;</span>,<br>  `type` tinyint(<span class="hljs-number">1</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;0,普通券；1,秒杀券&#x27;</span>,<br>  `status` tinyint(<span class="hljs-number">1</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;1,上架; 2,下架; 3,过期&#x27;</span>,<br>  `create_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `update_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">CHARACTER SET</span> <span class="hljs-operator">=</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> `tb_seckill_voucher`  (<br>  `voucher_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;关联的优惠券的id&#x27;</span>,<br>  `stock` <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;库存&#x27;</span>,<br>  `create_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `begin_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;生效时间&#x27;</span>,<br>  `end_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;失效时间&#x27;</span>,<br>  `update_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`voucher_id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-keyword">CHARACTER SET</span> <span class="hljs-operator">=</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8mb4_general_ci COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;秒杀优惠券表，与优惠券是一对一关系&#x27;</span> ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br></code></pre></td></tr></table></figure><p>两张表是关联的，添加秒杀优惠券只需先保存到优惠券表中，然后再将部分字段保存到秒杀优惠券表中即可。</p><h3 id="实现秒杀优惠券下单"><a href="#实现秒杀优惠券下单" class="headerlink" title="实现秒杀优惠券下单"></a><strong>实现秒杀优惠券下单</strong></h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753985.png" alt="image-20250212164645234" style="zoom:33%;" /><p>扣减库存选择直接使用MybatisPlus中的update操作：seckillVoucherService.update().setSql(“stock &#x3D; stock - 1”).eq(“voucher_id”, voucherId).update()。</p><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a><strong>超卖问题</strong></h4><p>但是这样的做法会导致<strong>超卖现象</strong>的产生：即在线程1扣减库存之前，<strong>其他线程查到了未扣减之前的库存</strong>，导致最终<strong>库存变为了负数</strong>。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753604.png" alt="image-20250212165754627" style="zoom:33%;" /><p>超卖问题是典型的多线程安全问题，常见的解决方案就是加锁。而锁又可分为**&#x3D;&#x3D;悲观锁和乐观锁&#x3D;&#x3D;**：</p><ul><li><strong>悲观锁</strong>：<strong>认为线程安全问题一定会发生</strong>，因此在操作数据之前先获取锁，确保<strong>线程串行执行</strong>。Synchronized、Lock都属于悲观锁。优点：简单；缺点：性能一般。</li><li><strong>乐观锁</strong>：<strong>认为线程安全问题不一定会发生</strong>，因此&#x3D;&#x3D;不加锁&#x3D;&#x3D;，而是在更新数据的时候去<strong>判断有没有其他线程对数据进行修改</strong>。优点：性能好；缺点：存在成功率低的问题。<ul><li>如果没有修改，则认为是安全的，更新数据。</li><li>如果发现数据被修改了，说明发生了线程安全问题，此时可以重试或报异常。</li><li>乐观锁的常见实现方式有两种：<strong>版本号法、CAS（Compare and Swap）</strong><ul><li>版本号法：在原有数据基础上，为每个数据添加一个版本号version，数据每进行一次修改就使版本号增加。当要修改数据时，比较之前查询该数据得到的版本号与当前的版本号是否一致，若不一致则说明数据出现了修改。</li><li>CAS：在版本号的基础上，直接拿数据中要进行修改的字段进行比较，若前后不一致则说明发生了修改。</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754527.png" alt="image-20250212170606199" style="zoom: 33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754859.png" alt="image-20250212170924768" style="zoom: 33%;" /></li></ul></li></ul></li></ul><h4 id="CAS解决超卖问题时出现的问题"><a href="#CAS解决超卖问题时出现的问题" class="headerlink" title="CAS解决超卖问题时出现的问题"></a><strong>CAS解决超卖问题时出现的问题</strong></h4><p>我们选择使用上方的CAS方法解决超卖问题，在jMeter压力测试中，选择使用200个线程同时对100张秒杀优惠券进行抢购，这一次优惠券的库存没有变为负数，但是优惠券只卖出了20张，秒杀成功率大大减少了。</p><p>这是因为当有<strong>多个线程同时查到了同样的库存</strong>时，<strong>只有一个线程能够抢到优惠券</strong>，其他线程会因为当前剩余库存与前面查询到的库存不一致导致秒杀失败。</p><p>解决方案：将sql语句中的：stock &#x3D; 前面查询到的stock更改为<strong>stock &gt; 0</strong> 即可。</p><h4 id="实现一人一单功能"><a href="#实现一人一单功能" class="headerlink" title="实现一人一单功能"></a><strong>实现一人一单功能</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754411.png" alt="image-20250212175948943" style="zoom: 33%;" /><p>相较于上面主要的改动就是在扣减库存之前多了一道判断订单是否存在的步骤：判断数据库中<strong>是否已存在相同user_id和相同voucher_id的订单</strong>，如果这样的订单数量大于0，说明该用户已经买过这张优惠券，返回异常值。</p><p>1️⃣但是这样的操作会导致&#x3D;&#x3D;<strong>线程安全问题</strong>&#x3D;&#x3D;：一个用户在<strong>多个线程中同时进行了订单是否存在的判断</strong>，而此时还没创建订单，因此判断的结果都说明数据库中不存在这样的订单，则这多个线程会同时对库存进行扣减，还是没达到一人一单的效果。为了解决这个线程安全问题，我们可以加锁。由于<strong>乐观锁是在数据发生修改时才生效的</strong>，因此无法用于本问题里，于是我们选择<strong>悲观锁——synchronized</strong>用于解决线程安全问题。</p><p>由于前面的判断环节不会产生线程安全问题，为了方便synchronized关键字的使用，我们选择将查询订单到返回订单id这一段代码独立出来成为一个方法createVoucherOrder，该方法带有**@Transactional注释**。<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151756013.png" alt="image-20250212190212401" style="zoom:33%;" /></p><p>2️⃣现在就有一个问题，&#x3D;&#x3D;<strong>synchronized关键字的位置应该放在什么位置呢</strong>&#x3D;&#x3D;？是用于修饰方法createVoucherOrder呢？还是修饰方法内的一段代码块呢？解决这个问题的关键在于我们引入锁的初衷——实现一人一单功能。</p><ul><li>如果我们将synchronized用于修饰方法，那么当一个用户执行这个方法时，其他用户无法执行这个方法，只能等待，这显然大大削减了性能。而我们的目的仅仅只是让一个用户的多个线程无法同时进行方法的执行。</li><li>因此我们选择将synchronized用于修饰代码块，同时将**&#x3D;&#x3D;userId作为对象传入synchronized实现对单个用户加锁&#x3D;&#x3D;**。</li><li>为了实现对单个用户加锁，不同的用户不会被锁定，那么同一个用户传入synchronized的Long userId对象就需要是同一个：<ul><li>如果仅仅只传userId，多个线程下查到的userId地址不同，是不同的userId对象❌</li><li>如果传入userId.toString()，多个线程下查到的字符串地址不同，是不同的字符串对象❌</li><li>因此需要传入的是<strong>userId.toString().intern()</strong>，String.intern()是一个Native方法，它的作用是：如果字符常量池中已经包含一个等于此String对象的字符串，则返回常量池中字符串的引用。总之就是源于<strong>String对象的字符串是存储在&#x3D;&#x3D;常量池&#x3D;&#x3D;中的</strong>，如果多个String对象的字符串长得一样，那么他们在常量池中都<strong>指向同一个字符串</strong>，这就保证了传入synchronized关键字的是同一个对象。<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151756025.png" alt="image-20250212191841136" style="zoom:33%;" />✅</li></ul></li></ul><p>3️⃣但是，这样也会产生新的问题。由于方法是被@Transactional注释所修饰的，因此如果synchronized修饰<strong>方法内的一段代码块</strong>，就会出现**&#x3D;&#x3D;先释放锁，再提交事务&#x3D;&#x3D;<strong>的现象。如果一个线程释放锁但还没提交事务，这时有一个新的线程获取了锁，由于事务尚未提交，如果这时这个新的线程去查询订单，<strong>查询到的可能就是前一个线程未修改前的数据</strong>，这就产生了线程安全问题。这说明</strong>&#x3D;&#x3D;锁的范围小了，应该在事务提交之后再释放锁&#x3D;&#x3D;**，于是synchronized应该修饰函数调用所在的代码块，即：<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754132.png" alt="image-20250212193326069" style="zoom: 50%;" /></p><p>4️⃣经过上述操作，确保了线程安全，但是随之而来又有事务方面的问题。注意到，我们是对当前的createVoucherOrder方法进行了@Transactional的注释，而没有给外面的函数seckillVoucher加事务，而外面的函数seckillVoucher在执行上面这段代码时，等价于是这样执行的：<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754889.png" alt="image-20250212194040961" style="zoom:33%;" />这里的**&#x3D;&#x3D;this&#x3D;&#x3D;代表的是当前VoucherOrderServiceImpl这个类的对象，而不是它的代理对象**。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754096.png" alt="image-20250212194513920" style="zoom: 33%;" /><p>而事务要想生效，是因为<strong>spring对VoucherOrderServiceImpl这个类进行了动态代理，拿到了它的&#x3D;&#x3D;代理对象&#x3D;&#x3D;</strong>，用这个代理对象来去做事务处理；而<strong>现在这个this指的是非代理对象，是不具有事务功能的</strong>。因此我们需要拿到这个代理对象，获取方法如下：<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754106.png" alt="image-20250212194939735" style="zoom:33%;" />当然，上面的解决代理对象问题还需要如下两个步骤：</p><ul><li>pom文件中引入aspectjweaver依赖。</li><li>启动类添加@EnableAspectJAutoProxy(exposeProxy &#x3D; true)注解，用于暴露代理对象。</li></ul><p>这样就解决了事务问题。</p><h4 id="集群下一人一单的并发安全问题"><a href="#集群下一人一单的并发安全问题" class="headerlink" title="集群下一人一单的并发安全问题"></a><strong>集群下一人一单的并发安全问题</strong></h4><p>上面的处理方式，在单体部署的情况下是没有问题的，因为此时只有一台Tomcat1，即只有一台JVM1，线程获取的锁都是这台JVM1中的同一把锁（锁的UUID保存在常量池中），故<strong>多个线程竞争这一把锁</strong>，保证了线程安全。</p><p>但是如果在集群部署的情况下，就说明有<strong>多台Tomcat提供服务，即有多台JVM</strong>，故Tomcat1中的线程竞争的是JVM1中的锁，而Tomcat2中的线程竞争的是JVM2中的锁，<strong>此时有多把锁</strong>。故此时如果一个用户在两台Tomcat中都实现了下单操作，则<strong>两边都能获取到锁</strong>，故生成了两个订单，违背了一人一单的规定，这就导致了集群下一人一单问题的并发安全问题。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754699.png" alt="image-20250212203633633" style="zoom:33%;" /><h4 id="Redis的分布式锁实现"><a href="#Redis的分布式锁实现" class="headerlink" title="Redis的分布式锁实现"></a><strong>Redis的分布式锁实现</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754441.png" alt="image-20250213114816370" style="zoom:33%;" /><p>为了解决上述的并发安全，我们就需要实现<strong>多台JVM下的线程竞争同一把锁</strong>，<strong>即分布式锁</strong>——满足分布式系统或集群模式下多进程可见并且互斥的锁，本项目中我们选择使用redis的<strong>setnx</strong>关键字来解决分布式锁的实现。</p><p>而为了实现redis分布式锁只对同一个用户产生作用，设置的<strong>key值就需要区分不同用户</strong>，以此来实现对同一个用户的不同进程加锁，而不同用户获取的锁不同。对于下单功能，本项目设置的key值为：<strong>“lock:order:”+userId</strong>。</p><p>1️⃣而使用redis实现分布式锁就会出现一个问题：当一个进程占有锁时，若此时redis宕机了，就会导致锁无法被释放，造成<strong>死锁现象</strong>的产生。解决这个问题也很简单，我们只需要给这个锁设置一个<strong>过期时间</strong>，超时自动释放锁，就不会出现由于redis宕机导致的死锁现象。</p><p>2️⃣但是，正是由于给锁设置了过期时间，新的问题产生了——<strong>锁的误删问题</strong>。如下图所示，当线程1获取锁但是业务阻塞导致<strong>超时释放锁</strong>，在线程1业务完成之前，<strong>线程2趁虚而入拿到了锁并开始执行业务</strong>，这时候线程1完成了业务并按部就班去释放锁，但是这时候占用锁的是线程2，也就是说<strong>线程1把线程2的锁给释放了</strong>，这时候如果又有一个线程3来获取锁是能够获取成功的，这就导致了线程2、线程3同时执行业务，产生了并发安全问题。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754037.png" alt="image-20250213130001479" style="zoom:33%;" /><p>解决锁的误删问题可以采用如下方法：在给锁设置<strong>value值</strong>时，使用<strong>线程ID作为锁的value值</strong>，这样就能知道当前的锁是不是本线程所设置的，当线程业务执行完毕想要释放锁时，先执行一个判断，<strong>判断当前锁的value值与自身线程ID是否相同</strong>，如果相同说明是同一把锁可以释放，否则说明是别的线程的锁，不做操作，这样就避免了锁的误删问题。</p><p>当然，仅仅只使用线程ID作为value值是不够的，因为在不同的进程之间可能存在相同的线程ID，有小概率出现混淆的情况，我们可以选择在<strong>线程ID之前拼接一个UUID确保唯一性</strong>，将拼接的结果作为锁的value值。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754613.png" alt="image-20250213131120388" style="zoom:33%;" /><p>3️⃣但是，还会有一个问题：当线程1获取锁之后，未执行业务就发生了阻塞，此时如果锁释放了，线程2来获取锁是能够获取得到的，这就会造成线程1、2同时执行业务的情况出现，还是会发生一个用户下了多个订单的情况。如上图中<strong>线程1、2执行业务有重叠的部分</strong>。</p><p>4️⃣此外，由于<strong>判断锁标识是否一致与释放锁不是一个原子操作</strong>，如果<strong>判断完后想要释放锁时发生了阻塞</strong>，会触发锁的超时释放，此时线程2来获取了锁，线程1阻塞结束后会使用之前的判断结果去把线程2的锁释放，这就又导致的并发安全问题，如下图所示：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754097.png" alt="image-20250213131921945" style="zoom:33%;" /><p>为了解决原子性的问题，我们可以选择使用redis提供的lua脚本功能，在一个脚本中编写多条redis命令，确保多条命令执行的原子性。</p><h3 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a><strong>Redisson分布式锁</strong></h3><h4 id="基于SETNX实现的分布式锁存在的问题"><a href="#基于SETNX实现的分布式锁存在的问题" class="headerlink" title="基于SETNX实现的分布式锁存在的问题"></a><strong>基于SETNX实现的分布式锁存在的问题</strong></h4><ol><li>重入问题<ul><li>重入问题是指<strong>获取锁的线程，可以再次进入到相同的锁的代码块中</strong>，可重入锁的意义在于防止死锁，例如在HashTable这样的代码中，它的方法都是使用synchronized修饰的，加入它在一个方法内调用另一个方法，如果此时是不可重入的，那就死锁了。所以<strong>可重入锁的主要意义是防止死锁</strong>，我们的synchronized和Lock锁都是可重入的</li></ul></li><li>不可重试<ul><li>我们编写的分布式锁只能尝试一次，失败了就返回false，没有重试机制。但合理的情况应该是：当线程获取锁失败后，他应该能再次尝试获取锁</li></ul></li><li>超时释放<ul><li>我们在加锁的时候增加了TTL，这样我们可以防止死锁，但是如果卡顿(阻塞)时间太长，也会导致锁的释放。虽然我们采用Lua脚本来防止删锁的时候，误删别人的锁，但现在的新问题是没锁住，也有安全隐患，也就是上面的问题3️⃣</li></ul></li><li>主从一致性<ul><li>如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题</li></ul></li></ol><h4 id="Redisson可重入锁原理"><a href="#Redisson可重入锁原理" class="headerlink" title="Redisson可重入锁原理"></a><strong>Redisson可重入锁原理</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754395.png" alt="image-20250213160502630" style="zoom:33%;" /><ul><li><p>method1在方法内部调用method2，method1和method2出于<strong>同一个线程</strong>，那么method1已经拿到一把锁了，想进入method2中拿另外一把锁，必然是拿不到的，于是就出现了死锁</p></li><li><p>所以我们需要额外判断，<strong>method1和method2是否处于同一线程</strong>，如果是<strong>同一个线程，则可以拿到锁，但是state会<code>+1</code></strong>，之后执行method2中的方法，释放锁，<strong>释放锁的时候也只是将state进行<code>-1</code>，只有减至0，才会真正释放锁</strong></p></li><li><p>由于我们需要额外存储一个state，所以用字符串型<code>SET NX EX</code>是不行的，需要用到**<code>Hash</code>结构**，但是<code>Hash</code>结构又没有<code>NX</code>这种方法，所以我们需要将原有的逻辑拆开，进行手动判断，如上图所示</p></li><li><p>为了保证原子性，所以流程图中的业务逻辑也是需要我们用Lua来实现的</p></li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754005.png" alt="image-20250213160531577" style="zoom:33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754783.png" alt="image-20250213160607090" style="zoom:33%;" /></p><h4 id="Redisson锁重试和WatchDog机制"><a href="#Redisson锁重试和WatchDog机制" class="headerlink" title="Redisson锁重试和WatchDog机制"></a><strong>Redisson锁重试和WatchDog机制</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754136.png" alt="image-20250213161206038" style="zoom:33%;" /><ul><li><strong>锁重试</strong>：利用信号量、发布消息publish、订阅消息subscribe功能，实现获取锁失败后的一段时间（ttl）内重新尝试获取锁。而重新尝试获取锁<strong>并不是立刻重新尝试</strong>，而是通过<strong>订阅</strong>释放锁的消息，接收到锁释放的消息后去重试，<strong>减轻了cpu的负担</strong>，因此在线程释放锁后需要向外<strong>发布</strong>释放锁的消息。</li><li><strong>WatchDog机制</strong>：给锁添加过期时间，虽然能够解决死锁的问题，但是如果事务发生了阻塞导致超时释放锁，还是会出现多个线程同时执行业务的情况，失去了锁的作用，造成了一人多单的情况。因此，关键点就是**&#x3D;&#x3D;不要让事务阻塞导致超时释放锁，超时释放只应该在redis服务宕机、或持有锁的线程挂掉时起作用&#x3D;&#x3D;**，于是就引出了WatchDog机制。<ul><li>WatchDog就是持有锁的线程给锁加了一条看门狗，<strong>只要这个线程存在，狗就会不断给锁续期不让它过期</strong>，<strong>&#x3D;&#x3D;直到线程执行完事务并亲自释放锁&#x3D;&#x3D;</strong>。</li><li>既然WatchDog会给锁不断续期，那么锁设置过期时间还有意义吗？答案是有的。因为这个<strong>过期时间主要是为了防止线程挂掉、redis宕机导致的死锁，过期时间只应在这些情况下释放锁</strong>，如果过期时间是因为线程事务发生阻塞超时释放锁，就会产生上面的并发问题，而WatchDog就是引进来不让这种情况发生的。</li></ul></li></ul><h4 id="Redisson锁的MutiLock原理"><a href="#Redisson锁的MutiLock原理" class="headerlink" title="Redisson锁的MutiLock原理"></a><strong>Redisson锁的MutiLock原理</strong></h4><ul><li>为了提高Redis的可用性，我们会搭建集群或者主从，现在以主从为例</li><li>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设<strong>主机还没来得及把数据写入到从机去的时候，主机宕机了</strong></li><li>哨兵会发现主机宕机了，于是选举一个slave(从机)变成master(主机)，而此时<strong>新的master(主机)上并没有锁的信息</strong>，那么其他线程就可以获取锁，又会引发安全问题</li><li>为了解决这个问题。Redisson提出来了MutiLock锁，使用这把锁的话，那我们就不用主从了，每个节点的地位都是一样的，都可以当做是主机，那我们就**&#x3D;&#x3D;需要将加锁的逻辑写入到每一个主从节点上，只有所有的服务器都写入成功，此时才是加锁成功&#x3D;&#x3D;**，假设现在某个节点挂了，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性</li></ul><h4 id="Redisson小结"><a href="#Redisson小结" class="headerlink" title="Redisson小结"></a><strong>Redisson小结</strong></h4><ol><li>不可重入Redis分布式锁<ul><li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入Redis分布式锁<ul><li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：Redis宕机引起锁失效问题</li></ul></li><li>Redisson的multiLock<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li><li>缺陷：运维成本高、实现复杂</li></ul></li></ol><h3 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a><strong>秒杀优化</strong></h3><h4 id="异步秒杀思路"><a href="#异步秒杀思路" class="headerlink" title="异步秒杀思路"></a><strong>异步秒杀思路</strong></h4><p>我们先来回顾一下下单流程，当用户发起请求，此时会先请求Nginx，Nginx反向代理到Tomcat，而Tomcat中的程序，会进行串行操作，分为如下几个步骤：</p><ol><li>查询优惠券</li><li>判断秒杀库存是否足够</li><li>查询订单</li><li>校验是否一人一单</li><li>扣减库存</li><li>创建订单</li></ol><p>在这六个步骤中，有很多操作都是要去操作数据库的，而且还是一个线程串行执行，这样就会导致我们的程序执行很慢，所以我们需要异步程序执行，那么如何加速呢？</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754941.png" alt="image-20250213200222171" style="zoom:33%;" /><ul><li>优化方案：我们<strong>将耗时较短的逻辑判断放到Redis</strong>中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。</li><li>我们现在来看整体思路：当用户下单之后，判断库存是否充足，只需要取Redis中根据key找对应的value是否大于0即可，如果不充足，则直接结束。如果充足，则在Redis中判断用户是否可以下单，如果set集合中没有该用户的下单数据，则可以下单，并将<strong>userId和优惠券存入到Redis</strong>中，并且返回0，整个过程需要保证是原子性的，所以我们要用Lua来操作</li><li>我们只需要判断Lua脚本的返回值是否为0，如果是0，则表示可以下单，将信息保存到queue中去，然后返回，开一个线程来异步下单</li></ul><h4 id="异步秒杀小结"><a href="#异步秒杀小结" class="headerlink" title="异步秒杀小结"></a><strong>异步秒杀小结</strong></h4><ul><li>秒杀业务的优化思路是什么？<ol><li>先利用Redis完成库存容量、一人一单的判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li></ol></li><li>基于阻塞队列的异步秒杀存在哪些问题？<ol><li>内存限制问题：<ul><li>我们现在使用的是JDK里的阻塞队列，它使用的是JVM的内存，如果在高并发的条件下，无数的订单都会放在阻塞队列里，可能就会造成内存溢出，所以我们在创建阻塞队列时，设置了一个长度，但是如果真的存满了，再有新的订单来往里塞，那就塞不进去了，存在内存限制问题</li></ul></li><li>数据安全问题：<ul><li>经典服务器宕机了，用户明明下单了，但是数据库里没看到</li></ul></li></ol></li></ul><h3 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a><strong>Redis消息队列</strong></h3><h4 id="认识消息队列"><a href="#认识消息队列" class="headerlink" title="认识消息队列"></a><strong>认识消息队列</strong></h4><ul><li>什么是消息队列？字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色<ol><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ol></li><li>使用队列的好处在于<code>解耦</code>：举个例子，快递员(生产者)把快递放到驿站&#x2F;快递柜里去(Message Queue)去，我们(消费者)从快递柜&#x2F;驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的</li></ul><h4 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a><strong>基于List实现消息队列</strong></h4><ul><li>基于List结构模拟消息队列</li><li>消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果</li><li>队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。</li><li>不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用<strong>BRPOP或者BLPOP来实现阻塞效果</strong></li><li>基于List的消息队列有哪些优缺点？<ul><li>优点<ol><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保障</li><li>可以满足消息有序性</li></ol></li><li>缺点<ol><li>无法避免消息丢失(经典服务器宕机)</li><li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)</li></ol></li></ul></li></ul><h4 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a><strong>基于PubSub的消息队列</strong></h4><ul><li>PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</li><li><code>SUBSCRIBE channel [channel]</code>：订阅一个或多个频道</li><li><code>PUBLISH channel msg</code>：向一个频道发送消息</li><li><code>PSUBSCRIBE pattern [pattern]</code>：订阅与pattern格式匹配的所有频道</li><li>基于PubSub的消息队列有哪些优缺点<ul><li>优点：<ol><li>采用发布订阅模型，支持多生产，多消费</li></ol></li><li>缺点：<ol><li>不支持数据持久化</li><li>无法避免消息丢失（如果向频道发送了消息，却<strong>没有人订阅该频道</strong>，那发送的这条消息就丢失了）</li><li>消息堆积有上限，超出时数据丢失（<strong>消费者拿到数据的时候处理的太慢，而发送消息发的太快</strong>）</li></ol></li></ul></li></ul><h4 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a><strong>基于Stream的消息队列</strong></h4><ul><li>发送消息的命令</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">XADD key <span class="hljs-comment">[NOMKSTREAM]</span> <span class="hljs-comment">[MAXLEN|MINID <span class="hljs-comment">[=!~]</span> threshold <span class="hljs-comment">[LIMIT count]</span>]</span> *|ID field value <span class="hljs-comment">[field value ...]</span><br><br>NOMKSTREAM<br>如果队列不存在，是否自动创建队列，默认是自动创建<br><span class="hljs-comment">[MAXLEN|MINID <span class="hljs-comment">[=!~]</span> threshold <span class="hljs-comment">[LIMIT count]</span>]</span><br>设置消息队列的最大消息数量，不设置则无上限<br>*|ID<br>消息的唯一id，*代表由Redis自动生成。格式是”时间戳-递增数字”，例如”114514114514-0”<br>field value <span class="hljs-comment">[field value …]</span><br>发送到队列中的消息，称为Entry。格式就是多个key-value键值对<br><br>举例：创建名为users的队列，并向其中发送一个消息，内容是&#123;name=jack, age=21&#125;，并且使用Redis自动生成ID<br>XADD users * name jack age 21<br></code></pre></td></tr></table></figure><ul><li>读取消息的命令</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">XREAD <span class="hljs-comment">[COUNT count]</span> <span class="hljs-comment">[BLOCK milliseconds]</span> STREAMS key <span class="hljs-comment">[key ...]</span> ID <span class="hljs-comment">[ID ...]</span><br><br><span class="hljs-comment">[COUNT count]</span><br>每次读取消息的最大数量<br><span class="hljs-comment">[BLOCK milliseconds]</span><br>当没有消息时，是否阻塞，阻塞时长<br>STREAMS key <span class="hljs-comment">[key …]</span><br>要从哪个队列读取消息，key就是队列名<br>ID <span class="hljs-comment">[ID …]</span><br>起始ID，只返回大于该ID的消息<br>0：表示从第一个消息开始<br>$：表示从最新的消息开始<br>注意：当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现漏读消息的问题<br></code></pre></td></tr></table></figure><ul><li>STREAM类型消息队列的XREAD命令特点<ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有漏读消息的风险</li></ol></li></ul><h4 id="基于Stream的消息队列—消费者组"><a href="#基于Stream的消息队列—消费者组" class="headerlink" title="基于Stream的消息队列—消费者组"></a><strong>基于Stream的消息队列—消费者组</strong></h4><ul><li><p>消费者组(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列，具备以下特点</p><ol><li>消息分流<ul><li>队列中的消息会分留给组内的不同消费者，而不是重复消费者，从而<strong>加快消息处理的速度</strong></li></ul></li><li>消息标识<ul><li>消费者会维护一个标识，<strong>记录最后一个被处理的消息</strong>，哪怕消费者宕机重启，还会从标识之后读取消息，<strong>确保每一个消息都会被消费</strong></li></ul></li><li>消息确认<ul><li>消费者获取消息后，消息处于pending状态，并存入一个<strong>pending-list</strong>，当处理完成后，<strong>需要通过XACK来确认消息</strong>，标记消息为已处理，才会从pending-list中移除</li></ul></li></ol></li><li><p>创建消费者组</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gauss">XGROUP <span class="hljs-keyword">CREATE</span> <span class="hljs-built_in">key</span> groupName ID [MKSTREAM]<br><br><span class="hljs-built_in">key</span><br>队列名称<br>groupName<br>消费者组名称<br>ID<br>起始ID标识，$代表队列中的最后一个消息，<span class="hljs-number">0</span>代表队列中的第一个消息<br>MKSTREAM<br>队列不存在时自动创建队列<br></code></pre></td></tr></table></figure></li><li><p>从消费者组中读取消息</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs q">XREADGROUP GROUP <span class="hljs-built_in">group</span> consumer [COUNT <span class="hljs-built_in">count</span>] [BLOCK milliseconds] [NOACK] STREAMS <span class="hljs-built_in">key</span> [<span class="hljs-built_in">keys</span> ...] ID [ID ...]<br><br><span class="hljs-built_in">group</span><br>消费者组名称<br>consumer<br>消费者名，如果消费者不存在，会自动创建一个消费者<br><span class="hljs-built_in">count</span><br>本次查询的最大数量<br>BLOCK milliseconds<br>当前没有消息时的最大等待时间<br>NOACK<br>无需手动ACK，获取到消息后自动确认（一般不用，我们都是手动确认）<br>STREAMS <span class="hljs-built_in">key</span><br>指定队列名称<br>ID<br>获取消息的起始ID<br>&gt;：从下一个未消费的消息开始(pending-list中)<br>其他：根据指定id从pending-list中获取已消费但未确认的消息，例如<span class="hljs-number">0</span>，是从pending-list中的第一个消息开始<br></code></pre></td></tr></table></figure></li><li><p>STREAM类型消息队列的XREADGROUP命令的特点</p><ol><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ol></li></ul><h4 id="三种方式实现消息队列对比"><a href="#三种方式实现消息队列对比" class="headerlink" title="三种方式实现消息队列对比"></a><strong>三种方式实现消息队列对比</strong></h4><table><thead><tr><th align="center"></th><th align="center">List</th><th align="center">PubSub</th><th align="center">Stream</th></tr></thead><tbody><tr><td align="center">消息持久化</td><td align="center">支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">阻塞读取</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">消息堆积处理</td><td align="center">受限于内存空间， 可以利用多消费者加快处理</td><td align="center">受限于消费者缓冲区</td><td align="center">受限于队列长度， 可以利用消费者组提高消费速度，减少堆积</td></tr><tr><td align="center">消息确认机制</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">消息回溯</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr></tbody></table><h4 id="Redis消息队列实现异步秒杀"><a href="#Redis消息队列实现异步秒杀" class="headerlink" title="Redis消息队列实现异步秒杀"></a><strong>Redis消息队列实现异步秒杀</strong></h4><ul><li><p>需求：</p><ol><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li></ol></li><li><p>业务实现伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// 尝试监听队列，使用阻塞模式，最大等待时长为2000ms</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;&quot;</span>)<br>    <span class="hljs-keyword">if</span>(msg == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">// 没监听到消息，重试</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//处理消息，完成后要手动确认ACK</span><br>        handleMessage(msg);<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0&quot;</span>);<br>            <span class="hljs-keyword">if</span>(msg == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//null表示没有异常消息，所有消息均已确认，结束循环</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//说明有异常消息，再次处理</span><br>                handleMessage(msg);<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                <span class="hljs-comment">//再次出现异常，记录日志，继续循环</span><br>                log.error(<span class="hljs-string">&quot;..&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="使用RabbitMQ实现异步秒杀"><a href="#使用RabbitMQ实现异步秒杀" class="headerlink" title="使用RabbitMQ实现异步秒杀"></a><strong>使用RabbitMQ实现异步秒杀</strong></h4><p>具体实现：</p><ol><li>首先还是先使用lua脚本，在redis中实现耗时较短的逻辑判断：判断库存是否充足、判断用户是否下单、扣减redis中的库存、将用户加入下单名单里</li><li>如果上面判断出用户还未下过单，则能够进行下一步扣减数据库中的库存</li><li>数据库的扣减就交给消息队列去实现，实现了如下几个程序：<ul><li>MQSender：将信息封装成一个优惠券订单对象后，转换为JSON字符串，使用这个MQSender发送出去</li><li>MQReceiver：rabbitmq在接收到这个消息后，将接收到的json字符串解析为订单对象，在数据库中判断一人一单、基于CAS实现库存扣减，然后扣减库存。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 创建订单</span><br><span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>voucherOrder.setUserId(userId);<br>voucherOrder.setId(orderId);<br>voucherOrder.setVoucherId(voucherId);<br><span class="hljs-comment">// 将信息放入MQ中</span><br>mqSender.sendSeckillMessage(JSON.toJSONString(voucherOrder));<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MQSender</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROUTINGKEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;seckill.message&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送秒杀信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendSeckillMessage</span><span class="hljs-params">(String msg)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;发送消息&quot;</span>+msg);<br>        rabbitTemplate.convertAndSend(RabbitMQTopicConfig.EXCHANGE,ROUTINGKEY,msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MQReceiver</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    IVoucherOrderService voucherOrderService;<br><br>    <span class="hljs-meta">@Resource</span><br>    ISeckillVoucherService seckillVoucherService;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 接收秒杀信息并下单</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@RabbitListener(queues = RabbitMQTopicConfig.QUEUE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">receiveSeckillMessage</span><span class="hljs-params">(String msg)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;接收到消息: &quot;</span>+msg);<br>        <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> JSON.parseObject(msg, VoucherOrder.class);<br><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">voucherId</span> <span class="hljs-operator">=</span> voucherOrder.getVoucherId();<br>        <span class="hljs-comment">//5.一人一单</span><br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>        <span class="hljs-comment">//5.1查询订单</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> voucherOrderService.query().eq(<span class="hljs-string">&quot;user_id&quot;</span>,userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>        <span class="hljs-comment">//5.2判断是否存在</span><br>        <span class="hljs-keyword">if</span>(count&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//用户已经购买过了</span><br>            log.error(<span class="hljs-string">&quot;该用户已购买过&quot;</span>);<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;扣减库存&quot;</span>);<br>        <span class="hljs-comment">//6.扣减库存</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService<br>                .update()<br>                .setSql(<span class="hljs-string">&quot;stock = stock-1&quot;</span>)<br>                .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId)<br>                .gt(<span class="hljs-string">&quot;stock&quot;</span>,<span class="hljs-number">0</span>)<span class="hljs-comment">//cas乐观锁</span><br>                .update();<br>        <span class="hljs-keyword">if</span>(!success)&#123;<br>            log.error(<span class="hljs-string">&quot;库存不足&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//直接保存订单</span><br>        voucherOrderService.save(voucherOrder);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Blog点赞功能"><a href="#Blog点赞功能" class="headerlink" title="Blog点赞功能"></a><strong>Blog点赞功能</strong></h2><h3 id="一人一赞"><a href="#一人一赞" class="headerlink" title="一人一赞"></a><strong>一人一赞</strong></h3><p>当前的业务下，点赞功能直接在controller层中，update数据库中blog的点赞数，这会导致一个用户可以给一篇blog无限点赞，这是不合理的。我们的需求是：</p><ul><li>同一个用户只能对同一篇笔记点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则<strong>点赞按钮高亮显示</strong>（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现的方法如下：</p><ul><li>修改点赞功能，利用<strong>redis中的set集合</strong>的sismember方法来判断是否点赞过，未点赞则点赞数+1，已点赞则点赞数-1</li><li>修改根据id查询blog的业务，判断当前用户是否点赞过，赋值给blog对象的isLike字段</li><li>修改分页查询blog业务，判断当前用户是否点赞过，赋值给blog对象的isLike字段</li></ul><h3 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a><strong>点赞排行榜</strong></h3><p>当我们点击探店笔记详情页面时，应该按点赞顺序展示点赞用户，比如显示最早点赞的TOP5，形成点赞排行榜。之前的点赞是放到Set集合中，但是Set集合又不能排序，所以这个时候，我们就可以改用<strong>SortedSet(Zset)</strong>，将<strong>时间戳作为zset对应用户id的得分</strong>，根据得分排序即可实现显示最早点赞的top5。</p><ul><li><p>而Zset没有ismember的方法，我们可以选择score方法，该方法查询对应用户ID的score，如果没有这个用户，就返回空值。</p></li><li><pre><code class="language-java">// 查询点赞排行榜@Overridepublic Result queryBlogLikes(Integer id) &#123;    String key = BLOG_LIKED_KEY + id;    //zrange key 0 4  查询zset中前5个元素    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);    //如果是空的(可能没人点赞)，直接返回一个空集合    if (top5 == null || top5.isEmpty()) &#123;        return Result.ok(Collections.emptyList());    &#125;    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());    //将ids使用`,`拼接，SQL语句查询出来的结果并不是按照我们期望的方式进行排    //所以我们需要用order by field来指定排序方式，期望的排序方式就是按照查询出来的id进行排序    String idsStr = StrUtil.join(&quot;,&quot;, ids);    //select * from tb_user where id in (ids[0], ids[1] ...) order by field(id, ids[0], ids[1] ...)    List&lt;UserDTO&gt; userDTOS = userService.query().in(&quot;id&quot;, ids)            .last(&quot;order by field(id,&quot; + idsStr + &quot;)&quot;)            .list().stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    return Result.ok(userDTOS);&#125;</code></pre></li></ul><h2 id="好友关注功能"><a href="#好友关注功能" class="headerlink" title="好友关注功能"></a><strong>好友关注功能</strong></h2><h3 id="关注与取关"><a href="#关注与取关" class="headerlink" title="关注与取关"></a><strong>关注与取关</strong></h3><p>关注与取关会传入一个isFollow参数，true表示关注，false表示取关</p><ul><li>关注只需要创建一个Follow对象，将关注者（当前用户）id与被关注者id赋给这个Follow对象，然后直接保存到数据库中即可</li><li>同理，取关只需要把数据库中<code>user_id = userId</code>且<code>follow_user_id = followUserId</code>的记录删除即可。</li></ul><h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a><strong>共同关注</strong></h3><p>共同关注可以利用redis中<strong>set</strong>数据类型，对<strong>两个key的set取交集来实现</strong></p><ul><li>key用于区分用户，模式为<code>follow:userId</code></li><li>value则是对应用户的关注对象的set集合</li><li>因此，需要在关注时，同步将关注信息传入redis中；同理取关时也要将被关注者从当前用户的set集合中删除</li><li>使用set数据结构的intersect功能来实现取交集</li><li>取得共同关注id集合（String集合）后，要将id集合解析（String转化为Long），然后查询各id对应的用户信息user并<strong>封装到userDTO</strong>中确保安全，然后返回。</li></ul><h3 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a><strong>关注推送</strong></h3><ul><li>需求：<ol><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须使用Redis的数据结构实现</li><li>查询收件箱数据时，实现分页查询</li></ol></li><li>实现：<ol><li><strong>基于redis实现收件箱</strong>：在redis为每个用户设置一个收件箱，key模式为<code>FEED_KEY + userId</code>，每当一个用户发布一条blog时，在tb_follow表中查询他的粉丝，并<strong>将blog id推送到每个粉丝的收件箱</strong></li><li>由于要按照时间戳排序，我们选择redis数据结构为<strong>zset，score使用时间戳来表示</strong></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/15/hello-world/"/>
    <url>/2025/02/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
