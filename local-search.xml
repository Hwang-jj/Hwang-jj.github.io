<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JVM上04_虚拟机栈</title>
    <link href="/2025/02/27/JVM%E4%B8%8A04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <url>/2025/02/27/JVM%E4%B8%8A04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>笔记来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" title="尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）">尚硅谷 JVM 全套教程，百万播放，全网巅峰（宋红康详解 java 虚拟机）</a></p><p>同步更新：<a href="https://gitee.com/vectorx/NOTE_JVM">https://gitee.com/vectorx/NOTE_JVM</a></p><p><a href="https://codechina.csdn.net/qq_35925558/NOTE_JVM">https://codechina.csdn.net/qq_35925558/NOTE_JVM</a></p><p><a href="https://github.com/uxiahnan/NOTE_JVM">https://github.com/uxiahnan/NOTE_JVM</a></p></blockquote><p>[toc]</p><h1 id="4-虚拟机栈"><a href="#4-虚拟机栈" class="headerlink" title="4. 虚拟机栈"></a>4. 虚拟机栈</h1><h2 id="4-1-虚拟机栈概述"><a href="#4-1-虚拟机栈概述" class="headerlink" title="4.1. 虚拟机栈概述"></a>4.1. 虚拟机栈概述</h2><h3 id="4-1-1-虚拟机栈出现的背景"><a href="#4-1-1-虚拟机栈出现的背景" class="headerlink" title="4.1.1. 虚拟机栈出现的背景"></a>4.1.1. 虚拟机栈出现的背景</h3><p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p><p><mark>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</mark>。</p><h3 id="4-1-2-初步印象"><a href="#4-1-2-初步印象" class="headerlink" title="4.1.2. 初步印象"></a>4.1.2. 初步印象</h3><p>有不少 Java 开发人员一提到 Java 内存结构，就会非常粗粒度地将 JVM 中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？</p><h3 id="4-1-3-内存中的栈与堆"><a href="#4-1-3-内存中的栈与堆" class="headerlink" title="4.1.3. 内存中的栈与堆"></a>4.1.3. 内存中的栈与堆</h3><p><mark>栈是运行时的单位，而堆是存储的单位</mark></p><ul><li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057952.png" alt="image-20200705163928652"></p><h3 id="4-1-4-虚拟机栈基本内容"><a href="#4-1-4-虚拟机栈基本内容" class="headerlink" title="4.1.4. 虚拟机栈基本内容"></a>4.1.4. 虚拟机栈基本内容</h3><h4 id="Java-虚拟机栈是什么？"><a href="#Java-虚拟机栈是什么？" class="headerlink" title="Java 虚拟机栈是什么？"></a>Java 虚拟机栈是什么？</h4><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用，是线程私有的。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>生命周期和线程一致</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><h4 id="栈的特点"><a href="#栈的特点" class="headerlink" title="栈的特点"></a>栈的特点</h4><p>栈是一种快速有效的分配存储方式，访问速度仅次于罹序计数器。</p><p>JVM 直接对 Java 栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057953.png" alt="image-20200705165025382"></p><h4 id="面试题：开发中遇到哪些异常？"><a href="#面试题：开发中遇到哪些异常？" class="headerlink" title="面试题：开发中遇到哪些异常？"></a>面试题：开发中遇到哪些异常？</h4><p><strong>栈中可能出现的异常</strong></p><p>Java 虚拟机规范允许<mark>Java 栈的大小是动态的或者是固定不变的</mark>。</p><ul><li><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个<mark>StackOverflowError </mark>异常。</p></li><li><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<mark> OutOfMemoryError </mark>异常。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    test();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    test();<br>&#125;<br><span class="hljs-comment">//抛出异常：Exception in thread&quot;main&quot;java.lang.StackoverflowError</span><br><span class="hljs-comment">//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。</span><br></code></pre></td></tr></table></figure><p><strong>设置栈内存大小</strong></p><p>我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackDeepTest</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recursion</span><span class="hljs-params">()</span>&#123;<br>        count++;<br>        recursion();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            recursion();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e)&#123;<br>            System.out.println(<span class="hljs-string">&quot;deep of calling=&quot;</span>+count);<br>            e.printstackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-栈的存储单位"><a href="#4-2-栈的存储单位" class="headerlink" title="4.2. 栈的存储单位"></a>4.2. 栈的存储单位</h2><h3 id="4-2-1-栈中存储什么？"><a href="#4-2-1-栈中存储什么？" class="headerlink" title="4.2.1. 栈中存储什么？"></a>4.2.1. 栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以<mark>栈帧（Stack Frame）的格式存在</mark>。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="4-2-2-栈运行原理"><a href="#4-2-2-栈运行原理" class="headerlink" title="4.2.2. 栈运行原理"></a>4.2.2. 栈运行原理</h3><p>JVM 直接对 Java 栈的操作只有两个，就是对<mark>栈帧的压栈和出栈，遵循“先进后出”&#x2F;“后进先出”原则</mark>。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<mark>当前栈帧（Current Frame）</mark>，与当前栈帧相对应的方法就是<mark>当前方法（Current Method）</mark>，定义这个方法的类就是<mark>当前类（Current Class）</mark>。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057954.png" alt="image-20200705203142545"></p><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java 方法有两种返回函数的方式，<mark>一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出</mark>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentFrameTest</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span>&#123;<br>        system.out.println（<span class="hljs-string">&quot;当前栈帧对应的方法-&gt;methodA&quot;</span>);<br>        methodB();<br>        system.out.println（<span class="hljs-string">&quot;当前栈帧对应的方法-&gt;methodA&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span>&#123;<br>        System.out.println（<span class="hljs-string">&quot;当前栈帧对应的方法-&gt;methodB&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-栈帧的内部结构"><a href="#4-2-3-栈帧的内部结构" class="headerlink" title="4.2.3. 栈帧的内部结构"></a>4.2.3. 栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li><mark>局部变量表（Local Variables）</mark></li><li><mark>操作数栈（operand Stack）（或表达式栈）</mark></li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057955.png" alt="image-20200705204836977"></p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057956.png" alt="image-20200705205443993"></p><h2 id="4-3-局部变量表-Local-Variables"><a href="#4-3-局部变量表-Local-Variables" class="headerlink" title="4.3. 局部变量表(Local Variables)"></a>4.3. 局部变量表(Local Variables)</h2><p>局部变量表也被称之为局部变量数组或本地变量表</p><ul><li><p><mark>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</mark>，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress 类型。</p></li><li><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<mark>不存在数据安全问题</mark></p></li><li><p><mark>局部变量表所需的容量大小是在编译期确定下来的</mark>，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。</p></li><li><p><mark>方法嵌套调用的次数由栈的大小决定</mark>。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p></li><li><p><mark>局部变量表中的变量只在当前方法调用中有效</mark>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p></li></ul><h3 id="4-3-1-关于-Slot-的理解"><a href="#4-3-1-关于-Slot-的理解" class="headerlink" title="4.3.1. 关于 Slot 的理解"></a>4.3.1. 关于 Slot 的理解</h3><ul><li><p>局部变量表，最基本的存储单元是 Slot（变量槽）</p></li><li><p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1 的索引结束。</p></li><li><p>局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference），returnAddress 类型的变量。</p></li><li><p>在局部变量表里，32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占用两个 slot。</p></li><li><p>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true。</p></li><li><p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<mark>按照顺序被复制</mark>到局部变量表中的每一个 slot 上</p></li><li><p><mark>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</mark>。（比如：访问 long 或 doub1e 类型变量）</p></li><li><p>如果当前帧是由构造方法或者实例方法创建的，那么<mark>该对象引用 this 将会存放在 index 为 0 的 slot 处</mark>，其余的参数按照参数表顺序继续排列。</p></li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057957.png" alt="image-20200705212454445"></p><h3 id="4-3-2-Slot-的重复利用"><a href="#4-3-2-Slot-的重复利用" class="headerlink" title="4.3.2. Slot 的重复利用"></a>4.3.2. Slot 的重复利用</h3><p>栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SlotTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localVarl</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        System.out.println(a);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">localVar2</span><span class="hljs-params">()</span> &#123;<br>        &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            System.out.println(a);<br>        &#125;<br>        <span class="hljs-comment">//此时的就会复用a的槽位</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-3-静态变量与局部变量的对比"><a href="#4-3-3-静态变量与局部变量的对比" class="headerlink" title="4.3.3. 静态变量与局部变量的对比"></a>4.3.3. 静态变量与局部变量的对比</h3><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在“<mark>准备阶段</mark>”，执行系统初始化，对类变量设置零值，另一次则是在“<mark>初始化</mark>”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    System. out. println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的代码是错误的，没有赋值不能够使用。</p><h3 id="4-3-4-补充说明"><a href="#4-3-4-补充说明" class="headerlink" title="4.3.4. 补充说明"></a>4.3.4. 补充说明</h3><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p><mark>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</mark>。</p><h2 id="4-4-操作数栈（Operand-Stack）"><a href="#4-4-操作数栈（Operand-Stack）" class="headerlink" title="4.4. 操作数栈（Operand Stack）"></a>4.4. 操作数栈（Operand Stack）</h2><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 <mark>操作数栈</mark>，也可以称之为<mark>表达式栈（Expression Stack）</mark></p><p><mark>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</mark></p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057958.png" alt="image-20200706090618332"></p><p>代码举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddOperation</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">byte</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i + j;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码指令信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">public void testAddOperation();<br>    Code:<br>    0: bipush 15<br>    2: istore_1<br>    3: bipush 8<br>    5: istore_2<br>    6:iload_1<br>    7:iload_2<br>    8:iadd<br>    9:istore_3<br>    10:return<br></code></pre></td></tr></table></figure><p>操作数栈，<mark>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</mark>。</p><p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<mark>这个方法的操作数栈是空的</mark>。</p><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性中，为 max_stack 的值。</p><p>栈中的任何一个元素都是可以任意的 Java 数据类型</p><ul><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li></ul><p>操作数栈<mark>并非采用访问索引的方式来进行数据访问</mark>的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p><mark>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</mark>，并更新 PC 寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p><p>另外，我们说 Java 虚拟机的<mark>解释引擎是基于栈的执行引擎</mark>，其中的栈指的就是操作数栈。</p><h2 id="4-5-代码追踪"><a href="#4-5-代码追踪" class="headerlink" title="4.5. 代码追踪"></a>4.5. 代码追踪</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAddOperation</span>()</span> &#123;<br>    <span class="hljs-built_in">byte</span> i = <span class="hljs-number">15</span>;<br>    <span class="hljs-built_in">int</span> j = <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">int</span> k = i + j;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 javap 命令反编译 class 文件：<code> javap -v 类名.class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddoperation</span><span class="hljs-params">()</span>; Code:<span class="hljs-number">0</span>: bipush <span class="hljs-number">15</span> <span class="hljs-number">2</span>: istore_1 <span class="hljs-number">3</span>: bipush <span class="hljs-number">8</span><span class="hljs-number">5</span>: istore_2<span class="hljs-number">6</span>: iload_1<span class="hljs-number">7</span>: iload_2<span class="hljs-number">8</span>: iadd<span class="hljs-number">9</span>: istore_3    <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057959.png" alt="image-20200706093131621"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057960.png" alt="image-20200706093251302"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057961.png" alt="image-20200706093646406"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057962.png" alt="image-20200706093751711"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057963.png" alt="image-20200706093859191"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057964.png" alt="image-20200706093921573"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057965.png" alt="image-20200706094046782"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057966.png" alt="image-20200706094109629"></p><p>程序员面试过程中，常见的 i++和++i 的区别，放到字节码篇章时再介绍。</p><h2 id="4-6-栈顶缓存技术（Top-Of-Stack-Cashing）技术"><a href="#4-6-栈顶缓存技术（Top-Of-Stack-Cashing）技术" class="headerlink" title="4.6. 栈顶缓存技术（Top Of Stack Cashing）技术"></a>4.6. 栈顶缓存技术（Top Of Stack Cashing）技术</h2><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。</p><p>由于操作数是存储在内存中的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<mark>将栈顶元素全部缓存在物理 CPU 的寄存器中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率</mark>。</p><h2 id="4-7-动态链接（Dynamic-Linking）"><a href="#4-7-动态链接（Dynamic-Linking）" class="headerlink" title="4.7. 动态链接（Dynamic Linking）"></a>4.7. 动态链接（Dynamic Linking）</h2><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p><p>每一个栈帧内部都包含一个指向<mark>运行时常量池中该栈帧所属方法的引用</mark>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令</p><p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<mark>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用</mark>。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057967.png" alt="image-20200706101251847"></p><p>为什么需要运行时常量池呢？</p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p><h2 id="4-8-方法的调用：解析与分配"><a href="#4-8-方法的调用：解析与分配" class="headerlink" title="4.8. 方法的调用：解析与分配"></a>4.8. 方法的调用：解析与分配</h2><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h3 id="4-8-1-静态链接"><a href="#4-8-1-静态链接" class="headerlink" title="4.8.1. 静态链接"></a>4.8.1. 静态链接</h3><p>当一个字节码文件被装载进 JVM 内部时，如果被调用的<mark>目标方法在编译期可知，且运行期保持不变时</mark>，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h3 id="4-8-2-动态链接"><a href="#4-8-2-动态链接" class="headerlink" title="4.8.2. 动态链接"></a>4.8.2. 动态链接</h3><p>如果<mark>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用</mark>，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><p><mark>静态链接和动态链接不是名词，而是动词，这是理解的关键。</mark></p><hr><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<mark>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</mark></p><h3 id="4-8-3-早期绑定"><a href="#4-8-3-早期绑定" class="headerlink" title="4.8.3. 早期绑定"></a>4.8.3. 早期绑定</h3><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h3 id="4-8-4-晚期绑定"><a href="#4-8-4-晚期绑定" class="headerlink" title="4.8.4. 晚期绑定"></a>4.8.4. 晚期绑定</h3><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><hr><p>随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<mark>这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</mark></p><p>Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C++语言中的虚函数（C++中则需要使用关键字 virtual 来显式定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。</p><hr><h3 id="4-8-5-虚方法和非虚方法"><a href="#4-8-5-虚方法和非虚方法" class="headerlink" title="4.8.5. 虚方法和非虚方法"></a>4.8.5. 虚方法和非虚方法</h3><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p><p>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法。其他方法称为虚方法。</p><p>在类加载的解析阶段就可以进行解析，如下是非虚方法举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str)</span>&#123;        System. out. println(<span class="hljs-string">&quot;father &quot;</span>+str);     &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String str)</span>&#123;        System. out. println(<span class="hljs-string">&quot;father&quot;</span>+str);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualMethodTest</span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;            Son.print(<span class="hljs-string">&quot;coder&quot;</span>);            <span class="hljs-comment">//Father fa=new Father();            //fa.show(&quot;atguigu.com&quot;);        &#125;    &#125;</span><br></code></pre></td></tr></table></figure><p>虚拟机中提供了以下几条方法调用指令：</p><h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul><li><mark>invokestatic：调用静态方法，解析阶段确定唯一方法版本</mark></li><li><mark>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</mark></li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。<mark>其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（fina1 修饰的除外）称为虚方法。</mark></p><p><strong>关于 invokednamic 指令</strong></p><ul><li><p>JVM 字节码指令集一直比较稳定，一直到 Java7 中才增加了一个 invokedynamic 指令，这是<mark>Java 为了实现「动态类型语言」支持而做的一种改进。</mark></p></li><li><p>但是在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。<mark>直到 Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。</mark></p></li><li><p>Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。</p></li></ul><h4 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h4><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，<mark>静态类型语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息</mark>，这是动态语言的一个重要特征。</p><h3 id="4-8-6-方法重写的本质"><a href="#4-8-6-方法重写的本质" class="headerlink" title="4.8.6. 方法重写的本质"></a>4.8.6. 方法重写的本质</h3><p><strong>Java 语言中方法重写的本质：</strong></p><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</li><li>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出 java.1ang.AbstractMethodsrror 异常。</li></ol><p><strong>IllegalAccessError 介绍</strong></p><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h3 id="4-8-7-方法的调用：虚方法表"><a href="#4-8-7-方法的调用：虚方法表" class="headerlink" title="4.8.7. 方法的调用：虚方法表"></a>4.8.7. 方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。<mark>因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</mark></p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><p>举例 1：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057968.png" alt="image-20200706144954070"></p><p>举例 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Friendly</span>&#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayGoodbye</span><span class="hljs-params">()</span>; &#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span>&#123;    &#125;    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">tostring</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Dog&quot;</span>;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Friendly</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;     &#125;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayGoodbye</span><span class="hljs-params">()</span> &#123;    &#125;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> &#123;    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CockerSpaniel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Friendly</span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;         <span class="hljs-built_in">super</span>.sayHello();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayGoodbye</span><span class="hljs-params">()</span> &#123;    &#125;&#125;<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271057969.png" alt="image-20210509203351535"></p><h2 id="4-9-方法返回地址（return-address）"><a href="#4-9-方法返回地址（return-address）" class="headerlink" title="4.9. 方法返回地址（return address）"></a>4.9. 方法返回地址（return address）</h2><p>存放调用该方法的 pc 寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<mark>调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</mark>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<mark>正常完成出口</mark>；<ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含 ireturn（当返回值是 boolean，byte，char，short 和 int 类型时使用），lreturn（Long 类型），freturn（Float 类型），dreturn（Double 类型），areturn。另外还有一个 return 指令声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul></li><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<mark>异常完成出口</mark>。</li></ol><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Exception table:from to target type4 16  19   any19 21  19   any<br></code></pre></td></tr></table></figure><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p><p><mark>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</mark></p><h2 id="4-10-一些附加信息"><a href="#4-10-一些附加信息" class="headerlink" title="4.10. 一些附加信息"></a>4.10. 一些附加信息</h2><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="4-11-栈的相关面试题"><a href="#4-11-栈的相关面试题" class="headerlink" title="4.11. 栈的相关面试题"></a>4.11. 栈的相关面试题</h2><ul><li>举例栈溢出的情况？（StackOverflowError）<ul><li>通过 -Xss 设置栈的大小</li></ul></li><li>调整栈大小，就能保证不出现溢出么？<ul><li>不能保证不溢出</li></ul></li><li>分配的栈内存越大越好么？<ul><li>不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li>垃圾回收是否涉及到虚拟机栈？<ul><li>不会</li></ul></li><li>方法中定义的局部变量是否线程安全？<ul><li>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul></li></ul><table><thead><tr><th align="left">运行时数据区</th><th align="left">是否存在 Error</th><th align="left">是否存在 GC</th></tr></thead><tbody><tr><td align="left">程序计数器</td><td align="left">否</td><td align="left">否</td></tr><tr><td align="left">虚拟机栈</td><td align="left">是（SOE）</td><td align="left">否</td></tr><tr><td align="left">本地方法栈</td><td align="left">是</td><td align="left">否</td></tr><tr><td align="left">方法区</td><td align="left">是（OOM）</td><td align="left">是</td></tr><tr><td align="left">堆</td><td align="left">是</td><td align="left">是</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM上03_运行时数据区及程序计数器</title>
    <link href="/2025/02/27/JVM%E4%B8%8A03-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <url>/2025/02/27/JVM%E4%B8%8A03-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>笔记来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" title="尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）">尚硅谷 JVM 全套教程，百万播放，全网巅峰（宋红康详解 java 虚拟机）</a></p><p>同步更新：<a href="https://gitee.com/vectorx/NOTE_JVM">https://gitee.com/vectorx/NOTE_JVM</a></p><p><a href="https://codechina.csdn.net/qq_35925558/NOTE_JVM">https://codechina.csdn.net/qq_35925558/NOTE_JVM</a></p><p><a href="https://github.com/uxiahnan/NOTE_JVM">https://github.com/uxiahnan/NOTE_JVM</a></p></blockquote><p>[toc]</p><h1 id="3-运行时数据区及程序计数器"><a href="#3-运行时数据区及程序计数器" class="headerlink" title="3. 运行时数据区及程序计数器"></a>3. 运行时数据区及程序计数器</h1><h2 id="3-1-运行时数据区"><a href="#3-1-运行时数据区" class="headerlink" title="3.1. 运行时数据区"></a>3.1. 运行时数据区</h2><h3 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1. 概述"></a>3.1.1. 概述</h3><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054979.png" alt="image-20200705111640511"></p><p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054980.png" alt="image-20200705111843003"></p><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来探讨一下经典的 JVM 内存布局。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054981.png" alt="image-20210509174724223"></p><p>我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054982.png" alt="image-20210509174543026"></p><p>我们通过磁盘或者网络 IO 得到的数据，都需要先加载到内存中，然后 CPU 从内存中获取数据进行读取，也就是说内存充当了 CPU 和磁盘之间的桥梁</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054983.png" alt="image-20200705112416101"></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054984.png" alt="image-20200705112601211"></p><p>每个 JVM 只有一个 Runtime 实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054985.png" alt="image-20210509173410373"></p><h3 id="3-1-2-线程"><a href="#3-1-2-线程" class="headerlink" title="3.1.2. 线程"></a>3.1.2. 线程</h3><p>线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。 在 Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射。</p><p>当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。</p><p>操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run()方法。</p><h3 id="3-1-3-JVM-系统线程"><a href="#3-1-3-JVM-系统线程" class="headerlink" title="3.1.3. JVM 系统线程"></a>3.1.3. JVM 系统线程</h3><p>如果你使用 console 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[] args)</code>的 main 线程以及所有这个 main 线程自己创建的线程。</p><p>这些主要的后台系统线程在 Hotspot JVM 里主要是以下几个：</p><ul><li><mark>虚拟机线程</mark>：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li><mark>周期任务线程</mark>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li><li><mark>GC 线程</mark>：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。</li><li><mark>编译线程</mark>：这种线程在运行时会将字节码编译成到本地代码。</li><li><mark>信号调度线程</mark>：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。</li></ul><h2 id="3-2-程序计数器-PC-寄存器"><a href="#3-2-程序计数器-PC-寄存器" class="headerlink" title="3.2. 程序计数器(PC 寄存器)"></a>3.2. 程序计数器(PC 寄存器)</h2><p>JVM 中的程序计数寄存器（Program Counter Register）中，Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<mark>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</mark>。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054986.png" alt="image-20200705155551919"></p><p><strong>作用</strong></p><p>PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054987.png" alt="image-20200705155728557"></p><p>它是一块很小的内存空间，几乎可以忽略不记。也是<mark>运行速度最快的存储区域</mark>。</p><p>在 JVM 规范中，<mark>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</mark>。</p><p><mark>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法</mark>。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native 方法，则是未指定值（undefined）。</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p>它是唯一一个在 Java 虚拟机规范中没有规定任何 OutofMemoryError 情况的区域。</p><p><strong>举例说明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minus</span><span class="hljs-params">()</span>&#123;<br>    intc = <span class="hljs-number">3</span>;<br>    intd = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">return</span> c - d;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">0: iconst_3<br>1: istore_1<br>2: iconst_4<br>3: istore_2<br>4: iload_1<br>5: iload_2<br>6: isub<br>7: ireturn<br></code></pre></td></tr></table></figure><p><strong>使用 PC 寄存器存储字节码指令地址有什么用呢？为什么使用 PC 寄存器记录当前线程的执行地址呢？</strong></p><p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054988.png" alt="image-20200705161409533"></p><p><strong>PC 寄存器为什么被设定为私有的？</strong></p><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<mark>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器</mark>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p><strong>CPU 时间片</strong></p><p>CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p><p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271054989.png" alt="image-20200705161849557"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM上02_类加载子系统</title>
    <link href="/2025/02/27/JVM%E4%B8%8A02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/02/27/JVM%E4%B8%8A02-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>笔记来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" title="尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）">尚硅谷 JVM 全套教程，百万播放，全网巅峰（宋红康详解 java 虚拟机）</a></p><p>同步更新：<a href="https://gitee.com/vectorx/NOTE_JVM">https://gitee.com/vectorx/NOTE_JVM</a></p><p><a href="https://codechina.csdn.net/qq_35925558/NOTE_JVM">https://codechina.csdn.net/qq_35925558/NOTE_JVM</a></p><p><a href="https://github.com/uxiahnan/NOTE_JVM">https://github.com/uxiahnan/NOTE_JVM</a></p></blockquote><p>[toc]</p><h1 id="2-类加载子系统"><a href="#2-类加载子系统" class="headerlink" title="2. 类加载子系统"></a>2. 类加载子系统</h1><h2 id="2-1-内存结构概述"><a href="#2-1-内存结构概述" class="headerlink" title="2.1. 内存结构概述"></a>2.1. 内存结构概述</h2><ul><li>Class 文件</li><li><mark>类加载子系统</mark></li><li>运行时数据区<ul><li>方法区</li><li>堆</li><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li><li>执行引擎</li><li>本地方法接口</li><li>本地方法库</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052152.png" alt="image-20200705080719531"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052153.png" alt="image-20200705080911284"></p><p>如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><h2 id="2-2-类加载器与类的加载过程"><a href="#2-2-类加载器与类的加载过程" class="headerlink" title="2.2. 类加载器与类的加载过程"></a>2.2. 类加载器与类的加载过程</h2><p><strong>类加载器子系统作用</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052154.png" alt="image-20200705081813409"></p><ul><li>类加载器子系统负责从文件系统或者网络中加载 Class 文件，class 文件在文件开头有特定的文件标识。</li><li>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。</li><li>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</li></ul><p><strong>类加载器 ClasLoader 角色</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052155.png" alt="image-20200705081913538"></p><ul><li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例。</li><li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区。</li><li>在.class 文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</li></ul><p><strong>类的加载过程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *示例代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloLoader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用流程图表示上述示例代码：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052156.png" alt="image-20200705082255746"></p><h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052157.png" alt="image-20200705082601441"></p><ul><li><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li></ol></li><li><ol start="2"><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li></ol></li><li><ol start="3"><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li></ol></li></ul><p><strong>补充：加载 class 文件的方式</strong></p><ul><li>从<mark>本地系统</mark>中直接加载</li><li>通过<mark>网络</mark>获取，典型场景：Web Applet</li><li>从 zip<mark>压缩包</mark>中读取，成为日后 jar、war 格式的基础</li><li>运行时计算生成，使用最多的是：<mark>动态代理技术</mark></li><li>由其他文件生成，典型场景：<mark>JSP 应用</mark></li><li>从专有<mark>数据库</mark>中提取.class 文件，比较少见</li><li>从<mark>加密文件</mark>中获取，典型的防 Class 文件被反编译的保护措施</li></ul><h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><ul><li><strong>验证（Verify）</strong>：<ul><li>目的在子确保 Class 文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</li><li>主要包括四种验证，<mark>文件格式验证，元数据验证，字节码验证，符号引用验证。</mark></li></ul></li><li><strong>准备（Prepare）</strong>：<ul><li>为类变量分配内存并且设置该类变量的默认初始值，即零值。</li><li><mark>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化；</mark></li><li><mark>这里不会为实例变量分配初始化</mark>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li></ul></li><li><strong>解析（Resolve）</strong>：<ul><li>将常量池内的<mark>符号引用转换为直接引用</mark>的过程。</li><li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</li></ul></li></ul><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul><li><mark>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</mark></li><li>此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li><mark>&lt;clinit&gt;()不同于类的构造器。</mark>（关联：构造器是虚拟机视角下的&lt;init&gt;()）</li><li>若该类具有父类，JVM 会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕。</li><li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li></ul><h2 id="2-3-类加载器分类"><a href="#2-3-类加载器分类" class="headerlink" title="2.3. 类加载器分类"></a>2.3. 类加载器分类</h2><p>JVM 支持两种类型的类加载器 。分别为<mark>引导类加载器（Bootstrap ClassLoader）</mark>和<mark>自定义类加载器（User-Defined ClassLoader）</mark>。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将<mark>所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</mark>。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有 3 个，如下所示：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052158.png" alt="image-20200705094149223"></p><p>这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p><h3 id="2-3-1-虚拟机自带的加载器"><a href="#2-3-1-虚拟机自带的加载器" class="headerlink" title="2.3.1. 虚拟机自带的加载器"></a>2.3.1. 虚拟机自带的加载器</h3><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li>这个类加载使用 C&#x2F;C++语言实现的，嵌套在 JVM 内部。</li><li>它用来加载 Java 的核心库（JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li><li>并不继承自 ava.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li></ul><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。</li><li>派生于 ClassLoader 类</li><li>父类加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre&#x2F;1ib&#x2F;ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li>java 语言编写，由 sun.misc.LaunchersAppClassLoader 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li><li><mark>该类加载是程序中默认的类加载器</mark>，一般来说，Java 应用的类都是由它来完成加载</li><li>通过 ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</li></ul><h3 id="2-3-2-用户自定义类加载器"><a href="#2-3-2-用户自定义类加载器" class="headerlink" title="2.3.2. 用户自定义类加载器"></a>2.3.2. 用户自定义类加载器</h3><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。 为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ol><li>开发人员可以通过继承抽象类 ava.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK1.2 之后已不再建议用户去覆盖 loadclass() 方法，而是建议把自定义的类加载逻辑写在 findClass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><h2 id="2-4-ClassLoader-的使用说明"><a href="#2-4-ClassLoader-的使用说明" class="headerlink" title="2.4. ClassLoader 的使用说明"></a>2.4. ClassLoader 的使用说明</h2><p>ClassLoader 类是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052159.png" alt="image-20200705103516138"></p><p>sun.misc.Launcher 它是一个 java 虚拟机的入口应用</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052160.png" alt="image-20200705103636003"></p><p><strong>获取 ClassLoader 的途径</strong></p><ul><li><p>方式一：获取当前 ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">clazz.getClassLoader()<br></code></pre></td></tr></table></figure></li><li><p>方式二：获取当前线程上下文的 ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread.currentThread().getContextClassLoader()<br></code></pre></td></tr></table></figure></li><li><p>方式三：获取系统的 ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ClassLoader.getSystemClassLoader()<br></code></pre></td></tr></table></figure></li><li><p>方式四：获取调用者的 ClassLoader</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">DriverManager.getCallerClassLoader()<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-5-双亲委派机制"><a href="#2-5-双亲委派机制" class="headerlink" title="2.5. 双亲委派机制"></a>2.5. 双亲委派机制</h2><p>Java 虚拟机对 class 文件采用的是<mark>按需加载</mark>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<mark>双亲委派模式</mark>，即把请求交由父类处理，它是一种任务委派模式。</p><p><strong>工作原理</strong></p><ul><li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052161.png" alt="image-20200705105151258"></p><p><strong>举例</strong></p><p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271052162.png" alt="image-20200705105810107"></p><p><strong>优势</strong></p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心 API 被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li></ul></li></ul><p><strong>沙箱安全机制</strong></p><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p><h2 id="2-6-其他"><a href="#2-6-其他" class="headerlink" title="2.6. 其他"></a>2.6. 其他</h2><p><strong>如何判断两个 class 对象是否相同</strong></p><p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。</li></ul><p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p><p><strong>对类加载器的引用</strong></p><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会<mark>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</mark>。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</p><p><strong>类的主动使用和被动使用</strong></p><p>Java 程序对类的使用方式分为：主动使用和被动使用。</p><p>主动使用，又分为七种情况：</p><ul><li><p>创建类的实例</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（比如：Class.forName（”com.atguigu.Test”））</p></li><li><p>初始化一个类的子类</p></li><li><p>Java 虚拟机启动时被标明为启动类的类</p></li><li><p>JDK 7 开始提供的动态语言支持：</p><p>java.lang.invoke.MethodHandle 实例的解析结果</p><p>REF_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化，则初始化</p></li></ul><p>除了以上七种情况，其他使用 Java 类的方式都被看作是对<mark>类的被动使用</mark>，都<mark>不会导致类的初始化</mark>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM上01_JVM与Java体系结构</title>
    <link href="/2025/02/27/JVM%E4%B8%8A01-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2025/02/27/JVM%E4%B8%8A01-JVM%E4%B8%8EJava%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>笔记来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" title="尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）">尚硅谷 JVM 全套教程，百万播放，全网巅峰（宋红康详解 java 虚拟机）</a></p><p>同步更新：<a href="https://gitee.com/vectorx/NOTE_JVM">https://gitee.com/vectorx/NOTE_JVM</a></p><p><a href="https://codechina.csdn.net/qq_35925558/NOTE_JVM">https://codechina.csdn.net/qq_35925558/NOTE_JVM</a></p><p><a href="https://github.com/uxiahnan/NOTE_JVM">https://github.com/uxiahnan/NOTE_JVM</a></p></blockquote><p>[toc]</p><h1 id="1-JVM-与-Java-体系结构"><a href="#1-JVM-与-Java-体系结构" class="headerlink" title="1.JVM 与 Java 体系结构"></a>1.JVM 与 Java 体系结构</h1><h2 id="1-1-前言"><a href="#1-1-前言" class="headerlink" title="1.1. 前言"></a>1.1. 前言</h2><p>作为 Java 工程师的你曾被伤害过吗？你是否也遇到过这些问题？</p><ul><li>运行着的线上系统突然卡死，系统无法访问，甚至直接 OOM</li><li>想解决线上 JVM GC 问题，但却无从下手</li><li>新项目上线，对各种 JVM 参数设置一脸茫然，直接默认吧然后就 JJ 了</li><li>每次面试之前都要重新背一遍 JVM 的一些原理概念性的东西，然而面试官却经常问你在实际项目中如何调优 VM 参数，如何解决 GC、OOM 等问题，一脸懵逼</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050448.png" alt="image-20200704111417472"></p><p>大部分 Java 开发人员，除会在项目中使用到与 Java 平台相关的各种高精尖技术，对于 Java 技术的核心 Java 虚拟机了解甚少。</p><p><strong>开发人员如何看待上层框架</strong></p><p>一些有一定工作经验的开发人员，打心眼儿里觉得 SSM、微服务等上层技术才是重点，基础技术并不重要，这其实是一种本末倒置的“病态”。</p><p>如果我们把核心类库的 API 比做数学公式的话，那么 Java 虚拟机的知识就好比公式的推导过程。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050450.png" alt="image-20200704112119729"></p><p>计算机系统体系对我们来说越来越远，在不了解底层实现方式的前提下，通过高级语言很容易编写程序代码。但事实上计算机并不认识高级语言</p><p><strong>我们为什么要学习 JVM？</strong></p><ul><li>面试的需要（BATJ、TMD，PKQ 等面试都爱问）</li><li>中高级程序员必备技能<ul><li>项目管理、调优的需求</li></ul></li><li>追求极客的精神<ul><li>比如：垃圾回收算法、JIT、底层原理</li></ul></li></ul><p><strong>Java vs C++</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050451.png" alt="image-20200704112700211"></p><p>垃圾收集机制为我们打理了很多繁琐的工作，大大提高了开发的效率，但是，垃圾收集也不是万能的，懂得 JVM 内部的内存结构、工作机制，是设计高扩展性应用和诊断运行时问题的基础，也是 Java 工程师进阶的必备能力。</p><h2 id="1-2-面向人群及参考书目"><a href="#1-2-面向人群及参考书目" class="headerlink" title="1.2. 面向人群及参考书目"></a>1.2. 面向人群及参考书目</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050452.png" alt="image-20210507095948516"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050453.png" alt="image-20200704145340513"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050454.png" alt="image-20210507100021400"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050455.png" alt="image-20210507100104455"></p><h2 id="1-3-Java-及-JVM-简介"><a href="#1-3-Java-及-JVM-简介" class="headerlink" title="1.3. Java 及 JVM 简介"></a>1.3. Java 及 JVM 简介</h2><p><strong>TIOBE 语言热度排行榜：<a href="https://tiobe.com/tiobe-index/">index | TIOBE - The Software Quality Company</a></strong></p><table><thead><tr><th align="left">Programming Language</th><th align="left">2021</th><th align="left">2016</th><th align="left">2011</th><th align="left">2006</th><th align="left">2001</th><th align="left">1996</th><th align="left">1991</th><th align="left">1986</th></tr></thead><tbody><tr><td align="left">C</td><td align="left">1</td><td align="left">2</td><td align="left">2</td><td align="left">2</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">Java</td><td align="left">2</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">3</td><td align="left">26</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">Python</td><td align="left">3</td><td align="left">5</td><td align="left">6</td><td align="left">8</td><td align="left">27</td><td align="left">19</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">C++</td><td align="left">4</td><td align="left">3</td><td align="left">3</td><td align="left">3</td><td align="left">2</td><td align="left">2</td><td align="left">2</td><td align="left">8</td></tr><tr><td align="left">C#</td><td align="left">5</td><td align="left">4</td><td align="left">5</td><td align="left">7</td><td align="left">13</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">Visual Basic</td><td align="left">6</td><td align="left">13</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">JavaScript</td><td align="left">7</td><td align="left">8</td><td align="left">10</td><td align="left">9</td><td align="left">10</td><td align="left">32</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">PHP</td><td align="left">8</td><td align="left">6</td><td align="left">4</td><td align="left">4</td><td align="left">11</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">SQL</td><td align="left">9</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">R</td><td align="left">10</td><td align="left">17</td><td align="left">31</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td><td align="left">-</td></tr><tr><td align="left">Lisp</td><td align="left">34</td><td align="left">27</td><td align="left">13</td><td align="left">14</td><td align="left">17</td><td align="left">7</td><td align="left">4</td><td align="left">2</td></tr><tr><td align="left">Ada</td><td align="left">36</td><td align="left">28</td><td align="left">17</td><td align="left">16</td><td align="left">20</td><td align="left">8</td><td align="left">5</td><td align="left">3</td></tr><tr><td align="left">(Visual) Basic</td><td align="left">-</td><td align="left">-</td><td align="left">7</td><td align="left">6</td><td align="left">4</td><td align="left">3</td><td align="left">3</td><td align="left">5</td></tr></tbody></table><p>世界上没有最好的编程语言，只有最适用于具体应用场景的编程语言</p><p><strong>JVM：跨语言的平台</strong></p><p>Java 是目前应用最为广泛的软件开发平台之一。随着 Java 以及 Java 社区的不断壮大 Java 也早已不再是简简单单的一门计算机语言了，它更是一个平台、一种文化、一个社区。</p><ul><li>作为一个平台，Java 虚拟机扮演着举足轻重的作用<ul><li>Groovy、Scala、JRuby、Kotlin 等都是 Java 平台的一部分</li></ul></li><li>作为灯种文化，Java 几乎成为了“开源”的代名词。<ul><li>第三方开源软件和框架。如 Tomcat、Struts，MyBatis，Spring 等。</li><li>就连 JDK 和 JVM 自身也有不少开源的实现，如 openJDK、Harmony。</li></ul></li><li>作为一个社区，Java 拥有全世界最多的技术拥护者和开源社区支持，有数不清的论坛和资料。从桌面应用软件、嵌入式开发到企业级应用、后台服务器、中间件，都可以看到 Java 的身影。其应用形式之复杂、参与人数之众多也令人咋舌。</li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050456.png" alt="image-20200704151731216"></p><p>每个语言都需要转换成字节码文件，最后转换的字节码文件都能通过 Java 虚拟机进行运行和处理</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050457.png" alt="image-20200704152052489"></p><ul><li>随着 Java7 的正式发布，Java 虚拟机的设计者们通过 JSR-292 规范基本实现在<mark>Java 虚拟机平台上运行非 Java 语言编写的程序。</mark></li><li>Java 虚拟机根本不关心运行在其内部的程序到底是使用何种编程语言编写的，<mark>它只关心“字节码”文件</mark>。也就是说 Java 虚拟机拥有语言无关性，并不会单纯地与 Java 语言“终身绑定”，只要其他编程语言的编译结果满足并包含 Java 虚拟机的内部指令集、符号表以及其他的辅助信息，它就是一个有效的字节码文件，就能够被虚拟机所识别并装载运行。</li></ul><p><strong>字节码</strong></p><ul><li>我们平时说的 java 字节码，指的是用 java 语言编译成的字节码。准确的说任何能在 jvm 平台上执行的字节码格式都是一样的。所以应该统称为：<mark>jvm 字节码</mark>。</li><li>不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的 JVM 上运行。</li><li>Java 虚拟机与 Java 语言并没有必然的联系，它只与特定的二进制文件格式—Class 文件格式所关联，Class 文件中包含了 Java 虚拟机指令集（或者称为字节码、Bytecodes）和符号表，还有一些其他辅助信息。</li></ul><p><strong>多语言混合编程</strong></p><ul><li><mark>Java 平台上的多语言混合编程正成为主流，通过特定领域的语言去解决特定领域的问题是当前软件开发应对日趋复杂的项目需求的一个方向。</mark></li><li>试想一下，在一个项目之中，并行处理用 Clojure 语言编写，展示层使用 JRuby&#x2F;Rails，中间层则是 Java，每个应用层都将使用不同的编程语言来完成，而且，接口对每一层的开发者都是透明的，<mark>各种语言之间的交互不存在任何困难，就像使用自己语言的原生 API 一样方便，因为它们最终都运行在一个虚拟机之上。</mark></li><li>对这些运行于 Java 虚拟机之上、Java 之外的语言，来自系统级的、底层的支持正在迅速增强，以 JSR-292 为核心的一系列项目和功能改进（如 Da Vinci Machine 项目、Nashorn 引擎、InvokeDynamic 指令、java.lang.invoke 包等），<mark>推动 Java 虚拟机从“Java 语言的虚拟机”向 “多语言虚拟机”的方向发展。</mark></li></ul><p><strong>如何真正搞懂 JVM？</strong></p><p>Java 虚拟机非常复杂，要想真正理解它的工作原理，最好的方式就是自己动手编写一个！</p><p>自己动手写一个 Java 虚拟机，难吗？</p><p>天下事有难易乎？</p><p>为之，则难者亦易矣；不为，则易者亦难矣</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050458.png" alt="image-20210507102334642"></p><h2 id="1-4-Java-发展的重大事件"><a href="#1-4-Java-发展的重大事件" class="headerlink" title="1.4. Java 发展的重大事件"></a>1.4. Java 发展的重大事件</h2><ul><li>1990 年，在 Sun 计算机公司中，由 Patrick Naughton、MikeSheridan 及 James Gosling 领导的小组 Green Team，开发出的新的程序语言，命名为 oak，后期命名为 Java</li><li>1995 年，Sun 正式发布 Java 和 HotJava 产品，Java 首次公开亮相。</li><li>1996 年 1 月 23 日，Sun Microsystems 发布了 JDK 1.0。</li><li>1998 年，JDK1.2 版本发布。同时，sun 发布了 JSP&#x2F;Servlet、EJB 规范，以及将 Java 分成了 J2EE、J2SE 和 J2ME。这表明了 Java 开始向企业、桌面应用和移动设备应用 3 大领域挺进。</li><li>2000 年，JDK1.3 发布，<mark>Java HotSpot Virtual Machine 正式发布，成为 Java 的默认虚拟机。</mark></li><li>2002 年，JDK1.4 发布，古老的 Classic 虚拟机退出历史舞台。</li><li>2003 年年底，<mark>Java 平台的 Scala 正式发布，同年 Groovy 也加入了 Java 阵营。</mark></li><li>2004 年，JDK1.5 发布。同时 JDK1.5 改名为 JavaSE5.0。</li><li>2006 年，JDK6 发布。同年，<mark>Java 开源并建立了 OpenJDK</mark>。顺理成章，<mark>Hotspot 虚拟机也成为了 openJDK 中的默认虚拟机。</mark></li><li>2007 年，<mark>Java 平台迎来了新伙伴 Clojure。</mark></li><li>2008 年，Oracle 收购了 BEA，<mark>得到了 JRockit 虚拟机。</mark></li><li>2009 年，Twitter 宣布把后台大部分程序从 Ruby 迁移到 Scala，这是 Java 平台的又一次大规模应用。</li><li>2010 年，Oracle 收购了 Sun，<mark>获得 Java 商标和最真价值的 HotSpot 虚拟机</mark>。此时，Oracle 拥有市场占用率最高的两款虚拟机 HotSpot 和 JRockit，并计划在未来对它们进行整合：HotRockit</li><li>2011 年，JDK7 发布。在 JDK1.7u4 中，<mark>正式启用了新的垃圾回收器 G1。</mark></li><li>2017 年，JDK9 发布。<mark>将 G1 设置为默认 Gc，替代 CMS</mark></li><li>同年，<mark>IBM 的 J9 开源</mark>，形成了现在的 Open J9 社区</li><li>2018 年，Android 的 Java 侵权案判决，Google 赔偿 Oracle 计 88 亿美元</li><li>同年，Oracle 宣告 JavaEE 成为历史名词 JDBC、JMS、Servlet 赠予 Eclipse 基金会</li><li>同年，JDK11 发布，LTS 版本的 JDK，<mark>发布革命性的 ZGC，调整 JDK 授权许可</mark></li><li>2019 年，JDK12 发布，加入 RedHat 领导开发的<mark>shenandoah GC</mark></li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050459.png" alt="image-20200704182035810"></p><p>在 JDK11 之前，OracleJDK 中还会存在一些 OpenJDK 中没有的、闭源的功能。但在 JDK11 中，我们可以认为 OpenJDK 和 OracleJDK 代码实质上已经完全一致的程度。</p><p>不过，主流的 JDK 8 在 2019 年 01 月之后就被宣布停止更新了。另外， JDK 11 及以后的版本也不再提供免费的长期支持（LTS），而且 JDK 15 和 JDK 16 也不是一个长期支持的版本，最新的 JDK 15 只支持 6 个月时间，到 2021 年 3 月，所以千万不要把 JDK 15 等非长期支持版本用在生产。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050460.png" alt="img"></p><h2 id="1-5-虚拟机与-Java-虚拟机"><a href="#1-5-虚拟机与-Java-虚拟机" class="headerlink" title="1.5. 虚拟机与 Java 虚拟机"></a>1.5. 虚拟机与 Java 虚拟机</h2><p><strong>虚拟机</strong></p><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li>大名鼎鼎的 Visual Box，Mware 就属于系统虚拟机，它们<mark>完全是对物理计算机的仿真</mark>，提供了一个可运行完整操作系统的软件平台。</li><li>程序虚拟机的典型代表就是 Java 虚拟机，它<mark>专门为执行单个计算机程序而设计</mark>，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令。</li></ul><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p><p><strong>Java 虚拟机</strong></p><ul><li>Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其运行的 Java 字节码也未必由 Java 语言编译而成。</li><li>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li><mark>Java 技术的核心就是 Java 虚拟机</mark>（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机内部。</li></ul><p>作用</p><ul><li>Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</li></ul><p>特点</p><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><p><strong>JVM 的位置</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050461.png" alt="image-20200704183048061"></p><p>JVM 是运行在操作系统之上的，它与硬件没有直接的交互<br><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050462.png" alt="image-20210507104030823"></p><h2 id="1-6-JVM-的整体结构"><a href="#1-6-JVM-的整体结构" class="headerlink" title="1.6. JVM 的整体结构"></a>1.6. JVM 的整体结构</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050463.png" alt="image-20200704183436495"></p><ul><li>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。</li><li>它采用解释器与即时编译器并存的架构。</li><li>在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C&#x2F;C++程序一较高下的地步。</li></ul><h2 id="1-7-Java-代码执行流程"><a href="#1-7-Java-代码执行流程" class="headerlink" title="1.7. Java 代码执行流程"></a>1.7. Java 代码执行流程</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502271050464.png" alt="image-20200704210429535"></p><h2 id="1-8-JVM-的架构模型"><a href="#1-8-JVM-的架构模型" class="headerlink" title="1.8. JVM 的架构模型"></a>1.8. JVM 的架构模型</h2><p>Java 编译器输入的指令流基本上是一种基于<mark>栈的指令集架构</mark>，另外一种指令集架构则是基于<mark>寄存器的指令集架构</mark>。</p><p>具体来说：这两种架构之间的区别：</p><p><strong>基于栈式架构的特点</strong></p><ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><p><strong>基于寄存器架构的特点</strong></p><ul><li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li></ul><p><strong>举例 1</strong></p><p>同样执行 2+3 这种逻辑操作，其指令分别如下：</p><p>基于栈的计算流程（以 Java 虚拟机为例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">iconst_2 <span class="hljs-comment">//常量2入栈</span><br>istore_1<br>iconst_3 <span class="hljs-comment">// 常量3入栈</span><br>istore_2<br>iload_1<br>iload_2<br>iadd <span class="hljs-comment">//常量2/3出栈，执行相加</span><br>istore_0 <span class="hljs-comment">// 结果5入栈</span><br></code></pre></td></tr></table></figure><p>而基于寄存器的计算流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">mov eax,<span class="hljs-number">2</span> <span class="hljs-comment">//将eax寄存器的值设为1</span><br>add eax,<span class="hljs-number">3</span> <span class="hljs-comment">//使eax寄存器的值加3</span><br></code></pre></td></tr></table></figure><p><strong>举例 2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">100</span>;<br>    <span class="hljs-type">int</span> b=<span class="hljs-number">200</span>;<br>    <span class="hljs-type">int</span> c=<span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">return</span> (a + b) * c;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">&gt; javap -c Test.class<br>...<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">()</span>;<br>    Code:<br>    Stack=<span class="hljs-number">2</span>,Locals=<span class="hljs-number">4</span>,Args_size=<span class="hljs-number">1</span><br>       <span class="hljs-number">0</span>: bipush        <span class="hljs-number">100</span><br>       <span class="hljs-number">2</span>: istore_1<br>       <span class="hljs-number">3</span>: sipush        <span class="hljs-number">200</span><br>       <span class="hljs-number">6</span>: istore_2<br>       <span class="hljs-number">7</span>: sipush        <span class="hljs-number">300</span><br>      <span class="hljs-number">10</span>: istore_3<br>      <span class="hljs-number">11</span>: iload_1<br>      <span class="hljs-number">12</span>: iload_2<br>      <span class="hljs-number">13</span>: iadd<br>      <span class="hljs-number">14</span>: iload_3<br>      <span class="hljs-number">15</span>: imul<br>      <span class="hljs-number">16</span>: ireturn<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><p><mark>由于跨平台性的设计，Java 的指令都是根据栈来设计的。</mark>不同平台 CPU 架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说应该是 HotSpotVM 的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p><h2 id="1-9-JVM-的生命周期"><a href="#1-9-JVM-的生命周期" class="headerlink" title="1.9. JVM 的生命周期"></a>1.9. JVM 的生命周期</h2><p><strong>虚拟机的启动</strong></p><p>Java 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p><strong>虚拟机的执行</strong></p><ul><li>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。</li><li>程序开始执行时他才运行，程序结束时他就停止。</li><li><mark>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</mark></li></ul><p><strong>虚拟机的退出</strong></p><p>有如下的几种情况：</p><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致 Java 虚拟机进程终止</li><li>某线程调用 Runtime 类或 system 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。</li></ul><h2 id="X-JVM-的发展历程"><a href="#X-JVM-的发展历程" class="headerlink" title="X. JVM 的发展历程"></a>X. JVM 的发展历程</h2><h3 id="Sun-Classic-VM"><a href="#Sun-Classic-VM" class="headerlink" title="Sun Classic VM"></a>Sun Classic VM</h3><ul><li>早在 1996 年 Java1.0 版本的时候，Sun 公司发布了一款名为 sun classic VM 的 Java 虚拟机，它同时也是<mark>世界上第一款商用 Java 虚拟机</mark>，JDK1.4 时完全被淘汰。</li><li>这款虚拟机内部只提供解释器。现在还有及时编译器，因此效率比较低，而及时编译器会把热点代码缓存起来，那么以后使用热点代码的时候，效率就比较高。</li><li>如果使用 JIT 编译器，就需要进行外挂。但是一旦使用了 JIT 编译器，JIT 就会接管虚拟机的执行系统。解释器就不再工作。解释器和编译器不能配合工作。</li><li>现在 hotspot 内置了此虚拟机。</li></ul><h3 id="Exact-VM"><a href="#Exact-VM" class="headerlink" title="Exact VM"></a>Exact VM</h3><ul><li>为了解决上一个虚拟机问题，jdk1.2 时，Sun 提供了此虚拟机。</li><li>Exact Memory Management：准确式内存管理<ul><li>也可以叫 Non-Conservative&#x2F;Accurate Memory Management</li><li>虚拟机可以知道内存中某个位置的数据具体是什么类型。</li></ul></li><li>具备现代高性能虚拟机的维形<ul><li>热点探测</li><li>编译器与解释器混合工作模式</li></ul></li><li>只在 solaris 平台短暂使用，其他平台上还是 classic vm<ul><li>英雄气短，终被 Hotspot 虚拟机替换</li></ul></li></ul><h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><ul><li>HotSpot 历史<ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997 年，此公司被 sun 收购；2009 年，Sun 公司被甲骨文收购。</li><li>JDK1.3 时，HotSpot VM 成为默认虚拟机</li></ul></li><li><mark>目前 Hotspot 占有绝对的市场地位，称霸武林。</mark><ul><li>不管是现在仍在广泛使用的 JDK6，还是使用比例较多的 JDK8 中，默认的虚拟机都是 HotSpot</li><li>Sun &#x2F; Oracle JDK 和 OpenJDK 的默认虚拟机</li><li>因此本课程中默认介绍的虚拟机都是 HotSpot，相关机制也主要是指 HotSpot 的 Gc 机制。（比如其他两个商用虚机都没有方法区的概念）</li></ul></li><li>从服务器、桌面到移动端、嵌入式都有应用。</li><li>名称中的 HotSpot 指的就是它的热点代码探测技术。<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul><h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><ul><li><p><mark>专注于服务器端应用</mark></p><ul><li>它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li></ul></li><li><p>大量的行业基准测试显示，<mark>JRockit JVM 是世界上最快的 JVM。</mark></p><ul><li>使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了 70%）和硬件成本的减少（达 50%）。</li></ul></li><li><p>优势：全面的 Java 运行时解决方案组合</p><ul><li>JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要</li><li>MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li><p>2008 年，JRockit 被 oracle 收购。</p></li><li><p>Oracle 表达了整合两大优秀虚拟机的工作，大致在 JDK8 中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 的优秀特性。</p></li><li><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p></li></ul><h3 id="IBM-的-J9"><a href="#IBM-的-J9" class="headerlink" title="IBM 的 J9"></a>IBM 的 J9</h3><ul><li><p>全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9</p></li><li><p>市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM</p></li><li><p>广泛用于 IBM 的各种 Java 产品。</p></li><li><p>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的 Java 虚拟机。</p></li><li><p>2017 年左右，IBM 发布了开源 J9VM，命名为 openJ9，交给 EClipse 基金会管理，也称为 Eclipse OpenJ9</p></li></ul><h3 id="KVM-和-CDC-CLDC-Hotspot"><a href="#KVM-和-CDC-CLDC-Hotspot" class="headerlink" title="KVM 和 CDC &#x2F; CLDC Hotspot"></a>KVM 和 CDC &#x2F; CLDC Hotspot</h3><ul><li><p>Oracle 在 Java ME 产品线上的两款虚拟机为：CDC&#x2F;CLDC HotSpot Implementation VM</p></li><li><p>KVM（Kilobyte）是 CLDC-HI 早期产品</p></li><li><p>目前移动领域地位尴尬，智能机被 Android 和 iOS 二分天下。</p></li><li><p>KVM 简单、轻量、高度可移植，面向更低端的设备上还维持自己的一片市场</p><ul><li>智能控制器、传感器</li><li>老人手机、经济欠发达地区的功能手机</li></ul></li><li><p>所有的虚拟机的原则：一次编译，到处运行。</p></li></ul><h3 id="Azul-VM"><a href="#Azul-VM" class="headerlink" title="Azul VM"></a>Azul VM</h3><ul><li><p>前面三大“高性能 Java 虚拟机”使用在通用硬件平台上这里 Azul VW 和 BEA Liquid VM 是<mark>与特定硬件平台绑定、软硬件配合的专有虚拟机</mark></p><ul><li>高性能 Java 虚拟机中的战斗机。</li></ul></li><li><p>Azul VM 是 Azul Systems 公司在 HotSpot 基础上进行大量改进，运行于 Azul Systems 公司的专有硬件 Vega 系统上的 Java 虚拟机。</p></li><li><p><mark>每个 Azul VM 实例都可以管理至少数十个 CPU 和数百 GB 内存的硬件资源，并提供在巨大内存范围内实现可控的 GC 时间的垃圾收集器、专有硬件优化的线程调度等优秀特性。</mark></p></li><li><p>2010 年，AzulSystems 公司开始从硬件转向软件，发布了自己的 Zing JVM，可以在通用 x86 平台上提供接近于 Vega 系统的特性。</p></li></ul><h3 id="Liquid-VM"><a href="#Liquid-VM" class="headerlink" title="Liquid VM"></a>Liquid VM</h3><ul><li><p>高性能 Java 虚拟机中的战斗机。</p></li><li><p>BEA 公司开发的，直接运行在自家 Hypervisor 系统上</p></li><li><p>Liquid VM 即是现在的 JRockit VE（Virtual Edition），<mark>Liquid VM 不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如线程调度、文件系统、网络支持等。</mark></p></li><li><p>随着 JRockit 虚拟机终止开发，Liquid vM 项目也停止了。</p></li></ul><h3 id="Apache-Harmony"><a href="#Apache-Harmony" class="headerlink" title="Apache Harmony"></a>Apache Harmony</h3><ul><li><p>Apache 也曾经推出过与 JDK1.5 和 JDK1.6 兼容的 Java 运行平台 Apache Harmony。</p></li><li><p>它是 IBM 和 Intel 联合开发的开源 JVM，受到同样开源的 OpenJDK 的压制，Sun 坚决不让 Harmony 获得 JCP 认证，最终于 2011 年退役，IBM 转而参与 OpenJDK</p></li><li><p>虽然目前并没有 Apache Harmony 被大规模商用的案例，但是它的 Java 类库代码吸纳进了 Android SDK。</p></li></ul><h3 id="Micorsoft-JVM"><a href="#Micorsoft-JVM" class="headerlink" title="Micorsoft JVM"></a>Micorsoft JVM</h3><ul><li><p>微软为了在 IE3 浏览器中支持 Java Applets，开发了 Microsoft JVM。</p></li><li><p>只能在 Windows 平台下运行。但确是当时 Windows 下性能最好的 Java VM。</p></li><li><p>1997 年，Sun 以侵犯商标、不正当竞争罪名指控微软成功，赔了 Sun 很多钱。微软 WindowsXP SP3 中抹掉了其 VM。现在 Windows 上安装的 jdk 都是 HotSpot。</p></li></ul><h3 id="Taobao-JVM"><a href="#Taobao-JVM" class="headerlink" title="Taobao JVM"></a>Taobao JVM</h3><ul><li><p>由 AliJVM 团队发布。阿里，国内使用 Java 最强大的公司，覆盖云计算、金融、物流、电商等众多领域，需要解决高并发、高可用、分布式的复合问题。有大量的开源产品。</p></li><li><p><mark>基于 OpenJDK 开发了自己的定制版本 AlibabaJDK</mark>，简称 AJDK。是整个阿里 Java 体系的基石。</p></li><li><p>基于 OpenJDK Hotspot VM 发布的国内第一个优化、<mark>深度定制且开源的高性能服务器版 Java 虚拟机</mark>。</p><ul><li>创新的 GCIH（GC invisible heap）技术实现了 off-heap，<mark>即将生命周期较长的 Java 对象从 heap 中移到 heap 之外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</mark></li><li>GCIH 中的<mark>对象还能够在多个 Java 虚拟机进程中实现共享</mark></li><li>使用 crc32 指令实现 JVM intrinsic 降低 JNI 的调用开销</li><li>PMU hardware 的 Java profiling tool 和诊断协助功能</li><li>针对大数据场景的 ZenGc</li></ul></li><li><p>taobao vm 应用在阿里产品上性能高，硬件严重依赖 intel 的 cpu，损失了兼容性，但提高了性能</p><ul><li>目前已经在淘宝、天猫上线，把 oracle 官方 JvM 版本全部替换了。</li></ul></li></ul><h3 id="Dalvik-VM"><a href="#Dalvik-VM" class="headerlink" title="Dalvik VM"></a>Dalvik VM</h3><ul><li><p>谷歌开发的，应用于 Android 系统，并在 Android2.2 中提供了 JIT，发展迅猛。</p></li><li><p>Dalvik VM 只能称作虚拟机，而不能称作“Java 虚拟机”，它没有遵循 Java 虚拟机规范，不能直接执行 Java 的 Class 文件</p></li><li><p>基于寄存器架构，不是 jvm 的栈架构。</p></li><li><p>执行的是编译以后的 dex（Dalvik Executable）文件。执行效率比较高。</p><ul><li>它执行的 dex（Dalvik Executable）文件可以通过 class 文件转化而来，使用 Java 语法编写应用程序，可以直接使用大部分的 Java API 等。</li></ul></li><li><p>Android 5.0 使用支持提前编译（Ahead of Time Compilation，AoT）的 ART VM 替换 Dalvik VM。</p></li></ul><h3 id="Graal-VM"><a href="#Graal-VM" class="headerlink" title="Graal VM"></a>Graal VM</h3><ul><li><p>2018 年 4 月，oracle Labs 公开了 Graal VM，号称 “Run Programs Faster Anywhere”，野心勃勃。与 1995 年 java 的”write once，run anywhere”遥相呼应。</p></li><li><p>Graal VM 在 HotSpot VM 基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言” 的运行平台使用。语言包括：Java、Scala、Groovy、Kotlin；C、C++、Javascript、Ruby、Python、R 等</p></li><li><p>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</p></li><li><p>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。Graal VM 提供 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</p></li><li><p>如果说 HotSpot 有一天真的被取代，Graal VM 希望最大。但是 Java 的软件生态没有丝毫变化。</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以 Oracle HotSpot VM 为默认虚拟机。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MYDB record</title>
    <link href="/2025/02/21/MYDB-record/"/>
    <url>/2025/02/21/MYDB-record/</url>
    
    <content type="html"><![CDATA[<h1 id="MYDB"><a href="#MYDB" class="headerlink" title="MYDB"></a><strong>MYDB</strong></h1><h1 id="1-项目结构"><a href="#1-项目结构" class="headerlink" title="1. 项目结构"></a>1. 项目结构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502211203817.jpg" alt="img"></p><ol><li>Transaction Manager（TM）</li><li>Data Manager（DM）</li><li>Version Manager（VM）</li><li>Index Manager（IM）</li><li>Table Manager（TBM）</li></ol><p>每个模块的职责如下：</p><ol><li>TM 通过维护 XID 文件来维护事务的状态，并提供接口供其他模块来查询某个事务的状态。</li><li>DM 直接管理数据库 DB 文件和日志文件。DM 的主要职责有：1) 分页管理 DB 文件，并进行缓存；2) 管理日志文件，保证在发生错误时可以根据日志进行恢复；3) 抽象 DB 文件为 DataItem 供上层模块使用，并提供缓存。</li><li>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。</li><li>IM 实现了基于 B+ 树的索引，BTW，目前 where 只支持已索引字段。</li><li>TBM 实现了对字段和表的管理。同时，解析 SQL 语句，并根据语句操作表。</li></ol><h1 id="2-Transaction-Manager"><a href="#2-Transaction-Manager" class="headerlink" title="2. Transaction Manager"></a>2. Transaction Manager</h1><blockquote><p>TM模块通过维护一个XID文件来维护事务状态，并提供接口供其他模块来查询某个事务的状态</p></blockquote><h2 id="XID文件"><a href="#XID文件" class="headerlink" title="XID文件"></a>XID文件</h2><p>在 MYDB 中，每一个事务都有一个 XID，这个 ID 唯一标识了这个事务。事务的 XID 从 1 开始标号，并自增，不可重复。并特殊规定 <strong>XID 0 是一个超级事务（Super Transaction）</strong>。当一些操作想在没有申请事务的情况下进行，那么可以将操作的 XID 设置为 0。XID 为 0 的事务的状态永远是 committed。</p><p>TransactionManager 维护了一个 XID 格式的文件，用来记录各个事务的状态。MYDB 中，每个事务都有下面的三种状态：</p><ol><li><code>active</code>，正在进行，尚未结束</li><li><code>committed</code>，已提交</li><li><code>aborted</code>，已撤销（回滚）</li></ol><p>XID 文件给每个事务分配了一个字节的空间，用来保存其状态。同时，在 XID 文件的头部，还保存了一个 8 字节的数字，记录了这个 XID 文件管理的事务的个数。于是，<strong>事务 xid 在文件中的状态就存储在 (xid-1)+8 字节处</strong>，xid-1 是因为 xid 0（Super XID） 的状态不需要记录。（XID文件头8个字节用于记录此XID文件管理的事务数量，后面记录事务的状态）</p><h2 id="必要的常量及变量"><a href="#必要的常量及变量" class="headerlink" title="必要的常量及变量"></a>必要的常量及变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// XID文件头长度</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LEN_XID_HEADER_LENGTH</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 每个事务的占用长度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">XID_FIELD_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 事务的三种状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ACTIVE</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_COMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">FIELD_TRAN_ABORTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">// 超级事务，永远为commited状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SUPER_XID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// XID 文件后缀</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">XID_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.xid&quot;</span>;<br><br><span class="hljs-comment">// 用于获取XID文件</span><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-comment">// 文件通道，用于文件的读写</span><br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-comment">// 用于记录XID文件中事务的数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> xidCounter;<br><span class="hljs-keyword">private</span> Lock counterLock;<br></code></pre></td></tr></table></figure><h2 id="XID文件校验"><a href="#XID文件校验" class="headerlink" title="XID文件校验"></a>XID文件校验</h2><p>在构造函数创建了一个 TransactionManager 之后，首先要对 XID 文件进行校验，以保证这是一个合法的 XID 文件。校验的方式也很简单，通过<strong>文件头的 8 字节数字反推文件的理论长度，与文件的实际长度做对比</strong>。如果不同则认为 XID 文件不合法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">fileLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 记录文件的实际长度</span><br>        fileLen = file.length();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br>  <span class="hljs-comment">// 文件实际长度比文件头的8字节还小，说明文件不合法</span><br>    <span class="hljs-keyword">if</span>(fileLen &lt; LEN_XID_HEADER_LENGTH) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(LEN_XID_HEADER_LENGTH);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 设置FileChannel的position</span><br>        fc.position(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">// 从文件通道读取内容到ByteBuffer中</span><br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.xidCounter = Parser.parseLong(buf.array());<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> getXidPosition(<span class="hljs-built_in">this</span>.xidCounter + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span>(end != fileLen) &#123;<br>        Panic.panic(Error.BadXIDFileException);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 根据事务xid取得其在xid文件中对应的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getXidPosition</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-keyword">return</span> LEN_XID_HEADER_LENGTH + (xid-<span class="hljs-number">1</span>)*XID_FIELD_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="更新事务状态"><a href="#更新事务状态" class="headerlink" title="更新事务状态"></a>更新事务状态</h2><ul><li><code>begin()</code>：开启一个事务，首先设置<code>xid = xidCounter+1</code>的事务状态为<code>active</code>，随后<strong>xidCounter自增</strong></li><li><code>commit()</code>：提交一个事务，将<code>xid</code>事务的状态设置为<code>committed</code></li><li><code>abort()</code>：取消一个事务，将<code>xid</code>事务的状态设置为<code>aborted</code></li><li>这三个更新操作都可借助下面的<code>updateXID()</code>方法实现，同时开启事务还需要实现一个xidCounter自增的方法<code>incrXIDCounter()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 更新xid事务的状态为status</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">byte</span>[] tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE];<br>    tmp[<span class="hljs-number">0</span>] = status;<br>  <span class="hljs-comment">// tmp数组包装成bytebuffer数组</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(tmp);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 将ByteBuffer中的内容写入到文件通道中的offset位置，即更改事务状态</span><br>        fc.position(offset);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 所有文件操作，在执行后都需要立刻刷入文件中，防止在崩溃后文件丢失数据，fileChannel 的 force() 方法，强制同步缓存内容到文件中。force 方法的参数是一个布尔，表示是否同步文件的元数据（例如最后修改时间等）。</span><br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 将XID加一，并更新XID Header（开启一个新事务时需要此操作）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrXIDCounter</span><span class="hljs-params">()</span> &#123;<br>    xidCounter ++;<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(Parser.long2Byte(xidCounter));<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(<span class="hljs-number">0</span>);<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="检查事务状态"><a href="#检查事务状态" class="headerlink" title="检查事务状态"></a>检查事务状态</h2><p><code>isActive()</code>、<code>isCommitted()</code> 和 <code>isAborted()</code> 都是检查一个 xid 的状态，可以用一个通用的方法解决：（检查时需要排除<code>SUPER_XID</code>的情况，因为该情况一定是<code>committed</code>的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检测XID事务是否处于status状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkXID</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span> status)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getXidPosition(xid);<br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[XID_FIELD_SIZE]);<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buf.array()[<span class="hljs-number">0</span>] == status;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="创建和打开XID文件"><a href="#创建和打开XID文件" class="headerlink" title="创建和打开XID文件"></a>创建和打开XID文件</h2><p>在接口中创建的两个静态方法<code>create()</code>和<code>open()</code></p><ul><li><code>create()</code>：创建一个XID文件，并创建TM（TM的构造器需要XID文件和FileChannel）</li><li><code>open()</code>：从一个已有的XID文件来创建TM</li></ul><h1 id="3-Data-Manager"><a href="#3-Data-Manager" class="headerlink" title="3. Data Manager"></a>3. Data Manager</h1><blockquote><p>DataManager（DM）功能归纳：</p><ul><li>上层模块和文件系统中的一个抽象层。向上，提供数据包装；向下，直接读写文件。</li><li>提供日志功能。</li></ul></blockquote><h2 id="计数缓存框架"><a href="#计数缓存框架" class="headerlink" title="计数缓存框架"></a>计数缓存框架</h2><blockquote><p>分页管理和数据项（DataItem）管理涉及缓存，故抽象出一个<strong>通用缓存框架</strong>。</p></blockquote><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>**引用计数法（Reference counting）**是一种内存管理技术，它通过计算每个对象被引用的次数来判断是否需要回收该对象。当对象被创建时，引用计数为 1，每当有一个新的引用指向该对象时，计数加 1，当引用失效时，计数减 1。<strong>当计数为 0 时，该对象就可以被回收</strong>。</p><p>在 MYDB 的实践中，需要的效果是，只有上层模块<strong>主动释放引用</strong>，缓存在确保没有模块在使用这个资源了，才会去驱逐资源。于是，选择引用计数法。增加了一个方法 <code>release (key)</code>，用于在上册模块不使用某个资源时，释放对资源的引用。当引用归零时，缓存就会驱逐这个资源。</p><p>同样，在缓存满了之后，引用计数法无法自动释放缓存，此时应该直接报错（和 JVM 似的，直接 OOM）。</p><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>**LRU（least recently used）**是一种缓存淘汰算法。它的特点是根据数据最近被访问的时间来决定哪些数据应该被保留，哪些数据应该被淘汰。当缓存达到一定容量时，会淘汰掉最近最少使用的数据。</p><p>如果使用 LRU 缓存，那么只需要设计一个<code>get (key)</code>接口即可，释放缓存可以在缓存满了之后自动完成。</p><p>however，当某时刻缓存满了，缓存驱逐一个资源，此时上层模块想将某个资源强制刷回数据源，这个资源恰恰是刚被驱逐的资源。此时的上层模块会发现，资源在缓存中消失了，那么，是否有必要做回源操作？</p><ul><li><strong>不回源</strong>。由于没法确定缓存被驱逐的时间，更没法确定被驱逐之后数据项是否被修改，这样是极其不安全的</li><li><strong>回源</strong>。如果数据项被驱逐时的数据和现在又是相同的，那就是一次<strong>无效回源</strong></li><li><strong>放回缓存里，等下次被驱逐时回源</strong>。看起来解决了问题，但是此时缓存已经满了，这意味着你还需要驱逐一个资源才能放进去。这有可能会导致<strong>缓存抖动</strong>问题。</li></ul><h3 id="必要的变量"><a href="#必要的变量" class="headerlink" title="必要的变量"></a>必要的变量</h3><p><code>AbstractCache&lt;T&gt;</code>是一个抽象类，内部有两个抽象方法，留给实现类去实现具体的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当资源不在缓存时的获取行为（去数据源中获取）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当资源被驱逐时的写回行为</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(T obj)</span>;<br></code></pre></td></tr></table></figure><p>由于我们选择使用的是引用计数法实现缓存，因此除了普通的缓存功能，还需要另外<strong>维护一个计数</strong>，用于记录资源被引用的个数。除此以外，为了应对<strong>多线程场景</strong>，还需要记录哪些资源正在从数据源获取中（<strong>从数据源获取资源是一个相对费时的操作</strong>）。于是有下面三个 Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> HashMap&lt;Long, T&gt; cache;                     <span class="hljs-comment">// 实际缓存的数据</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Integer&gt; references;          <span class="hljs-comment">// 资源的引用个数</span><br><span class="hljs-keyword">private</span> HashMap&lt;Long, Boolean&gt; getting;             <span class="hljs-comment">// 正在被获取的资源</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxResource;                            <span class="hljs-comment">// 缓存的最大缓存资源数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;                              <span class="hljs-comment">// 缓存中元素的个数</span><br><span class="hljs-keyword">private</span> Lock lock;<br></code></pre></td></tr></table></figure><h3 id="get-方法获取资源"><a href="#get-方法获取资源" class="headerlink" title="get()方法获取资源"></a>get()方法获取资源</h3><ol><li>判断请求的资源是否正在被其他线程获取，若是，则过一段时间再来查看</li><li>没有其他线程在获取目标资源，到缓存中查看是否有需要的资源，若有，则直接返回</li><li>资源不在缓存中，且缓存已满，抛出<code>CacheFullException</code>异常</li><li>资源不在缓存中且缓存没满，尝试去数据源获取该资源</li><li>在数据源中没找到该资源，抛出异常</li><li>在数据源中找到需要的资源，添加到缓存中后返回</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.在通过 get() 方法获取资源时，首先进入一个死循环，来无限尝试从缓存里获取。</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        lock.lock();<br>        <span class="hljs-comment">// 1.1.首先就需要检查这个时候是否有其他线程正在从数据源获取这个资源，如果有，就过会再来看看</span><br>        <span class="hljs-keyword">if</span>(getting.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 请求的资源正在被其他线程获取</span><br>            lock.unlock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 1.2.如果没有其他线程在获取这个资源，那么就可以尝试从缓存中获取了</span><br>        <span class="hljs-keyword">if</span>(cache.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 资源在缓存中，直接返回</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-comment">// 记得给资源的引用计数加一</span><br>            references.put(key, references.get(key) + <span class="hljs-number">1</span>);<br>            lock.unlock();<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br><br>        <span class="hljs-comment">// 1.3.尝试获取该资源</span><br>        <span class="hljs-comment">// a.判断缓存是否已满，如果已满，就抛出一个异常</span><br>        <span class="hljs-keyword">if</span>(maxResource &gt; <span class="hljs-number">0</span> &amp;&amp; count == maxResource) &#123;<br>            lock.unlock();<br>            <span class="hljs-keyword">throw</span> Error.CacheFullException;<br>        &#125;<br>        <span class="hljs-comment">// b.如果缓存未满，就在 getting 中注册一下，该线程准备从数据源获取资源了</span><br>        count ++;<br>        getting.put(key, <span class="hljs-literal">true</span>);<br>        lock.unlock();<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 2.从数据源获取资源</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 调用抽象方法从数据源中获取资源</span><br>        obj = getForCache(key);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 如果获取失败，就把 getting 中的注册信息清除掉</span><br>        lock.lock();<br>        count --;<br>        getting.remove(key);<br>        lock.unlock();<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br><br>    lock.lock();<br>    getting.remove(key);       <span class="hljs-comment">// 获取完成要从 getting 中清除注册信息</span><br>    cache.put(key, obj);<br>    references.put(key, <span class="hljs-number">1</span>);<br>    lock.unlock();<br><br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="release-方法释放资源"><a href="#release-方法释放资源" class="headerlink" title="release()方法释放资源"></a>release()方法释放资源</h3><p>当引用计数references减到0后，就可以回源并删除缓存中的相关结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 3.释放资源</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 释放一个缓存时，直接从 references 中减 1，如果已经减到 0 了，就可以回源，并且删除缓存中所有相关的结构</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> references.get(key) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(ref == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            <span class="hljs-comment">// 调用抽象方法释放缓存</span><br>            releaseForCache(obj);<br>            <span class="hljs-comment">// 删除缓存中所有相关的结构</span><br>            references.remove(key);<br>            cache.remove(key);<br>            count --;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            references.put(key, ref);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="close-方法关闭缓存"><a href="#close-方法关闭缓存" class="headerlink" title="close()方法关闭缓存"></a>close()方法关闭缓存</h3><p>缓存应当还有以一个安全关闭的功能，在关闭时，需要将缓存中所有的资源强行回源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Set&lt;Long&gt; keys = cache.keySet();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> key : keys) &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> cache.get(key);<br>            releaseForCache(obj);<br>            references.remove(key);<br>            cache.remove(key);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，一个简单的缓存框架就实现完了，其他的缓存只需要继承这个类，并实现那两个抽象方法即可。</p><h2 id="数据页的缓存与管理"><a href="#数据页的缓存与管理" class="headerlink" title="数据页的缓存与管理"></a>数据页的缓存与管理</h2><h3 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h3><p>参考大部分数据库的设计，将<strong>默认数据页大小定为 8K</strong>。如果想要提升向数据库写入大量数据情况下的性能的话，也可以适当增大这个值。</p><p>上一节我们已经实现了一个通用的缓存框架，那么这一节我们需要缓存页面，就可以直接借用那个缓存的框架了。但是首先，需要<strong>定义出页面的结构</strong>。注意这个页面是存储在内存中的，与已经持久化到磁盘的抽象页面有区别。定义一个页面如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Page</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pageNumber;<span class="hljs-comment">// 页号，从1开始</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] data;<span class="hljs-comment">// 此页面实际包含的字节数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> dirty;<span class="hljs-comment">// 标识该页面是否是脏页面，在缓存驱逐的时候，脏页面需要被写回磁盘</span><br>    <span class="hljs-keyword">private</span> Lock lock;<br><br>    <span class="hljs-keyword">private</span> PageCache pc;<span class="hljs-comment">// 这里保存了一个 PageCache（还未定义）的引用，用来方便在拿到 Page 的引用时可以快速对这个页面的缓存进行释放操作。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>页面缓存接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PageCache</span> &#123;<br>  <br>  <span class="hljs-comment">// 页面大小8192</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PAGE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>;<br>  <br>    <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span>;<br>    Page <span class="hljs-title function_">getPage</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Page page)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">truncateByBgno</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPgno)</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getPageNumber</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">flushPage</span><span class="hljs-params">(Page pg)</span>;<br>  <br>  <span class="hljs-comment">// 创建一个新的.db文件</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageCacheImpl <span class="hljs-title function_">create</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> memory)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+PageCacheImpl.DB_SUFFIX);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(!f.createNewFile()) &#123;<br>                Panic.panic(Error.FileExistsException);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;<br>            Panic.panic(Error.FileCannotRWException);<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br>            fc = raf.getChannel();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageCacheImpl</span>(raf, fc, (<span class="hljs-type">int</span>)memory/PAGE_SIZE);<br>    &#125;<br><br>  <span class="hljs-comment">// 打开一个.db文件</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PageCacheImpl <span class="hljs-title function_">open</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> memory)</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+PageCacheImpl.DB_SUFFIX);<br>        <span class="hljs-keyword">if</span>(!f.exists()) &#123;<br>            Panic.panic(Error.FileNotExistsException);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!f.canRead() || !f.canWrite()) &#123;<br>            Panic.panic(Error.FileCannotRWException);<br>        &#125;<br><br>        <span class="hljs-type">FileChannel</span> <span class="hljs-variable">fc</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br>            fc = raf.getChannel();<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>           Panic.panic(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageCacheImpl</span>(raf, fc, (<span class="hljs-type">int</span>)memory/PAGE_SIZE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>页面缓存的具体实现类<code>PageCacheImpl</code>，需要继承抽象缓存框架AbstractCache，并且实现<code>getForCache() </code>和 <code>releaseForCache() </code>两个抽象方法。由于数据源就是文件系统（<strong>.db文件</strong>），<code>getForCache() </code>直接从文件中读取，并包裹成 Page 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据pageNumber从数据库文件中读取页数据，并包裹成Page</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Page <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// 页号</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)key;<br>  <span class="hljs-comment">// 页号对应的页在文件中的位置</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageCacheImpl.pageOffset(pgno);<br><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(PAGE_SIZE);<br>    fileLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        fc.position(offset);<br>        fc.read(buf);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    fileLock.unlock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, buf.array(), <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">pageOffset</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno)</span> &#123;<br>    <span class="hljs-comment">// 页号从 1 开始</span><br>    <span class="hljs-keyword">return</span> (pgno-<span class="hljs-number">1</span>) * PAGE_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<code> releaseForCache()</code>驱逐页面时，也只需要根据页面是否是脏页面，来决定是否需要写回文件系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-keyword">if</span>(pg.isDirty()) &#123;<br>        flush(pg);<br>        pg.setDirty(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pg.getPageNumber();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> pageOffset(pgno);<br><br>    fileLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(pg.getData());<br>        fc.position(offset);<br>        fc.write(buf);<br>        fc.force(<span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        fileLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>PageCache 还使用了一个 AtomicInteger，来记录了当前打开的数据库文件有多少页。这个数字在数据库文件被打开时就会被计算，并在新建页面时自增。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">newPage</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] initData)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pageNumbers.incrementAndGet();<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PageImpl</span>(pgno, initData, <span class="hljs-literal">null</span>);<br>    flush(pg);  <span class="hljs-comment">// 新建的页面需要立刻写回</span><br>    <span class="hljs-keyword">return</span> pgno;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据页管理"><a href="#数据页管理" class="headerlink" title="数据页管理"></a>数据页管理</h3><h4 id="第一页"><a href="#第一页" class="headerlink" title="第一页"></a>第一页</h4><p>数据库文件的第一页，通常用作一些特殊用途，比如存储一些元数据，用来启动检查什么的。MYDB 的第一页，只是<strong>用来做启动检查</strong>。具体的原理是，在每次数据库<strong>启动</strong>时，会生成一串随机字节，存储在 <strong>100 ~ 107</strong> 字节。在数据库<strong>正常关闭</strong>时，会将这串字节，拷贝到第一页的 1<strong>08 ~ 115</strong> 字节。</p><p>这样数据库在每次启动时，就会<strong>检查第一页两处的字节是否相同</strong>，以此来判断上一次是否正常关闭。如果是异常关闭，就需要执行数据的恢复流程。</p><p>启动时设置初始字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(Page pg)</span> &#123;<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    setVcOpen(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcOpen</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    System.arraycopy(RandomUtil.randomBytes(LEN_VC), <span class="hljs-number">0</span>, raw, OF_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure><p>关闭时拷贝字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(Page pg)</span> &#123;<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    setVcClose(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setVcClose</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    System.arraycopy(raw, OF_VC, raw, OF_VC+LEN_VC, LEN_VC);<br>&#125;<br></code></pre></td></tr></table></figure><p>校验字节：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(Page pg)</span> &#123;<br>    <span class="hljs-keyword">return</span> checkVc(pg.getData());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkVc</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    <span class="hljs-keyword">return</span> Arrays.equals(Arrays.copyOfRange(raw, OF_VC, OF_VC+LEN_VC), Arrays.copyOfRange(raw, OF_VC+LEN_VC, OF_VC+<span class="hljs-number">2</span>*LEN_VC));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="普通页"><a href="#普通页" class="headerlink" title="普通页"></a>普通页</h4><p>一个普通页面以一个 <strong>2 字节无符号数</strong>起始，表示<strong>这一页的空闲位置的偏移</strong>。剩下的部分都是实际存储的数据。对普通页的管理，基本都是围绕着对 <strong>FSO（Free Space Offset）进行的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageX</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">short</span> <span class="hljs-variable">OF_FREE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">short</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<span class="hljs-comment">// 数据起始位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_FREE_SPACE</span> <span class="hljs-operator">=</span> PageCache.PAGE_SIZE - OF_DATA;<span class="hljs-comment">// 页面最大空闲空间</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] initRaw() &#123;<br>        <span class="hljs-type">byte</span>[] raw = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[PageCache.PAGE_SIZE];<br>        setFSO(raw, OF_DATA);<br>        <span class="hljs-keyword">return</span> raw;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> ofData)</span> &#123;<br>        System.arraycopy(Parser.short2Byte(ofData), <span class="hljs-number">0</span>, raw, OF_FREE, OF_DATA);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取pg的FSO</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(Page pg)</span> &#123;<br>        <span class="hljs-keyword">return</span> getFSO(pg.getData());<br>    &#125;<br><span class="hljs-comment">// 获取页面数据row的前两个字节（这两个字节标识空闲位置的起始位置）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">getFSO</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>        <span class="hljs-keyword">return</span> Parser.parseShort(Arrays.copyOfRange(raw, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中，返回插入位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>        setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset + raw.length));<br>        <span class="hljs-keyword">return</span> offset;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取页面的空闲空间大小</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFreeSpace</span><span class="hljs-params">(Page pg)</span> &#123;<br>        <span class="hljs-keyword">return</span> PageCache.PAGE_SIZE - (<span class="hljs-type">int</span>)getFSO(pg.getData());<br>    &#125;<br><br>  <span class="hljs-comment">// 下面两个函数在updateLog 和 insertLog 的重做和撤销处理中涉及，用于在数据库崩溃后重新打开时，恢复例程直接插入数据以及修改数据使用</span><br>    <span class="hljs-comment">// 将raw插入pg中的offset位置，并将pg的offset设置为较大的offset</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverInsert</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br><br>        <span class="hljs-type">short</span> <span class="hljs-variable">rawFSO</span> <span class="hljs-operator">=</span> getFSO(pg.getData());<br>        <span class="hljs-keyword">if</span>(rawFSO &lt; offset + raw.length) &#123;<br>            setFSO(pg.getData(), (<span class="hljs-type">short</span>)(offset+raw.length));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 将raw插入pg中的offset位置，不更新update</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recoverUpdate</span><span class="hljs-params">(Page pg, <span class="hljs-type">byte</span>[] raw, <span class="hljs-type">short</span> offset)</span> &#123;<br>        pg.setDirty(<span class="hljs-literal">true</span>);<br>        System.arraycopy(raw, <span class="hljs-number">0</span>, pg.getData(), offset, raw.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="日志文件与恢复策略"><a href="#日志文件与恢复策略" class="headerlink" title="日志文件与恢复策略"></a>日志文件与恢复策略</h2><blockquote><p>MYDB 提供了崩溃后的数据恢复功能。DM 层在每次对底层数据操作时，都会记录一条日志到磁盘上。在数据库崩溃之后，再次启动时，可以根据日志的内容，恢复数据文件，保证其一致性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 必要的常量及变量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SEED</span> <span class="hljs-operator">=</span> <span class="hljs-number">13331</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// 单条记录Size的起始位置：0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_CHECKSUM</span> <span class="hljs-operator">=</span> OF_SIZE + <span class="hljs-number">4</span>;<span class="hljs-comment">// 单条记录CheckSum起始位置：4</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> OF_CHECKSUM + <span class="hljs-number">4</span>;<span class="hljs-comment">// 单条记录数据起始位置：8</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOG_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;.log&quot;</span>;<span class="hljs-comment">// 日志文件后缀</span><br><br><span class="hljs-keyword">private</span> RandomAccessFile file;<br><span class="hljs-keyword">private</span> FileChannel fc;<br><span class="hljs-keyword">private</span> Lock lock;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> position;  <span class="hljs-comment">// 当前日志指针的位置</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">long</span> fileSize;  <span class="hljs-comment">// 初始化时记录，log操作不更新</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> xChecksum;  <span class="hljs-comment">// 总校验和</span><br></code></pre></td></tr></table></figure><h3 id="日志读写"><a href="#日志读写" class="headerlink" title="日志读写"></a>日志读写</h3><h4 id="日志文件格式"><a href="#日志文件格式" class="headerlink" title="日志文件格式"></a>日志文件格式</h4><p>日志的二进制文件，按照如下的格式排布：</p><blockquote><p>[<code>XCheckSum</code>] [<code>Log1</code>] [<code>Log2</code>] [<code>Log3</code>] … [<code>LogN</code>] [<code>BadTail</code>]</p></blockquote><p>其中 <code>XChecksum</code> 是一个四字节的整数int，是<strong>对后续所有日志计算的校验和</strong>。<code>Log1</code> ~ <code>LogN</code> 是常规的日志数据，<code>BadTail</code> 是在数据库崩溃时，<strong>没有来得及写完的日志数据</strong>，这个 <code>BadTail</code> 不一定存在。</p><p>每条日志的格式如下：</p><blockquote><p>[<code>Size</code>] [<code>CheckSum</code>] [<code>Data</code>]</p></blockquote><p>其中，Size 是一个四字节整数int，标识了 <strong>Data 段的字节数</strong>。Checksum 则是<strong>该条日志的校验和int</strong>。单条日志的校验和，其实就是通过一个指定的种子实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calChecksum</span><span class="hljs-params">(<span class="hljs-type">int</span> xCheck, <span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">byte</span> b : log) &#123;<br>        xCheck = xCheck * SEED + b;<br>    &#125;<br>    <span class="hljs-keyword">return</span> xCheck;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，对所有日志求出校验和<code>CheckSum</code>，每条校验和再求和（❌）就能得到日志文件的校验和<code>XCheckSum</code>了。</p><blockquote><p>注意，文件里的<code>XCheckSum</code>和每条日志的<code>CheckSum</code>计算对象是不一样的：</p><ul><li><code>XCheckSum</code>是用后续所有日志（包括日志里的<code>size</code>、<code>checkSum</code>、<code>data</code>字段）计算得到的<ul><li><code>XCheckSum</code>是用来保证文件的完整性的，关心的是整个文件，故可以用一整条日志参与计算</li></ul></li><li>每条日志里的<code>CheckSum</code>只用到日志里的<code>data</code>字段计算得到<ul><li>这是因为每条日志里的<code>CheckSum</code>是用来确保当前日志<code>data</code>部分的完整性，故只用<code>data</code>部分计算</li><li>此外，每条日志里的<code>CheckSum</code>的计算也无法用到整条日志进行计算，这是因为整条日志里也包含自身，如果用整条日志计算<code>CheckSum</code>会用到<code>CheckSum</code>自身，这是有问题的</li></ul></li><li>因此<code>XCheckSum</code>  !&#x3D; <code>calChecksum( calChecksum( calChecksum(0, data1), data2), ... dataN)</code></li></ul></blockquote><h4 id="遍历日志文件中的每一条日志"><a href="#遍历日志文件中的每一条日志" class="headerlink" title="遍历日志文件中的每一条日志"></a>遍历日志文件中的每一条日志</h4><p>Logger 被实现成迭代器模式，通过 <code>next()</code> 方法，不断地从文件中<strong>读取下一条日志</strong>，并<strong>将其中的 <code>Data</code> 解析出来并返回</strong>，<code>next()</code> 方法的实现主要依靠 <code>internNext()</code>，大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] internNext() &#123;<br>  <span class="hljs-comment">// 位置超出文件大小</span><br>    <span class="hljs-keyword">if</span>(position + OF_DATA &gt;= fileSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 读取size，读取后position指针向后移动4位，指向checkSum开头</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>    fc.position(position);<br>    fc.read(tmp);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Parser.parseInt(tmp.array());<br>    <span class="hljs-keyword">if</span>(position + size + OF_DATA &gt; fileSize) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取checksum+data，log中包含size+checkSum+data</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(OF_DATA + size);<br>    fc.position(position);<br>    fc.read(buf);<br>    <span class="hljs-type">byte</span>[] log = buf.array();<br><br>    <span class="hljs-comment">// 校验 checksum，确保本条日志的完整性</span><br>  <span class="hljs-comment">// checkSum1:手动计算该条日志的校验和，从log的第8位到最后一位读取</span><br>  <span class="hljs-comment">// checkSum2:从日志数据log中读取该条日志的校验和，从log的4到8位读取</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">checkSum1</span> <span class="hljs-operator">=</span> calChecksum(<span class="hljs-number">0</span>, Arrays.copyOfRange(log, OF_DATA, log.length));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">checkSum2</span> <span class="hljs-operator">=</span> Parser.parseInt(Arrays.copyOfRange(log, OF_CHECKSUM, OF_DATA));<br>    <span class="hljs-keyword">if</span>(checkSum1 != checkSum2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  <span class="hljs-comment">// position指针位置指向下一条日志</span><br>    position += log.length;<br>  <span class="hljs-comment">// 返回这条日志</span><br>    <span class="hljs-keyword">return</span> log;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="校验日志文件"><a href="#校验日志文件" class="headerlink" title="校验日志文件"></a>校验日志文件</h4><p>在<strong>打开一个日志文件</strong>时，需要首先<strong>校验日志文件</strong>的 <code>XChecksum</code>，并移除文件尾部可能存在的 <code>BadTail</code>，由于 <code>BadTail</code> 该条日志尚未写入完成，文件的校验和也就不会包含该日志的校验和，去掉 <code>BadTail</code> 即可保证日志文件的一致性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndRemoveTail</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 设置position为4，也就是XCheckSum后面，第一条日志开头的位置</span><br>    rewind();<br><br>  <span class="hljs-comment">// 对每条日志的!!所有字段!!(区别于一条日志的校验和计算)计算校验和，校验和再求和得到总校验和xCheck</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">xCheck</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">byte</span>[] log = internNext();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        xCheck = calChecksum(xCheck, log);<br>    &#125;<br>  <br>  <span class="hljs-comment">// xCheckSum是从日志文件开头4个字节获得的</span><br>    <span class="hljs-keyword">if</span>(xCheck != xChecksum) &#123;<br>        Panic.panic(Error.BadLogFileException);<br>    &#125;<br><br>    <span class="hljs-comment">// 截断文件到正常日志的末尾</span><br>    truncate(position);<br>  <span class="hljs-comment">// position指针回到起点</span><br>    rewind();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rewind</span><span class="hljs-params">()</span> &#123;<br>    position = <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算总校验和是用不到它，因为它只返回了日志的数据部分</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] next() &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">byte</span>[] log = internNext();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> Arrays.copyOfRange(log, OF_DATA, log.length);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="写入日志"><a href="#写入日志" class="headerlink" title="写入日志"></a>写入日志</h4><p>向日志文件写入日志时，也是首先<strong>将数据包裹成日志格式</strong>，写入文件后，再<strong>更新文件的校验和</strong>，更新校验和时，会刷新缓冲区，保证内容写入磁盘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>  <span class="hljs-comment">// 将数据包装成日志格式[Size][CheckSum][Data]</span><br>    <span class="hljs-type">byte</span>[] log = wrapLog(data);<br>  <span class="hljs-comment">// 将包装好的一条日志包装成ByteBuffer格式</span><br>    <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(log);<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 将日志写到文件通道中的末尾</span><br>        fc.position(fc.size());<br>        fc.write(buf);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>  <span class="hljs-comment">// 更新总校验和xCheckSum（这里的log是[Size][CheckSum][Data]这样一整条日志的格式）</span><br>    updateXChecksum(log);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateXChecksum</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-built_in">this</span>.xChecksum = calChecksum(<span class="hljs-built_in">this</span>.xChecksum, log);<br>  <span class="hljs-comment">// 将更新后的总校验和xCheckSum写到文件开头4个字节的位置</span><br>    fc.position(<span class="hljs-number">0</span>);<br>    fc.write(ByteBuffer.wrap(Parser.int2Byte(xChecksum)));<br>    fc.force(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 在数据前面拼接上Size和CheckSum</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] wrapLog(<span class="hljs-type">byte</span>[] data) &#123;<br>    <span class="hljs-type">byte</span>[] checksum = Parser.int2Byte(calChecksum(<span class="hljs-number">0</span>, data));<br>    <span class="hljs-type">byte</span>[] size = Parser.int2Byte(data.length);<br>    <span class="hljs-keyword">return</span> Bytes.concat(size, checksum, data);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="恢复策略"><a href="#恢复策略" class="headerlink" title="恢复策略"></a>恢复策略</h3><p>DM 为上层模块，提供了两种操作，分别是<strong>插入新数据（I）<strong>和</strong>更新现有数据（U）</strong>。（不包含删除操作）DM 的日志策略很简单，一句话就是：</p><blockquote><p>在进行 I 和 U 操作之前，<strong>必须先进行对应的日志操作</strong>，在保证日志写入磁盘后，才进行数据操作。</p></blockquote><p>这个日志策略，使得 DM 对于数据操作的磁盘同步，可以更加随意。日志在数据操作之前，保证到达了磁盘，那么即使该数据操作最后<strong>没有来得及同步到磁盘</strong>，<strong>数据库就发生了崩溃</strong>，后续也可以<strong>通过磁盘上的日志恢复该数据</strong>。</p><p>对于两种数据操作，DM 记录的日志如下：</p><ul><li>(Ti, I, A, x)，表示事务 Ti 在 A 位置插入了一条数据 x</li><li>(Ti, U, A, oldx, newx)，表示事务 Ti 将 A 位置的数据，从 oldx 更新成 newx</li></ul><p>我们首先不考虑并发的情况，那么在某一时刻，只可能有一个事务在操作数据库。日志会看起来像下面那样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">(Ti, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Ti, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), (Tj, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Tj, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), (Tk, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>), ..., (Tk, <span class="hljs-attribute">x</span>, <span class="hljs-attribute">x</span>)<br></code></pre></td></tr></table></figure><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>由于单线程，Ti、Tj 和 Tk 的日志永远不会相交。这种情况下<strong>利用日志恢复</strong>很简单，假设日志中<strong>最后一个事务是 Ti</strong>：</p><ol><li>对 <strong>Ti 之前所有的事务</strong>的日志，进行<strong>重做（redo）</strong></li><li>接着检查 <strong>Ti 的状态（XID 文件）</strong>，如果 Ti 的状态是<strong>已完成（包括 committed 和 aborted），就将 Ti 重做，否则进行撤销（undo）</strong></li></ol><p>接着，是如何对事务 T 进行 <strong>redo</strong>：</p><ol><li><strong>正序扫描</strong>事务 T 的所有日志</li><li>如果日志是插入操作 (Ti, I, A, x)，就将 x 重新插入 A 位置</li><li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 newx</li></ol><p><strong>undo</strong> 也很好理解：</p><ol><li><strong>倒序扫描</strong>事务 T 的所有日志</li><li>如果日志是插入操作 (Ti, I, A, x)，就将 A 位置的数据删除</li><li>如果日志是更新操作 (Ti, U, A, oldx, newx)，就将 A 位置的值设置为 oldx</li></ol><p>注意，MYDB 中其实没有真正的删除操作，对于插入操作的 undo，只是将其中的标志位设置为 invalid。对于删除的探讨将在 VM 一节中进行。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>考虑以下两种情况：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 情况1</span><br><br>T1 <span class="hljs-keyword">begin</span><br>T2 <span class="hljs-keyword">begin</span><br>T2 U(<span class="hljs-variable language_">x</span>)<br>T1 R(<span class="hljs-variable language_">x</span>)<br>...<br>T1 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure><p>在系统崩溃时，T2 仍然是<strong>活跃</strong>状态（active）。那么当数据库重新启动，执行恢复例程时，会<strong>撤销 T2</strong>，它对数据库的影响会被消除。但是<strong>由于 T1 读取了 T2 更新的值</strong>，既然 T2 被撤销，那么 <strong>T1 也应当被撤销</strong>。这种情况，就是<strong>级联回滚Cascading Rollback</strong>。但是，T1 已经 commit 了，所有 commit 的事务的影响，应当被持久化。这里就造成了矛盾。所以这里需要保证：</p><blockquote><p>规定1:正在进行的事务，不会读取其他未提交的事务产生的数据（读提交Read Committed）</p></blockquote><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 情况2，假设x的初值为0</span><br><br>T1 <span class="hljs-keyword">begin</span><br>T2 <span class="hljs-keyword">begin</span><br>T1 set <span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 产生的日志为(T1, U, A, 0, 1)</span><br>T2 set <span class="hljs-variable language_">x</span> = <span class="hljs-variable language_">x</span>+<span class="hljs-number">1</span> <span class="hljs-comment">// 产生的日志为(T1, U, A, 1, 2)</span><br>T2 commit<br>MYDB <span class="hljs-keyword">break</span> down<br></code></pre></td></tr></table></figure><p>在系统崩溃时，T1 仍然是活跃状态。那么当数据库重新启动，执行恢复例程时，<strong>会对 T1 进行撤销，对 T2 进行重做</strong>，但是，无论撤销和重做的先后顺序如何，x 最后的结果，要么是 0，要么是 2，这都是错误的。</p><blockquote><p>出现这种问题的原因, 归根结底是因为我们的<strong>日志太过简单</strong>, 仅仅记录了**”前相”和”后相”<strong>. 并单纯的</strong>依靠”前相”undo, 依靠”后相”redo.** 这种简单的日志方式和恢复方式, 并不能涵盖住所有数据库操作形成的语义</p></blockquote><p>解决方法有两种：</p><ol><li>增加日志种类</li><li>限制数据库操作</li></ol><p>MYDB 采用的是<strong>限制数据库操作</strong>，需要保证：</p><blockquote><p>规定2：正在进行的事务，<strong>不会修改其他任何未提交的事务修改或产生的数据</strong>。</p></blockquote><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="两种日志的格式"><a href="#两种日志的格式" class="headerlink" title="两种日志的格式"></a><strong>两种日志的格式</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">LOG_TYPE_INSERT</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span> <span class="hljs-variable">LOG_TYPE_UPDATE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// updateLog:</span><br><span class="hljs-comment">// [LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><br><span class="hljs-comment">// insertLog:</span><br><span class="hljs-comment">// [LogType] [XID] [Pgno] [Offset] [Raw]</span><br></code></pre></td></tr></table></figure><p>和原理中描述的类似，recover 例程主要也是两步：<strong>重做所有已完成事务，撤销所有未完成事务</strong></p><h5 id="重做所有已完成事务（committed、aborted）"><a href="#重做所有已完成事务（committed、aborted）" class="headerlink" title="重做所有已完成事务（committed、aborted）"></a><strong>重做所有已完成事务（committed、aborted）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重做所有已完成事务（committed、aborted）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">redoTranscations</span><span class="hljs-params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;<br>  <span class="hljs-comment">// 从第一个事务开始（重做redo要按顺序重做）</span><br>    lg.rewind();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-comment">// 一个一个事务遍历</span><br>        <span class="hljs-type">byte</span>[] log = lg.next();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>          <span class="hljs-comment">// 如果是插入事务</span><br>            <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> li.xid;<br>            <span class="hljs-keyword">if</span>(!tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 事务状态是committed或aborted，重做插入操作</span><br>                doInsertLog(pc, log, REDO);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果是更新事务</span><br>            <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xi.xid;<br>            <span class="hljs-keyword">if</span>(!tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 事务状态是committed或aborted，重做更新操作</span><br>                doUpdateLog(pc, log, REDO);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="撤销所有未完成事务（active）"><a href="#撤销所有未完成事务（active）" class="headerlink" title="撤销所有未完成事务（active）"></a><strong>撤销所有未完成事务（active）</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 撤销所有未完成事务（active）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">undoTranscations</span><span class="hljs-params">(TransactionManager tm, Logger lg, PageCache pc)</span> &#123;<br>  <span class="hljs-comment">// 用于记录(要撤回事务的xid，事务xid要撤回的操作列表)，一个事务可能要撤回多个操作，所以要用列表记录</span><br>    Map&lt;Long, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt; logCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    lg.rewind();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">byte</span>[] log = lg.next();<br>        <span class="hljs-keyword">if</span>(log == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>          <span class="hljs-comment">// 如果是插入事务</span><br>            <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> li.xid;<br>          <span class="hljs-comment">// 事务状态是active</span><br>            <span class="hljs-keyword">if</span>(tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 把事务xid及其要撤回的操作加入到logCache中</span><br>                <span class="hljs-keyword">if</span>(!logCache.containsKey(xid)) &#123;<br>                    logCache.put(xid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                logCache.get(xid).add(log);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 如果是更新事务</span><br>            <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> xi.xid;<br>          <span class="hljs-comment">// 事务状态是active</span><br>            <span class="hljs-keyword">if</span>(tm.isActive(xid)) &#123;<br>              <span class="hljs-comment">// 把事务xid及其要撤回的操作加入到logCache中</span><br>                <span class="hljs-keyword">if</span>(!logCache.containsKey(xid)) &#123;<br>                    logCache.put(xid, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>                &#125;<br>                logCache.get(xid).add(log);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 对所有active log进行倒序undo</span><br>    <span class="hljs-keyword">for</span>(Entry&lt;Long, List&lt;<span class="hljs-type">byte</span>[]&gt;&gt; entry : logCache.entrySet()) &#123;<br>        List&lt;<span class="hljs-type">byte</span>[]&gt; logs = entry.getValue();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> logs.size()-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;<br>            <span class="hljs-type">byte</span>[] log = logs.get(i);<br>            <span class="hljs-keyword">if</span>(isInsertLog(log)) &#123;<br>                doInsertLog(pc, log, UNDO);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                doUpdateLog(pc, log, UNDO);<br>            &#125;<br>        &#125;<br>        tm.abort(entry.getKey());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判读是否是插入事务，否则是更新事务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInsertLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-keyword">return</span> log[<span class="hljs-number">0</span>] == LOG_TYPE_INSERT;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="解析插入事务与更新事务"><a href="#解析插入事务与更新事务" class="headerlink" title="解析插入事务与更新事务"></a><strong>解析插入事务与更新事务</strong></h5><ul><li><strong>解析插入事务日志</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解析插入事务日志 [LogType] [XID] [Pgno] [Offset] [Raw]</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// LogType位置：0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XID</span> <span class="hljs-operator">=</span> OF_TYPE+<span class="hljs-number">1</span>;<span class="hljs-comment">// XID位置：1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_PGNO</span> <span class="hljs-operator">=</span> OF_XID+<span class="hljs-number">8</span>;<span class="hljs-comment">// 插入事务发生的页号位置：9</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_OFFSET</span> <span class="hljs-operator">=</span> OF_INSERT_PGNO+<span class="hljs-number">4</span>;<span class="hljs-comment">// 插入事务发生在页中的位置：13</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_INSERT_RAW</span> <span class="hljs-operator">=</span> OF_INSERT_OFFSET+<span class="hljs-number">2</span>;<span class="hljs-comment">// 插入数据位置：15</span><br><br><span class="hljs-comment">// 插入事务日志信息</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InsertLogInfo</span> &#123;<br>    <span class="hljs-type">long</span> xid;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] raw;<br>&#125;<br><br><span class="hljs-comment">// 解析插入事务日志</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InsertLogInfo <span class="hljs-title function_">parseInsertLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsertLogInfo</span>();<br>    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_INSERT_PGNO));<br>    li.pgno = Parser.parseInt(Arrays.copyOfRange(log, OF_INSERT_PGNO, OF_INSERT_OFFSET));<br>    li.offset = Parser.parseShort(Arrays.copyOfRange(log, OF_INSERT_OFFSET, OF_INSERT_RAW));<br>    li.raw = Arrays.copyOfRange(log, OF_INSERT_RAW, log.length);<br>    <span class="hljs-keyword">return</span> li;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>解析更新事务日志</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 解析更新事务日志 [LogType] [XID] [UID] [OldRaw] [NewRaw]</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_UPDATE_UID</span> <span class="hljs-operator">=</span> OF_XID+<span class="hljs-number">8</span>;<span class="hljs-comment">// UID位置：9</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_UPDATE_RAW</span> <span class="hljs-operator">=</span> OF_UPDATE_UID+<span class="hljs-number">8</span>;<span class="hljs-comment">// 更新数据位置：17</span><br><br><span class="hljs-comment">// 更新事务日志信息</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpdateLogInfo</span> &#123;<br>    <span class="hljs-type">long</span> xid;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] oldRaw;<br>    <span class="hljs-type">byte</span>[] newRaw;<br>&#125;<br><br><span class="hljs-comment">// 解析更新事务日志</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> UpdateLogInfo <span class="hljs-title function_">parseUpdateLog</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] log)</span> &#123;<br>    <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateLogInfo</span>();<br>    li.xid = Parser.parseLong(Arrays.copyOfRange(log, OF_XID, OF_UPDATE_UID));<br>    <span class="hljs-type">long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> Parser.parseLong(Arrays.copyOfRange(log, OF_UPDATE_UID, OF_UPDATE_RAW));<br>    li.offset = (<span class="hljs-type">short</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">16</span>) - <span class="hljs-number">1</span>));<br>    uid &gt;&gt;&gt;= <span class="hljs-number">32</span>;<br>    li.pgno = (<span class="hljs-type">int</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>));<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (log.length - OF_UPDATE_RAW) / <span class="hljs-number">2</span>;<br>    li.oldRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW, OF_UPDATE_RAW+length);<br>    li.newRaw = Arrays.copyOfRange(log, OF_UPDATE_RAW+length, OF_UPDATE_RAW+length*<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> li;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="updateLog-和-insertLog-的重做和撤销处理"><a href="#updateLog-和-insertLog-的重做和撤销处理" class="headerlink" title="updateLog 和 insertLog 的重做和撤销处理"></a><strong>updateLog 和 insertLog 的重做和撤销处理</strong></h5><p>updateLog 和 insertLog 的重做和撤销处理，分别合并为一个方法实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// updateLog的重做和撤销处理</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doUpdateLog</span><span class="hljs-params">(PageCache pc, <span class="hljs-type">byte</span>[] log, <span class="hljs-type">int</span> flag)</span> &#123;<br>    <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-type">short</span> offset;<br>    <span class="hljs-type">byte</span>[] raw;<br>    <span class="hljs-keyword">if</span>(flag == REDO) &#123;<br>      <span class="hljs-comment">// 重做</span><br>        <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>        pgno = xi.pgno;<br>        offset = xi.offset;<br>        raw = xi.newRaw;<span class="hljs-comment">// 重做要设置数据到最新</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 撤销</span><br>        <span class="hljs-type">UpdateLogInfo</span> <span class="hljs-variable">xi</span> <span class="hljs-operator">=</span> parseUpdateLog(log);<br>        pgno = xi.pgno;<br>        offset = xi.offset;<br>        raw = xi.oldRaw;<span class="hljs-comment">// 撤销要设置数据到久版本</span><br>    &#125;<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(pgno);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 见普通页部分</span><br>        PageX.recoverUpdate(pg, raw, offset);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        pg.release();<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// insertLog的重做和撤销操作</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInsertLog</span><span class="hljs-params">(PageCache pc, <span class="hljs-type">byte</span>[] log, <span class="hljs-type">int</span> flag)</span> &#123;<br>    <span class="hljs-type">InsertLogInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> parseInsertLog(log);<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(li.pgno);<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(flag == UNDO) &#123;<br>          <span class="hljs-comment">// 撤销插入，逻辑删除，大致的作用，就是将该条 DataItem 的有效位设置为无效，来进行逻辑删除。</span><br>            DataItem.setDataItemRawInvalid(li.raw);<br>        &#125;<br>      <span class="hljs-comment">// 见普通页部分</span><br>        PageX.recoverInsert(pg, li.raw, li.offset);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        pg.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="页面索引与DM的实现"><a href="#页面索引与DM的实现" class="headerlink" title="页面索引与DM的实现"></a>页面索引与DM的实现</h2><blockquote><p>本节将为 DM 层做收尾，介绍一个实现简单的页面索引。并且实现了 DM 层对于上层的抽象：DataItem。</p></blockquote><h3 id="页面索引"><a href="#页面索引" class="headerlink" title="页面索引"></a>页面索引</h3><p>页面索引，<strong>缓存了每一页的空闲空间</strong>。用于在上层模块进行插入操作时，能够快速找到一个合适空间的页面，而<strong>无需从磁盘或者缓存中检查每一个页面的信息</strong>。</p><p>MYDB 用一个比较粗略的算法实现了页面索引，将一页的空间划分成了 <strong>40 个区间</strong>。在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这 40 个区间中。insert 在请求一个页时，会首先将所需的空间<strong>向上取整</strong>，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求。</p><p><code>PageIndex</code> 的实现也很简单，一个 List 类型的数组。</p><blockquote><p><code>lists</code>的作用是将页面信息根据页面的剩余空间分组存储，<code>THRESHOLD</code> &#x3D; 8192 &#x2F; 40 &#x3D; 204.8，这意味着，页面的剩余空间将被按大约 <strong>204.8 字节</strong>划分成多个区间，每个页面的剩余空间将根据这个阈值来计算自己属于哪个区间，并将自己的页面信息PageInfo放到对应的<code>list</code>下。打个比方：</p><ul><li>如果页面的<strong>剩余空间是 500 字节</strong>，那么它将**被划分到 500 &#x2F; 204.8 ≈ 2 的区间中（即 lists[2]）。**此时如果有一个数据，大小在 <code>[1 * 204.8, 2 * 204.8] </code>之间，那么他就会先到lists[2]中找到这个页面，并将数据保存在这个页面。</li><li>如果剩余空间是 1500 字节，那么它将被划分到 1500 &#x2F; 204.8 ≈ 7 的区间中（即 lists[7]）。</li><li>如果有多个页面，它们的<strong>剩余空间都在同一个区间内</strong>，那就会<strong>放在同一个<code>list</code>中</strong>，要取的时候，从列表头取起。</li><li>通过这个操作，要保存数据的时候就不用到磁盘中去一个个找哪个页面能够容纳这个数据，直接在<code>PageIndex</code>中就能够知道哪一页是能容纳该数据的。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageIndex</span> &#123;<br>    <span class="hljs-comment">// 将一页划成40个区间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERVALS_NO</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br>  <span class="hljs-comment">// 一个区间的大小，8192 / 40 = 204.8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> PageCache.PAGE_SIZE / INTERVALS_NO;<br><br>    <span class="hljs-keyword">private</span> Lock lock;<br>  <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">private</span> List&lt;PageInfo&gt;[] lists;<br>  <br>  <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PageIndex</span><span class="hljs-params">()</span> &#123;<br>        lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>[INTERVALS_NO+<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; INTERVALS_NO+<span class="hljs-number">1</span>; i ++) &#123;<br>            lists[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PageInfo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pgno;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> freeSpace;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PageInfo</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno, <span class="hljs-type">int</span> freeSpace)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pgno = pgno;<br>        <span class="hljs-built_in">this</span>.freeSpace = freeSpace;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当来了一个大小为<code>spaceSize</code>的数据要保存到页面时，使用<code>select()</code>方法，直接算出区间号，直接取即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> PageInfo <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">int</span> spaceSize)</span> &#123;<br>  <span class="hljs-comment">// 计算哪个区间内的页面能容纳该数据（大于number的list中包含能容纳该数据的页面）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> spaceSize / THRESHOLD;<br>    <span class="hljs-keyword">if</span>(number &lt; INTERVALS_NO) number ++;<br>    <span class="hljs-keyword">while</span>(number &lt;= INTERVALS_NO) &#123;<br>      <span class="hljs-comment">// lists[number]中没有页面，那就往下找</span><br>        <span class="hljs-keyword">if</span>(lists[number].size() == <span class="hljs-number">0</span>) &#123;<br>            number ++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>      <span class="hljs-comment">// 找到一个符合的页面，返回页面信息PageInfo，并将该页从list中移除</span><br>        <span class="hljs-keyword">return</span> lists[number].remove(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以注意到，被选择的页，会<strong>直接从 <code>PageIndex</code> 中移除</strong>，这意味着，<strong>同一个页面是不允许并发写的</strong>。在上层模块使用完这个页面后，需要将其重新插入 <code>PageIndex</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> pgno, <span class="hljs-type">int</span> freeSpace)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> freeSpace / THRESHOLD;<br>    lists[number].add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>(pgno, freeSpace));<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>DataManager</code> 被创建时，需要获取所有页面并填充 <code>PageIndex</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化pageIndex</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">fillPageIndex</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pageNumber</span> <span class="hljs-operator">=</span> pc.getPageNumber();<br>  <span class="hljs-comment">// 第一页用于启动检查，页面从1开始，故int i = 2</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= pageNumber; i ++) &#123;<br>        <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// getPage调用了AbstractCache中get方法，调用这个方法会先到缓存（HashMap cache）中找对应页号i的页面，若没有再到数据源（文件系统）找</span><br>            pg = pc.getPage(i);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>      <span class="hljs-comment">// 将对应的页面信息添加到PageIndex中</span><br>        pIndex.add(pg.getPageNumber(), PageX.getFreeSpace(pg));<br>      <span class="hljs-comment">// 注意在使用完 Page 后需要及时 release，否则可能会撑爆缓存</span><br>        pg.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DataItem"><a href="#DataItem" class="headerlink" title="DataItem"></a>DataItem</h3><p><code>DataItem</code>是 DM 层<strong>向上层提供的数据抽象</strong>。上层模块通过地址，向 DM 请求到对应的 <code>DataItem</code>，再获取到其中的数据。<code>DataItem</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dataItem 结构如下：</span><br><span class="hljs-comment"> * [ValidFlag] [DataSize] [Data]</span><br><span class="hljs-comment"> * ValidFlag 1字节，0为合法，1为非法</span><br><span class="hljs-comment"> * DataSize  2字节，标识Data的长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataItemImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataItem</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_VALID</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <span class="hljs-keyword">private</span> SubArray raw;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] oldRaw;<br>    <span class="hljs-keyword">private</span> Lock rLock;<br>    <span class="hljs-keyword">private</span> Lock wLock;<br>    <span class="hljs-keyword">private</span> DataManagerImpl dm;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> uid;<br>    <span class="hljs-keyword">private</span> Page pg;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubArray</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] raw;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> start;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SubArray</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-built_in">this</span>.raw = raw;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>DataItem</code>中<code>SubArray raw</code>的大概意思：</p><ul><li>因为数据都是放在页面里的，取数据的时候也是按页为单位取的，故**<code>raw.raw</code>一般表示的是数据所在页那一整页的数据**</li><li>所以**<code>raw.start</code>表示的是<code>DataItem</code>所表示的数据在这一页中的起始位置**（偏移<code>offset</code>）</li></ul></blockquote><p>DataItem 中保存的数据，结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[ValidFlag]</span> <span class="hljs-selector-attr">[DataSize]</span> <span class="hljs-selector-attr">[Data]</span><br></code></pre></td></tr></table></figure><p>其中 <code>ValidFlag</code> 占用 1 字节，<strong>标识了该 <code>DataItem</code> 是否有效</strong>。<strong>删除一个 <code>DataItem</code>，只需要简单地将其有效位设置为 1</strong>。<code>DataSize</code> 占用 2 字节，标识了后面 <code>Data</code> 的长度。</p><blockquote><p>根据上面<code>DataItem</code>的结构，我们有：</p><ul><li><code>offset = raw.start</code></li><li><code>ValidFlag = raw.raw[offset + OF_VALID]</code></li><li><code>DataSize = Parser.parseShort(Arrays.copyOfRange(raw, offset+DataItemImpl.OF_SIZE, offset+DataItemImpl.OF_DATA))</code></li></ul></blockquote><p>上层模块在获取到 <code>DataItem</code> 后，可以通过 <code>data()</code> 方法，该方法返回的数组是数据共享的，而不是拷贝实现的，所以使用了 <code>SubArray</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> SubArray <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(raw.raw, raw.start+OF_DATA, raw.end);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上层模块试图对 <code>DataItem</code> 进行修改时，需要遵循一定的流程：在<strong>修改之前</strong>需要调用 <code>before()</code> 方法，想要<strong>撤销修改</strong>时，调用 <code>unBefore()</code> 方法，在<strong>修改完成</strong>后，调用 <code>after()</code> 方法。整个流程，<strong>主要是为了保存前相数据，并及时落日志</strong>。DM 会保证对 <code>DataItem</code> 的修改是原子性的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>    wLock.lock();<br>    pg.setDirty(<span class="hljs-literal">true</span>);<br>    System.arraycopy(raw.raw, raw.start, oldRaw, <span class="hljs-number">0</span>, oldRaw.length);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unBefore</span><span class="hljs-params">()</span> &#123;<br>    System.arraycopy(oldRaw, <span class="hljs-number">0</span>, raw.raw, raw.start, oldRaw.length);<br>    wLock.unlock();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>  <span class="hljs-comment">// 调用 dm 中的一个方法，对修改操作落日志</span><br>    dm.logDataItem(xid, <span class="hljs-built_in">this</span>);<br>    wLock.unlock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> raw.raw[raw.start+OF_VALID] == (<span class="hljs-type">byte</span>)<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用完 <code>DataItem</code> 后，也应当及时调用 <code>release()</code>方法，释放掉 <code>DataItem</code> 的缓存（由 DM 缓存 <code>DataItem</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    dm.releaseDataItem(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="DM的实现"><a href="#DM的实现" class="headerlink" title="DM的实现"></a>DM的实现</h3><h4 id="DM读取、释放数据DataItem"><a href="#DM读取、释放数据DataItem" class="headerlink" title="DM读取、释放数据DataItem"></a>DM读取、释放数据DataItem</h4><p><code>DataManager</code> 是 DM 层直接对外提供方法的类，同时，也实现成 <code>DataItem</code> 对象的<strong>缓存</strong>，继承<code>AbstractCache</code>。<code>DataItem</code> 存储的 <strong>key</strong>，是<strong>由页号和页内偏移组成的一个 8 字节无符号整数，页号和偏移各占 4 字节</strong>。</p><p>DataItem 缓存，<code>getForCache()</code>，只需要从 key 中解析出页号，从 pageCache 中获取到页面，再根据偏移，解析出 DataItem 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> DataItem <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">16</span>) - <span class="hljs-number">1</span>));<br>    uid &gt;&gt;&gt;= <span class="hljs-number">32</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(uid &amp; ((<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>));<br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> pc.getPage(pgno);<br>    <span class="hljs-keyword">return</span> DataItem.parseDataItem(pg, offset, <span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 从页面的offset处解析处DataItem</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataItem <span class="hljs-title function_">parseDataItem</span><span class="hljs-params">(Page pg, <span class="hljs-type">short</span> offset, DataManagerImpl dm)</span> &#123;<br>  <span class="hljs-comment">// 获取这个页面的所有数据</span><br>    <span class="hljs-type">byte</span>[] raw = pg.getData();<br>  <span class="hljs-comment">// 获取这个DataItem的Data字段的长度</span><br>    <span class="hljs-type">short</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Parser.parseShort(Arrays.copyOfRange(raw, offset+DataItemImpl.OF_SIZE, offset+DataItemImpl.OF_DATA));<br>  <span class="hljs-comment">// 获取这个DataItem总长度，则这个DataItem在这个页面中的范围是[offset， offset + length]</span><br>    <span class="hljs-type">short</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(size + DataItemImpl.OF_DATA);<br>  <span class="hljs-comment">// 获取这个DataItem的uid</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> Types.addressToUid(pg.getPageNumber(), offset);<br>  <span class="hljs-comment">// 拼装成一个DataItem返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataItemImpl</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(raw, offset, offset+length), <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length], pg, uid, dm);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DataItem</code> 缓存释放，需要将 <code>DataItem</code> 写回数据源，由于对文件的读写是以页为单位进行的，只需要<strong>将 <code>DataItem</code> 所在的页 release</strong> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(DataItem di)</span> &#123;<br>    di.page().release();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DM的创建与打开"><a href="#DM的创建与打开" class="headerlink" title="DM的创建与打开"></a>DM的创建与打开</h4><p>从<strong>已有文件</strong>创建 <code>DataManager</code> 和从<strong>空文件</strong>创建 <code>DataManager</code> 的流程稍有不同，除了 PageCache 和 Logger 的创建方式有所不同以外，从<strong>空文件创建首先需要对第一页进行初始化</strong>，而<strong>从已有文件创建，则是需要对第一页进行校验</strong>，来判断是否需要执行恢复流程。并重新对第一页生成随机字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataManager <span class="hljs-title function_">create</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem, TransactionManager tm)</span> &#123;<br>    <span class="hljs-type">PageCache</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> PageCache.create(path, mem);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> Logger.create(path);<br>    <span class="hljs-type">DataManagerImpl</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataManagerImpl</span>(pc, lg, tm);<br>    dm.initPageOne();<br>    <span class="hljs-keyword">return</span> dm;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataManager <span class="hljs-title function_">open</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem, TransactionManager tm)</span> &#123;<br>    <span class="hljs-type">PageCache</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> PageCache.open(path, mem);<br>    <span class="hljs-type">Logger</span> <span class="hljs-variable">lg</span> <span class="hljs-operator">=</span> Logger.open(path);<br>    <span class="hljs-type">DataManagerImpl</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataManagerImpl</span>(pc, lg, tm);<br>    <span class="hljs-keyword">if</span>(!dm.loadCheckPageOne()) &#123;<br>        Recover.recover(tm, lg, pc);<br>    &#125;<br>    dm.fillPageIndex();<br>    PageOne.setVcOpen(dm.pageOne);<br>    dm.pc.flushPage(dm.pageOne);<br>    <span class="hljs-keyword">return</span> dm;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，初始化第一页，和校验第一页，基本都是调用 PageOne 类中的方法实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在创建文件时初始化PageOne</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">initPageOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pgno</span> <span class="hljs-operator">=</span> pc.newPage(PageOne.InitRaw());<br>    <span class="hljs-keyword">assert</span> pgno == <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pageOne = pc.getPage(pgno);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    pc.flushPage(pageOne);<br>&#125;<br><br><span class="hljs-comment">// 在打开已有文件时时读入PageOne，并验证正确性</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">loadCheckPageOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pageOne = pc.getPage(<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> PageOne.checkVc(pageOne);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DM读、插入数据"><a href="#DM读、插入数据" class="headerlink" title="DM读、插入数据"></a>DM读、插入数据</h4><p>DM 层提供了三个功能<strong>供上层使用</strong>，分别是读、插入和修改。修改是通过读出的 <code>DataItem</code> 实现的，于是 <code>DataManager</code> 只需要提供 <code>read()</code> 和 <code>insert()</code> 方法。</p><ul><li><code>read()</code> 根据 UID 从缓存中获取 DataItem，并校验有效位：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> DataItem <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DataItemImpl</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> (DataItemImpl)<span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">if</span>(!di.isValid()) &#123;<br>        di.release();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> di;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>insert()</code> 方法，在 <code>pageIndex</code> 中获取一个<strong>足以存储插入内容的页面的页号</strong>，获取页面后，<strong>首先需要写入插入日志</strong>，接着才可以<strong>通过 pageX 插入数据</strong>，并返回插入位置的偏移。最后需要<strong>将页面信息重新插入 pageIndex</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] wrapDataItemRaw(<span class="hljs-type">byte</span>[] raw) &#123;<br>    <span class="hljs-type">byte</span>[] valid = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1</span>];<span class="hljs-comment">// 起始默认值为0，表示合法</span><br>    <span class="hljs-type">byte</span>[] size = Parser.short2Byte((<span class="hljs-type">short</span>)raw.length);<br>    <span class="hljs-keyword">return</span> Bytes.concat(valid, size, raw);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-comment">// 包装成DataItem</span><br>    <span class="hljs-type">byte</span>[] raw = DataItem.wrapDataItemRaw(data);<br>    <span class="hljs-keyword">if</span>(raw.length &gt; PageX.MAX_FREE_SPACE) &#123;<br>        <span class="hljs-keyword">throw</span> Error.DataTooLargeException;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试获取可用页</span><br>    <span class="hljs-type">PageInfo</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) &#123;<br>        pi = pIndex.select(raw.length);<br>        <span class="hljs-keyword">if</span> (pi != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newPgno</span> <span class="hljs-operator">=</span> pc.newPage(PageX.initRaw());<br>            pIndex.add(newPgno, PageX.MAX_FREE_SPACE);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pi == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> Error.DatabaseBusyException;<br>    &#125;<br><br>    <span class="hljs-type">Page</span> <span class="hljs-variable">pg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">freeSpace</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        pg = pc.getPage(pi.pgno);<br>        <span class="hljs-comment">// 首先做日志</span><br>        <span class="hljs-type">byte</span>[] log = Recover.insertLog(xid, pg, raw);<br>        logger.log(log);<br>        <span class="hljs-comment">// 再执行插入操作</span><br>        <span class="hljs-type">short</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> PageX.insert(pg, raw);<br><br>        pg.release();<br>        <span class="hljs-keyword">return</span> Types.addressToUid(pi.pgno, offset);<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 将取出的pg重新插入pIndex</span><br>        <span class="hljs-keyword">if</span>(pg != <span class="hljs-literal">null</span>) &#123;<br>            pIndex.add(pi.pgno, PageX.getFreeSpace(pg));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pIndex.add(pi.pgno, freeSpace);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="DM的关闭"><a href="#DM的关闭" class="headerlink" title="DM的关闭"></a>DM的关闭</h4><p><code>DataManager</code> 正常关闭时，需要执行缓存和日志的关闭流程，不要忘了设置<strong>第一页的字节校验</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// DataManager缓存关闭</span><br>    <span class="hljs-built_in">super</span>.close();<br>  <span class="hljs-comment">// 日志关闭</span><br>    logger.close();<br><br>  <br>  <span class="hljs-comment">// 第一页的字节校验</span><br>    PageOne.setVcClose(pageOne);<br>    pageOne.release();<br>  <span class="hljs-comment">// 页面缓存关闭</span><br>    pc.close();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-Version-Manager"><a href="#4-Version-Manager" class="headerlink" title="4. Version Manager"></a>4. Version Manager</h1><blockquote><p>VM 基于两段锁协议实现了调度序列的可串行化，并实现了 MVCC 以消除读写阻塞。同时实现了两种隔离级别。类似于 Data Manager 是 MYDB 的数据管理核心，Version Manager 是 MYDB 的<strong>事务和数据版本的管理核心</strong>。</p></blockquote><h2 id="2PL与MVCC"><a href="#2PL与MVCC" class="headerlink" title="2PL与MVCC"></a>2PL与MVCC</h2><h3 id="冲突与2PL"><a href="#冲突与2PL" class="headerlink" title="冲突与2PL"></a>冲突与2PL</h3><p>首先来定义数据库的冲突，暂时不考虑插入操作，只看更新操作（U）和读操作（R），两个操作只要满足下面三个条件，就可以说这<strong>两个操作相互冲突</strong>：</p><ol><li>这两个操作是由不同的事务执行的</li><li>这两个操作操作的是同一个数据项</li><li>这两个操作至少有一个是更新操作</li></ol><p>那么这样，对同一个数据操作的冲突，其实就只有下面这两种情况：</p><ol><li>两个不同事务的 U 操作冲突</li><li>两个不同事务的 U、R 操作冲突</li></ol><p>那么冲突或者不冲突，意义何在？作用在于，<strong>交换两个互不冲突的操作的顺序，不会对最终的结果造成影响</strong>，而交换两个冲突操作的顺序，则是会有影响的。 </p><p>VM 的一个很重要的职责，就是实现了调度序列的可串行化。<strong>MYDB 采用两段锁协议（2PL）来实现。<strong>当采用 2PL 时，如果某个事务 i 已经对 x 加锁，且另一个事务 j 也想操作 x，但是这个操作与事务 i 之前的操作</strong>相互冲突</strong>的话，事务 j 就会被阻塞。譬如，T1 已经因为 U1(x) 锁定了 x，那么 T2 对 x 的<strong>读或者写操作都会被阻塞</strong>，T2 必须等待 T1 释放掉对 x 的锁。</p><p>由此来看，2PL 确实保证了调度序列的可串行话，但是不可避免地导致了<strong>事务间的相互阻塞</strong>，甚至可能导致死锁。MYDB 为了提高事务处理的效率，降低阻塞概率，实现了 MVCC。</p><h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p>在介绍 MVCC 之前，首先明确记录和版本的概念。</p><p>DM 层向上层提供了数据项（<code>DataItem</code>）的概念，VM 通过管理所有的数据项，向上层提供了记录（<code>Entry</code>）的概念。上层模块通过 VM 操作数据的最小单位，就是记录。VM 则在其内部，为每个记录，维护了多个版本（<code>Version</code>）。每当上层模块对某个记录进行修改时，VM 就会为这个记录<strong>创建一个新的版本</strong>。</p><p>MYDB 通过 MVCC，<strong>降低了事务的阻塞概率</strong>。譬如，T1 想要更新记录 X 的值，于是 T1 需要首先获取 X 的锁，接着更新，也就是<strong>创建了一个新的 X 的版本，假设为 x3</strong>。假设 T1 <strong>还没有释放</strong> X 的锁时，T2 想要读取 X 的值，这时候就不会阻塞，MYDB 会<strong>返回一个较老版本的 X，例如 x2</strong>。这样最后执行的结果，就等价于，T2 先执行，T1 后执行，调度序列依然是可串行化的。如果 X <strong>没有一个更老的版本</strong>，那<strong>只能等待 T1 释放锁</strong>了。所以只是<strong>降低了概率</strong>。</p><h2 id="记录的实现"><a href="#记录的实现" class="headerlink" title="记录的实现"></a>记录的实现</h2><p>对于一条记录来说，MYDB 使用 <code>Entry</code> 类维护了其结构。虽然理论上，MVCC 实现了多版本，但是在实现中，VM 并没有提供 <code>Update</code> 操作，对于字段的<strong>更新操作由后面的表和字段管理（TBM）实现</strong>。所以在 VM 的实现中，一条记录只有一个版本。</p><p>一条记录存储在一条 <code>DataItem</code> 中，所以 <code>Entry</code> 中保存一个 <code>DataItem</code> 的引用即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * VM向上层抽象出entry</span><br><span class="hljs-comment"> * entry结构：</span><br><span class="hljs-comment"> * [XMIN] [XMAX] [data]</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XMIN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">// entry XMIN的起始位置：0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_XMAX</span> <span class="hljs-operator">=</span> OF_XMIN+<span class="hljs-number">8</span>;<span class="hljs-comment">// entry XMAX的起始位置：8</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">OF_DATA</span> <span class="hljs-operator">=</span> OF_XMAX+<span class="hljs-number">8</span>;<span class="hljs-comment">// 注意⚠️，这里的OF_DATA=16要和DataItemImpl中的OF_DATA=3区分开来</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> uid;<br>    <span class="hljs-keyword">private</span> DataItem dataItem;<br>    <span class="hljs-keyword">private</span> VersionManager vm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title function_">loadEntry</span><span class="hljs-params">(VersionManager vm, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DataItem</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);<br>        <span class="hljs-keyword">return</span> newEntry(vm, di, uid);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        dataItem.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们规定，一条 <code>Entry</code> 中存储的数据格式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">// XMIN和XMAX都是一个<span class="hljs-number">8</span>字节的byte<span class="hljs-selector-attr">[]</span><br><span class="hljs-selector-attr">[XMIN]</span> <span class="hljs-selector-attr">[XMAX]</span> <span class="hljs-selector-attr">[DATA]</span><br></code></pre></td></tr></table></figure><p><code>XMIN</code> 是<strong>创建该条记录（版本）的事务编号</strong>，而 <code>XMAX</code> 则是<strong>删除该条记录（版本）的事务编号</strong>。它们的作用将在下一节中说明。<code>DATA</code> 就是<strong>这条记录持有的数据</strong>。根据这个结构，在<strong>创建记录</strong>时调用的 <code>wrapEntryRaw()</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] wrapEntryRaw(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data) &#123;<br>    <span class="hljs-type">byte</span>[] xmin = Parser.long2Byte(xid);<br>    <span class="hljs-type">byte</span>[] xmax = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">return</span> Bytes.concat(xmin, xmax, data);<br>&#125;<br></code></pre></td></tr></table></figure><p>同样，如果要<strong>获取记录中持有的数据</strong>，也就需要按照这个结构来解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以拷贝的形式返回内容</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] data() &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 从DataItem中取出数据部分：也就是除去VaildFlag和DataSize后面的数据部分，也是一个SubArray</span><br>        <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> dataItem.data();<br>      <span class="hljs-comment">// 取出来的数据sa也被分为[XMIN] [XMAX] [DATA]的结构，这里的OF_DATA=16</span><br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[sa.end - sa.start - OF_DATA];<br>        System.arraycopy(sa.raw, sa.start+OF_DATA, data, <span class="hljs-number">0</span>, data.length);<br>        <span class="hljs-keyword">return</span> data;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里以拷贝的形式返回数据，如果需要修改的话，需要对 <code>DataItem</code> 执行 <code>before()</code> 方法，这个在设置 <code>XMAX</code> 的值中体现了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setXmax</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    dataItem.before();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> dataItem.data();<br>      <span class="hljs-comment">// 将sa的XMAX部分修改为当前的xid</span><br>        System.arraycopy(Parser.long2Byte(xid), <span class="hljs-number">0</span>, sa.raw, sa.start+OF_XMAX, <span class="hljs-number">8</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.after(xid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="读提交（Read-Committed-RC）"><a href="#读提交（Read-Committed-RC）" class="headerlink" title="读提交（Read Committed, RC）"></a>读提交（Read Committed, RC）</h3><p>上面提到，如果一个记录的最新版本被加锁，当另一个事务想要修改或读取这条记录时，MYDB 就会返回一个较旧的版本的数据。这时就可以认为，最新的被加锁的版本，对于另一个事务来说，是不可见的。于是<strong>版本可见性</strong>的概念就诞生了。</p><p>版本的可见性与事务的隔离度是相关的。MYDB 支持的最低的事务隔离程度，是“读提交”（Read Committed），即事务在读取数据时, 只能读取已经提交事务产生的数据。保证最低的读提交的好处，第四章中已经说明（防止级联回滚与 commit 语义冲突）。</p><p>MYDB 实现读提交，为每个版本维护了两个变量，就是上面提到的 <code>XMIN</code>和 <code>XMAX</code>：</p><ul><li><code>XMIN</code>：创建该版本的事务编号</li><li><code>XMAX</code>：删除该版本的事务编号</li></ul><p><strong><code>XMIN</code> 应当在版本创建时填写，而 <code>XMAX</code> 则在版本被删除，或者有新版本出现时填写。</strong></p><p><code>XMAX</code> 这个变量，也就解释了为什么 DM 层不提供删除操作，<strong>当想删除一个版本时，只需要设置其 <code>XMAX</code></strong>，这样，<strong>这个版本对每一个 <code>XMAX</code> 之后的事务都是不可见的</strong>，也就等价于删除了。</p><p>如此，在读提交下，版本对事务的可见性逻辑如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 对于当前事务Ti，当如下逻辑判断为true时，该版本对当前事务Ti可见</span><br><br>(XMIN == Ti <span class="hljs-keyword">and</span>                             <span class="hljs-comment">// 由Ti创建且</span><br>    XMAX == NULL                            <span class="hljs-comment">// 还未被删除</span><br>)<br><span class="hljs-symbol">or</span>                                          <span class="hljs-comment">// 或</span><br>(XMIN is commited <span class="hljs-keyword">and</span>                       <span class="hljs-comment">// 由一个已提交的事务创建且</span><br>    (XMAX == NULL or                        <span class="hljs-comment">// 尚未删除或</span><br>    (XMAX != Ti <span class="hljs-keyword">and</span> XMAX is not commited)   <span class="hljs-comment">// 由一个未提交的事务删除</span><br>    )<br>)<br></code></pre></td></tr></table></figure><p>若条件为 true，则版本对 Ti 可见。那么获取 Ti 适合的版本，只需要<strong>从最新版本开始，依次向前检查可见性</strong>，如果为 true，就可以直接返回。以下方法判断某个记录对事务 t 是否可见：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">readCommitted</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>  <span class="hljs-comment">// 当前事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> t.xid;<br>  <span class="hljs-comment">// 该条记录的XMIN，即创建该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmin</span> <span class="hljs-operator">=</span> e.getXmin();<br>  <span class="hljs-comment">// 该条记录的XMAX，即删除该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  <br>  <span class="hljs-comment">// 该记录由当前事务创建，且还未被删除，则对当前事务可见</span><br>    <span class="hljs-keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 该记录由一条已提交事务创建</span><br>    <span class="hljs-keyword">if</span>(tm.isCommitted(xmin)) &#123;<br>      <span class="hljs-comment">// 该记录还未被删除，则对当前事务可见</span><br>        <span class="hljs-keyword">if</span>(xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 该记录已被删除，但不是当前事务删除的，且删除这条记录的事务还没提交，则对当前事务可见</span><br>        <span class="hljs-keyword">if</span>(xmax != xid) &#123;<br>            <span class="hljs-keyword">if</span>(!tm.isCommitted(xmax)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">// 对当前事务不可见</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可重复读（Repeatable-Read-RR）"><a href="#可重复读（Repeatable-Read-RR）" class="headerlink" title="可重复读（Repeatable Read, RR）"></a>可重复读（Repeatable Read, RR）</h3><p>读提交会导致的问题大家也都很清楚，八股也背了不少。那就是不可重复读和幻读。这里我们来解决<strong>不可重复读</strong>的问题。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">T1 begin<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1 读得 0</span><br>T2 begin<br><span class="hljs-function"><span class="hljs-title">U2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// 将 X 修改为 1</span><br>T2 commit<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1 读的 1</span><br></code></pre></td></tr></table></figure><p>T1 在第二次读取的时候，读到了已经提交的 T2 修改的值，导致了这个问题。于是我们可以规定：</p><blockquote><p>事务只能读取<strong>它开始时, 就已经结束的那些事务产生的数据版本</strong></p></blockquote><p>这条规定，相当于，事务需要<strong>忽略</strong>：</p><ol><li>在<strong>本事务后开始的事务的数据</strong>;</li><li><strong>本事务开始时还是 active 状态的事务的数据</strong></li></ol><p>对于第一条，只需要<strong>比较事务 ID，即可确定，因为事务ID是自增的</strong>。而对于第二条，则需要在<strong>事务 Ti 开始时，记录下当前活跃的所有事务 SP(Ti)</strong>，如果记录的某个版本，XMIN 在 SP(Ti) 中，说明<strong>创建这个版本记录的事务，在当前事务开始时处于active状态</strong>，也应当对 Ti 不可见。于是，可重复读的判断逻辑如下：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-comment">// 对于当前事务Ti，当如下逻辑判断为true时，该版本对当前事务Ti可见</span><br><br>(XMIN == Ti <span class="hljs-keyword">and</span>                 <span class="hljs-comment">// 由Ti创建且</span><br> (XMAX == NULL)                 <span class="hljs-comment">// 尚未被删除</span><br>)<br><span class="hljs-symbol">or</span>                              <span class="hljs-comment">// 或</span><br>(XMIN is commited <span class="hljs-keyword">and</span>           <span class="hljs-comment">// 由一个已提交的事务创建且</span><br> XMIN &lt; XID <span class="hljs-keyword">and</span>                 <span class="hljs-comment">// 这个事务小于Ti且</span><br> XMIN is not in <span class="hljs-built_in">SP</span>(Ti) <span class="hljs-keyword">and</span>      <span class="hljs-comment">// 这个事务在Ti开始前提交且</span><br> (XMAX == NULL or               <span class="hljs-comment">// 尚未被删除或</span><br>  (XMAX != Ti <span class="hljs-keyword">and</span>               <span class="hljs-comment">// 由其他事务删除但是</span><br>   (XMAX is not commited or     <span class="hljs-comment">// 这个事务尚未提交或</span><br><span class="hljs-symbol">XMAX</span> &gt; Ti or                    <span class="hljs-comment">// 这个事务在Ti开始之后才开始或</span><br><span class="hljs-symbol">XMAX</span> is in <span class="hljs-built_in">SP</span>(Ti)               <span class="hljs-comment">// 这个事务在Ti开始前还未提交</span><br>))))<br></code></pre></td></tr></table></figure><p>于是，需要提供一个结构，来抽象一个事务，以保存<strong>快照数据</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> xid;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> level;<br>  <span class="hljs-comment">// snapshot用来保存活跃事务id</span><br>    <span class="hljs-keyword">public</span> Map&lt;Long, Boolean&gt; snapshot;<br>    <span class="hljs-keyword">public</span> Exception err;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> autoAborted;<br><br>  <span class="hljs-comment">// 构造方法，active保存着当前所有状态为active的事务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Transaction <span class="hljs-title function_">newTransaction</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">int</span> level, Map&lt;Long, Transaction&gt; active)</span> &#123;<br>        <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transaction</span>();<br>        t.xid = xid;<br>        t.level = level;<br>      <span class="hljs-comment">// 如果是可重复读隔离级别，会将当前处于active的事务id保存到snapshot中</span><br>        <span class="hljs-keyword">if</span>(level != <span class="hljs-number">0</span>) &#123;<br>            t.snapshot = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span>(Long x : active.keySet()) &#123;<br>                t.snapshot.put(x, <span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInSnapshot</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>        <span class="hljs-keyword">if</span>(xid == TransactionManagerImpl.SUPER_XID) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> snapshot.containsKey(xid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是，可重复读的隔离级别下，一个版本是否对事务可见的判断如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">repeatableRead</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>  <span class="hljs-comment">// 当前事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> t.xid;<br>  <span class="hljs-comment">// 创建该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmin</span> <span class="hljs-operator">=</span> e.getXmin();<br>  <span class="hljs-comment">// 删除该记录的事务id</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  <span class="hljs-comment">// 当前事务创建了该记录 且 该记录还没被删除</span><br>    <span class="hljs-keyword">if</span>(xmin == xid &amp;&amp; xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">// 创建该记录的事务已提交 且 创建该记录的事务比当前事务早 且 当前事务创建时，创建该记录的事务不处于active状态</span><br>    <span class="hljs-keyword">if</span>(tm.isCommitted(xmin) &amp;&amp; xmin &lt; xid &amp;&amp; !t.isInSnapshot(xmin)) &#123;<br>      <span class="hljs-comment">// 该记录还未被删除</span><br>        <span class="hljs-keyword">if</span>(xmax == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      <span class="hljs-comment">// 该记录被删除，但不是当前事务删除的</span><br>        <span class="hljs-keyword">if</span>(xmax != xid) &#123;<br>          <span class="hljs-comment">// 删除该记录的事务未提交 或 删除该记录的事务比当前事务晚 或 当前事务创建时，删除该记录的事务处于active状态</span><br>            <span class="hljs-keyword">if</span>(!tm.isCommitted(xmax) || xmax &gt; xid || t.isInSnapshot(xmax)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="版本跳跃问题"><a href="#版本跳跃问题" class="headerlink" title="版本跳跃问题"></a>版本跳跃问题</h2><p>版本跳跃问题，考虑如下的情况，假设 X 最初只有 x0 版本，T1 和 T2 都是可重复读的隔离级别：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">T1 begin<br>T2 begin<br><span class="hljs-function"><span class="hljs-title">R1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1读取x0</span><br><span class="hljs-function"><span class="hljs-title">R2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T2读取x0</span><br><span class="hljs-function"><span class="hljs-title">U1</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T1将X更新到x1</span><br>T1 commit<br><span class="hljs-function"><span class="hljs-title">U2</span><span class="hljs-params">(X)</span></span> <span class="hljs-comment">// T2将X更新到x2</span><br>T2 commit<br></code></pre></td></tr></table></figure><p>这种情况实际运行起来是没问题的，但是逻辑上不太正确。T1 将 X 从 x0 更新为了 x1，这是没错的。但是 <strong>T2 则是将 X 从 x0 更新成了 x2，跳过了 x1 版本</strong>。</p><p>**读提交是允许版本跳跃的，而可重复读则是不允许版本跳跃的。**解决版本跳跃的思路也很简单：<strong>如果 Ti 需要修改 X，而 X 已经被 Ti 不可见的事务 Tj 修改了，那么要求 Ti 回滚</strong>。</p><p>上一节中就总结了，<strong>Ti 不可见的 Tj</strong>，有两种情况：</p><ol><li>XID(Tj) &gt; XID(Ti)</li><li>Tj in SP(Ti)</li></ol><p>于是版本跳跃的检查也就很简单了，取出要修改的数据 X 的最新提交版本，并<strong>检查该最新版本的创建者对当前事务是否可见</strong>：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502221957403.jpg" alt="IMG_3883 2" style="zoom:10%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检查版本跳跃 -&gt; 检查当前事务要修改的数据最新版本的创建者是否对当前事务可见</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVersionSkip</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">xmax</span> <span class="hljs-operator">=</span> e.getXmax();<br>  <span class="hljs-comment">// level = 0是读提交，可以接受版本跳跃</span><br>    <span class="hljs-keyword">if</span>(t.level == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 创建该数据的最新版本的事务已提交 且 （这个事务比当前事务创建晚 或 这个事务在当前事务创建时处于active状态），而我们当前事务想要更改这个数据，就会发生版本跳跃</span><br>        <span class="hljs-keyword">return</span> tm.isCommitted(xmax) &amp;&amp; <br>          (xmax &gt; t.xid || t.isInSnapshot(xmax));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><p>上一节提到了 2PL 会阻塞事务，直至持有锁的线程释放锁。可以将这种等待关系抽象成有向边，例如 Tj 在等待 Ti，就可以表示为 Tj –&gt; Ti。这样，无数有向边就可以形成一个图（不一定是连通图）。检测死锁也就简单了，只需要<strong>查看这个图中是否有环即可</strong>。</p><p>MYDB 使用一个 LockTable 对象，在内存中维护这张图。维护结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; x2u;  <span class="hljs-comment">// 某个XID已经获得的资源的UID列表</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Long&gt; u2x;        <span class="hljs-comment">// UID被某个XID持有</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, List&lt;Long&gt;&gt; wait; <span class="hljs-comment">// 正在等待UID的XID列表</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Lock&gt; waitLock;   <span class="hljs-comment">// 正在等待资源的XID的锁</span><br>    <span class="hljs-keyword">private</span> Map&lt;Long, Long&gt; waitU;      <span class="hljs-comment">// XID正在等待的UID</span><br>    <span class="hljs-keyword">private</span> Lock lock;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在<strong>每次出现等待的情况时，就尝试向图中增加一条边，并进行死锁检测</strong>。如果<strong>检测到死锁，就撤销这条边，不允许添加，并撤销该事务</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// xid事务想要获得uid资源</span><br><span class="hljs-comment">// 不需要等待则返回null，否则返回锁对象</span><br><span class="hljs-comment">// 会造成死锁则抛出异常</span><br><span class="hljs-keyword">public</span> Lock <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// xid事务已获得uid资源</span><br>        <span class="hljs-keyword">if</span>(isInList(x2u, xid, uid)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      <span class="hljs-comment">// 没有事务持有uid资源，则xid事务可以获取</span><br>        <span class="hljs-keyword">if</span>(!u2x.containsKey(uid)) &#123;<br>            u2x.put(uid, xid);<br>            putIntoList(x2u, xid, uid);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>      <span class="hljs-comment">// xid事务正在等待uid资源</span><br>        waitU.put(xid, uid);<br>      <span class="hljs-comment">// 将xid事务加入到等待uid资源的事务列表里</span><br>        putIntoList(wait, xid, uid);<br>      <span class="hljs-comment">// 发生死锁，抛出异常</span><br>        <span class="hljs-keyword">if</span>(hasDeadLock()) &#123;<br>            waitU.remove(xid);<br>            removeFromList(wait, uid, xid);<br>            <span class="hljs-keyword">throw</span> Error.DeadlockException;<br>        &#125;<br>      <span class="hljs-comment">// 没发生死锁，则将一个上了锁的Lock对象加入到xid事务的锁map里，返回这个锁</span><br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        l.lock();<br>        waitLock.put(xid, l);<br>        <span class="hljs-keyword">return</span> l;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 add，如果<strong>需要等待的话，会返回一个上了锁的 Lock 对象</strong>。调用方在<strong>获取到该对象时，需要尝试获取该对象的锁，由此实现阻塞线程的目的</strong>，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ⚠️</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> lt.add(xid, uid);<br><span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>    l.lock();   <span class="hljs-comment">// 阻塞在这一步？ l是一个可重入锁，同一个线程再执行加锁不会阻塞吧？</span><br>    l.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p>查找<strong>图中是否有环</strong>的算法也非常简单，就是一个深搜，只是需要注意这个图不一定是连通图。思路就是为每个节点设置一个访问戳，都初始化为 -1，随后遍历所有节点，以每个非 -1 的节点作为根进行深搜，并将深搜该连通图中遇到的所有节点都设置为同一个数字，不同的连通图数字不同。这样，如果在遍历某个图时，遇到了之前遍历过的节点，说明出现了环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasDeadLock</span><span class="hljs-params">()</span> &#123;<br>    xidStamp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    stamp = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">long</span> xid : x2u.keySet()) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> xidStamp.get(xid);<br>        <span class="hljs-keyword">if</span>(s != <span class="hljs-literal">null</span> &amp;&amp; s &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        stamp ++;<br>        <span class="hljs-keyword">if</span>(dfs(xid)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">stp</span> <span class="hljs-operator">=</span> xidStamp.get(xid);<br>    <span class="hljs-keyword">if</span>(stp != <span class="hljs-literal">null</span> &amp;&amp; stp == stamp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(stp != <span class="hljs-literal">null</span> &amp;&amp; stp &lt; stamp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    xidStamp.put(xid, stamp);<br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> waitU.get(xid);<br>    <span class="hljs-keyword">if</span>(uid == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> u2x.get(uid);<br>    <span class="hljs-keyword">assert</span> x != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> dfs(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>在一个事务 commit 或者 abort 时，就可以释放<strong>所有</strong>它持有的锁，并将自身从等待图中删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        List&lt;Long&gt; l = x2u.get(xid);<br>        <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 把所有资源都释放</span><br>            <span class="hljs-keyword">while</span>(l.size() &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Long</span> <span class="hljs-variable">uid</span> <span class="hljs-operator">=</span> l.remove(<span class="hljs-number">0</span>);<br>              <span class="hljs-comment">// 被释放的资源，从它的等待队列中选一个xid事务来占用该uid资源</span><br>                selectNewXID(uid);<br>            &#125;<br>        &#125;<br>      <br>      <span class="hljs-comment">// abort时可能还在等别的资源，abort后就不用等了，故移除waitU中的东西</span><br>        waitU.remove(xid);<br>      <span class="hljs-comment">// xid事务已释放所有资源，将xid从获得资源map中移除</span><br>        x2u.remove(xid);<br>      <span class="hljs-comment">// 因为abort时可能还在等资源，故waitLock中还有东西，要移除</span><br>        waitLock.remove(xid);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>while 循环释放掉了这个线程所有持有的资源的锁，这些资源可以被等待的线程所获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从等待队列中选择一个xid来占用uid</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectNewXID</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> &#123;<br>  <span class="hljs-comment">// 当前uid已不被占有</span><br>    u2x.remove(uid);<br>  <span class="hljs-comment">// 去uid资源的等待列表中找一个xid事务来占用</span><br>    List&lt;Long&gt; l = wait.get(uid);<br>  <span class="hljs-comment">// 没有xid想要uid</span><br>    <span class="hljs-keyword">if</span>(l == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">assert</span> l.size() &gt; <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(l.size() &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 选取等待列表中最前面的xid，并将其从wait中移除</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> l.remove(<span class="hljs-number">0</span>);<br>      <span class="hljs-comment">// 若xid没有等待资源锁，说明xid已获得过了资源，跳过这个xid</span><br>      <span class="hljs-comment">// 至于为什么获得过了还会在wait中，因为在remove那里xid释放所有资源时并没有将wait的(uid, xid)记录删除，故导致wait中xid还在等uid，但是实际上xid已经获取并释放过uid了；但是如下方所示，获取资源后会将xid从waitLock中删除，故用waitLock来判断这个xid是否还需要资源。</span><br>        <span class="hljs-keyword">if</span>(!waitLock.containsKey(xid)) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// xid占有uid</span><br>            u2x.put(uid, xid);<br>          <span class="hljs-comment">// xid的资源列表要加上uid</span><br>          <span class="hljs-comment">// putIntoList(x2u, xid, uid);</span><br>          <br>          <span class="hljs-comment">// xid的等待资源锁要移除</span><br>            <span class="hljs-type">Lock</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> waitLock.remove(xid);<br>          <span class="hljs-comment">// 将(xid,uid)从waitU中移除</span><br>            waitU.remove(xid);<br>          <span class="hljs-comment">// xid的等待资源锁解锁，才能进行获得资源后的操作</span><br>            lo.unlock();<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">// uid资源分配出去后，发现没有事务在等它了，将它从wait中移除</span><br>    <span class="hljs-keyword">if</span>(l.size() == <span class="hljs-number">0</span>) wait.remove(uid);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="VM的实现"><a href="#VM的实现" class="headerlink" title="VM的实现"></a>VM的实现</h2><p>VM 层通过 <code>VersionManager</code> 接口，向上层提供功能，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">VersionManager</span> &#123;<br>    <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时，VM 的实现类还**被设计为 <code>Entry</code> 的缓存，需要继承 <code>AbstractCache&lt;Entry&gt;</code>。**需要实现的获取到缓存和从缓存释放的方法很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Entry <span class="hljs-title function_">getForCache</span><span class="hljs-params">(<span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> Entry.loadEntry(<span class="hljs-built_in">this</span>, uid);<br>    <span class="hljs-keyword">if</span>(entry == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> Error.NullEntryException;<br>    &#125;<br>    <span class="hljs-keyword">return</span> entry;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseForCache</span><span class="hljs-params">(Entry entry)</span> &#123;<br>    entry.remove();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title function_">loadEntry</span><span class="hljs-params">(VersionManager vm, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">DataItem</span> <span class="hljs-variable">di</span> <span class="hljs-operator">=</span> ((VersionManagerImpl)vm).dm.read(uid);<br>    <span class="hljs-keyword">return</span> newEntry(vm, di, uid);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    dataItem.release();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>begin()</code> 开启一个事务，并<strong>初始化事务的结构</strong>，将其<strong>存放在 <code>activeTransaction</code> 中</strong>，用于检查和快照使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">begin</span><span class="hljs-params">(<span class="hljs-type">int</span> level)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 创建一个新事务，事务id自增并返回</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">xid</span> <span class="hljs-operator">=</span> tm.begin();<br>      <span class="hljs-comment">// 创建事务时传入activeTransaction是为了创造快照</span><br>        <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Transaction.newTransaction(xid, level, activeTransaction);<br>      <span class="hljs-comment">// 创建完将这个事务也加入active事务组中</span><br>        activeTransaction.put(xid, t);<br>        <span class="hljs-keyword">return</span> xid;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>commit()</code> 方法提交一个事务，主要就是 free 掉相关的结构，并且释放持有的锁，并修改 TM 状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(NullPointerException n) &#123;<br>        System.out.println(xid);<br>        System.out.println(activeTransaction.keySet());<br>        Panic.panic(n);<br>    &#125;<br>    lock.lock();<br>  <span class="hljs-comment">// 将xid事务从active事务中中移除</span><br>    activeTransaction.remove(xid);<br>    lock.unlock();<br>  <span class="hljs-comment">// 释放xid事务所拥有的所有资源</span><br>    lt.remove(xid);<br>  <span class="hljs-comment">// 提交xid事务</span><br>    tm.commit(xid);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>abort</code> 事务的方法则有两种，<strong>手动和自动</strong>。手动指的是调用 <code>abort()</code> 方法；而<strong>自动</strong>，则是在事务被检测出出现<strong>死锁</strong>时，会自动撤销回滚事务；或者出现<strong>版本跳跃</strong>时，也会自动回滚：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internAbort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">boolean</span> autoAborted)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    <span class="hljs-keyword">if</span>(!autoAborted) &#123;<br>        activeTransaction.remove(xid);<br>    &#125;<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.autoAborted) <span class="hljs-keyword">return</span>;<br>    lt.remove(xid);<br>    tm.abort(xid);<br>&#125;<br><br><span class="hljs-comment">// 手动abort</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> &#123;<br>    internAbort(xid, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">// 自动abort，t.autoAborted默认值为false</span><br>internAbort(xid, <span class="hljs-literal">true</span>); 然后-&gt; t.autoAborted = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><code>read()</code> 方法读取一个 <code>entry</code>，注意判断下可见性即可：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502221935459.png" alt="image-20250222193536630" style="zoom: 33%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid) <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 想要读取的资源是对于当前事务是可见的</span><br>        <span class="hljs-keyword">if</span>(Visibility.isVisible(tm, t, entry)) &#123;<br>            <span class="hljs-keyword">return</span> entry.data();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        entry.release();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isVisible</span><span class="hljs-params">(TransactionManager tm, Transaction t, Entry e)</span> &#123;<br>    <span class="hljs-keyword">if</span>(t.level == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 读提交隔离级别下查看是否可见</span><br>        <span class="hljs-keyword">return</span> readCommitted(tm, t, e);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 可重复读隔离级别下查看是否可见</span><br>        <span class="hljs-keyword">return</span> repeatableRead(tm, t, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>insert()</code> 则是将数据包裹成 Entry，无脑交给 DM 插入即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>  <span class="hljs-comment">// 将数据包裹成Entry格式：[XMIN] [XMAX] [data]，然后交给DM层</span><br>    <span class="hljs-type">byte</span>[] raw = Entry.wrapEntryRaw(xid, data);<br>  <span class="hljs-comment">// 插入时DM会再将entry包裹成DataItem格式：[ValidFlag] [DataSize] [Data]</span><br>  <span class="hljs-comment">// Entry就是这里的Data</span><br>    <span class="hljs-keyword">return</span> dm.insert(xid, raw);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>delete()</code> 方法看起来略为复杂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> xid, <span class="hljs-type">long</span> uid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    lock.lock();<br>    <span class="hljs-type">Transaction</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> activeTransaction.get(xid);<br>    lock.unlock();<br><br>    <span class="hljs-keyword">if</span>(t.err != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> t.err;<br>    &#125;<br>    <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.get(uid);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 要删除的资源对这个事务不可见，无法删除</span><br>        <span class="hljs-keyword">if</span>(!Visibility.isVisible(tm, t, entry)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 可见，就让xid去获取uid</span><br>            l = lt.add(xid, uid);<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            t.err = Error.ConcurrentUpdateException;<br>            internAbort(xid, <span class="hljs-literal">true</span>);<br>            t.autoAborted = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>      <span class="hljs-comment">// 获取非空，是一把锁</span><br>        <span class="hljs-keyword">if</span>(l != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// ⚠️由于l是一把可重入锁，当获取到一把已上锁的锁时，再在这里上锁也能上锁成功，不会发生阻塞。。。</span><br>          <span class="hljs-comment">// 而我们这段代码的思路就是要让程序阻塞在这里。。。</span><br>            l.lock();<br>            l.unlock();<br>        &#125;<br>      <span class="hljs-comment">// 本事务已经删除过了（同一个事务，前面删除过了，这次再删当然删不了）</span><br>        <span class="hljs-keyword">if</span>(entry.getXmax() == xid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>      <span class="hljs-comment">// 发生版本跳跃，抛出异常</span><br>        <span class="hljs-keyword">if</span>(Visibility.isVersionSkip(tm, t, entry)) &#123;<br>            t.err = Error.ConcurrentUpdateException;<br>            internAbort(xid, <span class="hljs-literal">true</span>);<br>            t.autoAborted = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">throw</span> t.err;<br>        &#125;<br>      <span class="hljs-comment">// 设置XMAX为本事务的xid，表明事务xid已删除这条数据</span><br>        entry.setXmax(xid);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        entry.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上主要是前置的三件事：<strong>一是可见性判断，二是获取资源的锁，三是版本跳跃判断。删除的操作只有一个设置 <code>XMAX</code>。</strong></p><h1 id="5-Index-Manager"><a href="#5-Index-Manager" class="headerlink" title="5. Index Manager"></a>5. Index Manager</h1><blockquote><p>IM，即 Index Manager，索引管理器，为 MYDB 提供了基于 B+ 树的聚簇索引。目前 <strong>MYDB 只支持基于索引查找数据</strong>，不支持全表扫描。</p></blockquote><h2 id="二叉树索引"><a href="#二叉树索引" class="headerlink" title="二叉树索引"></a>二叉树索引</h2><p>二叉树由一个个 <code>Node</code> 组成，每个 <code>Node</code> 都存储在一条 <code>DataItem</code> 中。结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[LeafFlag]</span><span class="hljs-selector-attr">[KeyNumber]</span><span class="hljs-selector-attr">[SiblingUid]</span><br><span class="hljs-selector-attr">[Son0]</span><span class="hljs-selector-attr">[Key0]</span><span class="hljs-selector-attr">[Son1]</span><span class="hljs-selector-attr">[Key1]</span>...<span class="hljs-selector-attr">[SonN]</span><span class="hljs-selector-attr">[KeyN]</span><br></code></pre></td></tr></table></figure><p>其中 <code>LeafFlag</code> 标记了该节点是否是个叶子节点；<code>KeyNumber</code> 为该节点中 key 的个数；<code>SiblingUid</code> 是其兄弟节点存储在 DM 中的 UID。后续是穿插的子节点（<code>SonN</code>）和 <code>KeyN</code>。最后的一个 <code>KeyN</code> 始终为 <code>MAX_VALUE</code>，以此方便查找。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502231400050.jpg" alt="IMG_3885"></p><p><code>Node</code> 类持有了其 B+ 树结构的引用，<code>DataItem</code> 的引用和 <code>SubArray</code> 的引用，用于方便快速修改数据和释放数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>  <br>  <span class="hljs-comment">// LeafFlag起始位置：0</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">IS_LEAF_OFFSET</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// KeyNumber起始位置：1</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NO_KEYS_OFFSET</span> <span class="hljs-operator">=</span> IS_LEAF_OFFSET+<span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// SiblingUid起始位置：3</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIBLING_OFFSET</span> <span class="hljs-operator">=</span> NO_KEYS_OFFSET+<span class="hljs-number">2</span>;<br>  <span class="hljs-comment">// Node头文件大小：[LeafFlag][KeyNumber][SiblingUid]</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NODE_HEADER_SIZE</span> <span class="hljs-operator">=</span> SIBLING_OFFSET+<span class="hljs-number">8</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BALANCE_NUMBER</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NODE_SIZE</span> <span class="hljs-operator">=</span> NODE_HEADER_SIZE + (<span class="hljs-number">2</span>*<span class="hljs-number">8</span>)*(BALANCE_NUMBER*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>);<br>  <br>    BPlusTree tree;<br>    DataItem dataItem;<br>    SubArray raw;<br>    <span class="hljs-type">long</span> uid;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>于是<strong>生成一个根节点</strong>的数据可以写成如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该根节点的初始两个子节点为 left 和 right, 初始键值为 key。</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] newRootRaw(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right, <span class="hljs-type">long</span> key)  &#123;<br>    <span class="hljs-type">SubArray</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[NODE_SIZE], <span class="hljs-number">0</span>, NODE_SIZE);<br>  <span class="hljs-comment">// 根结点为非叶节点，LeafFlag = 0</span><br>    setRawIsLeaf(raw, <span class="hljs-literal">false</span>);<br>  <span class="hljs-comment">// 有left、right两个子节点，KeyNumber = 2</span><br>    setRawNoKeys(raw, <span class="hljs-number">2</span>);<br>  <span class="hljs-comment">// 根结点没有兄弟节点，SiblingUid = 0</span><br>    setRawSibling(raw, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// left子节点为第一个子节点</span><br>    setRawKthSon(raw, left, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// 给left子节点设置初始键值：key</span><br>    setRawKthKey(raw, key, <span class="hljs-number">0</span>);<br>  <span class="hljs-comment">// right子节点为第二个子节点</span><br>    setRawKthSon(raw, right, <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 给right子节点设置键值MAX_VALUE</span><br>    setRawKthKey(raw, Long.MAX_VALUE, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> raw.raw;<br>&#125;<br></code></pre></td></tr></table></figure><p>类似的，生成一个<strong>空的根节点</strong>数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] newNilRootRaw()  &#123;<br>    <span class="hljs-type">SubArray</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[NODE_SIZE], <span class="hljs-number">0</span>, NODE_SIZE);<br>    setRawIsLeaf(raw, <span class="hljs-literal">true</span>);<br>    setRawNoKeys(raw, <span class="hljs-number">0</span>);<br>    setRawSibling(raw, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> raw.raw;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Node</code> 类有两个方法，用于辅助 B+ 树做插入和搜索操作，分别是 <code>searchNext</code> 方法和 <code>leafSearchRange</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SearchNextRes</span> &#123;<br>    <span class="hljs-type">long</span> uid;<br>    <span class="hljs-type">long</span> siblingUid;<br>&#125;<br><br><span class="hljs-comment">// searchNext 寻找对应 key 的 UID, 如果找不到, 则返回兄弟节点的 UID。</span><br><span class="hljs-keyword">public</span> SearchNextRes <span class="hljs-title function_">searchNext</span><span class="hljs-params">(<span class="hljs-type">long</span> key)</span> &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SearchNextRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchNextRes</span>();<br>      <span class="hljs-comment">// 根据raw数据，获取当前Node节点的key数量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">noKeys</span> <span class="hljs-operator">=</span> getRawNoKeys(raw);<br>      <span class="hljs-comment">// 遍历所有key</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">kth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; kth &lt; noKeys; kth ++) &#123;<br>          <span class="hljs-comment">// 获取第kth个key</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>            <span class="hljs-keyword">if</span>(key &lt; ik) &#123;<br>                res.uid = getRawKthSon(raw, kth);<br>                res.siblingUid = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        res.uid = <span class="hljs-number">0</span>;<br>        res.siblingUid = getRawSibling(raw);<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>leafSearchRange</code> 方法在<strong>当前节点进行范围查找</strong>，范围是 <code>[leftKey, rightKey]</code>，这里约定如果 <code>rightKey</code> 大于等于该节点的最大的 key, 则还<strong>同时返回兄弟节点的 UID</strong>，方便继续搜索下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> LeafSearchRangeRes <span class="hljs-title function_">leafSearchRange</span><span class="hljs-params">(<span class="hljs-type">long</span> leftKey, <span class="hljs-type">long</span> rightKey)</span> &#123;<br>    dataItem.rLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">noKeys</span> <span class="hljs-operator">=</span> getRawNoKeys(raw);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">kth</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(kth &lt; noKeys) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>          <span class="hljs-comment">// 从leftKey开始找起</span><br>            <span class="hljs-keyword">if</span>(ik &gt;= leftKey) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            kth ++;<br>        &#125;<br>        List&lt;Long&gt; uids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-comment">// 在不超出key数量的前提下</span><br>        <span class="hljs-keyword">while</span>(kth &lt; noKeys) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">ik</span> <span class="hljs-operator">=</span> getRawKthKey(raw, kth);<br>          <span class="hljs-comment">// 若key在[leftKey, rightKey]范围内</span><br>            <span class="hljs-keyword">if</span>(ik &lt;= rightKey) &#123;<br>              <span class="hljs-comment">// 将符合条件的节点的uid加入</span><br>                uids.add(getRawKthSon(raw, kth));<br>                kth ++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-comment">// 在key数量范围内找完了 [leftKey, rightKey]范围的节点</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">siblingUid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 发现rightKey大于等于该节点的最大的 key</span><br>        <span class="hljs-keyword">if</span>(kth == noKeys) &#123;<br>          <span class="hljs-comment">// 返回兄弟节点的uid</span><br>            siblingUid = getRawSibling(raw);<br>        &#125;<br>        <span class="hljs-type">LeafSearchRangeRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeafSearchRangeRes</span>();<br>        res.uids = uids;<br>        res.siblingUid = siblingUid;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dataItem.rUnLock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 B+ 树在插入删除时，会动态调整，<strong>根节点不是固定节点</strong>，于是设置一个 <code>bootDataItem</code>，该 <code>DataItem</code> 中存储了根节点的 UID。可以注意到，IM 在操作 DM 时，使用的事务都是 <strong>SUPER_XID</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BPlusTree</span> &#123;<br>    DataItem bootDataItem;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-title function_">rootUid</span><span class="hljs-params">()</span> &#123;<br>        bootLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">SubArray</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> bootDataItem.data();<br>            <span class="hljs-keyword">return</span> Parser.parseLong(Arrays.copyOfRange(sa.raw, sa.start, sa.start+<span class="hljs-number">8</span>));<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bootLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateRootUid</span><span class="hljs-params">(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right, <span class="hljs-type">long</span> rightKey)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        bootLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] rootRaw = Node.newRootRaw(left, right, rightKey);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">newRootUid</span> <span class="hljs-operator">=</span> dm.insert(TransactionManagerImpl.SUPER_XID, rootRaw);<br>            bootDataItem.before();<br>            <span class="hljs-type">SubArray</span> <span class="hljs-variable">diRaw</span> <span class="hljs-operator">=</span> bootDataItem.data();<br>            System.arraycopy(Parser.long2Byte(newRootUid), <span class="hljs-number">0</span>, diRaw.raw, diRaw.start, <span class="hljs-number">8</span>);<br>            bootDataItem.after(TransactionManagerImpl.SUPER_XID);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bootLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里可能会有疑问，IM 为什么不提供删除索引的能力。当上层模块通过 VM 删除某个 <code>Entry</code>，实际的操作是设置其 <code>XMAX</code>。如果不去删除对应索引的话，当后续再次尝试读取该 <code>Entry</code> 时，是可以通过索引寻找到的，但是由于设置了 <code>XMAX</code>，寻找不到合适的版本而返回一个找不到内容的错误。</p><h1 id="6-Table-Manager"><a href="#6-Table-Manager" class="headerlink" title="6. Table Manager"></a>6. Table Manager</h1><blockquote><p>本章概述 TBM，即表管理器的实现。TBM 实现了对字段结构和表结构的管理。同时简要介绍 MYDB 使用的类 SQL 语句的解析。</p></blockquote><h2 id="SQL解析器"><a href="#SQL解析器" class="headerlink" title="SQL解析器"></a>SQL解析器</h2><p>Parser 实现了对类 SQL 语句的结构化解析，将<strong>语句中包含的信息封装为对应语句的类</strong>，这些类可见 top.guoziyang.mydb.backend.parser.statement 包。</p><p>MYDB 实现的 SQL 语句语法如下：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs pf">// 开启事务，isolation level设置事务隔离级别，默认为RC<br><span class="hljs-variable">&lt;begin statement&gt;</span><br>    begin [isolation level (read committedrepeatable read)]<br>        begin isolation level read committed<br><br>// 提交事务<br><span class="hljs-variable">&lt;commit statement&gt;</span><br>    commit<br><br>// 撤销事务<br><span class="hljs-variable">&lt;abort statement&gt;</span><br>    abort<br><br>// 建表语句<br><span class="hljs-variable">&lt;create statement&gt;</span><br>    create <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;table name&gt;</span><br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    ...<br>    <span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;field type&gt;</span><br>    [(index <span class="hljs-variable">&lt;field name list&gt;</span>)]<br>        create <span class="hljs-built_in">table</span> students<br>        id int32,<br>        name string,<br>        age int32,<br>        (index id name)<br><br>// 删表语句<br><span class="hljs-variable">&lt;drop statement&gt;</span><br>    <span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> <span class="hljs-variable">&lt;table name&gt;</span><br>        <span class="hljs-keyword">drop</span> <span class="hljs-built_in">table</span> students<br><br>// 查询语句<br><span class="hljs-variable">&lt;select statement&gt;</span><br>    select (*<span class="hljs-variable">&lt;field name list&gt;</span>) <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;table name&gt;</span> [<span class="hljs-variable">&lt;where statement&gt;</span>]<br>        select * <span class="hljs-keyword">from</span> student where id = <span class="hljs-number">1</span><br>        select name <span class="hljs-keyword">from</span> student where id &gt; <span class="hljs-number">1</span> and id <span class="hljs-variable">&lt; 4</span><br><span class="hljs-variable">        select name, age, id from student where id = 12</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">// 插入语句</span><br><span class="hljs-variable">&lt;insert statement&gt;</span><br>    insert into <span class="hljs-variable">&lt;table name&gt;</span> values <span class="hljs-variable">&lt;value list&gt;</span><br>        insert into student values <span class="hljs-number">5</span> <span class="hljs-string">&quot;Zhang Yuanjia&quot;</span> <span class="hljs-number">22</span><br><br>// 删除语句<br><span class="hljs-variable">&lt;delete statement&gt;</span><br>    delete <span class="hljs-keyword">from</span> <span class="hljs-variable">&lt;table name&gt;</span> <span class="hljs-variable">&lt;where statement&gt;</span><br>        delete <span class="hljs-keyword">from</span> student where name = <span class="hljs-string">&quot;Zhang Yuanjia&quot;</span><br><br>// 更新语句<br><span class="hljs-variable">&lt;update statement&gt;</span><br>    update <span class="hljs-variable">&lt;table name&gt;</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">&lt;field name&gt;</span>=<span class="hljs-variable">&lt;value&gt;</span> [<span class="hljs-variable">&lt;where statement&gt;</span>]<br>        update student <span class="hljs-built_in">set</span> name = <span class="hljs-string">&quot;ZYJ&quot;</span> where id = <span class="hljs-number">5</span><br><br>// where查询<br><span class="hljs-variable">&lt;where statement&gt;</span><br>    where <span class="hljs-variable">&lt;field name&gt;</span> (&gt;<span class="hljs-variable">&lt;=) &lt;value&gt;</span> [(andor) <span class="hljs-variable">&lt;field name&gt;</span> (&gt;<span class="hljs-variable">&lt;=) &lt;value&gt;</span>]<br>        where age &gt; <span class="hljs-number">10</span> or age <span class="hljs-variable">&lt; 3</span><br><span class="hljs-variable"></span><br><span class="hljs-variable">// 字段名命名规则</span><br><span class="hljs-variable">&lt;field name&gt;</span> <span class="hljs-variable">&lt;table name&gt;</span><br>    [a-zA-Z][a-zA-Z0-<span class="hljs-number">9</span>_]*<br><br>// 字段类型只有下面三种<br><span class="hljs-variable">&lt;field type&gt;</span><br>    int32 int64 string<br><br><span class="hljs-variable">&lt;value&gt;</span><br>    .*<br></code></pre></td></tr></table></figure><p>parser 包的 <code>Tokenizer</code> 类，对语句进行逐字节解析，根据空白符或者上述词法规则，<strong>将语句切割成多个 token</strong>。对外提供了 <code>peek()</code>、<code>pop()</code> 方法方便取出 <code>Token</code> 进行解析。</p><p><code>Parser</code> 类则直接对外提供了 <code>Parse(byte[] statement)</code> 方法，核心就是一个调用 <code>Tokenizer</code> 类分割 <code>Token</code>，并根据词法规则包装成具体的 <code>Statement</code> 类并返回。解析过程很简单，仅仅是<strong>根据第一个 <code>Token</code> 来区分语句类型</strong>，并分别处理，不再赘述。</p><h2 id="字段和表管理"><a href="#字段和表管理" class="headerlink" title="字段和表管理"></a>字段和表管理</h2><p>由于 TBM 基于 VM，单个字段信息和表信息都是直接保存在 Entry 中。字段的二进制表示如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[FieldName]</span><span class="hljs-selector-attr">[TypeName]</span><span class="hljs-selector-attr">[IndexUid]</span><br></code></pre></td></tr></table></figure><p>这里 <code>FieldName</code> 和 <code>TypeName</code>，以及后面的表名，存储的都是字节形式的字符串。这里规定一个字符串的存储方式，以明确其存储边界。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[StringLength]</span><span class="hljs-selector-attr">[StringData]</span><br></code></pre></td></tr></table></figure><p>TypeName 为字段的类型，<strong>限定为 int32、int64 和 string 类型</strong>。<strong>如果这个字段有索引，那个 IndexUID 指向了索引二叉树的根</strong>，否则该字段为 0。</p><p>根据这个结构，通过一个 UID 从 VM 中读取并解析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 读取字段信息</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Field <span class="hljs-title function_">loadField</span><span class="hljs-params">(Table tb, <span class="hljs-type">long</span> uid)</span> &#123;<br>    <span class="hljs-type">byte</span>[] raw = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        raw = ((TableManagerImpl)tb.tbm).vm.read(TransactionManagerImpl.SUPER_XID, uid);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">assert</span> raw != <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Field</span>(uid, tb).parseSelf(raw);<br>&#125;<br><br><span class="hljs-comment">// 解析字段信息</span><br><span class="hljs-keyword">private</span> Field <span class="hljs-title function_">parseSelf</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] raw)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 第一个res，包含FieldName的[StringLength][StringData]</span><br>  <span class="hljs-comment">// 返回的res.str 是 FieldName，res.next 是 [StringLength][StringData]的长度</span><br>    <span class="hljs-type">ParseStringRes</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Parser.parseString(raw);<br>    fieldName = res.str;<br>    position += res.next;<br>  <br>  <span class="hljs-comment">// 第二个res，包含TypeName的[StringLength][StringData]</span><br>  <span class="hljs-comment">// 返回的res.str 是 TypeName，res.next 是 [StringLength][StringData]的长度</span><br>    res = Parser.parseString(Arrays.copyOfRange(raw, position, raw.length));<br>    fieldType = res.str;<br>    position += res.next;<br>  <br>  <span class="hljs-comment">// 若有index，则继续解析index</span><br>    <span class="hljs-built_in">this</span>.index = Parser.parseLong(Arrays.copyOfRange(raw, position, position+<span class="hljs-number">8</span>));<br>    <span class="hljs-keyword">if</span>(index != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            bt = BPlusTree.load(index, ((TableManagerImpl)tb.tbm).dm);<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            Panic.panic(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建一个字段的方法类似，将相关的信息通过 VM 持久化即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">persistSelf</span><span class="hljs-params">(<span class="hljs-type">long</span> xid)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">byte</span>[] nameRaw = Parser.string2Byte(fieldName);<br>    <span class="hljs-type">byte</span>[] typeRaw = Parser.string2Byte(fieldType);<br>    <span class="hljs-type">byte</span>[] indexRaw = Parser.long2Byte(index);<br>    <span class="hljs-built_in">this</span>.uid = ((TableManagerImpl)tb.tbm).vm.insert(xid, Bytes.concat(nameRaw, typeRaw, indexRaw));<br>&#125;<br><br><span class="hljs-comment">// [StringLength] + [StringData]</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] string2Byte(String str) &#123;<br>    <span class="hljs-type">byte</span>[] l = int2Byte(str.length());<br>    <span class="hljs-keyword">return</span> Bytes.concat(l, str.getBytes());<br>&#125;<br></code></pre></td></tr></table></figure><p>一个数据库中存在多张表，TBM 使用链表的形式将其组织起来，每一张表都保存一个指向下一张表的 UID。表的二进制结构如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[TableName]</span><span class="hljs-selector-attr">[NextTable]</span><br><span class="hljs-selector-attr">[Field1Uid]</span><span class="hljs-selector-attr">[Field2Uid]</span>...<span class="hljs-selector-attr">[FieldNUid]</span><br></code></pre></td></tr></table></figure><p>这里由于每个 Entry 中的数据，字节数是确定的，于是<strong>无需保存字段的个数</strong>。根据 UID 从 Entry 中读取表数据的过程和读取字段的过程类似。</p><p>对表和字段的操作，有一个很重要的步骤，就是计算 Where 条件的范围，目前 MYDB 的 Where <strong>只支持两个条件的与和或</strong>。MYDB 只支持<strong>已索引字段</strong>作为 Where 的条件。。计算 Where 的范围，具体可以查看 <code>Table</code> 的 <code>parseWhere()</code> 和 <code>calWhere()</code> 方法，以及 Field 类的 <code>calExp()</code> 方法。</p><ul><li><code>parseWhere()</code>：解析Where语句，返回一个<code>Where</code>，<code>Where.singleExp1</code>表示第一个条件，<code>Where.logicOp</code>表示两个条件之间是and还是or，<code>Where.singleExp2</code>表示第二个条件<ul><li>其中条件<code>singleExp</code>所属类<code>SingleExpression</code>包含属性：字段<code>field</code>、条件比较符号<code>compareOp</code>、和字段比较的数值<code>value</code></li></ul></li><li><code>calWhere()</code>：处理逻辑连接词and和or</li><li><code>calExp()</code>：根据Where的条件，返回一个区间：<ul><li>如果<code>compareOp</code>是<code>&lt;</code>，表示字段<code> &lt; value</code>的一个区间。区间left &#x3D; 0，区间right &#x3D; 条件的<code>value</code> - 1；</li><li>如果<code>compareOp</code>是<code>&gt;</code>，表示字段<code>&gt; value</code>的一个区间。区间left &#x3D; <code>value</code>，区间right &#x3D; <code>Long.MAX_VALUE</code>；</li><li>如果如果<code>compareOp</code>是<code>=</code>，表示字段<code>= value</code>的一个区间。区间left &#x3D; right &#x3D; <code>value</code></li></ul></li></ul><p>由于 TBM 的表管理，使用的是链表串起的 Table 结构，所以就必须<strong>保存一个链表的头节点</strong>，即第一个表的 UID，这样在 MYDB 启动时，才能快速找到表信息。</p><p>MYDB 使用 Booter 类和 bt 文件，来管理 MYDB 的启动信息，虽然现在所需的启动信息，只有一个：头表的 UID。<strong>Booter 类对外提供了两个方法：load 和 update，并保证了其原子性。<strong>update 在修改 bt 文件内容时，没有直接对 bt 文件进行修改，而是首先将内容写入一个 bt_tmp 文件中，随后将这个文件重命名为 bt 文件。以期</strong>通过操作系统重命名文件的原子性，来保证操作的原子性</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> &#123;<br>    <span class="hljs-type">File</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path + BOOTER_TMP_SUFFIX);<br>    <span class="hljs-keyword">try</span> &#123;<br>        tmp.createNewFile();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!tmp.canRead() || !tmp.canWrite()) &#123;<br>        Panic.panic(Error.FileCannotRWException);<br>    &#125;<br>    <span class="hljs-keyword">try</span>(<span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(tmp)) &#123;<br>        out.write(data);<br>        out.flush();<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Files.move(tmp.toPath(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+BOOTER_SUFFIX).toPath(), StandardCopyOption.REPLACE_EXISTING);<br>    &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>        Panic.panic(e);<br>    &#125;<br>    file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path+BOOTER_SUFFIX);<br>    <span class="hljs-keyword">if</span>(!file.canRead() || !file.canWrite()) &#123;<br>        Panic.panic(Error.FileCannotRWException);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="TableManager"><a href="#TableManager" class="headerlink" title="TableManager"></a>TableManager</h2><p>TBM 层对外提供服务的是 TableManager 接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TableManager</span> &#123;<br>    BeginRes <span class="hljs-title function_">begin</span><span class="hljs-params">(Begin begin)</span>;<br>    <span class="hljs-type">byte</span>[] commit(<span class="hljs-type">long</span> xid) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] abort(<span class="hljs-type">long</span> xid);<br><br>    <span class="hljs-type">byte</span>[] show(<span class="hljs-type">long</span> xid);<br>    <span class="hljs-type">byte</span>[] create(<span class="hljs-type">long</span> xid, Create create) <span class="hljs-keyword">throws</span> Exception;<br><br>    <span class="hljs-type">byte</span>[] insert(<span class="hljs-type">long</span> xid, Insert insert) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] read(<span class="hljs-type">long</span> xid, Select select) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] update(<span class="hljs-type">long</span> xid, Update update) <span class="hljs-keyword">throws</span> Exception;<br>    <span class="hljs-type">byte</span>[] delete(<span class="hljs-type">long</span> xid, Delete delete) <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 TableManager 已经是直接被最外层 Server 调用（MYDB 是 <strong>C&#x2F;S</strong> 结构），这些方<strong>法直接返回执行的结果</strong>，例如<strong>错误信息</strong>或者<strong>结果信息的字节数组</strong>（可读）。</p><h1 id="7-服务端客户端的实现及其通信规则"><a href="#7-服务端客户端的实现及其通信规则" class="headerlink" title="7. 服务端客户端的实现及其通信规则"></a>7. 服务端客户端的实现及其通信规则</h1><blockquote><p>MYDB 被设计为 C&#x2F;S 结构，类似于 MySQL。支持启动一个服务器，并有多个客户端去连接，通过 socket 通信，执行 SQL 返回结果。</p></blockquote><h2 id="C-S通信"><a href="#C-S通信" class="headerlink" title="C&#x2F;S通信"></a>C&#x2F;S通信</h2><p>MYDB 使用了一种特殊的二进制格式，用于客户端和服务端通信。传输的最基本结构，是 <code>Package</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Package</span> &#123;<br>    <span class="hljs-type">byte</span>[] data;<br>    Exception err;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个 <code>Package</code> 在发送前，由 <code>Encoder</code> <strong>编码</strong>为字节数组，在对方收到后同样会由 <code>Encoder</code> 解<strong>码</strong>成 <code>Package</code> 对象。编码和解码的规则如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Flag]</span><span class="hljs-selector-attr">[data]</span><br></code></pre></td></tr></table></figure><p><strong>若 flag 为 0，表示发送的是数据</strong>，那么 data 即为这份数据本身；<strong>如果 flag 为 1，表示发送的是错误</strong>，data 是 Exception.getMessage() 的错误提示信息。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Encoder</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] encode(Package pkg) &#123;<br>        <span class="hljs-keyword">if</span>(pkg.getErr() != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 发送错误信息</span><br>            <span class="hljs-type">Exception</span> <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> pkg.getErr();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Intern server error!&quot;</span>;<br>            <span class="hljs-keyword">if</span>(err.getMessage() != <span class="hljs-literal">null</span>) &#123;<br>                msg = err.getMessage();<br>            &#125;<br>            <span class="hljs-keyword">return</span> Bytes.concat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>&#125;, msg.getBytes());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 发送数据信息</span><br>            <span class="hljs-keyword">return</span> Bytes.concat(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0</span>&#125;, pkg.getData());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Package <span class="hljs-title function_">decode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span>(data.length &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">throw</span> Error.InvalidPkgDataException;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(data[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// 接受数据</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(Arrays.copyOfRange(data, <span class="hljs-number">1</span>, data.length), <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>          <span class="hljs-comment">// 接受错误信息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(Arrays.copyOfRange(data, <span class="hljs-number">1</span>, data.length))));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> Error.InvalidPkgDataException;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编码之后的信息会通过 <code>Transporter</code> 类，写入输出流发送出去。为了避免特殊字符造成问题，这里会<strong>将数据转成十六进制字符串</strong>（Hex String），并为<strong>信息末尾加上换行符</strong>。这样在发送和接收数据时，就可以很简单地使用 <code>BufferedReader</code> 和 <code>Writer</code> 来直接按行读写了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transporter</span> &#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> BufferedReader reader;<br>    <span class="hljs-keyword">private</span> BufferedWriter writer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Transporter</span><span class="hljs-params">(Socket socket)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>        <span class="hljs-built_in">this</span>.reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(socket.getInputStream()));<br>        <span class="hljs-built_in">this</span>.writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(socket.getOutputStream()));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] data)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">raw</span> <span class="hljs-operator">=</span> hexEncode(data);<br>        writer.write(raw);<br>        writer.flush();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] receive() <span class="hljs-keyword">throws</span> Exception &#123;<br>      <span class="hljs-comment">// 按行读取</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> reader.readLine();<br>        <span class="hljs-keyword">if</span>(line == <span class="hljs-literal">null</span>) &#123;<br>            close();<br>        &#125;<br>        <span class="hljs-keyword">return</span> hexDecode(line);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        writer.close();<br>        reader.close();<br>        socket.close();<br>    &#125;<br><br>  <span class="hljs-comment">// 编码后的数据转成：16进制字符串+换行符</span><br>  <span class="hljs-comment">// 换行符方便接收方收到数据后直接按行读取，一行就是一条数据</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">hexEncode</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] buf)</span> &#123;<br>        <span class="hljs-keyword">return</span> Hex.encodeHexString(buf, <span class="hljs-literal">true</span>)+<span class="hljs-string">&quot;n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] hexDecode(String buf) <span class="hljs-keyword">throws</span> DecoderException &#123;<br>        <span class="hljs-keyword">return</span> Hex.decodeHex(buf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Packager</code> 则是 <code>Encoder</code> 和 <code>Transporter</code> 的结合体，直接对外提供 <code>send</code> 和 <code>receive</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Packager</span> &#123;<br>    <span class="hljs-keyword">private</span> Transporter transpoter;<br>    <span class="hljs-keyword">private</span> Encoder encoder;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Packager</span><span class="hljs-params">(Transporter transpoter, Encoder encoder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.transpoter = transpoter;<br>        <span class="hljs-built_in">this</span>.encoder = encoder;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(Package pkg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] data = encoder.encode(pkg);<br>        transpoter.send(data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Package <span class="hljs-title function_">receive</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">byte</span>[] data = transpoter.receive();<br>        <span class="hljs-keyword">return</span> encoder.decode(data);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        transpoter.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Server和Client的实现"><a href="#Server和Client的实现" class="headerlink" title="Server和Client的实现"></a>Server和Client的实现</h2><p><code>Server</code> 和 <code>Client</code>，偷懒直接使用了 Java 的 socket。</p><p><code>Server</code> 启动一个 <code>ServerSocket</code> 监听端口，当有请求到来时直接<strong>把请求丢给一个新线程处理</strong>。</p><p><code>HandleSocket</code> 类实现了 <code>Runnable</code> 接口，在建立连接后初始化 <code>Packager</code>，随后就循环接收来自客户端的数据并处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleSocket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Socket socket;<br>    <span class="hljs-keyword">private</span> TableManager tbm;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">HandleSocket</span><span class="hljs-params">(Socket socket, TableManager tbm)</span> &#123;<br>        <span class="hljs-built_in">this</span>.socket = socket;<br>        <span class="hljs-built_in">this</span>.tbm = tbm;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> (InetSocketAddress)socket.getRemoteSocketAddress();<br>        System.out.println(<span class="hljs-string">&quot;Establish connection: &quot;</span> + address.getAddress().getHostAddress()+<span class="hljs-string">&quot;:&quot;</span>+address.getPort());<br>        <span class="hljs-type">Packager</span> <span class="hljs-variable">packager</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Transporter</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transporter</span>(socket);<br>            <span class="hljs-type">Encoder</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Encoder</span>();<br>            packager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Packager</span>(t, e);<br>        &#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>                e1.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">exe</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Executor</span>(tbm);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">Package</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 收数据</span><br>                pkg = packager.receive();<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-type">byte</span>[] sql = pkg.getData();<br>            <span class="hljs-type">byte</span>[] result = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Exception</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                result = exe.execute(sql);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>                e = e1;<br>                e.printStackTrace();<br>            &#125;<br>            pkg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(result, e);<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 发回去</span><br>                packager.send(pkg);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>                e1.printStackTrace();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        exe.close();<br>        <span class="hljs-keyword">try</span> &#123;<br>            packager.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;    <br></code></pre></td></tr></table></figure><p>处理的核心是 <code>Executor</code> 类，<code>Executor</code> 调用 <code>Parser</code> <strong>获取到对应语句的结构化信息对象</strong>，并<strong>根据对象的类型，调用 TBM 的不同方法进行处理</strong>。</p><p>top.guoziyang.mydb.backend.Launcher 类，则是<strong>服务器的启动入口</strong>。这个类<strong>解析了命令行参数</strong>。很重要的参数就是 -open 或者 -create。<code>Launcher</code> 根据两个参数，来决定是<strong>创建数据库</strong>文件，还是<strong>启动一个已有的数据库</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createDB</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-type">TransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> TransactionManager.create(path);<br>    <span class="hljs-type">DataManager</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> DataManager.create(path, DEFALUT_MEM, tm);<br>    <span class="hljs-type">VersionManager</span> <span class="hljs-variable">vm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VersionManagerImpl</span>(tm, dm);<br>    TableManager.create(path, vm, dm);<br>    tm.close();<br>    dm.close();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">openDB</span><span class="hljs-params">(String path, <span class="hljs-type">long</span> mem)</span> &#123;<br>    <span class="hljs-type">TransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> TransactionManager.open(path);<br>    <span class="hljs-type">DataManager</span> <span class="hljs-variable">dm</span> <span class="hljs-operator">=</span> DataManager.open(path, mem, tm);<br>    <span class="hljs-type">VersionManager</span> <span class="hljs-variable">vm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VersionManagerImpl</span>(tm, dm);<br>    <span class="hljs-type">TableManager</span> <span class="hljs-variable">tbm</span> <span class="hljs-operator">=</span> TableManager.open(path, vm, dm);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(port, tbm).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端有一个简单的 Shell，实际上只是<strong>读入用户的输入</strong>，并调用 Client.execute()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] execute(<span class="hljs-type">byte</span>[] stat) <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Package</span> <span class="hljs-variable">pkg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Package</span>(stat, <span class="hljs-literal">null</span>);<br>    <span class="hljs-type">Package</span> <span class="hljs-variable">resPkg</span> <span class="hljs-operator">=</span> rt.roundTrip(pkg);<br>    <span class="hljs-keyword">if</span>(resPkg.getErr() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> resPkg.getErr();<br>    &#125;<br>    <span class="hljs-keyword">return</span> resPkg.getData();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>RoundTripper</code> 类实际上实现了<strong>单次收发</strong>动作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Package <span class="hljs-title function_">roundTrip</span><span class="hljs-params">(Package pkg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    packager.send(pkg);<br>    <span class="hljs-keyword">return</span> packager.receive();<br>&#125;<br></code></pre></td></tr></table></figure><p>最后附上<strong>客户端的启动入口</strong>，很简单，把 Shell run 起来即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Launcher</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnknownHostException, IOException &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9999</span>);<br>        <span class="hljs-type">Encoder</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Encoder</span>();<br>        <span class="hljs-type">Transporter</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transporter</span>(socket);<br>        <span class="hljs-type">Packager</span> <span class="hljs-variable">packager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Packager</span>(t, e);<br><br>        <span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>(packager);<br>        <span class="hljs-type">Shell</span> <span class="hljs-variable">shell</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Shell</span>(client);<br>        shell.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-项目总结"><a href="#8-项目总结" class="headerlink" title="8. 项目总结"></a>8. 项目总结</h1><p>为充分理解数据库知识，本项目参考MySQL数据库的设计原理，基于Java实现了简易的数据库MYDB，实现的功能如下：</p><ul><li>事务状态：active、committed、aborted</li><li>数据库日志管理，保证数据的可靠性和数据恢复</li><li>基本的缓存框架，用于缓存数据、日志等信息</li><li>2PL和MVCC</li><li>两种事务隔离级别（读提交和可重复读）和死锁处理</li><li>基于B+树的聚簇索引，支持基于索引查找数据</li><li>简单的表管理器和SQL解析器，支持SQL语句操作表</li><li>基于socket的Server和Client</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>MySQL</category>
      
      <category>Database</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC</title>
    <link href="/2025/02/17/RPC/"/>
    <url>/2025/02/17/RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="RPC（Remote-Procedure-Call）"><a href="#RPC（Remote-Procedure-Call）" class="headerlink" title="RPC（Remote Procedure Call）"></a><strong>RPC（Remote Procedure Call）</strong></h1><blockquote><p>本文参考：</p><p>​JavaGuide星球RPC文档</p><p>​<a href="https://javaguide.cn/distributed-system/rpc/http_rpc.html#http-%E5%92%8C-rpc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">https://javaguide.cn/distributed-system/rpc/http_rpc.html#http-%E5%92%8C-rpc-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB</a></p></blockquote><h1 id="1-什么是RPC？RPC原理是什么？"><a href="#1-什么是RPC？RPC原理是什么？" class="headerlink" title="1. 什么是RPC？RPC原理是什么？"></a><strong>1. 什么是RPC？RPC原理是什么？</strong></h1><h2 id="什么是RPC？"><a href="#什么是RPC？" class="headerlink" title="什么是RPC？"></a>什么是RPC？</h2><p><strong>RPC（Remote Procedure Call）</strong> 即远程过程调用，通过名字我们就能看出 RPC 关注的是远程调用而非本地调用。</p><p><strong>为什么要 RPC ？</strong> 因为，两个不同的服务器上的服务提供的方法不在一个内存空间，所以，需要通过网络编程才能传递方法调用所需要的参数。并且，方法调用的结果也需要通过网络编程来接收。但是，如果我们自己手动网络编程来实现这个调用过程的话工作量是非常大的，因为，我们需要考虑底层传输方式（TCP 还是 UDP）、序列化方式等等方面。</p><p><strong>RPC 能帮助我们做什么呢？</strong>  简单来说，通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。并且！我们不需要了解底层网络编程的具体细节。举个例子：两个不同的服务 A、B 部署在两台不同的机器上，服务 A 如果想要调用服务 B 中的某个方法的话就可以通过 RPC 来做。</p><p>一言蔽之：<strong>RPC 的出现就是为了让你调用远程方法像调用本地方法一样简单。</strong></p><h2 id="RPC原理是什么？"><a href="#RPC原理是什么？" class="headerlink" title="RPC原理是什么？"></a>RPC原理是什么？</h2><p>可以将整个 RPC 的 核心功能看作是下面 5 个部分实现的：</p><ol><li><strong>客户端（服务消费端）</strong> ：调用远程方法的一端。</li><li><strong>客户端 Stub（桩）</strong> ： 这其实就是一代理类。代理类主要做的事情很简单，就是把你调用方法、类、方法参数等信息传递到服务端。</li><li><strong>网络传输</strong> ： 网络传输就是你要把你调用的方法的信息比如说参数啊这些东西传输到服务端，然后服务端执行完之后再把返回结果通过网络传输给你传输回来。网络传输的实现方式有很多种比如最基本的 Socket 或者性能以及封装更加优秀的 Netty（推荐）。</li><li><strong>服务端 Stub（桩）</strong> ：这个桩就不是代理类了。我觉得理解为桩实际不太好，大家注意一下就好。这里的服务端 Stub 实际指的就是接收到客户端执行方法的请求后，去指定对应的方法然后返回结果给客户端的类。</li><li><strong>服务端（服务提供端）</strong> ：提供远程方法的一端。</li></ol><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154285.jpg" alt="1594701419183-13976b20-36c8-44fa-a797-5f16ce27c495"></p><ol><li>服务消费端（client）以本地调用的方式调用远程服务；</li><li>客户端 Stub（client stub） 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体（序列化）：<code>RpcRequest</code>；</li><li>客户端 Stub（client stub） 找到远程服务的地址，并将消息发送到服务提供端；</li><li>服务端 Stub（桩）收到消息将消息反序列化为 Java 对象: <code>RpcRequest</code>；</li><li>服务端 Stub（桩）根据<code>RpcRequest</code>中的类、方法、方法参数等信息调用本地的方法；</li><li>服务端 Stub（桩）得到方法执行结果并将组装成能够进行网络传输的消息体：<code>RpcResponse</code>（序列化）发送至消费方；</li><li>客户端 Stub（client stub）接收到消息并将消息反序列化为 Java 对象:<code>RpcResponse</code> ，这样也就得到了最终结果。over!</li></ol><h1 id="2-有了HTTP协议，为什么还要有RPC？"><a href="#2-有了HTTP协议，为什么还要有RPC？" class="headerlink" title="2. 有了HTTP协议，为什么还要有RPC？"></a><strong>2. 有了HTTP协议，为什么还要有RPC？</strong></h1><h2 id="从TCP聊起"><a href="#从TCP聊起" class="headerlink" title="从TCP聊起"></a><strong>从TCP聊起</strong></h2><p>假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。这时候，我们可选项一般也就<strong>TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。</strong></p><p>类似下面这样。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">fd</span> = socket(AF_INET,SOCK_STREAM,<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>其中<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP 协议</strong>。</p><p>在定义了 socket 之后，我们就可以愉快的对这个 socket 进行操作，比如用<code>bind()</code>绑定 IP 端口，用<code>connect()</code>发起建连。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154286.png" alt="f410977cda814d32b0eff3645c385a8a~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>在连接建立之后，我们就可以使用<code>send()</code>发送数据，<code>recv()</code>接收数据。光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？不行，这么用会有问题。</p><h2 id="使用纯裸TCP会有什么问题"><a href="#使用纯裸TCP会有什么问题" class="headerlink" title="使用纯裸TCP会有什么问题"></a><strong>使用纯裸TCP会有什么问题</strong></h2><p>TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。字节流可以理解为一个双向的通道里流淌的二进制数据，也就是 <strong>01 串</strong> 。纯裸 TCP 收发的这些 01 串之间是 <strong>没有任何边界</strong> 的，你根本不知道到哪个地方才算一条完整消息。正因为这个没有任何边界的特点，所以当我们选择使用 TCP 发送 <strong>“夏洛”和”特烦恼”</strong> 的时候，接收端收到的就是 <strong>“夏洛特烦恼”</strong> ，这时候接收端没发区分你是想要表达 <strong>“夏洛”+”特烦恼”</strong> 还是 <strong>“夏洛特”+”烦恼”</strong> ，这就是所谓的<strong>粘包问题</strong>。</p><p>因此，纯裸TCP是不能直接拿来用的，你需要在这个基础上加入一些 <strong>自定义的规则</strong> ，用于区分 <strong>消息边界</strong> 。于是我们会把每条要发送的数据都包装一下，比如加入 <strong>消息头</strong> ，消息头里写清楚一个完整的包长度是多少，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的 <strong>消息体</strong> 。</p><p>而这里头提到的 <strong>消息头</strong> ，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的 **协议。**每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能 <strong>有区别，但原理都类似</strong>。</p><p><strong>于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p><h2 id="HTTP和RPC"><a href="#HTTP和RPC" class="headerlink" title="HTTP和RPC"></a><strong>HTTP和RPC</strong></h2><h3 id="RPC其实是一直调用方式"><a href="#RPC其实是一直调用方式" class="headerlink" title="RPC其实是一直调用方式"></a><strong>RPC其实是一直调用方式</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154287.png" alt="04b603b5bd2443209233deea87816161~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p><strong>TCP 是传输层的协议</strong> ，而基于 TCP 造出来的 HTTP 和各类 RPC 协议，它们都只是定义了不同消息格式的 <strong>应用层协议</strong> 而已。</p><p><strong>HTTP</strong>（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol）协议又叫做 <strong>超文本传输协议</strong> 。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154288.png" alt="8f07a5d1c72a4c4fa811c6c3b5aadd3d~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>而 <strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all）又叫做 <strong>远程过程调用</strong>，它本身并不是一个具体的协议，而是一种 <strong>调用方式</strong> 。举个例子，我们平时调用一个 <strong>本地方法</strong> 就像下面这样。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">res</span> <span class="hljs-operator">=</span> localFunc(req)<br></code></pre></td></tr></table></figure><p>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法<code>remoteFunc</code>，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">res</span> <span class="hljs-operator">=</span> remoteFunc(req)<br></code></pre></td></tr></table></figure><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154289.png" alt="761da6c30af244e19b1c44075d8b4254~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>基于这个思路，大佬们造出了非常多款式的 RPC 协议，比如比较有名的<code>gRPC</code>，<code>thrift</code>。</p><p>值得注意的是，虽然大部分 RPC 协议底层使用 TCP，但实际上 <strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p><h3 id="那既然有-RPC-了，为什么还要有-HTTP-呢？"><a href="#那既然有-RPC-了，为什么还要有-HTTP-呢？" class="headerlink" title="那既然有 RPC 了，为什么还要有 HTTP 呢？"></a><strong>那既然有 RPC 了，为什么还要有 HTTP 呢？</strong></h3><p>其实，TCP 是 <strong>70 年</strong> 代出来的协议，而 HTTP 是 <strong>90 年代</strong> 才开始流行的。而直接使用裸 TCP 会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有 <strong>80 年代</strong> 出来的<code>RPC</code>。</p><p>所以我们该问的不是 <strong>既然有 HTTP 协议为什么要有 RPC</strong> ，而是 <strong>为什么有 RPC 还要有 HTTP 协议?</strong></p><p>现在电脑上装的各种联网软件，比如 xx 管家，xx 卫士，它们都作为客户端（Client） 需要跟服务端（Server） 建立连接收发消息，此时都会用到应用层协议，在这种 Client&#x2F;Server (C&#x2F;S) 架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。</p><p>但有个软件不同，浏览器（Browser） ，不管是 Chrome 还是 IE，它们不仅要能访问自家公司的<strong>服务器（Server）</strong> ，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 <strong>Browser&#x2F;Server (B&#x2F;S)</strong> 的协议。</p><p>也就是说在多年以前，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。</strong> 很多软件同时支持多端，比如某度云盘，既要支持<strong>网页版</strong>，还要支持<strong>手机端和 PC 端</strong>，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p><p>那这么说的话，<strong>都用 HTTP 得了，还用什么 RPC？</strong></p><h3 id="HTTP和RPC有什么区别"><a href="#HTTP和RPC有什么区别" class="headerlink" title="HTTP和RPC有什么区别"></a><strong>HTTP和RPC有什么区别</strong></h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a><strong>服务发现</strong></h4><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 <strong>IP 地址和端口</strong> 。这个找到服务对应的 IP 端口的过程，其实就是 <strong>服务发现</strong>。</p><p>在 <strong>HTTP</strong> 中，你知道服务的域名，就可以通过 <strong>DNS 服务</strong> 去解析得到它背后的 IP 地址，默认 <strong>80 端口</strong>。</p><p>而 <strong>RPC</strong> 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 <strong>Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 <strong>CoreDNS</strong>。</p><p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p><h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a><strong>底层连接形式</strong></h4><p>以主流的 <strong>HTTP1.1</strong> 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p><p>而 <strong>RPC</strong> 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 <strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154290.png" alt="72fcad064c9e4103a11f1a2d579f79b2~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池，比如 Go 就是这么干的。</p><h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a><strong>传输的内容</strong></h4><p>基于 TCP 传输的消息，说到底，无非都是 <strong>消息头 Header 和消息体 Body。</strong></p><p><strong>Header</strong> 是用于标记一些特殊信息，其中最重要的是 <strong>消息体长度</strong>。</p><p><strong>Body</strong> 则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如 <strong>JSON，Protocol Buffers (Protobuf)</strong> 。</p><p>这个将结构体转为二进制数组的过程就叫 <strong>序列化</strong> ，反过来将二进制数组复原成结构体的过程叫 <strong>反序列化</strong>。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154291.png" alt="d501dfc6f764430188ce61fda0f3e5d9~tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.awebp"></p><p>对于主流的 HTTP1.1，虽然它现在叫超文本协议，支持音频视频，但 HTTP 设计 初是用于做网页文本展示的，所以它传的内容以字符串为主。Header 和 Body 都是如此。在 Body 这块，它使用 <strong>JSON</strong> 来 <strong>序列化</strong> 结构体数据。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154292.png" alt="HTTP报文"></p><p>可以看到这里面的内容非常多的冗余，显得非常啰嗦。最明显的，像 Header 里的那些信息，其实如果我们约定好头部的第几位是 <code>Content-Type</code>，就不需要每次都真的把 <code>Content-Type</code> 这个字段都传过来，类似的情况其实在 Body 的 JSON 结构里也特别明显。</p><p>而 RPC，因为它定制化程度更高，可以采用体积更小的 Protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154293.png" alt="HTTP原理"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171154294.png" alt="RPC原理"></p><p>当然上面说的 HTTP，其实 <strong>特指的是现在主流使用的 HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以 <strong>性能可能比很多 RPC 协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p><h3 id="为什么既然有了HTTP2，还要有RPC"><a href="#为什么既然有了HTTP2，还要有RPC" class="headerlink" title="为什么既然有了HTTP2，还要有RPC"></a><strong>为什么既然有了HTTP2，还要有RPC</strong></h3><p>这个是由于 HTTP2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ul><li>纯裸 TCP 是能收发数据，但它是个无边界的数据流，上层需要定义消息格式用于定义 <strong>消息边界</strong> 。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li><li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li><li>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。</strong> 很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li><li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1 性能要更好，所以大部分公司内部都还在使用 RPC。</li><li><strong>HTTP2.0</strong> 在 <strong>HTTP1.1</strong> 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li></ul><h1 id="3-如何自己实现一个RPC框架"><a href="#3-如何自己实现一个RPC框架" class="headerlink" title="3.如何自己实现一个RPC框架"></a><strong>3.如何自己实现一个RPC框架</strong></h1><p>一般情况下， RPC 框架不仅要提供服务发现功能，还要提供负载均衡、容错等功能，这样的 RPC 框架才算真正合格的。</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410865.png" alt="e13cfb04-a05c-4882-92c9-ea0861e5cc10"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410866.png" alt="06f58c75-1637-456b-bea9-a83060a62c01"></p><p>从上图我们可以看出：服务提供端 Server 向注册中心注册服务，服务消费者 Client 通过注册中心拿到服务相关信息，然后再通过网络请求服务提供端 Server。</p><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a><strong>注册中心</strong></h2><p><strong>注册中心负责服务地址的注册与查找，相当于目录服务。</strong> 服务端启动的时候将服务名称及其对应的地址(ip+port)注册到注册中心，服务消费端根据服务名称找到对应的服务地址。有了服务地址之后，服务消费端就可以通过网络请求服务端了。结合Dubbo到架构图：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410867.png" alt="d0ba7446-455a-40e8-bba2-58f03634860d"></p><p>上述节点简单说明：</p><ul><li><strong>Provider：</strong> 暴露服务的服务提供方</li><li><strong>Consumer：</strong> 调用远程服务的服务消费方</li><li><strong>Registry：</strong> 服务注册与发现的注册中心</li><li><strong>Monitor：</strong> 统计服务的调用次数和调用时间的监控中心</li><li><strong>Container：</strong> 服务运行容器</li></ul><p>调用关系说明：</p><ol><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于<strong>长连接推送</strong>变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于<strong>软负载均衡算法</strong>，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h2 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a><strong>网络传输</strong></h2><p><strong>既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。</strong></p><p>网络传输具体实现你可以使用 <strong>Socket</strong> （ Java 中最原始、最基础的网络通信方式。但是，Socket 是阻塞 IO、性能低并且功能单一）。</p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a><strong>序列化与反序列化</strong></h2><p>要在网络传输数据就要涉及到<strong>序列化</strong>。<strong>为什么需要序列化和反序列化呢？</strong><br>因为网络传输的数据必须是二进制的。因此，我们的 Java 对象没办法直接在网络中传输。为了能够让 Java 对象在网络中传输我们需要将其<strong>序列化</strong>为二进制的数据。我们最终需要的还是目标 Java 对象，因此我们还要将二进制的数据“解析”为目标 Java 对象，也就是对二进制数据再进行一次<strong>反序列化</strong>。</p><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可，不过这种方式不推荐，因为不支持跨语言调用并且性能比较差。现在比较常用序列化的有 <strong>hessian</strong>、<strong>kryo</strong>、<strong>protostuff</strong> ……</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a><strong>动态代理</strong></h2><p>我们知道代理模式就是： 我们给某一个对象提供一个代理对象，并由代理对象来代替真实对象做一些事情。你可以把代理对象理解为一个幕后的工具人。 举个例子：我们真实对象调用方法的时候，我们可以通过代理对象去做一些事情比如安全校验、日志打印等等。但是，这个过程是完全对真实对象屏蔽的。</p><p>讲完了代理模式，再来说动态代理在 RPC 框架中的作用。</p><ul><li>前面第一节的时候，我们就已经提到 ：<strong>RPC 的主要目的就是让我们调用远程方法像调用本地方法一样简单，我们不需要关心远程方法调用的细节比如网络传输</strong>。</li></ul><p><strong>怎样才能屏蔽远程方法调用的底层细节呢？</strong></p><ul><li>答案就是<strong>动态代理</strong>。简单来说，当你调用远程方法的时候，实际会通过代理对象来传输网络请求，不然的话，怎么可能直接就调用到远程方法。</li><li>因为消费端没有服务的实现类，无法获得一个实例进行方法调用，所以只能通过动态代理获得一个代理对象。然后通过<strong>代理对象替我们调用方法</strong>。</li></ul><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h2><p>我们的系统中的某个服务的访问量特别大，我们将这个服务部署在了多台服务器上，当客户端发起请求的时候，多台服务器都可以处理这个请求。那么，如何正确选择处理该请求的服务器就很关键。假如，你就要一台服务器来处理该服务的请求，那该服务部署在多台服务器的意义就不复存在了。负载均衡就是为了避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题，我们从负载均衡的这四个字就能明显感受到它的意义。</p><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a><strong>传输协议</strong></h2><p>我们还需要设计一个私有的 RPC 协议，这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。</p><p>简单来说：**通过设计协议，我们定义需要传输哪些类型的数据， 并且还会规定每一种类型的数据应该占多少字节。这样我们在接收到二进制数据之后，就可以正确的解析出我们需要的数据。**这有一点像密文传输的感觉。</p><p>通常一些标准的 RPC 协议包含下面这些内容：</p><ul><li><strong>魔数</strong> ： 通常是 4 个字节。这个魔数主要是为了筛选来到服务端的数据包，有了这个魔数之后，服务端首先取出前面四个字节进行比对，能够在第一时间识别出这个数据包并非是遵循自定义协议的，也就是无效数据包，为了安全考虑可以直接关闭连接以节省资源。 </li><li><strong>序列化器编号</strong> ：标识序列化的方式，比如是使用 Java 自带的序列化，还是 json，kryo 等序列化方式。 </li><li><strong>消息体长度</strong> ： 运行时计算出来。</li></ul><h1 id="4-序列化介绍以及序列化协议选择"><a href="#4-序列化介绍以及序列化协议选择" class="headerlink" title="4. 序列化介绍以及序列化协议选择"></a><strong>4. 序列化介绍以及序列化协议选择</strong></h1><h2 id="什么是序列化和反序列化"><a href="#什么是序列化和反序列化" class="headerlink" title="什么是序列化和反序列化"></a>什么是序列化和反序列化</h2><ul><li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><h2 id="序列化协议对应于TCP-IP-4层模型中的哪一层？"><a href="#序列化协议对应于TCP-IP-4层模型中的哪一层？" class="headerlink" title="序列化协议对应于TCP&#x2F;IP 4层模型中的哪一层？"></a><strong>序列化协议对应于TCP&#x2F;IP 4层模型中的哪一层？</strong></h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171410868.png" alt="64adec3d-78ee-488f-92ad-ad3013006985"></p><p>如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？</p><p>因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP&#x2F;IP 四层模型中的应用层，所以<strong>序列化协议属于 TCP&#x2F;IP 协议应用层的一部分</strong>。</p><h2 id="常见的序列化协议有哪些？"><a href="#常见的序列化协议有哪些？" class="headerlink" title="常见的序列化协议有哪些？"></a><strong>常见的序列化协议有哪些？</strong></h2><p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p><p>像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。</p><h3 id="JDK自带的序列化方式"><a href="#JDK自带的序列化方式" class="headerlink" title="JDK自带的序列化方式"></a><strong>JDK自带的序列化方式</strong></h3><p>JDK 自带的序列化，只需实现 <code>java.io.Serializable</code>接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1905122041950251207L</span>;<br>    <span class="hljs-keyword">private</span> String requestId;<br>    <span class="hljs-keyword">private</span> String interfaceName;<br>    <span class="hljs-keyword">private</span> String methodName;<br>    <span class="hljs-keyword">private</span> Object[] parameters;<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt;[] paramTypes;<br>    <span class="hljs-keyword">private</span> RpcMessageTypeEnum rpcMessageTypeEnum;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="serialVersionUID有什么作用？"><a href="#serialVersionUID有什么作用？" class="headerlink" title="serialVersionUID有什么作用？"></a><strong>serialVersionUID有什么作用？</strong></h4><ul><li>序列化号 <code>serialVersionUID</code> 属于<strong>版本控制</strong>的作用。反序列化时，会检查 <code>serialVersionUID</code> 是否和当前类的 <code>serialVersionUID</code> 一致。如果 <code>serialVersionUID</code> 不一致则会抛出 <code>InvalidClassException</code> 异常。强烈推荐每个序列化类都手动指定其 <code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的 <code>serialVersionUID</code>。</li></ul><h4 id="serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？"><a href="#serialVersionUID-不是被-static-变量修饰了吗？为什么还会被“序列化”？" class="headerlink" title="serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？"></a><strong>serialVersionUID 不是被 static 变量修饰了吗？为什么还会被“序列化”？</strong></h4><ul><li><p><code>static</code> 修饰的变量是静态变量，位于方法区，本身是不会被序列化的。但是，<code>serialVersionUID</code> 的序列化做了特殊处理，在序列化时，会将 <code>serialVersionUID</code> 序列化到二进制字节流中；在反序列化时，也会解析它并做一致性判断。</p></li><li><blockquote><p>A serializable class can declare its own serialVersionUID explicitly by declaring a field named <code>&quot;serialVersionUID&quot;</code> that must be <code>static</code>, <code>final</code>, and of type <code>long</code>;</p><p>如果想显式指定 <code>serialVersionUID</code> ，则需要在类中使用 <code>static</code> 和 <code>final</code> 关键字来修饰一个 <code>long</code> 类型的变量，变量名字必须为 <code>&quot;serialVersionUID&quot;</code> 。</p></blockquote></li><li><p>也就是说，<code>serialVersionUID</code> 只是用来被 JVM 识别，实际并没有被序列化。</p></li></ul><h4 id="如果有些字段不想进行序列化怎么办？"><a href="#如果有些字段不想进行序列化怎么办？" class="headerlink" title="如果有些字段不想进行序列化怎么办？"></a><strong>如果有些字段不想进行序列化怎么办？</strong></h4><p>对于不想进行序列化的变量，可以使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：<strong>阻止实例中那些用此关键字修饰的的变量序列化</strong>；当对象被反序列化时，被 <code>transient</code> 修饰的变量值<strong>不会被持久化和恢复</strong>。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成<strong>类型的默认值</strong>。例如，如果是修饰 <code>int</code> 类型，那么反序列后结果就是 <code>0</code>。</li><li><code>static</code> 变量因为不属于任何对象(Object)，所以无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><h4 id="为什么不推荐使用-JDK-自带的序列化？"><a href="#为什么不推荐使用-JDK-自带的序列化？" class="headerlink" title="为什么不推荐使用 JDK 自带的序列化？"></a><strong>为什么不推荐使用 JDK 自带的序列化？</strong></h4><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong> ：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。</li></ul><h3 id="Kryo"><a href="#Kryo" class="headerlink" title="Kryo"></a><strong>Kryo</strong></h3><p>Kryo 是一个高性能的序列化&#x2F;反序列化工具，由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Kryo serialization class, Kryo serialization efficiency is very high, but only compatible with Java language</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年05月13日 19:29:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KryoSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializer</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;<br>        <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Kryo</span>();<br>        kryo.register(RpcResponse.class);<br>        kryo.register(RpcRequest.class);<br>        <span class="hljs-keyword">return</span> kryo;<br>    &#125;);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] serialize(Object obj) &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>             <span class="hljs-type">Output</span> <span class="hljs-variable">output</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Output</span>(byteArrayOutputStream)) &#123;<br>            <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoThreadLocal.get();<br>            <span class="hljs-comment">// Object-&gt;byte:将对象序列化为byte数组</span><br>            kryo.writeObject(output, obj);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> output.toBytes();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializeException</span>(<span class="hljs-string">&quot;Serialization failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">byteArrayInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>             <span class="hljs-type">Input</span> <span class="hljs-variable">input</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Input</span>(byteArrayInputStream)) &#123;<br>            <span class="hljs-type">Kryo</span> <span class="hljs-variable">kryo</span> <span class="hljs-operator">=</span> kryoThreadLocal.get();<br>            <span class="hljs-comment">// byte-&gt;Object:从byte数组中反序列化出对象</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> kryo.readObject(input, clazz);<br>            kryoThreadLocal.remove();<br>            <span class="hljs-keyword">return</span> clazz.cast(o);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializeException</span>(<span class="hljs-string">&quot;Deserialization failed&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-Socket网络通信"><a href="#5-Socket网络通信" class="headerlink" title="5. Socket网络通信"></a><strong>5. Socket网络通信</strong></h1><h2 id="什么是Socket（套接字）"><a href="#什么是Socket（套接字）" class="headerlink" title="什么是Socket（套接字）"></a><strong>什么是Socket（套接字）</strong></h2><p>Socket 是一个抽象概念，应用程序可以通过它发送或接收数据。在使用 Socket 进行网络通信的时候，通过 Socket 就可以让我们的数据在网络中传输。操作套接字的时候，和我们读写文件很像。套接字是 IP 地址与端口的组合，套接字 Socket&#x3D;（IP 地址：端口号）。</p><p>要通过互联网进行通信，至少需要一对套接字：</p><ol><li>运行于服务器端的 Server Socket。</li><li>运行于客户机端的 Client Socket</li></ol><p>在 Java 开发中使用 Socket 时会常用到两个类，都在 <code>java.net</code> 包中：</p><ol><li><code>Socket</code>: 一般用于客户端</li><li><code>ServerSocket</code> :用于服务端</li></ol><h2 id="Socket网络通信过程"><a href="#Socket网络通信过程" class="headerlink" title="Socket网络通信过程"></a><strong>Socket网络通信过程</strong></h2><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502171451051.png" alt="aacf635e-4ed6-4ba5-9346-d45500b48098"></p><p><strong>Socket 网络通信过程简单来说分为下面 4 步：</strong></p><ol><li>建立服务端并且监听客户端请求</li><li>客户端请求，服务端和客户端建立连接</li><li>两端之间可以传递数据</li><li>关闭资源</li></ol><p>对应到服务端和客户端的话，是下面这样的。</p><p><strong>服务器端：</strong></p><ol><li>创建 <code>ServerSocket</code> 对象并且绑定地址（ip）和端口号(port)：<code>server.bind(new InetSocketAddress(host, port))</code></li><li>通过 <code>accept()</code>方法监听客户端请求</li><li>连接建立后，通过输入流读取客户端发送的请求信息</li><li>通过输出流向客户端发送响应信息</li><li>关闭相关资源</li></ol><p><strong>客户端：</strong></p><ol><li>创建<code>Socket</code> 对象并且连接指定的服务器的地址（ip）和端口号(port)：<code>socket.connect(inetSocketAddress)</code></li><li>连接建立后，通过输出流向服务器端发送请求信息</li><li>通过输入流获取服务器响应的信息</li><li>关闭相关资源</li></ol><h2 id="Socket网络通信实战"><a href="#Socket网络通信实战" class="headerlink" title="Socket网络通信实战"></a><strong>Socket网络通信实战</strong></h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloServer.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-comment">//1.创建 ServerSocket 对象并且绑定一个端口</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ServerSocket</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);) &#123;<br>            Socket socket;<br>            <span class="hljs-comment">//2.通过 accept()方法监听客户端请求</span><br>            <span class="hljs-keyword">while</span> ((socket = server.accept()) != <span class="hljs-literal">null</span>) &#123;<br>                logger.info(<span class="hljs-string">&quot;client connected&quot;</span>);<br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());<br>                     <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream())) &#123;<br>                   <span class="hljs-comment">//3.通过输入流读取客户端发送的请求信息</span><br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (Message) objectInputStream.readObject();<br>                    logger.info(<span class="hljs-string">&quot;server receive message:&quot;</span> + message.getContent());<br>                    message.setContent(<span class="hljs-string">&quot;new content&quot;</span>);<br>                    <span class="hljs-comment">//4.通过输出流向客户端发送响应信息</span><br>                    objectOutputStream.writeObject(message);<br>                    objectOutputStream.flush();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                    logger.error(<span class="hljs-string">&quot;occur exception:&quot;</span>, e);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur IOException:&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HelloServer</span> <span class="hljs-variable">helloServer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloServer</span>();<br>        helloServer.start(<span class="hljs-number">6666</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ServerSocket</code> 的 <code>accept（）</code> 方法是<strong>阻塞方法</strong>，也就是说 <code>ServerSocket</code> 在调用 <code>accept（)</code>等待客户端的连接请求时会阻塞，直到收到客户端发送的连接请求才会继续往下执行代码。</p><p>很明显，上面演示的代码片段有一个很严重的问题：**只能同时处理一个客户端的连接，如果需要管理多个客户端的话，就需要为我们请求的客户端单独创建一个线程。**对应的 Java 代码可能是下面这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>   <span class="hljs-comment">// 创建 socket 连接</span><br>&#125;).start();<br></code></pre></td></tr></table></figure><p>但是，这样会导致一个很严重的问题：<strong>资源浪费</strong>。</p><p>我们知道线程是很宝贵的资源，如果我们为每一次连接都用一个线程处理的话，就会导致<strong>线程越来越多</strong>，最后达到了极限之后，就无法再创建线程处理请求了。处理的不好的话，甚至可能直接就宕机掉了。很多人就会问了：那有没有改进的方法呢？</p><p>当然有！ 比较简单并且实际的改进方法就是使用<strong>线程池</strong>。线程池还可以让线程的创建和回收成本相对较低，并且我们可以指定线程池的可创建线程的最大数量，这样就不会导致线程创建过多，机器资源被不合理消耗。<strong>但是，即使你再怎么优化和改变。也改变不了它的底层仍然是同步阻塞的 BIO 模型的事实，因此无法从根本上解决问题。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> Executors.defaultThreadFactory();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">1</span>, TimeUnit.MINUTES, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>), threadFactory);<br>threadPool.execute(() -&gt; &#123;<br>     <span class="hljs-comment">// 创建 socket 连接</span><br> &#125;);<br></code></pre></td></tr></table></figure><blockquote><p>bio的话，线程池最多防止资源耗费过多，因为你读完数据，下一轮还是会阻塞到read方法，并不会结束这个线程的任务，所以线程还不回线程池。</p></blockquote><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloClient</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(HelloClient.class);<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">send</span><span class="hljs-params">(Message message, String host, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-comment">//1. 创建Socket对象并且指定服务器的地址和端口号</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(host, port)) &#123;<br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(socket.getOutputStream());<br>            <span class="hljs-comment">//2.通过输出流向服务器端发送请求信息</span><br>            objectOutputStream.writeObject(message);<br>            <span class="hljs-comment">//3.通过输入流获取服务器响应的信息</span><br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(socket.getInputStream());<br>            <span class="hljs-keyword">return</span> objectInputStream.readObject();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;occur exception:&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HelloClient</span> <span class="hljs-variable">helloClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HelloClient</span>();<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (Message) helloClient.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;content from client&quot;</span>), <span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br>        System.out.println(<span class="hljs-string">&quot;client receive message:&quot;</span> + message.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先运行服务端，然后再运行客户端，控制台输出如下：</p><p>服务端:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">[main] INFO github.javaguide.socket.HelloServer - client connected<br>[main] INFO github.javaguide.socket.HelloServer - server receive message:content from client<br></code></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">client receive message:<span class="hljs-keyword">new</span> <span class="hljs-title class_">content</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>点评项目</title>
    <link href="/2025/02/15/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/02/15/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="点评项目"><a href="#点评项目" class="headerlink" title="点评项目"></a>点评项目</h1><h2 id="短信登录功能"><a href="#短信登录功能" class="headerlink" title="短信登录功能"></a>短信登录功能</h2><h3 id="基于Session实现登录"><a href="#基于Session实现登录" class="headerlink" title="基于Session实现登录"></a>基于Session实现登录</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151751207.png" alt="image-20250211151403643"></p><h4 id="Session原理"><a href="#Session原理" class="headerlink" title="Session原理"></a><strong>Session原理</strong></h4><ul><li>Session会为每一次会话分配一个Session对象</li><li>同一个浏览器发起的多次请求，同属于一次会话（Session）</li><li>首次使用到Session时，服务器会自动创建Session，并创建<strong>Cookie</strong>存储SessionId发送回客户端</li></ul><h4 id="Session在项目中的使用"><a href="#Session在项目中的使用" class="headerlink" title="Session在项目中的使用"></a><strong>Session在项目中的使用</strong></h4><ul><li><strong>保存验证码到session</strong>：session.setAttribute(“code”, code)</li><li><strong>校验验证码</strong>：session.getAttribute(“code”)获取前面生成的验证码，与提交表单中的验证码进行比较，相同则说明输入正确</li><li><strong>保存用户到session</strong>：session.setAttribute(“user”,BeanUtil.copyProperties(user,UserDTO.class))<ul><li>其中这里保存的并非User对象，而是UserDTO对象</li><li>这是因为user对象中包含密码等敏感信息，若直接将User对象保存到session不安全，故将UserDTO对象保存到session中，用于后面的登录校验</li></ul></li></ul><h4 id="登录校验功能"><a href="#登录校验功能" class="headerlink" title="登录校验功能"></a><strong>登录校验功能</strong></h4><p>登录校验功能用于检验用户的登录状态，因为某些功能需要用户登录才能实现，比如：用户主页、用户私信。但是每次执行这些功能，都需要在对应功能的service实现类中实现从session中获取用户的操作，这样会很麻烦。</p><p>于是，我们选择在前面加一层拦截器，用于实现session中获取用户的操作，具体实现如下：</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151751652.png" alt="image-20250211154537472"></p><h4 id="拦截器的实现"><a href="#拦截器的实现" class="headerlink" title="拦截器的实现"></a><strong>拦截器的实现</strong></h4><p>我们用于实现登录状态校验的拦截器<strong>LoginInterceptor</strong>，需要实现<strong>HandlerInterceptor</strong>，拦截器的执行流程分为三个主要阶段：<em><strong>preHandle</strong></em>、<em><strong>postHandle</strong></em>和<em><strong>afterCompletion</strong></em>。</p><ul><li>在请求处理的前期，<em>preHandle</em>方法会被调用，如果返回<em>true</em>，则继续执行后续的拦截器和请求处理器；如果返回<em>false</em>，则中断执行流程。</li><li>在请求处理完毕后，<em>postHandle</em>方法会被调用，用于进行后处理操作。</li><li>最后，在请求完成后，<em>afterCompletion</em>方法会被调用，用于进行资源清理等操作。</li></ul><h4 id="拦截器的注册"><a href="#拦截器的注册" class="headerlink" title="拦截器的注册"></a><strong>拦截器的注册</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">// 登录拦截器,order(1)表示顺序</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<br>                        <span class="hljs-string">&quot;/shop/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/voucher/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop-type/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/upload/**&quot;</span>,<br>                        <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/code&quot;</span>,<br>                        <span class="hljs-string">&quot;/user/login&quot;</span><br>                ).order(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">// 获取用户token并刷新token</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshTokenInterceptor</span>(stringRedisTemplate))<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).order(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="保存用户到ThreadLocal"><a href="#保存用户到ThreadLocal" class="headerlink" title="保存用户到ThreadLocal"></a><strong>保存用户到ThreadLocal</strong></h4><p>ThreadLocal的三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal.set(T value); <span class="hljs-comment">//设置值</span><br>ThreadLocal.get(); <span class="hljs-comment">//获取值</span><br>ThreadLocal.remove(); <span class="hljs-comment">//移除值</span><br></code></pre></td></tr></table></figure><p>所以我们可以借助这个ThreadLocal来存储登录用户的信息，在一个请求中，所有调用的方法都在同一个线程中去处理，这样就实现了在任何地方都可以获取到用户信息了，从而摆脱了HttpServletRequest的束缚。</p><h4 id="基于MybatisPlus实现的增删改查操作"><a href="#基于MybatisPlus实现的增删改查操作" class="headerlink" title="基于MybatisPlus实现的增删改查操作"></a><strong>基于MybatisPlus实现的增删改查操作</strong></h4><p>项目中使用MybatisPlus，简化了对数据库的增删改查操作，这是由service实现类通过继承MybatisPlus的<strong>ServiceImpl</strong>&lt;UserMapper, User&gt;实现的</p><ul><li><p><strong>根据手机号查询用户</strong>：User user &#x3D; query().eq(“phone”, phone).one()</p></li><li><p><strong>根据手机号生成新用户</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.创建用户</span><br><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>user.setPhone(phone);<br>user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="hljs-number">10</span>));<br><span class="hljs-comment">// 2.保存用户</span><br>save(user);<br></code></pre></td></tr></table></figure></li></ul><h4 id="集群的Session共享问题"><a href="#集群的Session共享问题" class="headerlink" title="集群的Session共享问题"></a><strong>集群的Session共享问题</strong></h4><p>当使用<strong>Tomcat集群</strong>时，多台Tomcat并不共享session的存储空间，当请求切换到不同tomcat服务时会导致数据丢失问题。如：用户登录时，使用Tomcat1，其对应的用户登录信息存储在Tomcat1的session中，当用户访问其他功能时，系统负载均衡分配了Tomcat2，这时的Tomcat2中不存在该用户存在session中的信息，于是会导致用户即使刚刚才登录，此时又需要再登录一遍。</p><p>session的替代方案应满足如下需求：</p><ul><li>数据共享</li><li>内存存储：session是基于内存存储的，它的读写效率高。而登录校验的访问频率非常高</li><li>key、value结构</li></ul><p><strong>——Redis</strong></p><h3 id="基于Redis实现共享session登录"><a href="#基于Redis实现共享session登录" class="headerlink" title="基于Redis实现共享session登录"></a><strong>基于Redis实现共享session登录</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752686.png" alt="image-20250211160014180"></p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752612.png" alt="image-20250211161336341"></p><h4 id="redis在项目中的使用"><a href="#redis在项目中的使用" class="headerlink" title="redis在项目中的使用"></a><strong>redis在项目中的使用</strong></h4><ul><li><p><strong>保存验证码到redis</strong>：stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES)，key设置为如上格式，能够清晰读懂redis各条键值对的功能，同时设置验证码的过期时间</p></li><li><p><strong>校验验证码</strong>：stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone)</p></li><li><p><strong>保存用户到redis</strong>：以随机token为key存储用户数据，用户对象使用Hash类型存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 7.保存用户信息到redis中</span><br><span class="hljs-comment">// 7.1随机生成token作为登陆令牌</span><br><span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 7.2 将User对象转换为HashMap存储</span><br><span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO);<br>userMap.replace(<span class="hljs-string">&quot;id&quot;</span>, userDTO.getId().toString());<br><span class="hljs-comment">// 7.3存储</span><br><span class="hljs-type">String</span> <span class="hljs-variable">tokenKey</span> <span class="hljs-operator">=</span> LOGIN_USER_KEY + token;<br>stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);<br><span class="hljs-comment">// 7.4设置有效期</span><br>stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure></li><li><p><strong>刷新过期时间</strong>：在拦截器中更新用户的过期时间</p></li></ul><p>通过上述改动，我们完成了使用redis实现共享session登录</p><h4 id="刷新过期时间问题"><a href="#刷新过期时间问题" class="headerlink" title="刷新过期时间问题"></a><strong>刷新过期时间问题</strong></h4><p>因为刷新过期时间是在拦截器中实现的，因此只有请求通过拦截器才会刷新过期时间，即使用户一直浏览主界面也不会刷新过期时间。为了解决这个问题，我们又添加了一个拦截器在前面</p><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752570.png" alt="image-20250211162311047"></p><ul><li>第一个拦截器RefreshTokenInterceptor的核心工作是得到用户、保存起来并刷新过期时间</li><li>第二个拦截器LoginInterceptor的核心工作是对不存在的用户进行拦截</li></ul><h2 id="商户查询缓存"><a href="#商户查询缓存" class="headerlink" title="商户查询缓存"></a>商户查询缓存</h2><h3 id="添加商户缓存"><a href="#添加商户缓存" class="headerlink" title="添加商户缓存"></a><strong>添加商户缓存</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752594.png" alt="image-20250211201328475"></p><p>使用redis中的<strong>string类型</strong>存储商铺缓存：</p><ul><li>若redis中存在要查询的商户，利用redis查到的json字符串结合hutool中的JSONUtil工具实现：Shop shop &#x3D; JSONUtil.toBean(shopJson, Shop.class)</li><li>若redis中不存在要查询的商户，到数据库中去查找，将找到的Shop对象通过hutool中的JSONUtil工具转换为json字符串：JSONUtil.toJsonStr(shop)</li></ul><h3 id="添加商户类型缓存"><a href="#添加商户类型缓存" class="headerlink" title="添加商户类型缓存"></a><strong>添加商户类型缓存</strong></h3><p>查询商户类型返回的是多个商户类型，即List<ShopType>，因此将商户类型存储在redis中时，我们选择使用<strong>redis中的list类型</strong>进行存储：</p><ul><li><p>先在缓存中查询：<strong>List<String></strong> shopTypeJsonList &#x3D; stringRedisTemplate.opsForList().range(CACHE_SHOPTYPE_LIST, 0, -1)，0、-1表示从头查到尾&#x3D;&#x3D;（注意，list类型查询返回只能得到一个List<String>类型的集合，因此我们每一个对象都要先转为json字符串再存储）&#x3D;&#x3D;</p></li><li><p>若redis中存在，即shopTypeJsonList非空，则将这个json字符串集合一个个转换为ShopType对象后，返回一个ShopTypeList集合</p></li><li><p>若redis中不存在，则需要到数据库中查找，注意，我们需要按照“sort”字段排序查找</p></li><li><p>查找到之后，将这些ShopType对象的集合一个个push到redis中去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(ShopType shopType : shopTypeList) &#123;<br>  stringRedisTemplate.opsForList().rightPush(CACHE_SHOPTYPE_LIST, JSONUtil.toJsonStr(shopType));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后返回一个ShopTypeList集合</p></li></ul><h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752321.png" alt="image-20250211202918433"></p><ul><li>低一致性需求：使用内存淘汰机制。如商户类型查询的缓存。</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案。如店铺详情查询的缓存。</li></ul><h4 id="操作缓存和数据库需要考虑的问题"><a href="#操作缓存和数据库需要考虑的问题" class="headerlink" title="操作缓存和数据库需要考虑的问题"></a><strong>操作缓存和数据库需要考虑的问题</strong></h4><ul><li>删除缓存还是更新缓存？<ul><li>更新缓存：每次更新数据库都更新缓存，无效的写操作较多。</li><li>&#x3D;&#x3D;删除缓存&#x3D;&#x3D;：更新数据库时让缓存失效，查询时再更新缓存。</li></ul></li><li>如何保证缓存和数据库的操作<strong>同时成功或失败</strong>？<ul><li>单体系统：将缓存和数据库的操作放在同一个事务内。如放在同一个方法内，并用**@Transactional**修饰这个方法。</li><li>分布式系统：利用TCC等分布式事务。</li></ul></li><li><strong>先操作缓存还是先操作数据库？</strong><ul><li><strong>先删除缓存再操作数据库</strong></li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752308.png" alt="image-20250211203731172" style="zoom: 33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752090.png" alt="image-20250211203755582" style="zoom: 33%;" /></li><li>&#x3D;&#x3D;<strong>先操作数据库再删除缓存</strong>&#x3D;&#x3D;</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752210.png" alt="image-20250211203939763" style="zoom:33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752102.png" alt="image-20250211203955306" style="zoom:33%;" /></li><li>左边为正常情况，右边为异常情况</li><li>相比之下，前者出现异常情况的概率较大，而后者出现异常情况的概率较小，<strong>这是因为更新数据库的耗时相对而言较长导致的</strong>，因此可以选择后者。</li></ul></li></ul><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a><strong>缓存穿透</strong></h3><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752365.png" alt="image-20250211204527433" style="zoom: 25%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752605.png" alt="image-20250211205011369" style="zoom:33%;" /></p><p>缓存穿透是指客户端请求的数据<strong>在缓存和数据库中都不存在</strong>，这样<strong>缓存永远不会生效</strong>，这些请求都会打到数据库。常见的解决方案有两种：</p><ul><li><p><strong>缓存空对象</strong>：将这种数据在redis中使用一个空对象如 “” 缓存起来，并设置一个<strong>较短的TTL</strong>，当下次再有这样的请求过来时就不会打到数据库了。</p><ul><li>优点：实现简单，维护方便</li><li>缺点：额外的内存消耗、可能造成短期的不一致</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752212.png" alt="image-20250211205343702" style="zoom:33%;" /></li></ul></li><li><p><strong>布隆过滤</strong></p><ul><li>布隆过滤算法是一种数据统计算法，用于检索一个元素是否在集合中。但是布隆过滤无需存储元素到集合，而是把元素映射到一个很长的二进制数位上。利用布隆过滤算法，在请求进入redis之前先判断是否存在，如果不存在则直接拒绝请求</li><li>优点：内存占用较少，没有多余的key</li><li>缺点：实现复杂、存在误判可能</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752022.png" alt="image-20250212135951528" style="zoom:33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151752918.png" alt="image-20250212140747872" style="zoom:33%;" /></li></ul></li><li><p><strong>其他</strong></p><ul><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul></li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753143.png" alt="image-20250211205458168" style="zoom: 33%;" /><p>缓存雪崩是指在<strong>同一时段大量的缓存key同时失效</strong>或者redis服务宕机，导致大量请求打到数据库，带来巨大压力。解决方案：</p><ul><li>给不同的key的TTL添加随机值</li><li>利用redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ul><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a><strong>缓存击穿</strong></h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753170.png" alt="image-20250211205931115" style="zoom: 33%;" /><p>缓存击穿问题也叫<strong>热点key问题</strong>，就是一个被高并发访问并且缓存重建业务比较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大冲击。常见的解决方案有两种：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753133.png" alt="image-20250211210042375" style="zoom:50%;" /><ul><li>互斥锁：给<strong>第一个未命中缓存的线程加锁</strong>、查询数据库并写入缓存后再释放锁，<strong>其他线程在此期间需要等待</strong>。<ul><li>优点：1. 没有额外的内存消耗    2. 保证一致性    3. 实现简单</li><li>缺点：1. 线程需要等待，性能受影响     2. 可能有死锁风险</li></ul></li><li>逻辑过期：不设置TTL，而是设置一个逻辑过期时间，首个发现逻辑时间过期的线程会<strong>开启一个新的线程用于更新数据</strong>，其本身以及在此期间查询的其他线程则会<strong>返回当下的过期数据</strong>。<ul><li>优点：线程无需等待，性能良好</li><li>缺点：1. 不保证一致性    2. 有额外内存消耗    3. 实现复杂</li></ul></li></ul><h4 id="利用互斥锁解决缓存击穿问题"><a href="#利用互斥锁解决缓存击穿问题" class="headerlink" title="利用互斥锁解决缓存击穿问题"></a><strong>利用互斥锁解决缓存击穿问题</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753969.png" alt="image-20250212113031052" style="zoom:50%;" /><ul><li>利用redis中的&#x3D;&#x3D;<strong>setnx（SET if Not eXists）命令</strong>&#x3D;&#x3D;实现互斥锁。</li><li>setnx基本语法：SETNX KEY_NAME VALUE在指定的 key 不存在时，为 key 设置指定的值，返回设置的值；若指定的key存在时，返回0。</li><li>Java中如何使用setnx方法实现<strong>获取互斥锁</strong>？stringRedisTemplate.opsForValue().<strong>setIfAbsent</strong>，这个方法返回一个Boolean值，在需要获取互斥锁时，在redis中设置<strong>setnx lockKey 1（TTL &#x3D; 20s）</strong>，如果设置成功，则返回true；而<strong>其他想要获取互斥锁的线程都会在setnx lockKey 1这一步中被堵住</strong>，故只有一个最早的线程能够到达后面的数据库，并进行缓存重建。</li><li>Java中如何使用setnx方法实现<strong>释放互斥锁</strong>？只需要进行缓存重建的线程在重建完毕后，将lockKey删除即可，这样后面想要获取互斥锁的线程就能够得到互斥锁了。注意，为了避免互斥锁无法释放，一般将释放锁操作放在finally代码块中执行。</li><li>由于缓存重建的过程需要先查找数据库，再写入redis，<strong>这一过程需要花费一定时间</strong>，在这段时间中，因为缓存未命中而想要重建缓存的线程都会被互斥锁挡住，直到缓存重建完毕，因此<strong>不会存在不一致的情况</strong>，即这段时间内所有的线程返回的值都是缓存重建完后的值。</li></ul><h4 id="利用逻辑过期解决缓存击穿问题"><a href="#利用逻辑过期解决缓存击穿问题" class="headerlink" title="利用逻辑过期解决缓存击穿问题"></a><strong>利用逻辑过期解决缓存击穿问题</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753395.png" alt="image-20250212113214513" style="zoom:33%;" /><ul><li>因为要处理的数据一般为热点数据，所以会提前写入缓存中预热，且只有逻辑过期时间、没有TTL，永不过期。因此，如果发现缓存未命中，说明不存在这样的数据，则直接返回空。</li><li>由于存到redis中的数据还需要包含一个逻辑过期的时间，因此创建一个新的对象redisData将商铺对象、逻辑过期时间包含起来。</li><li>将取得的逻辑过期时间与当前时间对比，若未过期，说明当前的商铺信息仍在有效期内，故直接返回。</li><li>若已过期，则先获取一个lockKey的互斥锁，获取方法同上。然后<strong>开启一个独立的线程</strong>，进行缓存重建，重建完释放互斥锁。而当前线程则直接返回获取到的过期数据。</li><li>在缓存重建期间，其他线程到达想要获取互斥锁，获取失败后也直接返回过期数据。</li><li>因为该方法存在返回过期数据的情况，因此这个方法会有不一致的情况出现。</li><li>注意⚠️：由于本项目中选择的缓存更新策略是——更新数据库时让缓存失效，查询时再更新缓存。但是在本方法中，<strong>删除缓存之后会导致其他线程无法命中缓存就直接返回空值</strong>，因此逻辑过期不适用于当前方法。可以采用更新缓存的策略——每次更新数据库都更新缓存。</li></ul><h3 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a><strong>缓存工具封装</strong></h3><p><strong>&#x3D;&#x3D;泛型&#x3D;&#x3D;</strong></p><h2 id="优惠券秒杀"><a href="#优惠券秒杀" class="headerlink" title="优惠券秒杀"></a><strong>优惠券秒杀</strong></h2><h3 id="全局唯一ID生成策略"><a href="#全局唯一ID生成策略" class="headerlink" title="全局唯一ID生成策略"></a><strong>全局唯一ID生成策略</strong></h3><p>当用户购买商品时，就会生成订单并保存到订单表中，而如果订单表采用数据库自增ID就会出现一些问题：</p><ul><li>ID的规律性太过明显，不安全</li><li>受单表数据量的限制，因为订单是会不断累积的，而单表所能容纳的数据量是有限的，后期会需要用到分库分表。而如果此时还使用数据库的自增ID，就会出现多个订单有相同的订单ID。</li></ul><p>故我们需要选择一种方法实现全局ID的生成，这种方法需要满足：唯一性、高可用、高性能、递增性、安全性的特点——<strong>redis</strong>。</p><ul><li>递增性：INCR key。当执行 INCR 命令时，如果键不存在，Redis 会先创建一个新的键，并将其初始值设置为0，然后再进行自增操作。</li><li>安全性：INCR 命令是原子操作，这意味着当多个客户端同时对同一个键执行 INCR 命令时，Redis 会确保操作的原子性。这意味着在多线程或并发环境下，不会出现竞态条件或数据不一致的情况。为了增加ID的安全性，我们可以不直接使用redis自增的数值，而是拼接一些其他的信息，如：时间戳（31位）+计数位（32位）</li></ul><h3 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a><strong>添加优惠券</strong></h3><p>本项目中的优惠券分为普通优惠券与秒杀优惠券，普通优惠券不限量且没有购买时间要求，而秒杀优惠券有库存，且需要在指定时间范围内才能购买。两者的数据表如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> `tb_voucher`  (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键&#x27;</span>,<br>  `shop_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;商铺id&#x27;</span>,<br>  `title` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">CHARACTER SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;代金券标题&#x27;</span>,<br>  `sub_title` <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">CHARACTER SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;副标题&#x27;</span>,<br>  `rules` <span class="hljs-type">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">CHARACTER SET</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> utf8mb4_general_ci <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;使用规则&#x27;</span>,<br>  `pay_value` <span class="hljs-type">bigint</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;支付金额，单位是分。例如200代表2元&#x27;</span>,<br>  `actual_value` <span class="hljs-type">bigint</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;抵扣金额，单位是分。例如200代表2元&#x27;</span>,<br>  `type` tinyint(<span class="hljs-number">1</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span> COMMENT <span class="hljs-string">&#x27;0,普通券；1,秒杀券&#x27;</span>,<br>  `status` tinyint(<span class="hljs-number">1</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span> COMMENT <span class="hljs-string">&#x27;1,上架; 2,下架; 3,过期&#x27;</span>,<br>  `create_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `update_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">10</span> <span class="hljs-keyword">CHARACTER SET</span> <span class="hljs-operator">=</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8mb4_general_ci ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> `tb_seckill_voucher`  (<br>  `voucher_id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) UNSIGNED <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;关联的优惠券的id&#x27;</span>,<br>  `stock` <span class="hljs-type">int</span>(<span class="hljs-number">8</span>) <span class="hljs-keyword">NOT NULL</span> COMMENT <span class="hljs-string">&#x27;库存&#x27;</span>,<br>  `create_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;创建时间&#x27;</span>,<br>  `begin_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;生效时间&#x27;</span>,<br>  `end_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;失效时间&#x27;</span>,<br>  `update_time` <span class="hljs-type">timestamp</span> <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;更新时间&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY KEY</span> (`voucher_id`) <span class="hljs-keyword">USING</span> BTREE<br>) ENGINE <span class="hljs-operator">=</span> InnoDB <span class="hljs-keyword">CHARACTER SET</span> <span class="hljs-operator">=</span> utf8mb4 <span class="hljs-keyword">COLLATE</span> <span class="hljs-operator">=</span> utf8mb4_general_ci COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;秒杀优惠券表，与优惠券是一对一关系&#x27;</span> ROW_FORMAT <span class="hljs-operator">=</span> Compact;<br></code></pre></td></tr></table></figure><p>两张表是关联的，添加秒杀优惠券只需先保存到优惠券表中，然后再将部分字段保存到秒杀优惠券表中即可。</p><h3 id="实现秒杀优惠券下单"><a href="#实现秒杀优惠券下单" class="headerlink" title="实现秒杀优惠券下单"></a><strong>实现秒杀优惠券下单</strong></h3><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753985.png" alt="image-20250212164645234" style="zoom:33%;" /><p>扣减库存选择直接使用MybatisPlus中的update操作：seckillVoucherService.update().setSql(“stock &#x3D; stock - 1”).eq(“voucher_id”, voucherId).update()。</p><h4 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a><strong>超卖问题</strong></h4><p>但是这样的做法会导致<strong>超卖现象</strong>的产生：即在线程1扣减库存之前，<strong>其他线程查到了未扣减之前的库存</strong>，导致最终<strong>库存变为了负数</strong>。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151753604.png" alt="image-20250212165754627" style="zoom:33%;" /><p>超卖问题是典型的多线程安全问题，常见的解决方案就是加锁。而锁又可分为**&#x3D;&#x3D;悲观锁和乐观锁&#x3D;&#x3D;**：</p><ul><li><strong>悲观锁</strong>：<strong>认为线程安全问题一定会发生</strong>，因此在操作数据之前先获取锁，确保<strong>线程串行执行</strong>。Synchronized、Lock都属于悲观锁。优点：简单；缺点：性能一般。</li><li><strong>乐观锁</strong>：<strong>认为线程安全问题不一定会发生</strong>，因此&#x3D;&#x3D;不加锁&#x3D;&#x3D;，而是在更新数据的时候去<strong>判断有没有其他线程对数据进行修改</strong>。优点：性能好；缺点：存在成功率低的问题。<ul><li>如果没有修改，则认为是安全的，更新数据。</li><li>如果发现数据被修改了，说明发生了线程安全问题，此时可以重试或报异常。</li><li>乐观锁的常见实现方式有两种：<strong>版本号法、CAS（Compare and Swap）</strong><ul><li>版本号法：在原有数据基础上，为每个数据添加一个版本号version，数据每进行一次修改就使版本号增加。当要修改数据时，比较之前查询该数据得到的版本号与当前的版本号是否一致，若不一致则说明数据出现了修改。</li><li>CAS：在版本号的基础上，直接拿数据中要进行修改的字段进行比较，若前后不一致则说明发生了修改。</li><li><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754527.png" alt="image-20250212170606199" style="zoom: 33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754859.png" alt="image-20250212170924768" style="zoom: 33%;" /></li></ul></li></ul></li></ul><h4 id="CAS解决超卖问题时出现的问题"><a href="#CAS解决超卖问题时出现的问题" class="headerlink" title="CAS解决超卖问题时出现的问题"></a><strong>CAS解决超卖问题时出现的问题</strong></h4><p>我们选择使用上方的CAS方法解决超卖问题，在jMeter压力测试中，选择使用200个线程同时对100张秒杀优惠券进行抢购，这一次优惠券的库存没有变为负数，但是优惠券只卖出了20张，秒杀成功率大大减少了。</p><p>这是因为当有<strong>多个线程同时查到了同样的库存</strong>时，<strong>只有一个线程能够抢到优惠券</strong>，其他线程会因为当前剩余库存与前面查询到的库存不一致导致秒杀失败。</p><p>解决方案：将sql语句中的：stock &#x3D; 前面查询到的stock更改为<strong>stock &gt; 0</strong> 即可。</p><h4 id="实现一人一单功能"><a href="#实现一人一单功能" class="headerlink" title="实现一人一单功能"></a><strong>实现一人一单功能</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754411.png" alt="image-20250212175948943" style="zoom: 33%;" /><p>相较于上面主要的改动就是在扣减库存之前多了一道判断订单是否存在的步骤：判断数据库中<strong>是否已存在相同user_id和相同voucher_id的订单</strong>，如果这样的订单数量大于0，说明该用户已经买过这张优惠券，返回异常值。</p><p>1️⃣但是这样的操作会导致&#x3D;&#x3D;<strong>线程安全问题</strong>&#x3D;&#x3D;：一个用户在<strong>多个线程中同时进行了订单是否存在的判断</strong>，而此时还没创建订单，因此判断的结果都说明数据库中不存在这样的订单，则这多个线程会同时对库存进行扣减，还是没达到一人一单的效果。为了解决这个线程安全问题，我们可以加锁。由于<strong>乐观锁是在数据发生修改时才生效的</strong>，因此无法用于本问题里，于是我们选择<strong>悲观锁——synchronized</strong>用于解决线程安全问题。</p><p>由于前面的判断环节不会产生线程安全问题，为了方便synchronized关键字的使用，我们选择将查询订单到返回订单id这一段代码独立出来成为一个方法createVoucherOrder，该方法带有**@Transactional注释**。<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151756013.png" alt="image-20250212190212401" style="zoom:33%;" /></p><p>2️⃣现在就有一个问题，&#x3D;&#x3D;<strong>synchronized关键字的位置应该放在什么位置呢</strong>&#x3D;&#x3D;？是用于修饰方法createVoucherOrder呢？还是修饰方法内的一段代码块呢？解决这个问题的关键在于我们引入锁的初衷——实现一人一单功能。</p><ul><li>如果我们将synchronized用于修饰方法，那么当一个用户执行这个方法时，其他用户无法执行这个方法，只能等待，这显然大大削减了性能。而我们的目的仅仅只是让一个用户的多个线程无法同时进行方法的执行。</li><li>因此我们选择将synchronized用于修饰代码块，同时将**&#x3D;&#x3D;userId作为对象传入synchronized实现对单个用户加锁&#x3D;&#x3D;**。</li><li>为了实现对单个用户加锁，不同的用户不会被锁定，那么同一个用户传入synchronized的Long userId对象就需要是同一个：<ul><li>如果仅仅只传userId，多个线程下查到的userId地址不同，是不同的userId对象❌</li><li>如果传入userId.toString()，多个线程下查到的字符串地址不同，是不同的字符串对象❌</li><li>因此需要传入的是<strong>userId.toString().intern()</strong>，String.intern()是一个Native方法，它的作用是：如果字符常量池中已经包含一个等于此String对象的字符串，则返回常量池中字符串的引用。总之就是源于<strong>String对象的字符串是存储在&#x3D;&#x3D;常量池&#x3D;&#x3D;中的</strong>，如果多个String对象的字符串长得一样，那么他们在常量池中都<strong>指向同一个字符串</strong>，这就保证了传入synchronized关键字的是同一个对象。<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151756025.png" alt="image-20250212191841136" style="zoom:33%;" />✅</li></ul></li></ul><p>3️⃣但是，这样也会产生新的问题。由于方法是被@Transactional注释所修饰的，因此如果synchronized修饰<strong>方法内的一段代码块</strong>，就会出现**&#x3D;&#x3D;先释放锁，再提交事务&#x3D;&#x3D;<strong>的现象。如果一个线程释放锁但还没提交事务，这时有一个新的线程获取了锁，由于事务尚未提交，如果这时这个新的线程去查询订单，<strong>查询到的可能就是前一个线程未修改前的数据</strong>，这就产生了线程安全问题。这说明</strong>&#x3D;&#x3D;锁的范围小了，应该在事务提交之后再释放锁&#x3D;&#x3D;**，于是synchronized应该修饰函数调用所在的代码块，即：<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754132.png" alt="image-20250212193326069" style="zoom: 50%;" /></p><p>4️⃣经过上述操作，确保了线程安全，但是随之而来又有事务方面的问题。注意到，我们是对当前的createVoucherOrder方法进行了@Transactional的注释，而没有给外面的函数seckillVoucher加事务，而外面的函数seckillVoucher在执行上面这段代码时，等价于是这样执行的：<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754889.png" alt="image-20250212194040961" style="zoom:33%;" />这里的**&#x3D;&#x3D;this&#x3D;&#x3D;代表的是当前VoucherOrderServiceImpl这个类的对象，而不是它的代理对象**。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754096.png" alt="image-20250212194513920" style="zoom: 33%;" /><p>而事务要想生效，是因为<strong>spring对VoucherOrderServiceImpl这个类进行了动态代理，拿到了它的&#x3D;&#x3D;代理对象&#x3D;&#x3D;</strong>，用这个代理对象来去做事务处理；而<strong>现在这个this指的是非代理对象，是不具有事务功能的</strong>。因此我们需要拿到这个代理对象，获取方法如下：<img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754106.png" alt="image-20250212194939735" style="zoom:33%;" />当然，上面的解决代理对象问题还需要如下两个步骤：</p><ul><li>pom文件中引入aspectjweaver依赖。</li><li>启动类添加@EnableAspectJAutoProxy(exposeProxy &#x3D; true)注解，用于暴露代理对象。</li></ul><p>这样就解决了事务问题。</p><h4 id="集群下一人一单的并发安全问题"><a href="#集群下一人一单的并发安全问题" class="headerlink" title="集群下一人一单的并发安全问题"></a><strong>集群下一人一单的并发安全问题</strong></h4><p>上面的处理方式，在单体部署的情况下是没有问题的，因为此时只有一台Tomcat1，即只有一台JVM1，线程获取的锁都是这台JVM1中的同一把锁（锁的UUID保存在常量池中），故<strong>多个线程竞争这一把锁</strong>，保证了线程安全。</p><p>但是如果在集群部署的情况下，就说明有<strong>多台Tomcat提供服务，即有多台JVM</strong>，故Tomcat1中的线程竞争的是JVM1中的锁，而Tomcat2中的线程竞争的是JVM2中的锁，<strong>此时有多把锁</strong>。故此时如果一个用户在两台Tomcat中都实现了下单操作，则<strong>两边都能获取到锁</strong>，故生成了两个订单，违背了一人一单的规定，这就导致了集群下一人一单问题的并发安全问题。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754699.png" alt="image-20250212203633633" style="zoom:33%;" /><h4 id="Redis的分布式锁实现"><a href="#Redis的分布式锁实现" class="headerlink" title="Redis的分布式锁实现"></a><strong>Redis的分布式锁实现</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754441.png" alt="image-20250213114816370" style="zoom:33%;" /><p>为了解决上述的并发安全，我们就需要实现<strong>多台JVM下的线程竞争同一把锁</strong>，<strong>即分布式锁</strong>——满足分布式系统或集群模式下多进程可见并且互斥的锁，本项目中我们选择使用redis的<strong>setnx</strong>关键字来解决分布式锁的实现。</p><p>而为了实现redis分布式锁只对同一个用户产生作用，设置的<strong>key值就需要区分不同用户</strong>，以此来实现对同一个用户的不同进程加锁，而不同用户获取的锁不同。对于下单功能，本项目设置的key值为：<strong>“lock:order:”+userId</strong>。</p><p>1️⃣而使用redis实现分布式锁就会出现一个问题：当一个进程占有锁时，若此时redis宕机了，就会导致锁无法被释放，造成<strong>死锁现象</strong>的产生。解决这个问题也很简单，我们只需要给这个锁设置一个<strong>过期时间</strong>，超时自动释放锁，就不会出现由于redis宕机导致的死锁现象。</p><p>2️⃣但是，正是由于给锁设置了过期时间，新的问题产生了——<strong>锁的误删问题</strong>。如下图所示，当线程1获取锁但是业务阻塞导致<strong>超时释放锁</strong>，在线程1业务完成之前，<strong>线程2趁虚而入拿到了锁并开始执行业务</strong>，这时候线程1完成了业务并按部就班去释放锁，但是这时候占用锁的是线程2，也就是说<strong>线程1把线程2的锁给释放了</strong>，这时候如果又有一个线程3来获取锁是能够获取成功的，这就导致了线程2、线程3同时执行业务，产生了并发安全问题。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754037.png" alt="image-20250213130001479" style="zoom:33%;" /><p>解决锁的误删问题可以采用如下方法：在给锁设置<strong>value值</strong>时，使用<strong>线程ID作为锁的value值</strong>，这样就能知道当前的锁是不是本线程所设置的，当线程业务执行完毕想要释放锁时，先执行一个判断，<strong>判断当前锁的value值与自身线程ID是否相同</strong>，如果相同说明是同一把锁可以释放，否则说明是别的线程的锁，不做操作，这样就避免了锁的误删问题。</p><p>当然，仅仅只使用线程ID作为value值是不够的，因为在不同的进程之间可能存在相同的线程ID，有小概率出现混淆的情况，我们可以选择在<strong>线程ID之前拼接一个UUID确保唯一性</strong>，将拼接的结果作为锁的value值。</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754613.png" alt="image-20250213131120388" style="zoom:33%;" /><p>3️⃣但是，还会有一个问题：当线程1获取锁之后，未执行业务就发生了阻塞，此时如果锁释放了，线程2来获取锁是能够获取得到的，这就会造成线程1、2同时执行业务的情况出现，还是会发生一个用户下了多个订单的情况。如上图中<strong>线程1、2执行业务有重叠的部分</strong>。</p><p>4️⃣此外，由于<strong>判断锁标识是否一致与释放锁不是一个原子操作</strong>，如果<strong>判断完后想要释放锁时发生了阻塞</strong>，会触发锁的超时释放，此时线程2来获取了锁，线程1阻塞结束后会使用之前的判断结果去把线程2的锁释放，这就又导致的并发安全问题，如下图所示：</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754097.png" alt="image-20250213131921945" style="zoom:33%;" /><p>为了解决原子性的问题，我们可以选择使用redis提供的lua脚本功能，在一个脚本中编写多条redis命令，确保多条命令执行的原子性。</p><h3 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a><strong>Redisson分布式锁</strong></h3><h4 id="基于SETNX实现的分布式锁存在的问题"><a href="#基于SETNX实现的分布式锁存在的问题" class="headerlink" title="基于SETNX实现的分布式锁存在的问题"></a><strong>基于SETNX实现的分布式锁存在的问题</strong></h4><ol><li>重入问题<ul><li>重入问题是指<strong>获取锁的线程，可以再次进入到相同的锁的代码块中</strong>，可重入锁的意义在于防止死锁，例如在HashTable这样的代码中，它的方法都是使用synchronized修饰的，加入它在一个方法内调用另一个方法，如果此时是不可重入的，那就死锁了。所以<strong>可重入锁的主要意义是防止死锁</strong>，我们的synchronized和Lock锁都是可重入的</li></ul></li><li>不可重试<ul><li>我们编写的分布式锁只能尝试一次，失败了就返回false，没有重试机制。但合理的情况应该是：当线程获取锁失败后，他应该能再次尝试获取锁</li></ul></li><li>超时释放<ul><li>我们在加锁的时候增加了TTL，这样我们可以防止死锁，但是如果卡顿(阻塞)时间太长，也会导致锁的释放。虽然我们采用Lua脚本来防止删锁的时候，误删别人的锁，但现在的新问题是没锁住，也有安全隐患，也就是上面的问题3️⃣</li></ul></li><li>主从一致性<ul><li>如果Redis提供了主从集群，那么当我们向集群写数据时，主机需要异步的将数据同步给从机，万一在同步之前，主机宕机了(主从同步存在延迟，虽然时间很短，但还是发生了)，那么又会出现死锁问题</li></ul></li></ol><h4 id="Redisson可重入锁原理"><a href="#Redisson可重入锁原理" class="headerlink" title="Redisson可重入锁原理"></a><strong>Redisson可重入锁原理</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754395.png" alt="image-20250213160502630" style="zoom:33%;" /><ul><li><p>method1在方法内部调用method2，method1和method2出于<strong>同一个线程</strong>，那么method1已经拿到一把锁了，想进入method2中拿另外一把锁，必然是拿不到的，于是就出现了死锁</p></li><li><p>所以我们需要额外判断，<strong>method1和method2是否处于同一线程</strong>，如果是<strong>同一个线程，则可以拿到锁，但是state会<code>+1</code></strong>，之后执行method2中的方法，释放锁，<strong>释放锁的时候也只是将state进行<code>-1</code>，只有减至0，才会真正释放锁</strong></p></li><li><p>由于我们需要额外存储一个state，所以用字符串型<code>SET NX EX</code>是不行的，需要用到**<code>Hash</code>结构**，但是<code>Hash</code>结构又没有<code>NX</code>这种方法，所以我们需要将原有的逻辑拆开，进行手动判断，如上图所示</p></li><li><p>为了保证原子性，所以流程图中的业务逻辑也是需要我们用Lua来实现的</p></li></ul><p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754005.png" alt="image-20250213160531577" style="zoom:33%;" /><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754783.png" alt="image-20250213160607090" style="zoom:33%;" /></p><h4 id="Redisson锁重试和WatchDog机制"><a href="#Redisson锁重试和WatchDog机制" class="headerlink" title="Redisson锁重试和WatchDog机制"></a><strong>Redisson锁重试和WatchDog机制</strong></h4><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754136.png" alt="image-20250213161206038" style="zoom:33%;" /><ul><li><strong>锁重试</strong>：利用信号量、发布消息publish、订阅消息subscribe功能，实现获取锁失败后的一段时间（ttl）内重新尝试获取锁。而重新尝试获取锁<strong>并不是立刻重新尝试</strong>，而是通过<strong>订阅</strong>释放锁的消息，接收到锁释放的消息后去重试，<strong>减轻了cpu的负担</strong>，因此在线程释放锁后需要向外<strong>发布</strong>释放锁的消息。</li><li><strong>WatchDog机制</strong>：给锁添加过期时间，虽然能够解决死锁的问题，但是如果事务发生了阻塞导致超时释放锁，还是会出现多个线程同时执行业务的情况，失去了锁的作用，造成了一人多单的情况。因此，关键点就是**&#x3D;&#x3D;不要让事务阻塞导致超时释放锁，超时释放只应该在redis服务宕机、或持有锁的线程挂掉时起作用&#x3D;&#x3D;**，于是就引出了WatchDog机制。<ul><li>WatchDog就是持有锁的线程给锁加了一条看门狗，<strong>只要这个线程存在，狗就会不断给锁续期不让它过期</strong>，<strong>&#x3D;&#x3D;直到线程执行完事务并亲自释放锁&#x3D;&#x3D;</strong>。</li><li>既然WatchDog会给锁不断续期，那么锁设置过期时间还有意义吗？答案是有的。因为这个<strong>过期时间主要是为了防止线程挂掉、redis宕机导致的死锁，过期时间只应在这些情况下释放锁</strong>，如果过期时间是因为线程事务发生阻塞超时释放锁，就会产生上面的并发问题，而WatchDog就是引进来不让这种情况发生的。</li></ul></li></ul><h4 id="Redisson锁的MutiLock原理"><a href="#Redisson锁的MutiLock原理" class="headerlink" title="Redisson锁的MutiLock原理"></a><strong>Redisson锁的MutiLock原理</strong></h4><ul><li>为了提高Redis的可用性，我们会搭建集群或者主从，现在以主从为例</li><li>此时我们去写命令，写在主机上，主机会将数据同步给从机，但是假设<strong>主机还没来得及把数据写入到从机去的时候，主机宕机了</strong></li><li>哨兵会发现主机宕机了，于是选举一个slave(从机)变成master(主机)，而此时<strong>新的master(主机)上并没有锁的信息</strong>，那么其他线程就可以获取锁，又会引发安全问题</li><li>为了解决这个问题。Redisson提出来了MutiLock锁，使用这把锁的话，那我们就不用主从了，每个节点的地位都是一样的，都可以当做是主机，那我们就**&#x3D;&#x3D;需要将加锁的逻辑写入到每一个主从节点上，只有所有的服务器都写入成功，此时才是加锁成功&#x3D;&#x3D;**，假设现在某个节点挂了，那么他去获取锁的时候，只要有一个节点拿不到，都不能算是加锁成功，就保证了加锁的可靠性</li></ul><h4 id="Redisson小结"><a href="#Redisson小结" class="headerlink" title="Redisson小结"></a><strong>Redisson小结</strong></h4><ol><li>不可重入Redis分布式锁<ul><li>原理：利用SETNX的互斥性；利用EX避免死锁；释放锁时判断线程标识</li><li>缺陷：不可重入、无法重试、锁超时失效</li></ul></li><li>可重入Redis分布式锁<ul><li>原理：利用Hash结构，记录线程标识与重入次数；利用WatchDog延续锁时间；利用信号量控制锁重试等待</li><li>缺陷：Redis宕机引起锁失效问题</li></ul></li><li>Redisson的multiLock<ul><li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li><li>缺陷：运维成本高、实现复杂</li></ul></li></ol><h3 id="秒杀优化"><a href="#秒杀优化" class="headerlink" title="秒杀优化"></a><strong>秒杀优化</strong></h3><h4 id="异步秒杀思路"><a href="#异步秒杀思路" class="headerlink" title="异步秒杀思路"></a><strong>异步秒杀思路</strong></h4><p>我们先来回顾一下下单流程，当用户发起请求，此时会先请求Nginx，Nginx反向代理到Tomcat，而Tomcat中的程序，会进行串行操作，分为如下几个步骤：</p><ol><li>查询优惠券</li><li>判断秒杀库存是否足够</li><li>查询订单</li><li>校验是否一人一单</li><li>扣减库存</li><li>创建订单</li></ol><p>在这六个步骤中，有很多操作都是要去操作数据库的，而且还是一个线程串行执行，这样就会导致我们的程序执行很慢，所以我们需要异步程序执行，那么如何加速呢？</p><img src="https://hwangjj-image-gallery.oss-cn-shenzhen.aliyuncs.com/imgs/202502151754941.png" alt="image-20250213200222171" style="zoom:33%;" /><ul><li>优化方案：我们<strong>将耗时较短的逻辑判断放到Redis</strong>中，例如：库存是否充足，是否一人一单这样的操作，只要满足这两条操作，那我们是一定可以下单成功的，不用等数据真的写进数据库，我们直接告诉用户下单成功就好了。然后后台再开一个线程，后台线程再去慢慢执行队列里的消息，这样我们就能很快的完成下单业务。</li><li>我们现在来看整体思路：当用户下单之后，判断库存是否充足，只需要取Redis中根据key找对应的value是否大于0即可，如果不充足，则直接结束。如果充足，则在Redis中判断用户是否可以下单，如果set集合中没有该用户的下单数据，则可以下单，并将<strong>userId和优惠券存入到Redis</strong>中，并且返回0，整个过程需要保证是原子性的，所以我们要用Lua来操作</li><li>我们只需要判断Lua脚本的返回值是否为0，如果是0，则表示可以下单，将信息保存到queue中去，然后返回，开一个线程来异步下单</li></ul><h4 id="异步秒杀小结"><a href="#异步秒杀小结" class="headerlink" title="异步秒杀小结"></a><strong>异步秒杀小结</strong></h4><ul><li>秒杀业务的优化思路是什么？<ol><li>先利用Redis完成库存容量、一人一单的判断，完成抢单业务</li><li>再将下单业务放入阻塞队列，利用独立线程异步下单</li></ol></li><li>基于阻塞队列的异步秒杀存在哪些问题？<ol><li>内存限制问题：<ul><li>我们现在使用的是JDK里的阻塞队列，它使用的是JVM的内存，如果在高并发的条件下，无数的订单都会放在阻塞队列里，可能就会造成内存溢出，所以我们在创建阻塞队列时，设置了一个长度，但是如果真的存满了，再有新的订单来往里塞，那就塞不进去了，存在内存限制问题</li></ul></li><li>数据安全问题：<ul><li>经典服务器宕机了，用户明明下单了，但是数据库里没看到</li></ul></li></ol></li></ul><h3 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a><strong>Redis消息队列</strong></h3><h4 id="认识消息队列"><a href="#认识消息队列" class="headerlink" title="认识消息队列"></a><strong>认识消息队列</strong></h4><ul><li>什么是消息队列？字面意思就是存放消息的队列，最简单的消息队列模型包括3个角色<ol><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ol></li><li>使用队列的好处在于<code>解耦</code>：举个例子，快递员(生产者)把快递放到驿站&#x2F;快递柜里去(Message Queue)去，我们(消费者)从快递柜&#x2F;驿站去拿快递，这就是一个异步，如果耦合，那么快递员必须亲自上楼把快递递到你手里，服务当然好，但是万一我不在家，快递员就得一直等我，浪费了快递员的时间。所以解耦还是非常有必要的</li></ul><h4 id="基于List实现消息队列"><a href="#基于List实现消息队列" class="headerlink" title="基于List实现消息队列"></a><strong>基于List实现消息队列</strong></h4><ul><li>基于List结构模拟消息队列</li><li>消息队列(Message Queue)，字面意思就是存放消息的队列，而Redis的list数据结构是一个双向链表，很容易模拟出队列的效果</li><li>队列的入口和出口不在同一边，所以我们可以利用：LPUSH结合RPOP或者RPUSH结合LPOP来实现消息队列。</li><li>不过需要注意的是，当队列中没有消息时，RPOP和LPOP操作会返回NULL，而不像JVM阻塞队列那样会阻塞，并等待消息，所以我们这里应该使用<strong>BRPOP或者BLPOP来实现阻塞效果</strong></li><li>基于List的消息队列有哪些优缺点？<ul><li>优点<ol><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保障</li><li>可以满足消息有序性</li></ol></li><li>缺点<ol><li>无法避免消息丢失(经典服务器宕机)</li><li>只支持单消费者(一个消费者把消息拿走了，其他消费者就看不到这条消息了)</li></ol></li></ul></li></ul><h4 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a><strong>基于PubSub的消息队列</strong></h4><ul><li>PubSub(发布订阅)是Redis2.0版本引入的消息传递模型。顾名思义，消费和可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</li><li><code>SUBSCRIBE channel [channel]</code>：订阅一个或多个频道</li><li><code>PUBLISH channel msg</code>：向一个频道发送消息</li><li><code>PSUBSCRIBE pattern [pattern]</code>：订阅与pattern格式匹配的所有频道</li><li>基于PubSub的消息队列有哪些优缺点<ul><li>优点：<ol><li>采用发布订阅模型，支持多生产，多消费</li></ol></li><li>缺点：<ol><li>不支持数据持久化</li><li>无法避免消息丢失（如果向频道发送了消息，却<strong>没有人订阅该频道</strong>，那发送的这条消息就丢失了）</li><li>消息堆积有上限，超出时数据丢失（<strong>消费者拿到数据的时候处理的太慢，而发送消息发的太快</strong>）</li></ol></li></ul></li></ul><h4 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a><strong>基于Stream的消息队列</strong></h4><ul><li>发送消息的命令</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">XADD key <span class="hljs-comment">[NOMKSTREAM]</span> <span class="hljs-comment">[MAXLEN|MINID <span class="hljs-comment">[=!~]</span> threshold <span class="hljs-comment">[LIMIT count]</span>]</span> *|ID field value <span class="hljs-comment">[field value ...]</span><br><br>NOMKSTREAM<br>如果队列不存在，是否自动创建队列，默认是自动创建<br><span class="hljs-comment">[MAXLEN|MINID <span class="hljs-comment">[=!~]</span> threshold <span class="hljs-comment">[LIMIT count]</span>]</span><br>设置消息队列的最大消息数量，不设置则无上限<br>*|ID<br>消息的唯一id，*代表由Redis自动生成。格式是”时间戳-递增数字”，例如”114514114514-0”<br>field value <span class="hljs-comment">[field value …]</span><br>发送到队列中的消息，称为Entry。格式就是多个key-value键值对<br><br>举例：创建名为users的队列，并向其中发送一个消息，内容是&#123;name=jack, age=21&#125;，并且使用Redis自动生成ID<br>XADD users * name jack age 21<br></code></pre></td></tr></table></figure><ul><li>读取消息的命令</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs inform7">XREAD <span class="hljs-comment">[COUNT count]</span> <span class="hljs-comment">[BLOCK milliseconds]</span> STREAMS key <span class="hljs-comment">[key ...]</span> ID <span class="hljs-comment">[ID ...]</span><br><br><span class="hljs-comment">[COUNT count]</span><br>每次读取消息的最大数量<br><span class="hljs-comment">[BLOCK milliseconds]</span><br>当没有消息时，是否阻塞，阻塞时长<br>STREAMS key <span class="hljs-comment">[key …]</span><br>要从哪个队列读取消息，key就是队列名<br>ID <span class="hljs-comment">[ID …]</span><br>起始ID，只返回大于该ID的消息<br>0：表示从第一个消息开始<br>$：表示从最新的消息开始<br>注意：当我们指定其实ID为$时，代表只能读取到最新消息，如果当我们在处理一条消息的过程中，又有超过1条以上的消息到达队列，那么下次获取的时候，也只能获取到最新的一条，会出现漏读消息的问题<br></code></pre></td></tr></table></figure><ul><li>STREAM类型消息队列的XREAD命令特点<ol><li>消息可回溯</li><li>一个消息可以被多个消费者读取</li><li>可以阻塞读取</li><li>有漏读消息的风险</li></ol></li></ul><h4 id="基于Stream的消息队列—消费者组"><a href="#基于Stream的消息队列—消费者组" class="headerlink" title="基于Stream的消息队列—消费者组"></a><strong>基于Stream的消息队列—消费者组</strong></h4><ul><li><p>消费者组(Consumer Group)：将多个消费者划分到一个组中，监听同一个队列，具备以下特点</p><ol><li>消息分流<ul><li>队列中的消息会分留给组内的不同消费者，而不是重复消费者，从而<strong>加快消息处理的速度</strong></li></ul></li><li>消息标识<ul><li>消费者会维护一个标识，<strong>记录最后一个被处理的消息</strong>，哪怕消费者宕机重启，还会从标识之后读取消息，<strong>确保每一个消息都会被消费</strong></li></ul></li><li>消息确认<ul><li>消费者获取消息后，消息处于pending状态，并存入一个<strong>pending-list</strong>，当处理完成后，<strong>需要通过XACK来确认消息</strong>，标记消息为已处理，才会从pending-list中移除</li></ul></li></ol></li><li><p>创建消费者组</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gauss">XGROUP <span class="hljs-keyword">CREATE</span> <span class="hljs-built_in">key</span> groupName ID [MKSTREAM]<br><br><span class="hljs-built_in">key</span><br>队列名称<br>groupName<br>消费者组名称<br>ID<br>起始ID标识，$代表队列中的最后一个消息，<span class="hljs-number">0</span>代表队列中的第一个消息<br>MKSTREAM<br>队列不存在时自动创建队列<br></code></pre></td></tr></table></figure></li><li><p>从消费者组中读取消息</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs q">XREADGROUP GROUP <span class="hljs-built_in">group</span> consumer [COUNT <span class="hljs-built_in">count</span>] [BLOCK milliseconds] [NOACK] STREAMS <span class="hljs-built_in">key</span> [<span class="hljs-built_in">keys</span> ...] ID [ID ...]<br><br><span class="hljs-built_in">group</span><br>消费者组名称<br>consumer<br>消费者名，如果消费者不存在，会自动创建一个消费者<br><span class="hljs-built_in">count</span><br>本次查询的最大数量<br>BLOCK milliseconds<br>当前没有消息时的最大等待时间<br>NOACK<br>无需手动ACK，获取到消息后自动确认（一般不用，我们都是手动确认）<br>STREAMS <span class="hljs-built_in">key</span><br>指定队列名称<br>ID<br>获取消息的起始ID<br>&gt;：从下一个未消费的消息开始(pending-list中)<br>其他：根据指定id从pending-list中获取已消费但未确认的消息，例如<span class="hljs-number">0</span>，是从pending-list中的第一个消息开始<br></code></pre></td></tr></table></figure></li><li><p>STREAM类型消息队列的XREADGROUP命令的特点</p><ol><li>消息可回溯</li><li>可以多消费者争抢消息，加快消费速度</li><li>可以阻塞读取</li><li>没有消息漏读风险</li><li>有消息确认机制，保证消息至少被消费一次</li></ol></li></ul><h4 id="三种方式实现消息队列对比"><a href="#三种方式实现消息队列对比" class="headerlink" title="三种方式实现消息队列对比"></a><strong>三种方式实现消息队列对比</strong></h4><table><thead><tr><th align="center"></th><th align="center">List</th><th align="center">PubSub</th><th align="center">Stream</th></tr></thead><tbody><tr><td align="center">消息持久化</td><td align="center">支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">阻塞读取</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">消息堆积处理</td><td align="center">受限于内存空间， 可以利用多消费者加快处理</td><td align="center">受限于消费者缓冲区</td><td align="center">受限于队列长度， 可以利用消费者组提高消费速度，减少堆积</td></tr><tr><td align="center">消息确认机制</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">消息回溯</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr></tbody></table><h4 id="Redis消息队列实现异步秒杀"><a href="#Redis消息队列实现异步秒杀" class="headerlink" title="Redis消息队列实现异步秒杀"></a><strong>Redis消息队列实现异步秒杀</strong></h4><ul><li><p>需求：</p><ol><li>创建一个Stream类型的消息队列，名为stream.orders</li><li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId、userId、orderId</li><li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li></ol></li><li><p>业务实现伪代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>    <span class="hljs-comment">// 尝试监听队列，使用阻塞模式，最大等待时长为2000ms</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 &gt;&quot;</span>)<br>    <span class="hljs-keyword">if</span>(msg == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-comment">// 没监听到消息，重试</span><br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-comment">//处理消息，完成后要手动确认ACK</span><br>        handleMessage(msg);<br>    &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//0表示从pending-list中的第一个消息开始，如果前面都ACK了，那么这里就不会监听到消息</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> redis.call(<span class="hljs-string">&quot;XREADGROUP GROUP g1 c1 COUNT 1 STREAMS s1 0&quot;</span>);<br>            <span class="hljs-keyword">if</span>(msg == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//null表示没有异常消息，所有消息均已确认，结束循环</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-comment">//说明有异常消息，再次处理</span><br>                handleMessage(msg);<br>            &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>                <span class="hljs-comment">//再次出现异常，记录日志，继续循环</span><br>                log.error(<span class="hljs-string">&quot;..&quot;</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="Blog点赞功能"><a href="#Blog点赞功能" class="headerlink" title="Blog点赞功能"></a><strong>Blog点赞功能</strong></h2><h3 id="一人一赞"><a href="#一人一赞" class="headerlink" title="一人一赞"></a><strong>一人一赞</strong></h3><p>当前的业务下，点赞功能直接在controller层中，update数据库中blog的点赞数，这会导致一个用户可以给一篇blog无限点赞，这是不合理的。我们的需求是：</p><ul><li>同一个用户只能对同一篇笔记点赞一次，再次点击则取消点赞</li><li>如果当前用户已经点赞，则<strong>点赞按钮高亮显示</strong>（前端已实现，判断字段Blog类的isLike属性）</li></ul><p>实现的方法如下：</p><ul><li>修改点赞功能，利用<strong>redis中的set集合</strong>的sismember方法来判断是否点赞过，未点赞则点赞数+1，已点赞则点赞数-1</li><li>修改根据id查询blog的业务，判断当前用户是否点赞过，赋值给blog对象的isLike字段</li><li>修改分页查询blog业务，判断当前用户是否点赞过，赋值给blog对象的isLike字段</li></ul><h3 id="点赞排行榜"><a href="#点赞排行榜" class="headerlink" title="点赞排行榜"></a><strong>点赞排行榜</strong></h3><p>当我们点击探店笔记详情页面时，应该按点赞顺序展示点赞用户，比如显示最早点赞的TOP5，形成点赞排行榜。之前的点赞是放到Set集合中，但是Set集合又不能排序，所以这个时候，我们就可以改用<strong>SortedSet(Zset)</strong>，将<strong>时间戳作为zset对应用户id的得分</strong>，根据得分排序即可实现显示最早点赞的top5。</p><ul><li><p>而Zset没有ismember的方法，我们可以选择score方法，该方法查询对应用户ID的score，如果没有这个用户，就返回空值。</p></li><li><pre><code class="language-java">// 查询点赞排行榜@Overridepublic Result queryBlogLikes(Integer id) &#123;    String key = BLOG_LIKED_KEY + id;    //zrange key 0 4  查询zset中前5个元素    Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);    //如果是空的(可能没人点赞)，直接返回一个空集合    if (top5 == null || top5.isEmpty()) &#123;        return Result.ok(Collections.emptyList());    &#125;    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());    //将ids使用`,`拼接，SQL语句查询出来的结果并不是按照我们期望的方式进行排    //所以我们需要用order by field来指定排序方式，期望的排序方式就是按照查询出来的id进行排序    String idsStr = StrUtil.join(&quot;,&quot;, ids);    //select * from tb_user where id in (ids[0], ids[1] ...) order by field(id, ids[0], ids[1] ...)    List&lt;UserDTO&gt; userDTOS = userService.query().in(&quot;id&quot;, ids)            .last(&quot;order by field(id,&quot; + idsStr + &quot;)&quot;)            .list().stream()            .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))            .collect(Collectors.toList());    return Result.ok(userDTOS);&#125;</code></pre></li></ul><h2 id="好友关注功能"><a href="#好友关注功能" class="headerlink" title="好友关注功能"></a><strong>好友关注功能</strong></h2><h3 id="关注与取关"><a href="#关注与取关" class="headerlink" title="关注与取关"></a><strong>关注与取关</strong></h3><p>关注与取关会传入一个isFollow参数，true表示关注，false表示取关</p><ul><li>关注只需要创建一个Follow对象，将关注者（当前用户）id与被关注者id赋给这个Follow对象，然后直接保存到数据库中即可</li><li>同理，取关只需要把数据库中<code>user_id = userId</code>且<code>follow_user_id = followUserId</code>的记录删除即可。</li></ul><h3 id="共同关注"><a href="#共同关注" class="headerlink" title="共同关注"></a><strong>共同关注</strong></h3><p>共同关注可以利用redis中<strong>set</strong>数据类型，对<strong>两个key的set取交集来实现</strong></p><ul><li>key用于区分用户，模式为<code>follow:userId</code></li><li>value则是对应用户的关注对象的set集合</li><li>因此，需要在关注时，同步将关注信息传入redis中；同理取关时也要将被关注者从当前用户的set集合中删除</li><li>使用set数据结构的intersect功能来实现取交集</li><li>取得共同关注id集合（String集合）后，要将id集合解析（String转化为Long），然后查询各id对应的用户信息user并<strong>封装到userDTO</strong>中确保安全，然后返回。</li></ul><h3 id="关注推送"><a href="#关注推送" class="headerlink" title="关注推送"></a><strong>关注推送</strong></h3><ul><li>需求：<ol><li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱</li><li>收件箱满足可以根据时间戳排序，必须使用Redis的数据结构实现</li><li>查询收件箱数据时，实现分页查询</li></ol></li><li>实现：<ol><li><strong>基于redis实现收件箱</strong>：在redis为每个用户设置一个收件箱，key模式为<code>FEED_KEY + userId</code>，每当一个用户发布一条blog时，在tb_follow表中查询他的粉丝，并<strong>将blog id推送到每个粉丝的收件箱</strong></li><li>由于要按照时间戳排序，我们选择redis数据结构为<strong>zset，score使用时间戳来表示</strong></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/15/hello-world/"/>
    <url>/2025/02/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
